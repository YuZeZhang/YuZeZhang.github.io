<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024-11-12 日报 Day4</title>
    <url>/undefined/2024-11-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>流水不争先，争的是滔滔不绝。</p>
<p>姜子牙年轻时也做过屠夫卖过酒，直到暮年遇到周文王才得以大展宏图。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《图解HTTP》 P1-140
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><ul>
<li><p>1、TCP&#x2F;IP协议族分为以下4层: 应用层、传输层、网络层、数据链路层。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411121823887.png"
                      alt="network"
                ></p>
</li>
<li><p>2、请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</p>
</li>
<li><p>3、响应报文是由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
</li>
<li><p>4、HTTP是一种无状态(stateless)协议，HTTP&#x2F;1.1引入了Cookie技术。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
</li>
<li><p>5、Cookie会根据服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务端发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
</li>
<li><p>6、内容协商机制(Content Negotiation)是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商机制有3种类型：</p>
<p>​	服务器驱动协商: 以请求的首部字段为参考，在服务器端自动处理。</p>
<p>​	客户端驱动协商: 比如按OS类型或浏览器类型自行切换成PC版页面或手机版页面。</p>
<p>​	透明协商</p>
</li>
<li><p>7、状态码类型：</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务端错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>具体状态码</th>
<th>状态名称</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>请求成功但无资源返回</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td></td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>8、通信数据转发程序: 代理、网关、隧道。</p>
</li>
<li><p>9、为Cookie服务的首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody></table>
</li>
<li><p>10、Set-Cookie字段的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME&#x3D;VALUE</td>
<td>赋予Cookie的名称和值</td>
</tr>
<tr>
<td>expires&#x3D;DATE</td>
<td>Cookie的有效期</td>
</tr>
<tr>
<td>path&#x3D;PATH</td>
<td></td>
</tr>
<tr>
<td>domain&#x3D;域名</td>
<td>Cookie适用对象的域名</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在HTTPS安全通信时才会发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使Cookie不能被JavaScript脚本访问</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>HTTP(HyperText Transfer Protocol): 超文本传输协议</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-10 日报 Day2</title>
    <url>/undefined/2024-11-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>于高山之巅，方见大河奔涌；于群峰之上，便觉长风浩荡。<br>As the top of the mountain, one can see the rushing river; Above the peaks, i feel the long and mighty wind.</p>

    </div>
  </div>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《网络是怎样连接的》 P13 - P74
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、GET、POST、PUT、DELETE</p>
<ul>
<li>GET: 从服务器获取资源<br>  GET用于获取资源。请求参数附加在 URL 中，因此这些参数可以被缓存、记录到日志中，并且可能暴露在网络中，容易被拦截。</li>
<li>POST：用于提交数据或创建资源。<br>数据在请求体中，表面上看似比 GET 更安全，实际上 POST 也存在被拦截的风险，尤其是通过明文 HTTP 传输时。</li>
<li>PUT和DELETE：用于更新和删除资源。<br>在RESTful API中，PUT和DELETE用于更新和删除资源。HTTP中的PUT、DELETE等请求不被认为安全，主要是因为它们旨在修改服务器上的资源、这些方法未必包含足够的安全机制来验证请求者的权限、容易受到跨站请求伪造（CSRF）等安全攻击。<br>Reference: <a class="link"   href="https://docs.pingcode.com/ask/244551.html" >https://docs.pingcode.com/ask/244551.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>2、CSRF（Cross-site request forgery）跨站请求伪造</p>
<ul>
<li>CSRF是一种网络攻击，它利用用户已登录的身份在用户不知情的情况下以用户的名义发送恶意请求。</li>
<li>CSRF Token:<ul>
<li>生成一个唯一的CSR Token并附加到每一个请求</li>
<li>服务器接收请求后，验证请求中的Token是否有效</li>
<li>每次生成的Token都是独立的、随机的，攻击者无法伪造</li>
</ul>
</li>
<li>同源检查:<ul>
<li>服务器检查请求来源的Referer或Origin头部，确保请求来自合法的源</li>
<li>如果Origin或Referer头部不匹配，服务器拒绝请求</li>
<li>例如发短信……</li>
</ul>
</li>
<li>使用双重Cookie验证<ul>
<li>用户登录时，将一个CSRF Token存储在Cookie中，同时在每个请求中都带上相同的CSRF Token</li>
<li>服务检验请求携带的Token和Cookie中的Token是否匹配</li>
</ul>
</li>
<li>设置Cookie的SameSite属性<ul>
<li>将Cookie的SameSite属性设置为Strict或Lax，可以防止CSRF攻击</li>
<li>SameSite&#x3D;Strict：只有在同源请求时才会发送Cookie</li>
<li>SameSite&#x3D;Lax：允许部分第三方请求（如 GET 请求）使用，但可以阻止大多数 CSRF 攻击。</li>
</ul>
</li>
</ul>
<p>Reference: <a class="link"   href="https://portswigger.net/web-security/csrf" >https://portswigger.net/web-security/csrf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>CSRF（Cross-site request forgery）: 跨站请求伪造</li>
<li>web security vulnerability: 网络安全漏洞</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-13 日报 Day5</title>
    <url>/undefined/2024-11-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>理想是赶路人的月，是逆流者的桨<br>是荆棘尽处的繁华，是万仞山上的日出<br>让人在现实的泥沼中甘愿苦苦跋涉</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《图解HTTP》 P141-200
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><ul>
<li>1、在HTTP协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。</li>
<li>2、HTTP的缺点:<br>  通信使用明文(不加密)，内容可能会被窃听。<br>  不验证通信方的身份，因此有可能遭遇伪装。<br>  无法证明报文的完整性，所以有可能已遭篡改。</li>
<li>3、HTTP协议中没有加密机制，但可以通过和SSL(Secure Socket Layer, 安全套接层)或TLS(Transport Layer Security, 传输层安全)的组合使用，加密HTTP的通信内容。</li>
<li>4、认证本人核对的信息通常是指:<ul>
<li>密码: 只有本人才知道的字符串信息。</li>
<li>动态令牌: 仅限本人持有的设备内显示的一次性密码。</li>
<li>数字证书: 仅限本人(终端)持有的信息。</li>
<li>生物认证: 指纹和虹膜等本人的生理信息。</li>
<li>IC卡等: 仅限本人持有的信息。</li>
</ul>
</li>
<li>5、HTTP&#x2F;1.1使用的认证方式:<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
</li>
<li>6、WebSocket是一种在单个TCP连接上进行全双工通信的协议。通过WebSocket，浏览器和服务器之间的数据交换变得更加高效。为实现WebSocket通信，需要借助于HTTP协议。<br>HTTP的Upgrade首部字段可以将通信的协议切换为其他协议。通过发送Upgrade: websocket首部字段，通信过程从HTTP协议变成了WebSocket协议。同时Connection也会变为Upgrade。</li>
<li>7、HTTP防火墙(80&#x2F;tcp)和HTTPS防火墙(443&#x2F;tcp)</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-11 日报 Day3</title>
    <url>/undefined/2024-11-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>最慢的步伐不是跬步，而是徘徊;<br>最快的脚步不是冲刺，而是坚持。<br>The slowest pace is not a step, but wandering;<br>The fastest pace is not to sprint, but to persevere.</p>

    </div>
  </div>

<h3 id="今日思考"><a href="#今日思考" class="headerlink" title="今日思考"></a>今日思考</h3><p>今天看到了一个youtube博主分享的一个行为习惯视频(<a class="link"   href="https://www.youtube.com/watch?v=4zXTyc2ZjXM)%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%8F%90%E5%88%B0%E7%9A%84%E8%BF%99%E6%9C%AC%E3%80%8AThe" >https://www.youtube.com/watch?v=4zXTyc2ZjXM)，其中提到的这本《The <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 5 AM CLUB》以及5 AM Project.想要做到真正的早起需要一个明确的5 AM Project.<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411110002901.jpg"
                      alt="image-202411110002901"
                ></p>
<p>这边就有一个问题，为什么非得是早上起来为什么不能是晚上熬夜呢？<br>早起奥义:<br>早上大脑是清空的 因此可以更好的学习自己的事情<br>晚上大脑经历了早上忙碌的工作，下班之后的时间都是垃圾时间，因此晚上经常会习惯刷短视频 一刷刷到后半夜</p>
<p>-针对这个视频内容对我个人有什么思考呢？<br>可以考虑把下班后的学习时间提前到上班前。</p>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《网络是怎样连接的》 P75 - 完结🎉
2、https://www.sonarsource.com/learn/monorepo/
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><ul>
<li><p>1、地址转换的基本原理是在转发网络包时对IP头部中的IP地址和端口号进行修改。</p>
</li>
<li><p>2、缓存服务器是一台通过<strong>代理机制</strong>对数据进行缓存的服务器。代理介于Web服务器和客户端之间，具有对Web服务器访问进行中转的功能。</p>
</li>
<li><p>3、正向代理: 在客户端部署一个代理。比如VPN、科学上网工具等。</p>
</li>
<li><p>4、反向代理: Nginx反向代理用于负载均衡和缓存、CDN加速服务。</p>
</li>
<li><p>5、CDN（Content Delivery Network）内容分发网络: 通过将内容分发到全球各地的服务器，使用户可以从距离较近的服务器获取内容，提高访问速度。<br>CDN基于WEB服务器运营者和网络运营商签约将自己的缓存服务器放在客户端的运营商处。一般有厂商提供CDN服务，提供这种服务的厂商称为CDSP（Content Delivery Service Provider）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411110345416.png"
                      alt="image-20241111034457433"
                ></p>
</li>
</ul>
<p>Reference: <a class="link"   href="https://bg.qianzhan.com/trends/detail/506/240226-8132891d.html" >https://bg.qianzhan.com/trends/detail/506/240226-8132891d.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>6、根据响应头的Content-Type字段，浏览器会决定如何处理响应的内容。例如，如果Content-Type字段的值是text&#x2F;html，浏览器会将响应的内容解析为HTML文档并显示在页面上。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-14 日报 Day6</title>
    <url>/undefined/2024-11-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>遇见，获得，失去，成长，释怀，完结<br>我与旧事归于尽，来年依旧迎花开</p>
<p>Encounter, gain, loss, growth, release, and completion.<br>I am at the end of old things, and the next year will still welcome the blooming flowers.</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《图解HTTP》 P141-完结
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、CGI(Common Gateway Interface)是一种Web服务器和应用程序之间的接口标准。通过CGI，Web服务器可以调用外部程序处理客户端发送的请求。CGI程序是一种独立于服务器的程序，可以用任何语言编写。<br>2、Java Servlet可以处理 HTTP 请求并生成动态响应。与 CGI 不同，Servlet 直接运行在服务器中，无需每次请求都启动新的进程，因此性能更高。Servlet 部署在 Servlet 容器中（如 Apache Tomcat）。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>CGI(Common Gateway Interface): 通用网关接口</li>
<li>XSS(Cross-Site Scripting): 跨站脚本攻击</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-18 日报 Day10</title>
    <url>/undefined/2024-11-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>与时俱进，良性循环。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、巴菲特致股东的信P1-26</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、巴菲特成功的八字诀：与时俱进，良性循环。<br>2、坚持与合适的人、合适的企业打交道，与人为善、良性互动、相濡以沫、相互尊重、相得益彰、交相辉映，这是巴菲特多年一直保持成功的关键。<br>3、从别人的故事里，找到自己的人生启发，这就是读书的意义所在。<br>4、一家餐馆可以定位于特定的食客阶层-喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困感,最终离开。公司定位与股东之间的相处关系，与餐馆和食客的关系类似。你不可能在所有的时候满足所有的人。<br>5、总之，伯克希尔和它的长期持有者会从下跌的股市中获得好处，就像一个需要购买日常食品的消费者，从食品价格的下跌中获得的好处一样。所以当市场大跌时，和平常一样，不用担忧，不用沮丧，这对于伯克希尔反而是个好消息。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-19 日报 Day11</title>
    <url>/undefined/2024-11-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每次归程，都是为了更好出发。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P1-10 第一章: 什么是JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、完整的JavaScript包含</p>
<ul>
<li>ECMAScript，描述了该语言的语法和基本对象</li>
<li>文档对象模型（DOM），描述处理网页内容的方法和接口</li>
<li>浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口<br>2、ECMA描述这门语言的如下部分:</li>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>全局对象<br>3、DOM: 文档对象模型(DOM, Document Object Model)是一个应用编程接口，用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。<br>DOM通过创建表示文档的树，让开发者可以随心所欲控制网页的内容和结构。可以通过DOM API可以轻松地删除、添加、替换、修改节点。<br>4、BOM: 浏览器对象模型(BOM, Browser Object Model)，用于访问和操作浏览器窗口。BOM主要针对浏览器窗口和子窗口。</li>
<li>弹出新浏览器窗口</li>
<li>移动、缩放和关闭浏览器窗口</li>
<li>navigator对象，提供关于浏览器的详尽信息</li>
<li>location对象，提供浏览器加载页面的详尽信息</li>
<li>screen对象，提供关于用户屏幕分辨率的详尽信息</li>
<li>performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息</li>
<li>对cookie的支持<br>5、小结:</li>
<li>JavaScript是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成:<ul>
<li>ECMAScript：由ECMA-262定义，提供核心语言功能</li>
<li>文档对象模型(DOM)：提供与网页内容交互的方法和接口</li>
<li>浏览器对象模型(BOM)：提供与浏览器交互的方法和接口</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-15 日报 Day7</title>
    <url>/undefined/2024-11-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>无人扶我青云志，我自踏雪至山巅。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P1-53
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、JS的基本数据类型有: Undefined、Null、Boolean、Number、String、Symbol、BigInt。<br>2、JS的引用数据类型有: Object、Array、Function、Date、RegExp、Error。<br>3、JS中的真值和假值: </p>
<table>
<thead>
<tr>
<th>数值类型</th>
<th>转换成布尔值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>undefined</strong></td>
<td><strong>false</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>false</strong></td>
</tr>
<tr>
<td><strong>布尔值</strong></td>
<td><strong>true时true false时false</strong></td>
</tr>
<tr>
<td><strong>数字</strong></td>
<td><strong>+0、-0和NaN都是false，其他都是true</strong></td>
</tr>
<tr>
<td><strong>字符串</strong></td>
<td><strong>如果字符串是空的（长度是0）就是false，其他都是true</strong></td>
</tr>
<tr>
<td><strong>对象</strong></td>
<td><strong>true</strong></td>
</tr>
</tbody></table>
<p>4、相等运算符（ &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; ）</p>
<ul>
<li><strong>&#x3D;&#x3D;</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型(x)</th>
<th>类型(y)</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>undefined</td>
<td>True</td>
</tr>
<tr>
<td>undefined</td>
<td>null</td>
<td>True</td>
</tr>
<tr>
<td>数字</td>
<td>字符串</td>
<td>x &#x3D;&#x3D; toNumber(y)</td>
</tr>
<tr>
<td>字符串</td>
<td>数字</td>
<td>toNumber(x) &#x3D;&#x3D; y</td>
</tr>
<tr>
<td>布尔值</td>
<td>任何类型</td>
<td>toNumber(x) &#x3D;&#x3D; y</td>
</tr>
<tr>
<td>任何类型</td>
<td>布尔值</td>
<td>x &#x3D;&#x3D; toNumber(y)</td>
</tr>
<tr>
<td>字符串或数字</td>
<td>对象</td>
<td>x &#x3D;&#x3D; toPrimitive(y)</td>
</tr>
<tr>
<td>对象</td>
<td>字符串或数字</td>
<td>toPrimitive(x) &#x3D;&#x3D; y</td>
</tr>
</tbody></table>
<p>toNumber</p>
<table>
<thead>
<tr>
<th>值类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>+0</td>
</tr>
<tr>
<td>布尔值</td>
<td>如果是true,返回1;如果是false,返回+0;</td>
</tr>
<tr>
<td>数字</td>
<td>数字对应的值</td>
</tr>
<tr>
<td>字符串</td>
<td>将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字</td>
</tr>
<tr>
<td>对象</td>
<td>Number(toPrimitive(value))</td>
</tr>
</tbody></table>
<p>toPrimitive</p>
<table>
<thead>
<tr>
<th>值类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误。</td>
</tr>
</tbody></table>
<ul>
<li><strong>&#x3D;&#x3D;&#x3D;</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型(x)</th>
<th>值</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>数字</td>
<td>x和y数值相同(但不是NaN)</td>
<td>true</td>
</tr>
<tr>
<td>字符串</td>
<td>x和y是相同的字符</td>
<td>true</td>
</tr>
<tr>
<td>布尔值</td>
<td>x和y都是true或false</td>
<td>true</td>
</tr>
<tr>
<td>对象</td>
<td>x和y引用同一个对象</td>
<td>true</td>
</tr>
</tbody></table>
<p>5、在类的定义里声明每个实例都会创建自己的函数副本。使用原型方法可以节约内存和降低实例化的开销。不过原型方法只能声明公共函数和属性，而类定义可以声明只在类的内部访问的私有函数和属性。<br>6、ES6展开运算符（…）可以将数组展开成参数列表，也可以将对象展开成键值对列表。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(...params)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数中展开操作符可以代替arguments,当作剩余参数使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">restParamaterFunction</span>(<span class="params">x, y, ...a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x + y) * a.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">restParamaterFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="number">7</span>)); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></div>
<p>等价于</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">restParamaterFunction</span> (x, y) &#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">2</span>);</span><br><span class="line"> <span class="keyword">return</span> (x + y) * a.<span class="property">length</span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>
<p>7、ES6引入了数组解构的概念，可以用来一次初始化多个变量。<br>8、虽然ES6引入了声明类的方法但是JavaScript仍然是基于原型的。类只是原型的语法糖。使用新的类语法可以为属性创建存取器函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-16 日报 Day8</title>
    <url>/undefined/2024-11-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>心存希冀，目有繁星；<br>追光而遇，沐光而行。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P54-78
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、数据方法: </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat</td>
<td>连接2个或更多数组，并返回结果</td>
</tr>
<tr>
<td>every</td>
<td>对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true</td>
</tr>
<tr>
<td>filter</td>
<td>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组</td>
</tr>
<tr>
<td>forEach</td>
<td>对数组中的每一项运行给定函数。这个方法没有返回值</td>
</tr>
<tr>
<td>join</td>
<td>将所有的数组元素连接成一个字符串</td>
</tr>
<tr>
<td>indexOf</td>
<td>返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>返回在数组中搜索到的与给定参数相等的元素的索引里最大的值</td>
</tr>
<tr>
<td>map</td>
<td>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</td>
</tr>
<tr>
<td>reverse</td>
<td>颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在 的第一个</td>
</tr>
<tr>
<td>slice</td>
<td>传入索引值，将数组里对应索引范围内的元素作为新数组返回</td>
</tr>
<tr>
<td>some</td>
<td>对数组中的每一项运行给定函数，如果任一项返回true，则返回true</td>
</tr>
<tr>
<td>sort</td>
<td>按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数</td>
</tr>
<tr>
<td>toString</td>
<td>将数组作为字符串返回</td>
</tr>
<tr>
<td>valueOf</td>
<td>和toString类似，将数组作为字符串返回</td>
</tr>
<tr>
<td>reduce</td>
<td>array.reduce(callback, initialValue) callback接收四个参数 。accumulator：累加器，保存回调函数的返回值，并将其在下一次迭代中传递。currentValue：当前处理的数组元素。currentIndex：当前元素的索引（可选）。array：调用 reduce 的数组本身（可选）。</td>
</tr>
</tbody></table>
<p>2、栈</p>
<p>栈实现</p>
<p>最简单的: 存在的缺点 希望Stack类的用户只能访问暴露给类的方法。否则，就有 可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span> = []; <span class="comment">// 用数组存储栈元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作：添加一个元素到栈顶</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作：移除并返回栈顶元素</span></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Stack is empty, cannot pop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Stack is empty, no top element&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空栈</span></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用ES6的限定作用域Symbol实现</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _items = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span> () &#123;</span><br><span class="line"> <span class="variable language_">this</span>[_items] = []; <span class="comment">//&#123;2&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//Stack方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(stack);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols); <span class="comment">// [Symbol()]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol()</span></span><br><span class="line">stack[objectSymbols[<span class="number">0</span>]].<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_">print</span>(); <span class="comment">//输出 5, 8, 1</span></span><br></pre></td></tr></table></figure></div>

<p>虽然创建了一个symbol属性 但是依然可以获取到数组</p>
<p>用ES6的WeakMap</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span> () &#123;</span><br><span class="line"> items.<span class="title function_">set</span>(<span class="variable language_">this</span>, []); <span class="comment">//&#123;2&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>); <span class="comment">//&#123;3&#125;</span></span><br><span class="line"> s.<span class="title function_">push</span>(element);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line"> <span class="keyword">let</span> r = s.<span class="title function_">pop</span>();</span><br><span class="line"> <span class="keyword">return</span> r;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//其他方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><p>栈: 例子(书堆) 先进后出(LIFO)<br>方法包含: push、pop、peek、isEmpty、getSize、clear<br>应用: 回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后<br>面的章节讨论图和回溯问题时，</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-17 日报 Day9</title>
    <url>/undefined/2024-11-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>少年应有鸿鹄志，当骑骏马踏平川。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P79-88
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、队列是一种遵循先进先出（FIFO）原则的有序集合。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p>
<ul>
<li>enqueue(element(s))：向队列尾部添加一个（或多个）新的项。</li>
<li>dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li>
<li>front()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）。</li>
<li>isEmpty()：如果队列中不包含任何元素，返回true，否则返回false。</li>
<li>size()：返回队列包含的元素个数，与数组的length属性类似。<br>2、普通队列类实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">element</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><p>队列: 先进先出(FIFO)<br>方法包含: enqueue, dequeue, front, isEmpty, size<br>应用: 任务队列，因为每个标签页都是单线程处理的，它被称为事件循环。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-20 日报 Day12</title>
    <url>/undefined/2024-11-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每次停歇，都是为了积攒力量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P11-13 第二章：HTML中的JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、<script>元素有下列8个属性：</p>
<ul>
<li>async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。</li>
<li>charset：可选。表示通过src属性指定的代码的字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</li>
<li>crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。可以设置的值为anonymous和use-credentials。</li>
<li>defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>
<li>integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性。如果接收到的资源没有完整性验证通过，会阻止资源加载。</li>
<li>src：可选。表示包含要执行代码的外部文件。</li>
<li>type：可选。代替language属性，表示代码块中脚本的内容类型（也称为MIME类型）。这个值是text/javascript，除非代码块是在JavaScript以外的语言编写的。</li>
<li>language：废弃。最初用于表示代码块中脚本的语言。大多数浏览器会忽略这个属性，因此不应该再使用它。</li>
</ul>
<p>外部javascript文件的扩展名不是必须是js。因为浏览器不会检察所包含javascript文件的扩展名，这位服务器端动态生成javascript文件提供了可能性。<br>2、<script>可以包含来自外部域的javascript文件, 这个URL指向的资源可以跟包含它的HTML页面不在同一个域中。<br>浏览器在解析这个资源时会向src属性指定的路径发送一个GET请求，以取得相应资源，假定是一个js文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的javascript则受限制。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-24 日报 Day16</title>
    <url>/undefined/2024-11-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你有多自律，就有多自由。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P30-37 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript中有6种简单数据类型（也称为原始数据类型）：Undefined、Null、Boolean、Number、String、Symbol（ES6新增）。<br>2、ECMAScript中有一种复杂数据类型——对象（Object）。<br>3、typeof操作符：用于检测给定变量的数据类型。typeof会返回下列字符串之一:<br>    - “undefined”：如果这个值未定义<br>    - “boolean”：如果这个值是布尔值<br>    - “string”：如果这个值是字符串<br>    - “number”：如果这个值是数值<br>    - “object”：如果这个值是对象或null<br>    - “function”：如果这个值是函数<br>    - “symbol”：如果这个值是符号</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (message)); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">95</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>调用typeof null会返回”object”，这是因为特殊值null被认为是一个对空对象的引用。<br>注意 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，<br>函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(message)&#123;</span><br><span class="line">    <span class="comment">// 这个代码块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!message)&#123;</span><br><span class="line">    <span class="comment">// 这个代码块会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(age)&#123;</span><br><span class="line">    <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4、Null类型：Null类型只有一个值，即特殊的null。逻辑上讲，null值表示一个空对象指针，因此用typeof操作符检测null值会返回”object”。<br>let car &#x3D; null;<br>console.log(typeof car); &#x2F;&#x2F; “object”<br>5、Boolean类型：Boolean类型有两个字面值：true和false。这两个值不是数字，但它们在需要时会被转换为数字。true转换为1，false转换为0。<br>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：<br>let message &#x3D; “Hello world!”;<br>let messageAsBoolean &#x3D; Boolean(message);<br>其转化规则如下表：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字（包含无穷值）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>N&#x2F;A（不存在）</td>
<td>undefined</td>
</tr>
<tr>
<td>6、Number类型：ECMAScript 中的所有数字都是浮点数。在其他编程语言中，整数和浮点数是不同的数据类型，但在 ECMAScript 中，它们是同一种数据类型。在 ECMAScript 中，可以使用十进制、八进制（在数字前加0）和十六进制（在数字前加0x）。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，</td>
<td></td>
<td></td>
</tr>
<tr>
<td>第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出了应</td>
<td></td>
<td></td>
</tr>
<tr>
<td>有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>; <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>; <span class="comment">// 无效的八进制数值——解析为79</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span>; <span class="comment">// 无效的八进制数值——解析为8</span></span><br></pre></td></tr></table></figure></div>
<p>十六进制字面量的第一部分必须是 0x，然后是任何十六进制数字（0<del>9 和 a</del>f）。字母 a~f 可以是大写的，也可以是小写的。如下所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十六进制的10</span></span><br><span class="line"><span class="keyword">let</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">// 十六进制的31</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>浮点数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>; <span class="comment">// 小数点后没有数字</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>; <span class="comment">// 小数点前没有数字</span></span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 可以省略整数部分和小数点</span></span><br></pre></td></tr></table></figure></div>
科学计数法表示的浮点数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure></div>
浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不<br>是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下<br>面的例子：<br>if (a + b &#x3D;&#x3D; 0.3) { &#x2F;&#x2F; 别这么干！<br> console.log(“You got 0.3.”);<br>}<br>这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。<br>注意 之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript<br>所独有。其他使用相同格式的语言也有这个问题。</li>
<li>值的范围：由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。</li>
<li>NaN(Not a Number)，用来表示本来要返回数值的操作失败了（而不是抛出错误）。NaN 是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，0 除以 0 会返回 NaN——这是一个数学错误，而不是一个 JavaScript 错误。NaN 与任何值都不相等，包括它自己：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>/<span class="number">0</span>); <span class="comment">// Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">5</span>/<span class="number">0</span>); <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure></div>
NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN&#x2F;10），在连续多步计算时这可能是个问题。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：<br>console.log(NaN &#x3D;&#x3D; NaN); &#x2F;&#x2F; false</li>
<li>数值转换：Number()、parseInt()和parseFloat()。<br>Number()函数：</li>
<li>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是 null 值，返回 0。</li>
<li>如果是 undefined，返回 NaN。</li>
<li>如果是字符串，遵循下列规则：<ul>
<li>字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值（忽略前导零）。</li>
<li>字符串中包含有效的浮点格式，如”10.1”，则将其转换为对应的浮点数值（同样忽略前导零）。</li>
<li>字符串中包含有效的十六进制格式，如”0xf”，则将其转换为对应的十进制整数值。</li>
<li>字符串中包含字面量”null”，返回 0。</li>
<li>字符串中包含字面量”undefined”，返回 NaN。</li>
<li>如果字符串是空的（不包含任何字符），则返回 0。</li>
<li>如果字符串中包含除上述情况之外的字符，则返回 NaN。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;Hello world!&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;000011&quot;</span>)); <span class="comment">// 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">false</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。<br>parseInt()函数：parseInt()函数会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()会返回 NaN。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="number">22.5</span>)); <span class="comment">// 22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>)); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure></div>
parseInt()函数还可以接受第二个参数，用于指定转换时使用的基数（即多少进制）。如果字符串以”0x”开头，那么基数是 16（十六进制）。如果字符串以”0”开头，那么基数是 8（八进制）。如果字符串以其他任何值开头，那么基数是 10（十进制）。例如：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>)); <span class="comment">// 175</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>)); <span class="comment">// 175</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>)); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></div>
parseFloat()函数：parseFloat()函数用于解析浮点数，但它始终会忽略字符串前面的空格。如果字符串的第一个字符不能转换为数字，parseFloat()会返回 NaN。例如：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>)); <span class="comment">// 22.5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>)); <span class="comment">// 22.34</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-25 日报 Day17</title>
    <url>/undefined/2024-11-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>把行动交给现在，把结果交给时间。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P38-47 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、String类型: 表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示，因此下面的代码都是合法的：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Zakas&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">`Hello, <span class="subst">$&#123;firstName&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>字符字面量: 如下表所示:<table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>`</td>
<td>反引号</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制代码nn表示的一个字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>以十六进制代码nnnn表示的一个 Unicode 字符</td>
</tr>
<tr>
<td>2、字符串的特点：变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</td>
<td></td>
</tr>
<tr>
<td>let lang &#x3D; “Java”;</td>
<td></td>
</tr>
<tr>
<td>lang &#x3D; lang + “Script”;</td>
<td></td>
</tr>
<tr>
<td>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如 Firefox 1.0 之前的版本和 IE6.0）在拼接字符串时非常慢的原因。这些浏览器在后来的版本中都有针对性地解决了这个问题</td>
<td></td>
</tr>
<tr>
<td>3、转换为字符串：有三种方法可以把值转换为字符串：toString()、String()和模板字面量。</td>
<td></td>
</tr>
</tbody></table>
</li>
<li>toString()方法: 该方法是所有引用类型中都具有的方法，其基本思想是返回一个表示该对象的字符串。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.<span class="title function_">toString</span>(); <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.<span class="title function_">toString</span>(); <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure></div>
null和undefined值没有toString()方法，如果调用这两个值的这个方法会导致错误。如果不确定一个值是不是null或undefined，可以使用String()转型函数。String()函数遵循如下规则:</li>
<li>如果值有toString()方法，则调用该方法（没有参数）并返回结果。</li>
<li>如果值是null，则返回”null”。</li>
<li>如果值是undefined，则返回”undefined”。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> value4;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value1)); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value2)); <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value3)); <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value4)); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></div>
注意 用加号操作符给一个值加上一个空字符串””也可以将其转换为字符串<br>3、模版字面量：ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：<br>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：<br>let pageHTML &#x3D; &#96; <div> 
 <a href="#"> 
 <span>Jake</span> 
 </a> 
</div>`; 
由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：
4、字符串插值：字符串插值通过在${}中使用一个 JavaScript 表达式实现：
`${ value } to the ${ exponent } power is ${ value * value }`
所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义：
将表达式转换为字符串时会调用 toString()：
let foo = { toString: () => 'World' }; 
console.log(`Hello, ${ foo }!`); // Hello, World!
5、模版字面量标签函数：标签函数可以自定义插值行为。标签函数
会接收被插值记号分隔后的模板和对每个表达式求值的结果。
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(strings); <span class="comment">// [&quot;The sum of &quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(aValExpression); <span class="comment">// 6</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(bValExpression); <span class="comment">// 9</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(sumExpression); <span class="comment">// 15</span></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(untaggedResult); <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure></div>
因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleTag</span>(<span class="params">strings, ...expressions</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(strings); </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(expression); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; </span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure></div>
6、原始字符串：使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数：
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unicode示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\u00A9`</span>); <span class="comment">// ©</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`\u00A9`</span>); <span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hello\nWorld`</span>); <span class="comment">// &quot;Hello\nWorld&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printRaw</span>(<span class="params">strings</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Actual characters:&#x27;</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(string); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Escaped characters;&#x27;</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.<span class="property">raw</span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(rawString); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>; </span><br><span class="line"><span class="comment">// Actual characters: </span></span><br><span class="line"><span class="comment">// © </span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters: </span></span><br><span class="line"><span class="comment">// \u00A9 </span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure></div>
🔹 模板字面量的行为</li>
</ul>
<p>当你使用标签模板时，字符串部分和插值部分是分开的，具体来说：<br>    •	strings 是一个 数组，包含字符串部分。<br>    •	strings.raw 是原始字符串数组，不会对 \u00A9 或 \n 进行转义解析。<br>    •	插值的 ${‘and’} 不会包含在 strings 数组中，而是作为函数的额外参数传递。</p>
<p>⸻</p>
<p>🔹 解析 printRaw\u00A9${ ‘and’ }\n&#96;&#96;</p>
<p>printRaw 函数的实际接收参数是：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">printRaw</span>([<span class="string">&quot;\u00A9&quot;</span>, <span class="string">&quot;\n&quot;</span>], <span class="string">&quot;and&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>参数解析</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">strings = [<span class="string">&quot;\u00A9&quot;</span>, <span class="string">&quot;\n&quot;</span>]; <span class="comment">// 解析后是 [&quot;©&quot;, &quot;\n&quot;]</span></span><br><span class="line">strings.<span class="property">raw</span> = [<span class="string">&quot;\\u00A9&quot;</span>, <span class="string">&quot;\\n&quot;</span>]; <span class="comment">// 原始字符串</span></span><br></pre></td></tr></table></figure></div>
<p>7、Symbol类型：Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。<br>symbol符号的基本使用方法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> sym); <span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建 Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。<br>最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：<br>let myBoolean &#x3D; new Boolean();<br>console.log(typeof myBoolean); &#x2F;&#x2F; “object”<br>let myString &#x3D; new String();<br>console.log(typeof myString); &#x2F;&#x2F; “object”<br>let myNumber &#x3D; new Number();<br>console.log(typeof myNumber); &#x2F;&#x2F; “object”</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 使用全局符号注册表：如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。使用Symbol.for()方法</span><br><span class="line">```javascript</span><br><span class="line">let fooGlobalSymbol = Symbol.for(&#x27;foo&#x27;);</span><br><span class="line">console.log(typeof fooGlobalSymbol); // &quot;symbol&quot;</span><br></pre></td></tr></table></figure></div>
<p>Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>可以使用 Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字<br>符串键。如果查询的不是全局符号，则返回 undefined。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s)); <span class="comment">// foo </span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)); <span class="comment">// undefined </span></span><br><span class="line">如果传给 <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>()的不是符号，则该方法抛出 <span class="title class_">TypeError</span>：</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用符号作为属性：凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()&#x2F;Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>), </span><br><span class="line"> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>), </span><br><span class="line"> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>), </span><br><span class="line"> s4 = <span class="title class_">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> [s1]: <span class="string">&#x27;foo val&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); </span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val&#125; </span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); </span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125; </span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(o, &#123; </span><br><span class="line"> [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;, </span><br><span class="line"> [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); </span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val, </span></span><br><span class="line"><span class="comment">// Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure></div>
类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型<br>的键<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>), </span><br><span class="line"> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> [s1]: <span class="string">&#x27;foo val&#x27;</span>, </span><br><span class="line"> [s2]: <span class="string">&#x27;bar val&#x27;</span>, </span><br><span class="line"> <span class="attr">baz</span>: <span class="string">&#x27;baz val&#x27;</span>, </span><br><span class="line"> <span class="attr">qux</span>: <span class="string">&#x27;qux val&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o)); </span><br><span class="line"><span class="comment">// [Symbol(foo), Symbol(bar)] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o)); </span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(o)); </span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(o)); </span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-21 日报 Day13</title>
    <url>/undefined/2024-11-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>生活的真谛从来都不在别处，就在日常一点一滴的奋斗里。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P14-17 第二章：HTML中的JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、推迟执行脚本：defer属性，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。<br>延迟脚本会在文档解析完毕后，DOMContentLoaded事件触发前执行。这样可以确保脚本在文档解析期间不会对DOM进行操作，从而加快页面加载速度。<br>2、异步执行脚本：async属性，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。<br>异步脚本不会按照它们在页面中出现的顺序执行，而是在下载完成后立即执行。这种方式对于不需要按照顺序执行的脚本非常有用，比如对页面进行统计分析或加载广告。<br>给脚本添加async属性，可以使脚本异步加载，不会阻塞页面的加载。但是异步脚本不能保证按照它们在页面中出现的顺序执行，所以要谨慎使用。异步脚本保证在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。<br>3、动态加载脚本：可以通过JavaScript动态创建script元素，然后将其添加到页面中。这种方式可以实现按需加载脚本，从而提高页面加载速度。使用预加载器</p>
<link rel="preload" href="example.js" as="script">可以在页面加载时预加载脚本，但不会执行它。]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-22 日报 Day14</title>
    <url>/undefined/2024-11-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>想，全是问题；做，才有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P18-20 第二章：HTML中的JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、外部js文件和行内代码相比的优势：</p>
<ul>
<li>可维护性：把js代码放在单独的文件中，可以让代码更易于维护。</li>
<li>可缓存：如果js代码在多个页面中使用，浏览器会缓存js文件，从而提高页面加载速度。</li>
<li>适应未来：通过使用外部文件，可以把js和HTML分离，从而提高代码的可维护性和适应未来的能力。<br>2、noscript元素：当浏览器不支持脚本或者禁用脚本时，noscript元素会显示替代内容。noscript元素可以包含任何HTML元素，除了script元素。<br>3、🚀 问题描述: 为什么使用 defer 的 <script> 不一定在 DOMContentLoaded 事件之前执行？<br>理论上: 带有 defer 属性的 <script> 应该在 HTML 解析完成后、DOMContentLoaded 事件触发之前执行。<br>实际中: 有时候会出现 defer 脚本在 DOMContentLoaded 事件之后才执行的情况。<br>⸻</li>
</ul>
<p>💡 原因一: 外部资源加载延迟</p>
<p>defer 属性只保证脚本 按顺序执行，且在 DOM 解析完成后执行，但不保证加载速度。</p>
<p>场景:<br>    •	如果 <script> 的外部资源 (如 CDN 上的 JS 文件) 加载很慢，可能导致脚本在 DOMContentLoaded 之后才执行。<br>    •	尤其是当网络环境较差时，外部资源加载速度直接影响脚本执行时间。</p>
<p>解决方法:<br>    •	确保外部资源的加载速度，例如使用本地缓存或可靠的 CDN。<br>    •	通过设置 Cache-Control 或使用 Service Worker 缓存脚本资源。</p>
<p>⸻</p>
<p>💡 原因二: 解析器阻塞与渲染阻塞</p>
<p>defer 脚本在 DOM 解析完成后执行，但如果有其他原因导致解析器或渲染阻塞，可能延后执行时间。</p>
<p>常见阻塞原因:<br>    1.	样式阻塞:<br>    •	CSS 文件的加载和解析可能阻塞 DOMContentLoaded 事件。<br>    •	如果 CSS 加载时间过长，可能导致 defer 脚本延后执行。<br>    2.	同步脚本阻塞:<br>    •	页面中如果有同步执行的 <script> (未加 async 或 defer)，会阻塞 DOM 解析，进而影响 defer 脚本的执行。</p>
<p>解决方法:<br>    •	使用 <link rel="preload"> 预加载关键 CSS。<br>    •	避免使用同步脚本或放置到页面底部。</p>
<p>⸻</p>
<p>💡 原因三: 异步脚本的干扰 (async vs defer)</p>
<p>async 和 defer 属性的执行顺序不同：<br>    •	async: 脚本加载完成后立即执行，可能在 defer 脚本之前执行。<br>    •	defer: 按顺序执行，且保证在 DOMContentLoaded 前执行。</p>
<p>问题:<br>    •	如果 async 脚本的执行时间过长，可能影响 defer 脚本的执行时间，导致其在 DOMContentLoaded 之后才执行。</p>
<p>解决方法:<br>    •	尽量避免 async 和 defer 混用。<br>    •	或者将 async 用于独立的、不影响 DOM 操作的脚本。</p>
<p>⸻</p>
<p>💡 原因四: 网络延迟与资源优先级<br>    1.	资源优先级:<br>    •	浏览器对脚本、样式、图片等资源有不同的加载优先级。<br>    •	某些资源 (如大图片) 的加载可能会影响 defer 脚本的下载速度，进而延后执行。<br>    2.	HTTP/2 的多路复用:<br>    •	使用 HTTP/2 时，资源加载顺序可能会被优化或调整，导致 defer 脚本的加载时间不确定。</p>
<p>解决方法:<br>    •	使用 <link rel="preload"> 提前加载关键资源。<br>    •	合理配置 CDN 和缓存策略。</p>
<p>⸻</p>
<p>💡 原因五: 浏览器兼容性与差异</p>
<p>不同浏览器对 defer 的支持存在细微差异，尤其是一些旧版本浏览器可能有 Bug:<br>    •	例如，早期的 IE 可能在 defer 执行时机上存在不一致。<br>    •	某些移动浏览器在解析 DOM 时处理 defer 方式不同。</p>
<p>解决方法:<br>    •	使用现代浏览器进行测试，必要时做兼容性处理。<br>    •	可以考虑使用 DOMContentLoaded 事件监听脚本执行情况进行调试。</p>
<p>⸻</p>
<p>🛠️ 总结与建议</p>
<p>原因	解决方法<br>外部资源加载延迟	使用可靠的 CDN 或缓存策略<br>解析器与渲染阻塞	预加载 CSS，避免同步脚本<br>async 与 defer 干扰	尽量避免混用，async 用于独立脚本<br>网络延迟与资源优先级	使用 <link rel="preload"> 和 HTTP/2 优化<br>浏览器兼容性问题	确保在现代浏览器上测试，必要时加条件注释处理</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-23 日报 Day15</title>
    <url>/undefined/2024-11-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你有多自律，就有多自由。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P21-29 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、标识符：指变量、函数、属性的名字，或者函数的参数。标识符可以是下列几种：</p>
<ul>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li>
<li>其他字符可以是字母、下划线、美元符号或数字；<br>2、注释：单行注释以两个斜杠（&#x2F;&#x2F;）开头，多行注释以斜杠加星号（&#x2F;<em>）开头，以星号加斜杠（</em>&#x2F;）结尾。<br>macOS系统中，可以使用 Command + &#x2F; 快捷键来快速注释代码。</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">单行注释：</span><br><span class="line">快捷键：<span class="title class_">Command</span>+/</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">多行注释:</span><br><span class="line">快捷键：<span class="title class_">Command</span>+shift+/</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 12</span></span><br><span class="line"><span class="comment">12 */</span></span><br></pre></td></tr></table></figure></div>
<p>3、严格模式: 通过在脚本开头添加”use strict”，可以强制开启 ECMAScript 5 的严格模式。use strict是一个预处理指令，用于指定代码在严格模式下执行。<br>也可以单独在函数内部开启严格模式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4、关键词和保留字：ECMAScript中有一些关键词和保留字，它们有特殊用途，不能用作标识符。</p>
<ul>
<li>关键词：break、case、catch、continue、debugger、default、delete、do、else、false、finally、for、function、if、in、instanceof、new、null、return、switch、this、throw、true、try、typeof、var、void、while、with</li>
<li>保留字：abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile<br>5、变量：ECMAScript 的变量是松散类型的，可以用来保存任何类型的数据。有三种方式声明变量：var、let、const。</li>
<li>var：</li>
<li>声明作用域：函数作用域</li>
<li>变量提升：变量声明会被提升到函数作用域的顶部<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure></div></li>
<li>let：</li>
<li>声明作用域：块作用域<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// ReferenceError: age is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
<li>变量提升：不存在变量提升<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// ReferenceError: Cannot access &#x27;age&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure></div></li>
<li>let的暂时性死区：在块作用域内，使用 let 声明的变量不会被提升，而且在声明之前使用这个变量会抛出错误。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂时性死区</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">    name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>全局声明：使用let声明的全局变量不会成为window对象的属性。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">age</span>); <span class="comment">// 26</span></span><br></pre></td></tr></table></figure></div></li>
<li>条件声明：使用let声明的变量只在块作用域内有效。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure></div></li>
<li>for循环中的let声明：<br>在let出现之前，for循环定义的迭代变量会渗透到循环体外部。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5 5 5 5 5</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>const：声明一个只读的常量。一旦声明，常量的值就不能改变。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"><span class="comment">// const也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">name = <span class="string">&#x27;Nicholas&#x27;</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"><span class="comment">// const声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure></div>
const 声明的限制只适用于它指向的变量的引用，而不适用于它指向的变量的值。</li>
</ul>
<pre><code class="javascript">const person = &#123;&#125;;
person.name = &#39;Matt&#39;;
console.log(person.name); // Matt
</code></pre>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-26 日报 Day18</title>
    <url>/undefined/2024-11-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你自己不放弃，别人才有机会帮你。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P48-54 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。<br>for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。<br>全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。<br>注意 在提到 ECMAScript 规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator 指的就是 Symbol.iterator。<br>2、Symbol.asyncIterator: 根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的 AsyncIterator。由 for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emitter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">max</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">max</span> = max; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">asyncIdx</span> = <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">async</span> *[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">asyncIdx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">asyncIdx</span>++)); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncCount</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>(<span class="number">5</span>); </span><br><span class="line"> <span class="keyword">for</span> <span class="title function_">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">asyncCount</span>(); </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
<p>3、Symbol.hasInstance: 这个符号作为一个属性表示“一个方法，该方法确定一个构造器对象识别的对象是否为其实例”。由instanceof 操作符使用”。instanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。instanceof 的典型使用场景如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f <span class="keyword">instanceof</span> <span class="title class_">Foo</span>); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系。以 Symbol.hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](f)); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Bar</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用。由于 instanceof操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Bar</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>]() &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Baz</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Bar</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Baz</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Baz</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>4、Symbol.isConcatSpreadable: 这个符号作为一个属性表示“一个布尔值，指示对象是否应该展开为数组元素”。这个属性会影响数组的 concat() 方法，如果一个对象的 Symbol.isConcatSpreadable 属性为 true，那么 concat() 方法会展开这个对象，否则会将这个对象作为一个整体添加到数组中。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(array)); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;] </span></span><br><span class="line">array[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(array)); <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLikeObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;] </span></span><br><span class="line">arrayLikeObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;] </span></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(otherObject)); <span class="comment">// [&#x27;foo&#x27;, Set(1)] </span></span><br><span class="line">otherObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(otherObject)); <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure></div>
<p>5、Symbol.iterator: 这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="title function_">constructor</span>(<span class="params">max</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">max</span> = max; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">idx</span> = <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">idx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">idx</span>++; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>(<span class="number">5</span>); </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">count</span>(); </span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
<p>6、Symbol.match: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于匹配字符串”。这个属性会影响 String.prototype.match() 方法，如果一个对象的 Symbol.match 属性为一个函数，那么 match() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">match</span>]); </span><br><span class="line"><span class="comment">// ƒ [Symbol.match]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/bar/</span>)); </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooMatcher</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringMatcher</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123; </span><br><span class="line"> <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="variable language_">this</span>.<span class="property">str</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>7、Symbol.replace: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于替换字符串”。这个属性会影响 String.prototype.replace() 方法，如果一个对象的 Symbol.replace 属性为一个函数，那么 replace() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">replace</span>]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobarbaz&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooReplacer</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">replace</span>](target, replacement) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="title function_">join</span>(replacement); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">replace</span>(<span class="title class_">FooReplacer</span>, <span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringReplacer</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">replace</span>](target, replacement) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="variable language_">this</span>.<span class="property">str</span>).<span class="title function_">join</span>(replacement); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">StringReplacer</span>(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>8、Symbol.search: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于搜索字符串”。这个属性会影响 String.prototype.search() 方法，如果一个对象的 Symbol.search 属性为一个函数，那么 search() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">search</span>]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooSearcher</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">search</span>](target) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">indexOf</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoo&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringSearcher</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">search</span>](target) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">str</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoo&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>
<p>9、Symbol.species: 这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true </span></span><br><span class="line">bar = bar.<span class="title function_">concat</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> <span class="title class_">Baz</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Baz</span>); <span class="comment">// true </span></span><br><span class="line">baz = baz.<span class="title function_">concat</span>(<span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Baz</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>10、Symbol.split: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于拆分字符串”。这个属性会影响 String.prototype.split() 方法，如果一个对象的 Symbol.split 属性为一个函数，那么 split() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">split</span>]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobarbaz&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooSplitter</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">split</span>](target) &#123; </span><br><span class="line"> <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">split</span>(<span class="title class_">FooSplitter</span>)); </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;] </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringSplitter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">split</span>](target) &#123; </span><br><span class="line"> <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="variable language_">this</span>.<span class="property">str</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">StringSplitter</span>(<span class="string">&#x27;foo&#x27;</span>))); </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>11、Symbol.toPrimitive: 这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值”。这个属性会影响对象的类型转换，如果一个对象的 Symbol.toPrimitive 属性为一个函数，那么对象会调用这个函数，而不是使用默认的类型转换。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + foo); <span class="comment">// &quot;3[object Object]&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> - foo); <span class="comment">// NaN </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(foo)); <span class="comment">// &quot;[object Object]&quot; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] = <span class="keyword">function</span>(<span class="params">hint</span>) &#123; </span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>: </span><br><span class="line">            <span class="attr">default</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + bar); <span class="comment">// &quot;3default bar&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> - bar); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-27 日报 Day18</title>
    <url>/undefined/2024-11-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>脆弱的人总是有很多借口，但勇者却从不逃走。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P54-55 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Symbol.toStringTag: 用来定制对象的toString方法返回的字符串的标签值。<br>通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Set(0) &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toString</span>()); <span class="comment">// [object Set] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// Set </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// Foo &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()); <span class="comment">// [object Object] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&#x27;Bar&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// Bar &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">toString</span>()); <span class="comment">// [object Bar] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure></div>
<p>2、Symbol.unscopables: 用来定制对象的with语句行为。这个符号作为一个属性表示“一个对象，其自有属性指定了使用 with 语句时要排除的属性”。这个符号的值是一个对象，其属性名指定了在 with 语句中排除的属性。这个符号的值是一个对象，其属性名指定了在 with 语句中排除的属性。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// bar </span></span><br><span class="line">&#125; </span><br><span class="line">o[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>] = &#123; </span><br><span class="line"> <span class="attr">foo</span>: <span class="literal">true</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3、with 是 JavaScript 中的一个语句，用来扩展一个对象的作用域链，临时将一个对象的属性作为当前作用域的变量使用。with 语句的语法如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) </span><br><span class="line"> statement</span><br><span class="line"><span class="keyword">with</span> (object) &#123;</span><br><span class="line">  <span class="comment">// 在这个块中，可以直接访问 object 的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>expression 是一个对象表达式，statement 是一个语句或一个代码块。with 语句的执行过程如下：</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-28 日报 Day19</title>
    <url>/undefined/2024-11-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>记住，能打败自己的永远只有下一秒的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P56-59 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Object类型：ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>; <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure></div>
<p>2、Object 的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数。对于前面的例子，这个属性的值就是 Object()。</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必題是字符串（如 o.hasOwnProperty(‘name’)）。</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。</li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必題是字符串。</li>
<li>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。<br>3、操作符：数学操作符、位操作符、关系操作符、相等操作符。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和&#x2F;或 toString()方法来取得可以计算的值。<br>4、一元操作符之递增&#x2F;递减操作符：前缀和后缀递增&#x2F;递减操作符。前缀递增&#x2F;递减操作符会在语句被求值之前改变变量的值，而后缀递增&#x2F;递减操作符则是在包含它们的语句被求值之后再改变变量的值。以下例子展示了这两种操作符的区别：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherAge); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2; </span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 21 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num4); <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2; </span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 22 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num4); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></div>
这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。<br> 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。<br> 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。<br> 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。<br> 对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。<br> 对于浮点值，加 1 或减 1。<br> 如果是对象，则调用其（第 5 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。<br>下面的例子演示了这些规则：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="title function_">valueOf</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">s1++; <span class="comment">// 值变成数值 3 </span></span><br><span class="line">s2++; <span class="comment">// 值变成 NaN </span></span><br><span class="line">b++; <span class="comment">// 值变成数值 1 </span></span><br><span class="line">f--; <span class="comment">// 值变成 0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--; <span class="comment">// 值变成-2</span></span><br></pre></td></tr></table></figure></div>
5、一元操作符之加和减: 一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：<br>let num &#x3D; 25;<br>num &#x3D; +num;<br>console.log(num); &#x2F;&#x2F; 25<br>如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和&#x2F;或 toString()方法以得到可以转换的值。<br>下面的例子演示了一元加在应用到不同数据类型时的行为：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="title function_">valueOf</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">s1 = +s1; <span class="comment">// 值变成数值 1 </span></span><br><span class="line">s2 = +s2; <span class="comment">// 值变成数值 1.1 </span></span><br><span class="line">s3 = +s3; <span class="comment">// 值变成 NaN </span></span><br><span class="line">b = +b; <span class="comment">// 值变成数值 0 </span></span><br><span class="line">f = +f; <span class="comment">// 不变，还是 1.1 </span></span><br><span class="line">o = +o; <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-30 日报 Day21</title>
    <url>/undefined/2024-11-30/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>焦虑不会消除明天的悲伤，它只会消耗今天的力量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P66-70 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、乘性操作符：乘性操作符包括乘法（*）、除法（&#x2F;）和求模（%）。这些操作符都是二元操作符，因为它们都需要两个值。乘法和除法的优先级相等，而求模的优先级略低。在使用多个乘性操作符时，需要注意它们的执行顺序。如果有多个乘性操作符，那么它们的执行顺序是从左到右。例如：<br>2、指数操作符：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> ** <span class="number">3</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">square **= <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></div>
<p>3、加性操作符之加法操作符：<br>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：<br> 如果有任一操作数是 NaN，则返回 NaN；<br> 如果是 Infinity 加 Infinity，则返回 Infinity；<br> 如果是-Infinity 加-Infinity，则返回-Infinity；<br> 如果是 Infinity 加-Infinity，则返回 NaN；<br> 如果是+0 加+0，则返回+0；<br> 如果是-0 加+0，则返回+0；<br> 如果是-0 加-0，则返回-0。<br>不过，如果有一个操作数是字符串，则要应用如下规则：<br> 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；<br> 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。<br>如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。<br>看下面的例子：<br>let result1 &#x3D; 5 + 5; &#x2F;&#x2F; 两个数值<br>console.log(result1); &#x2F;&#x2F; 10<br>let result2 &#x3D; 5 + “5”; &#x2F;&#x2F; 一个数值和一个字符串<br>console.log(result2); &#x2F;&#x2F; “55”<br>以上代码展示了加法操作符的两种运算模式。正常情况下，5 + 5 等于 10（数值），如前两行代码所示。但是，如果将一个操作数改为字符串，比如”5”，则相加的结果就变成了”55”（原始字符串值），因为第一个操作数也会被转换为字符串。<br>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：<br>let num1 &#x3D; 5;<br>let num2 &#x3D; 10;<br>let message &#x3D; “The sum of 5 and 10 is “ + num1 + num2;<br>console.log(message); &#x2F;&#x2F; “The sum of 5 and 10 is 510”<br>4、加性操作符之减法操作符：<br>减法操作符（-）也是使用很频繁的一种操作符，比如：<br>let result &#x3D; 2 - 1;<br>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。<br> 如果两个操作数都是数值，则执行数学减法运算并返回结果。<br> 如果有任一操作数是 NaN，则返回 NaN。<br> 如果是 Infinity 减 Infinity，则返回 NaN。<br> 如果是-Infinity 减-Infinity，则返回 NaN。<br> 如果是 Infinity 减-Infinity，则返回 Infinity。<br> 如果是-Infinity 减 Infinity，则返回-Infinity。<br> 如果是+0 减+0，则返回+0。<br> 如果是+0 减-0，则返回-0。<br> 如果是-0 减-0，则返回+0。<br> 如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转<br>换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是<br>NaN。<br> 如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则<br>减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再<br>将得到的字符串转换为数值。<br>以下示例演示了上面的规则：<br>let result1 &#x3D; 5 - true; &#x2F;&#x2F; true 被转换为 1，所以结果是 4<br>let result2 &#x3D; NaN - 1; &#x2F;&#x2F; NaN<br>let result3 &#x3D; 5 - 3; &#x2F;&#x2F; 2<br>let result4 &#x3D; 5 - “”; &#x2F;&#x2F; “”被转换为 0，所以结果是 5<br>let result5 &#x3D; 5 - “2”; &#x2F;&#x2F; “2”被转换为 2，所以结果是 3<br>let result6 &#x3D; 5 - null; &#x2F;&#x2F; null 被转换为 0，所以结果是 5<br>5、关系操作符：括小于（&lt;）、大于（&gt;）、小于等于（&lt;&#x3D;）和大于等于（&gt;&#x3D;）。这几个操作符都返回布尔值，用于比较两个值的大小关系。在比较两个值时，会遵循如下规则：<br> 如果两个操作数都是数值，则执行数值比较。<br> 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。<br> 如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较。<br> 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果没有 valueOf()方法，则调用 toString()方法，并按照前面的规则执行比较。<br> 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。<br>5、关系操作符：小于（&lt;）、大于（&gt;）、小于等于（&lt;&#x3D;）和大于等于（&gt;&#x3D;）。这几个操作符都返回布尔值，用于比较两个值的大小关系。与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。<br> 如果操作数都是数值，则执行数值比较。<br> 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。<br> 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。<br> 如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。<br>如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。<br> 如果有任一操作数是布尔值，则将其转换为数值再执行比较。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>
<p>因为字符”a”不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即任何关系操作符在涉及比较 NaN 时都返回 false。这样一来，下面的例子有趣了：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="title class_">NaN</span> &lt; <span class="number">3</span>; <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title class_">NaN</span> &gt;= <span class="number">3</span>; <span class="comment">// false </span></span><br></pre></td></tr></table></figure></div>
<p>在大多数比较的场景中，如果一个值不小于另一个值，那就一定大于或等于它。但在比较 NaN 时，无论是小于还是大于等于，比较的结果都会返回 false。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-29 日报 Day20</title>
    <url>/undefined/2024-11-29/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>躲起来的星星也在努力发光，你也要加油。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P60-65 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、位操作符: ECMAScript<br>中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑 32 位整数即可。<br>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。<br>负值是以补码形式存储的，即数值的绝对值的二进制形式取反后加 1。例如，-18 的二进制形式是 00000000 00000000 00000000 00010010，取反后是 11111111 11111111 11111111 11101101，加 1 后是 11111111 11111111 11111111 11101110。<br>2、按位非~</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>; <span class="comment">// 二进制 00000000000000000000000000011001 </span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1; <span class="comment">// 二进制 11111111111111111111111111100110 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num2); <span class="comment">// -26</span></span><br></pre></td></tr></table></figure></div>
<p>这里，按位非操作符作用到了数值 25，得到的结果是26。由此可以看出，按位非的最终效果是对<br>数值取反并减 1，就像执行如下操作的结果一样：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>; </span><br><span class="line"><span class="keyword">let</span> num2 = -num1 - <span class="number">1</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num2); <span class="comment">// &quot;-26&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>3、按位与&amp;、按位或|、按位异或^、左移&lt;&lt;、有符号右移&gt;&gt;、无符号右移&gt;&gt;&gt;。有符号右移由两个大于号（&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。无符号右移由三个大于号（&gt;&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时用 0 填充最高位。<br>4、布尔操作符：逻辑非!、逻辑与&amp;&amp;、逻辑或||。<br>逻辑非操作符会遵循如下规则。<br> 如果操作数是对象，则返回 false。<br> 如果操作数是空字符串，则返回 true。<br> 如果操作数是非空字符串，则返回 false。<br> 如果操作数是数值 0，则返回 true。<br> 如果操作数是非 0 数值（包括 Infinity），则返回 false。<br> 如果操作数是 null，则返回 true。<br> 如果操作数是 NaN，则返回 true。<br> 如果操作数是 undefined，则返回 true。<br>以下示例验证了上述行为：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="literal">false</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="string">&quot;blue&quot;</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="title class_">NaN</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="string">&quot;&quot;</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="number">12345</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure></div>
<p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="string">&quot;blue&quot;</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="number">0</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="title class_">NaN</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="string">&quot;&quot;</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="number">12345</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值，如下所示：<br>let result &#x3D; true &amp;&amp; false;<br>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不<br>一定会返回布尔值，而是遵循如下规则。<br> 如果第一个操作数是对象，则返回第二个操作数。<br> 如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。<br> 如果两个操作数都是对象，则返回第二个操作数。<br> 如果有一个操作数是 null，则返回 null。<br> 如果有一个操作数是 NaN，则返回 NaN。<br> 如果有一个操作数是 undefined，则返回 undefined。<br>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个<br>操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结<br>果也不可能等于 true。看下面的例子：<br>let found &#x3D; true;<br>let result &#x3D; (found &amp;&amp; someUndeclaredVariable); &#x2F;&#x2F; 这里会出错<br>console.log(result); &#x2F;&#x2F; 不会执行这一行<br>上面的代码之所以会出错，是因为 someUndeclaredVariable 没有事先声明，所以当逻辑与操作符对它求值时就会报错。变量 found 的值是 true，逻辑与操作符会继续求值变量 someUndeclaredVariable。<br>但是由于 someUndeclaredVariable 没有定义，不能对它应用逻辑与操作符，因此就报错了。假如变量 found 的值是 false，那么就不会报错了：<br>let found &#x3D; false;<br>let result &#x3D; (found &amp;&amp; someUndeclaredVariable); &#x2F;&#x2F; 不会出错<br>console.log(result); &#x2F;&#x2F; 会执行这里，console.log 会成功执行。即使变量 someUndeclaredVariable 没有定义，由于第一个操作数是 false，逻辑与操作符也不会对它求值，因为此时对&amp;&amp;右边的操作数求值是没有意义的。在使用逻辑与操作符时，一定别忘了它的这个短路的特性。<br>逻辑或操作符由两个竖线（||）表示，应用到两个值，如下所示：<br>let result &#x3D; true || false;<br>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则。<br> 如果第一个操作数是对象，则返回第一个操作数。<br> 如果第一个操作数求值为 false，则返回第二个操作数。<br> 如果两个操作数都是对象，则返回第一个操作数。<br> 如果两个操作数都是 null，则返回 null。<br> 如果两个操作数都是 NaN，则返回 NaN。<br> 如果两个操作数都是 undefined，则返回 undefined。<br>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。看下面的例子：<br>let found &#x3D; true;<br>let result &#x3D; (found || someUndeclaredVariable); &#x2F;&#x2F; 不会出错<br>console.log(result); &#x2F;&#x2F; 会执行<br>跟前面的例子一样，变量 someUndeclaredVariable 也没有定义。但是，因为变量 found 的值为 true，所以逻辑或操作符不会对变量 someUndeclaredVariable 求值，而直接返回 true。假如把<br>found 的值改为 false，那就会报错了：<br>let found &#x3D; false;<br>let result &#x3D; (found || someUndeclaredVariable); &#x2F;&#x2F; 这里会出错<br>console.log(result); &#x2F;&#x2F; 不会执行这一行<br>利用这个行为，可以避免给变量赋值 null 或 undefined。比如：<br>let myObject &#x3D; preferredObject || backupObject;</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-11 日报 Day32</title>
    <url>/undefined/2024-12-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>世间从不缺少辉煌的花冠，缺少的是不被花冠晕染的淡定。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P106-112
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、构建数据集合</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2、集合的一些基本方法</p>
<ul>
<li>add(value)：向集合添加一个新的项。</li>
<li>delete(value)：从集合移除一个值。</li>
<li>has(value)：如果值在集合中，返回true，否则返回false。</li>
<li>clear()：移除集合中的所有项。</li>
<li>size()：返回集合所包含元素的数量。与数组的length属性类似。</li>
<li>values()：返回一个包含集合中所有值的数组。<br>3、集合的实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="comment">// this.has = function(value)&#123;</span></span><br><span class="line">    <span class="comment">//     return value in items;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">has</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="title function_">hasOwnProperty</span>(value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">            items[value] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">            <span class="keyword">delete</span> items[value];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> values = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(items); i &lt; keys.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            values.<span class="title function_">push</span>(items[keys[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
4、集合操作</li>
<li>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</li>
<li>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</li>
<li>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</li>
<li>子集：验证一个集合是否是另一个集合的子集。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-1 日报 Day22</title>
    <url>/undefined/2024-12-1/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>愿你拥有坚如磐石的信念，还有无问西东的勇气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P71-72 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、相等操作符：ECMAScript提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换。<br>2、等于和不等于（&#x3D;&#x3D;和!&#x3D;）：<br>ECMAScript 中的等于操作符用两个等于号（&#x3D;&#x3D;）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!&#x3D;）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。<br>在转换操作数的类型时，相等和不相等操作符遵循如下规则。<br> 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。<br> 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。<br> 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。<br>在进行比较时，这两个操作符会遵循如下规则。<br> null 和 undefined 相等。<br> null 和 undefined 不能转换为其他类型的值再进行比较。<br> 如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。<br> 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。<br>下表总结了一些特殊情况及比较的结果：</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">null &#x3D;&#x3D; undefined</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“NaN” &#x3D;&#x3D; NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">5 &#x3D;&#x3D; NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN &#x3D;&#x3D; NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN !&#x3D; NaN</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false &#x3D;&#x3D; 0</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true &#x3D;&#x3D; 1</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true &#x3D;&#x3D; 2</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">undefined &#x3D;&#x3D; 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">null &#x3D;&#x3D; 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">“5” &#x3D;&#x3D; 5</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">3、全等和不全等（&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;）：全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（&#x3D;&#x3D;&#x3D;）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let result1 &#x3D; (“55” &#x3D;&#x3D; 55); &#x2F;&#x2F; true，转换后相等</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let result2 &#x3D; (“55” &#x3D;&#x3D;&#x3D; 55); &#x2F;&#x2F; false，不相等，因为数据类型不同</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4、条件操作符：variable &#x3D; boolean_expression ? true_value : false_value;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5、赋值操作符：赋值操作符用于给变量赋值。赋值操作符由等于号（&#x3D;）表示，它将右侧的值赋给左侧的变量。赋值操作符的右侧可以是任何类型的值，包括变量、常量、表达式等。赋值操作符的右侧可以是任何类型的值，包括变量、常量、表达式等。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">复合赋值操作符：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 乘后赋值（*&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 除后赋值（&#x2F;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 取模后赋值（%&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 加后赋值（+&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 减后赋值（-&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 左移后赋值（&lt;&lt;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 右移后赋值（&gt;&gt;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 无符号右移后赋值（&gt;&gt;&gt;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这些操作符仅仅是简写语法，使用它们不会提升性能。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6、逗号操作符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">逗号操作符可以用来在一条语句中执行多个操作，如下所示：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let num1 &#x3D; 1, num2 &#x3D; 2, num3 &#x3D; 3;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let num &#x3D; (5, 1, 4, 8, 0); &#x2F;&#x2F; num 的值为 0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-12 日报 Day33</title>
    <url>/undefined/2024-12-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>莫道春光难揽取，浮云过后艳阳天。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P113-160
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、集合并集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">union</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values = otherSet.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unionAB = setA.<span class="title function_">union</span>(setB);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unionAB.<span class="title function_">values</span>());</span><br></pre></td></tr></table></figure></div>

<p>2、集合交集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">intersection</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">            intersectionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intersectionAB = setA.<span class="title function_">intersection</span>(setB);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(intersectionAB.<span class="title function_">values</span>());</span><br></pre></td></tr></table></figure></div>

<p>3、集合差集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">difference</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">            differenceSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> differenceAB = setA.<span class="title function_">difference</span>(setB);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(differenceAB.<span class="title function_">values</span>());</span><br></pre></td></tr></table></figure></div>

<p>4、集合子集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">subset</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>() &gt; otherSet.<span class="title function_">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setC = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setC.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setC.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setC.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(setA.<span class="title function_">subset</span>(setB));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(setA.<span class="title function_">subset</span>(setC));</span><br></pre></td></tr></table></figure></div>
<p>5、ES6中的集合。ES6的Set的values方法返回的是Iterator对象，可以使用for…of循环遍历。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>6、使用ES6的Set实现数组去重</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]);</span><br></pre></td></tr></table></figure></div>
<p>7、字典和散列表<br>ES6中字典为Map,散列表为HashMap。<br>一般字典需要包含的方法：</p>
<ul>
<li>set(key, value)：向字典中添加新元素。</li>
<li>delete(key)：通过使用键值来从字典中移除键值对应的数据值。</li>
<li>has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。</li>
<li>get(key)：通过键值查找特定的数值并返回。</li>
<li>clear()：将这个字典中的所有元素全部删除。</li>
<li>size()：返回字典所包含元素的数量。与数组的length属性类似。</li>
<li>keys()：将字典所包含的所有键名以数组形式返回。</li>
<li>values()：将字典所包含的所有数值以数组形式返回。<br>8、方法实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dictionary</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">has</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> items;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">set</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">        items[key] = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">delete</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(key))&#123;</span><br><span class="line">            <span class="keyword">delete</span> items[key];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> values = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> items)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(k))&#123;</span><br><span class="line">                values.<span class="title function_">push</span>(items[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getItems</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> <span class="title class_">Dictionary</span>();</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">has</span>(<span class="string">&#x27;Gandalf&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">size</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">keys</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">get</span>(<span class="string">&#x27;John&#x27;</span>));</span><br></pre></td></tr></table></figure></div>
9、散列表<br>散列算法的作用是尽可能快地在数据结构中找到一个值。在散列表中插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下。最简单的散列方法是简单地将每个键值中的每个字母的ASCII值相加。<br>三个基本的方法:</li>
<li>put(key, value)：向散列表增加一个新的项（也能更新散列表）。</li>
<li>remove(key)：根据键值从散列表中移除值。</li>
<li>get(key)：返回根据键值检索到的特定的值。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HashTable</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> table = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
10、散列函数<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">loseloseHashCode</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        hash += key.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
11、基本方法实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(position + <span class="string">&#x27; - &#x27;</span> + key);</span><br><span class="line">    table[position] = value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> table[<span class="title function_">loseloseHashCode</span>(key)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    table[<span class="title function_">loseloseHashCode</span>(key)] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
12、测试<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Gandalf&#x27;</span>));</span><br></pre></td></tr></table></figure></div>
13、散列冲突<br>一些键会有相同的散列值,不同的值在散列表中对应相同的位置，这种现象称为散列冲突。解决冲突的方法有两种：分离链接、线性探查和双散列法。</li>
<li>分离链接: 散列表的每一个位置创建一个链表并将元素存储在里面。但是其在HashTable实例之外还需要额外的存储空间。<br>其需要重写三个方法: put、get、remove。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(table[position] == <span class="literal">undefined</span>)&#123;</span><br><span class="line">        table[position] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    table[position].<span class="title function_">append</span>(<span class="keyword">new</span> <span class="title class_">ValuePair</span>(key, value));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> current = table[position].<span class="title function_">getHead</span>();</span><br><span class="line">        <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">                <span class="keyword">return</span> current.<span class="property">element</span>.<span class="property">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">element</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> current = table[position].<span class="title function_">getHead</span>();</span><br><span class="line">        <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">                table[position].<span class="title function_">remove</span>(current.<span class="property">element</span>);</span><br><span class="line">                <span class="keyword">if</span>(table[position].<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">                    table[position] = <span class="literal">undefined</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">            table[position].<span class="title function_">remove</span>(current.<span class="property">element</span>);</span><br><span class="line">            <span class="keyword">if</span>(table[position].<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">                table[position] = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
14、线性探查<br>当发生冲突时，线性探查会检查散列表中的下一个位置是否为空。如果为空，就将数据存入。如果不为空，就继续检查下一个位置。直到找到一个空的位置。<br>统一需要重写put、get、remove方法<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(table[position] == <span class="literal">undefined</span>)&#123;</span><br><span class="line">        table[position] = <span class="keyword">new</span> <span class="title class_">ValuePair</span>(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = ++position;</span><br><span class="line">        <span class="keyword">while</span>(table[index] != <span class="literal">undefined</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = <span class="keyword">new</span> <span class="title class_">ValuePair</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table[position].<span class="property">key</span> === key)&#123;</span><br><span class="line">            <span class="keyword">return</span> table[position].<span class="property">value</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> index = ++position;</span><br><span class="line">            <span class="keyword">while</span>(table[index] === <span class="literal">undefined</span> || table[index].<span class="property">key</span> !== key)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(table[index].<span class="property">key</span> === key)&#123;</span><br><span class="line">                <span class="keyword">return</span> table[index].<span class="property">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table[position].<span class="property">key</span> === key)&#123;</span><br><span class="line">            table[position] = <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> index = ++position;</span><br><span class="line">            <span class="keyword">while</span>(table[index] === <span class="literal">undefined</span> || table[index].<span class="property">key</span> !== key)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(table[index].<span class="property">key</span> === key)&#123;</span><br><span class="line">                table[index] = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
15、树<br>非顺序数据结构–树。树是一种非线性数据结构，以分层的方式存储数据。树的第一个节点叫做根节点。树的最大层级叫做树的深度。<br>二叉树和二叉搜索树(BST, Binary Search Tree):二叉树的每个节点最多只能有两个子节点：左侧子节点和右侧子节点;二叉搜索树是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BinarySearchTree</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
树类中需要实现的方法有：</li>
<li>insert(key)：向树中插入一个新的键。</li>
<li>search(key)：在树中查找一个键。如果节点存在，则返回true；如果不存在，则返回false。</li>
<li>inOrderTraverse()：通过中序遍历方式遍历所有节点。</li>
<li>preOrderTraverse()：通过先序遍历方式遍历所有节点。</li>
<li>postOrderTraverse()：通过后序遍历方式遍历所有节点。</li>
<li>min()：返回树中最小的值&#x2F;键。</li>
<li>max()：返回树中最大的值&#x2F;键。</li>
<li>remove(key)：从树中移除某个键。<br>16、方法实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">insertNode</span>(root, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> insertNode = <span class="keyword">function</span>(<span class="params">node, newNode</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newNode.<span class="property">key</span> &lt; node.<span class="property">key</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">            node.<span class="property">left</span> = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">            node.<span class="property">right</span> = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
17、树的遍历: 中序、先序、后序<br>采用访问者模式，将回调函数作为参数传入遍历方法中。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">inOrderTraverse</span> = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="title function_">inOrderTraverseNode</span>(root, callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inOrderTraverseNode = <span class="keyword">function</span>(<span class="params">node, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line">        <span class="title function_">callback</span>(node.<span class="property">key</span>);</span><br><span class="line">        <span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">preOrderTraverse</span> = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="title function_">preOrderTraverseNode</span>(root, callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> preOrderTraverseNode = <span class="keyword">function</span>(<span class="params">node, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">callback</span>(node.<span class="property">key</span>);</span><br><span class="line">        <span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line">        <span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">postOrderTraverse</span> = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="title function_">postOrderTraverseNode</span>(root, callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> postOrderTraverseNode = <span class="keyword">function</span>(<span class="params">node, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line">        <span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">        <span class="title function_">callback</span>(node.<span class="property">key</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
18、自平衡树(Adelson-Velskii-Landi, AVL)<br>AVL树是最先发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1。AVL树是一种自平衡二叉查找树，任一节点对应的两棵子树的最大高度差为1。<br>19、红黑树: 红黑树是一种自平衡二叉查找树，它在每个节点上增加了存储位来表示节点的颜色，可以是红色或黑色。通过对任何一条从根到叶子的路径上各个节点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出两倍，因此是接近平衡的。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-9 日报 Day1</title>
    <url>/undefined/2024-11-9/</url>
    <content><![CDATA[<h2 id="写在本类目的最前面"><a href="#写在本类目的最前面" class="headerlink" title="写在本类目的最前面"></a>写在本类目的最前面</h2><p>   不知道以什么开始，就以最近看到的《我与地坛》中的一句话作为本类目的开头吧：</p>
<blockquote>
<p>但是太阳，它每时每刻都是夕阳也都是旭日。当它熄灭着走下山去收尽苍凉残照之际，正是它在另一面燃烧着爬上山巅布散烈烈朝晖之时。<br>那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。<br>当然，那不是我。<br>但是，那不是我吗？</p>
</blockquote>
<h3 id="今天的思考"><a href="#今天的思考" class="headerlink" title="今天的思考"></a>今天的思考</h3><pre><code>不满足于当前的苟且，却又无能为力改变现状。何以破局，唯有涅槃重生。所以从今天开始从最基本的知识学起，每日保持不间断的更新，去到自己想要去到的高度。
</code></pre>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《网络是怎样连接的》 P1 - P12
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>URL协议标识符如HTTP、HTTPS、FTP等，是用来标识资源的协议的。URL的格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://host:port/path?query#fragment</span><br></pre></td></tr></table></figure></div>

<ul>
<li>scheme：协议标识符，如HTTP、HTTPS、FTP等</li>
</ul>
<p>native上还有一些特殊的scheme，如：</p>
<ul>
<li>tell：用于电话号码</li>
<li>sms：用于短信</li>
<li>mailto：用于发送邮件</li>
<li>geo：用于地理位置</li>
<li>AppName：用于调起App</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-13 日报 Day34</title>
    <url>/undefined/2024-12-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>少欲则心静，心静则事简，只有这样方能够挣脱繁华虚妄的羁绊，拥抱明确而简单的生活。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P161-166
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、非线形数据结构-图。图是由一组由边连接的节点(或顶点)。<br>图由G&#x3D;(V,E)组成，其中V是顶点的集合，E是边的集合。<br>由一条边连接在一起的顶点称为相邻顶点。<br>一个顶点的度是其相邻顶点的数量。<br>路径是顶点v1,v2,…,vk的一个连续序列，其中vi和vi+1是相邻的。<br>简单路径要求不包含重复的顶点。<br>图分为有向图和无向图。图还可以是加权的或非加权的。<br>2、图的表示: 从数据结构上来说可以用多种方式来表示图，不存在绝对的正确表示方法，取决于待解决的问题和图的类型。</p>
<ul>
<li>邻接矩阵: 二维数组，其中的元素表示两个顶点之间是否有一条边。如果索引为i的节点和索引为j的节点相邻，则matrix[i][j]为1，否则为0。</li>
<li>邻接表: 用列表(数组)、链表，甚至是散列表或是字典来表示相邻顶点列表。</li>
<li>关联矩阵: 二维数组，其中的元素表示顶点和边的关系。行表示顶点，列表示边，元素表示顶点和边的关系。可以使用二维数组来表示两者之间的连通性，<br>如果顶点v是边e的入射点，则array[v][e]为1，否则为0。关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。<br>3、创建Graph类<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Graph</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> vertices = [];</span><br><span class="line">  <span class="keyword">var</span> adjList = <span class="keyword">new</span> <span class="title class_">Dictionary</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
其中vertices数组用来存储图中所有顶点的名字，adjList用来存储邻接表。图类需要实现三个方法:</li>
<li>addVertex: 向图中添加一个新的顶点。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">addVertex</span> = <span class="keyword">function</span>(<span class="params">v</span>)&#123;</span><br><span class="line">  vertices.<span class="title function_">push</span>(v);</span><br><span class="line">  adjList.<span class="title function_">set</span>(v, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>addEdge: 添加一条边。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">addEdge</span> = <span class="keyword">function</span>(<span class="params">v, w</span>)&#123;</span><br><span class="line">  adjList.<span class="title function_">get</span>(v).<span class="title function_">push</span>(w);</span><br><span class="line">  adjList.<span class="title function_">get</span>(w).<span class="title function_">push</span>(v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>toString: 输出图的顶点和邻接表。</li>
</ul>
<pre><code class="javascript">this.toString = function()&#123;
  var s = &#39;&#39;;
  for(var i=0; i&lt;vertices.length; i++)&#123;
    s += vertices[i] + &#39; -&gt; &#39;;
    var neighbors = adjList.get(vertices[i]);
    for(var j=0; j&lt;neighbors.length; j++)&#123;
      s += neighbors[j] + &#39; &#39;;
    &#125;
    s += &#39;\n&#39;;
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-10 日报 Day31</title>
    <url>/undefined/2024-12-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>山不让尘，<br>川不辞盈。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>最近已经要求开始写大论文了，所以学习的时间会减少，但是我会尽量保持每天的学习时间，不会放弃的。<br>    1、《JavaScript数据结构与算法》 P93-105</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、链表简单实现</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">append</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head === <span class="literal">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">                current = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current.<span class="property">next</span> = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">position, element</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(positio &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">            current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">          node.<span class="property">next</span> = current;</span><br><span class="line">          head = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          node.<span class="property">next</span> = current;</span><br><span class="line">          previous.<span class="property">next</span> = node;</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length)&#123;</span><br><span class="line">            <span class="keyword">let</span> current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">                head = current.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.<span class="property">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previous.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">element</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(element);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> current = head,</span><br><span class="line">          index = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        <span class="keyword">if</span>(element === current.<span class="property">element</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.isEmpty = function()&#123;</span></span><br><span class="line"><span class="string">      return length === 0;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.size = function()&#123;</span></span><br><span class="line"><span class="string">      return length;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.getHead = function()&#123;</span></span><br><span class="line"><span class="string">      return head;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.toString = function()&#123;</span></span><br><span class="line"><span class="string">      let current = head;</span></span><br><span class="line"><span class="string">      string = &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">      while(current)&#123;</span></span><br><span class="line"><span class="string">        string += current.element + (current.next ? &#x27;</span>n<span class="string">&#x27;: &#x27;</span><span class="string">&#x27;);</span></span><br><span class="line"><span class="string">        current = current.next;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      return string;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.print = function()&#123;&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>2、双向链表: 双向链表和普通链表的区别在于，双向链表的节点有两个指针，一个指向前一个节点，一个指向后一个节点。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DoublyLinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> tail = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里是方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3、循环链表: 循环链表和链表的区别在于，链表的最后一个节点指向null，而循环链表的最后一个节点指向第一个节点。<br>4、双向循环链表有指向head元素的tail.next,和指向tail元素的head.prev。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-14 日报 Day35</title>
    <url>/undefined/2024-12-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>成年人的生活,万般皆苦,唯有自渡,<br>活着就要遇山开山,见水架桥,<br>其实一直陪着你的永远都是那个了不起<br>的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P167-169
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、图的遍历<br>和树数据结构类似，图的遍历也有两种算法：广度优先搜索（BFS）和深度优先搜索（DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径、检查图是否连通、检查图是否含有环等。<br>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探<br>索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。<br>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点<br>列表的数据结构。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>深度优先搜索</td>
<td>栈</td>
<td>通过将顶点存入栈中（在第3章中学习过），顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td>
</tr>
<tr>
<td>广度优先搜索</td>
<td>队列</td>
<td>通过将顶点存入队列中（在第4章中学习过），最先入队列的顶点先被探索</td>
</tr>
</tbody></table>
<p>当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。</p>
<p> 白色：表示该顶点还没有被访问。</p>
<p> 灰色：表示该顶点被访问过，但并未被探索过。</p>
<p> 黑色：表示该顶点被访问过且被完全探索过。<br>2、广度优先搜索<br>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。<br>3、深度优先搜索<br>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶<br>点被访问了，接着原路回退并探索下一条路径。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-15 日报 Day36</title>
    <url>/undefined/2024-12-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>且以青春赴山海,<br>青舟无惧万重山。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P170-174
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、排序和搜索算法</p>
<ul>
<li><p>排序算法</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>计数排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
</li>
<li><p>搜索算法</p>
<ul>
<li>顺序搜索</li>
<li>二分搜索</li>
<li>插值搜索</li>
<li>斐波那契搜索</li>
<li>二叉树搜索</li>
<li>散列算法<br>2、排序算法: 排序算法是一种算法，用于将一组元素按照一定的顺序排列。在开始排序算法之前，先创建一个数组来表示待排序和搜索的数据结构。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ArrayList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">        array.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array.<span class="title function_">join</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
2、冒泡排序<br>冒泡排序是排序算法中最简单的但是从运行时间的角度来看，冒泡排序是最差的一个。<br>冒泡排序算法的原理如下:</li>
</ul>
</li>
</ul>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">bubbleSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="title function_">swap</span>(j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> swap = <span class="keyword">function</span>(<span class="params">index1, index2</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> aux = array[index1];</span><br><span class="line">    array[index1] = array[index2];</span><br><span class="line">    array[index2] = aux;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
冒泡排序的时间复杂度是O(n2)。<br>3、选择排序<br>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放在第一位，接着找到第二小的值并将其放在第二位，以此类推。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">selectionSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.<span class="property">length</span>,</span><br><span class="line">        indexMin;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        indexMin = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i; j&lt;length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[indexMin] &gt; array[j])&#123;</span><br><span class="line">                indexMin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i !== indexMin)&#123;</span><br><span class="line">            <span class="title function_">swap</span>(i, indexMin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
选择排序同样也是一个复杂度为O(n2)的算法。</li>
</ol>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-18 日报 Day39</title>
    <url>/undefined/2024-12-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在哪里付出，就在哪里得到；在哪里打磨，就在哪里闪耀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P103-108 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：let now &#x3D; new Date();函数也是一种引用类型。<br>2、Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。要创建日期对象，就使用 new 操作符来调用 Date 构造函数：<br>let now &#x3D; new Date();<br>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了 Date.parse()应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：<br>“月&#x2F;日&#x2F;年”，如”5&#x2F;23&#x2F;2019”；<br>“月名 日, 年”，如”May 23, 2019”；<br>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”；<br> ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现）。<br>比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：<br>let someDate &#x3D; new Date(Date.parse(“May 23, 2019”));<br>如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：<br>let someDate &#x3D; new Date(“May 23, 2019”);<br>这两行代码得到的日期对象相同。<br>Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：<br>&#x2F;&#x2F; GMT 时间 2000 年 1 月 1 日零点<br>let y2k &#x3D; new Date(Date.UTC(2000, 0));<br>&#x2F;&#x2F; GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒<br>let allFives &#x3D; new Date(Date.UTC(2005, 4, 5, 17, 55, 55));<br>ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：<br>&#x2F;&#x2F; 起始时间<br>let start &#x3D; Date.now();<br>&#x2F;&#x2F; 调用函数<br>doSomething();<br>&#x2F;&#x2F; 结束时间<br>let stop &#x3D; Date.now(),<br>result &#x3D; stop - start;<br>3、继承的方式：Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的2019 年 2 月 1 日零点的示例（地区为”en-US”的 PST，即 Pacific Standard Time，太平洋标准时间）：<br>toLocaleString() - 2&#x2F;1&#x2F;2019 12:00:00 AM<br>toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)<br>现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着 toLocaleString()和 toString()可能只对调试有用，不能用于显示。<br>Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：<br>let date1 &#x3D; new Date(2019, 0, 1); &#x2F;&#x2F; 2019 年 1 月 1 日<br>let date2 &#x3D; new Date(2019, 1, 1); &#x2F;&#x2F; 2019 年 2 月 1 日<br>console.log(date1 &lt; date2); &#x2F;&#x2F; true<br>console.log(date1 &gt; date2); &#x2F;&#x2F; false<br>4、日期格式化方法：<br>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：<br> toDateString()显示日期中的周几、月、日、年（格式特定于实现）；<br> toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；<br> toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；<br> toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；<br> toUTCString()显示完整的 UTC 日期（格式特定于实现）。<br>5、日期&#x2F;时间组件方法：Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getTime()</td>
<td align="center">返回日期的毫秒表示；与 valueOf()相同</td>
</tr>
<tr>
<td align="center">setTime(<em>milliseconds</em>)</td>
<td align="center">设置日期的毫秒表示，从而修改整个日期</td>
</tr>
<tr>
<td align="center">getFullYear()</td>
<td align="center">返回 4 位数年（即 2019 而不是 19）</td>
</tr>
<tr>
<td align="center">getUTCFullYear()</td>
<td align="center">返回 UTC 日期的 4 位数年</td>
</tr>
<tr>
<td align="center">setFullYear(<em>year</em>)</td>
<td align="center">设置日期的年（<em>year</em> 必须是 4 位数）</td>
</tr>
<tr>
<td align="center">setUTCFullYear(<em>year</em>)</td>
<td align="center">设置 UTC 日期的年（<em>year</em> 必须是 4 位数）</td>
</tr>
<tr>
<td align="center">getMonth()</td>
<td align="center">返回日期的月（0 表示 1 月，11 表示 12 月）</td>
</tr>
<tr>
<td align="center">getUTCMonth()</td>
<td align="center">返回 UTC 日期的月（0 表示 1 月）</td>
</tr>
<tr>
<td align="center">setMonth(<em>month</em>)</td>
<td align="center">设置日期的月（0 表示 1 月，11 表示 12 月）</td>
</tr>
<tr>
<td align="center">setUTCMonth(<em>month</em>)</td>
<td align="center">设置 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td>
</tr>
<tr>
<td align="center">getDate()</td>
<td align="center">返回日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">getUTCDate()</td>
<td align="center">返回 UTC 日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">setDate(<em>date</em>)</td>
<td align="center">设置日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">setUTCDate(<em>date</em>)</td>
<td align="center">设置 UTC 日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">getDay()</td>
<td align="center">返回日期中的星期几（0 表示星期日，6 表示星期六）</td>
</tr>
<tr>
<td align="center">getUTCDay()</td>
<td align="center">返回 UTC 日期中的星期几（0 表示星期日，6 表示星期六）</td>
</tr>
<tr>
<td align="center">getHours()</td>
<td align="center">返回日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">getUTCHours()</td>
<td align="center">返回 UTC 日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">setHours(<em>hours</em>)</td>
<td align="center">设置日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">setUTCHours(<em>hours</em>)</td>
<td align="center">设置 UTC 日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">getMinutes()</td>
<td align="center">返回日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">getUTCMinutes()</td>
<td align="center">返回 UTC 日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">setMinutes(<em>minutes</em>)</td>
<td align="center">设置日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">setUTCMinutes(<em>minutes</em>)</td>
<td align="center">设置 UTC 日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">getSeconds()</td>
<td align="center">返回日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">getUTCSeconds()</td>
<td align="center">返回 UTC 日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">setSeconds(<em>seconds</em>)</td>
<td align="center">设置日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">setUTCSeconds(<em>seconds</em>)</td>
<td align="center">设置 UTC 日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">getMilliseconds()</td>
<td align="center">返回日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">getUTCMilliseconds()</td>
<td align="center">返回 UTC 日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">setMilliseconds(<em>milliseconds</em>)</td>
<td align="center">设置日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">setUTCMilliseconds(<em>milliseconds</em>)</td>
<td align="center">设置 UTC 日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">getTimezoneOffset()</td>
<td align="center">返回本地时间与 UTC 时间相差的分钟数</td>
</tr>
<tr>
<td align="center">6、RegExp：ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let expression &#x3D; &#x2F;pattern&#x2F;flags;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这个正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> m：多行模式，表示查找到一行文本末尾时会继续查找。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> u：Unicode 模式，启用 Unicode 匹配。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">使用不同模式和标记可以创建出各种正则表达式，比如：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配字符串中的所有”at”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern1 &#x3D; &#x2F;at&#x2F;g;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”bat”或”cat”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern2 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配所有以”at”结尾的三字符组合，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern3 &#x3D; &#x2F;.at&#x2F;gi;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">( [ { \ ^ $</td>
<td align="center">) ] } ? * + .</td>
</tr>
<tr>
<td align="center">元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”bat”或”cat”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern1 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”[bc]at”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern2 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配所有以”at”结尾的三字符组合，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern3 &#x3D; &#x2F;.at&#x2F;gi;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配所有”.at”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern4 &#x3D; &#x2F;.at&#x2F;gi;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这里的 pattern1 匹配”bat”或”cat”，不区分大小写。要直接匹配”[bc]at”，左右中括号都必须像 pattern2 中那样使用反斜杠转义。在 pattern3 中，点号表示”at”前面的任意字符都可以匹配。如果想匹配”.at”，那么要像 pattern4 中那样对点号进行转义。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”bat”或”cat”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern1 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 跟 pattern1 一样，只不过是用构造函数创建的</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern2 &#x3D; new RegExp(“[bc]at”, “i”);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这里的 pattern1 和 pattern2 是等效的正则表达式。注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\，在正则表达式字符串中则要写成\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ 字面量模式 ｜ 对应的字符串 ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;[bc]at&#x2F; ｜  “\[bc\]at” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;.at&#x2F; ｜ “\.at” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;name/age&#x2F; ｜ “name\&#x2F;age” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;\d.\d{1,2}&#x2F; ｜ “\d.\d{1,2}” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;\w\hello\123&#x2F; ｜ “\w\\hello\\123” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">const re1 &#x3D; &#x2F;cat&#x2F;g;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">console.log(re1); &#x2F;&#x2F; “&#x2F;cat&#x2F;g”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">const re2 &#x3D; new RegExp(re1);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">console.log(re2); &#x2F;&#x2F; “&#x2F;cat&#x2F;g”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">const re3 &#x3D; new RegExp(re1, “i”);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">console.log(re3); &#x2F;&#x2F; “&#x2F;cat&#x2F;i”</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-19 日报 Day40</title>
    <url>/undefined/2024-12-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在哪里付出，就在哪里得到；在哪里打磨，就在哪里闪耀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P109-111 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、RegExp实例属性：<br>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。<br> global：布尔值，表示是否设置了 g 标记。<br> ignoreCase：布尔值，表示是否设置了 i 标记。<br> unicode：布尔值，表示是否设置了 u 标记。<br> sticky：布尔值，表示是否设置了 y 标记。<br> lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。<br> multiline：布尔值，表示是否设置了 m 标记。<br> dotAll：布尔值，表示是否设置了 s 标记。<br> source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的<br>斜杠。<br> flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没<br>有前后斜杠）。<br>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含<br>这些信息。下面是一个例子：<br>let pattern1 &#x3D; &#x2F;[bc]at&#x2F;i;<br>console.log(pattern1.global); &#x2F;&#x2F; false<br>console.log(pattern1.ignoreCase); &#x2F;&#x2F; true<br>console.log(pattern1.multiline); &#x2F;&#x2F; false<br>console.log(pattern1.lastIndex); &#x2F;&#x2F; 0<br>console.log(pattern1.source); &#x2F;&#x2F; “[bc]at”<br>console.log(pattern1.flags); &#x2F;&#x2F; “i”<br>let pattern2 &#x3D; new RegExp(“\[bc\]at”, “i”);<br>console.log(pattern2.global); &#x2F;&#x2F; false<br>console.log(pattern2.ignoreCase); &#x2F;&#x2F; true<br>console.log(pattern2.multiline); &#x2F;&#x2F; false<br>console.log(pattern2.lastIndex); &#x2F;&#x2F; 0<br>console.log(pattern2.source); &#x2F;&#x2F; “[bc]at”<br>console.log(pattern2.flags); &#x2F;&#x2F; “i”<br>2、RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>; </span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">input</span>); <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">1</span>]); <span class="comment">// &quot; and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">2</span>]); <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，模式包含两个捕获组：最内部的匹配项” and baby”，以及外部的匹配项” and dad”或” and dad and baby”。调用 exec()后找到了一个匹配项。因为整个字符串匹配模式，所以 matchs数组的 index 属性就是 0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。<br>如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标<br>记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>; </span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// cat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0 </span></span><br><span class="line">matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// cat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
<p>上面例子中的模式没有设置全局标记，因此调用 exec()只返回第一个匹配项（”cat”）。lastIndex在非全局模式下始终不变。<br>如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/g</span>; </span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// cat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 3 </span></span><br><span class="line">matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 5 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// bat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 8 </span></span><br><span class="line">matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 10 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// sat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure></div>
<p>这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到<br>字符串末尾。注意模式的 lastIndex 属性每次都会变化。在全局匹配模式下，每次调用 exec()都会更新 lastIndex 值，以反映上次匹配的最后一个字符的索引。<br>粘附模式要求正则匹配必须从 lastIndex 指定的位置开始，不能跳过字符，否则匹配失败。<br>正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数<br>返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在 if 语句中：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;000-00-0000&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The pattern was matched.&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。无论正则表达式是怎么创建的，继承的方法 toLocaleString()和 toString()都返回正则表达式的字面量表示。比如：<br>let pattern &#x3D; new RegExp(“\[bc\]at”, “gi”);<br>console.log(pattern.toString()); &#x2F;&#x2F; &#x2F;[bc]at&#x2F;gi<br>console.log(pattern.toLocaleString()); &#x2F;&#x2F; &#x2F;[bc]at&#x2F;gi<br>这里的模式是通过 RegExp 构造函数创建的，但 toLocaleString()和 toString()返回的都是其字面量的形式。<br>注意 正则表达式的 valueOf()方法返回正则表达式本身。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-16 日报 Day37</title>
    <url>/undefined/2024-12-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>且以青春赴山海,<br>青舟无惧万重山。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P174-
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、插入排序: 插入排序是一种最简单的排序算法，其原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">insertionSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.<span class="property">length</span>,</span><br><span class="line">        j, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;length; i++)&#123;</span><br><span class="line">        j = i;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; array[j-<span class="number">1</span>] &gt; temp)&#123;</span><br><span class="line">            array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>时间复杂度: O(n^2)<br>空间复杂度: O(1)</p>
<h3 id="低代码平台学习"><a href="#低代码平台学习" class="headerlink" title="低代码平台学习"></a>低代码平台学习</h3><p>1、以<a href="https://github.com/alibaba/lowcode-demo%E6%8F%90%E4%BE%9B%E7%9A%84https://lowcode-engine.cn/index">https://github.com/alibaba/lowcode-demo提供的https://lowcode-engine.cn/index</a> 模版学习<br>主要了解低代码平台所包含的主要模块和分包各自功能实现。对整体框架有一个简单的认识。<br>2、首先以demo-basic-antd为例进行学习，了解其基本功能和实现方式。<br>demo-basic-antd引入的包:</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;@alilc/lowcode-datasource-fetch-handler&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-code-editor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-code-generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-components-pane&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-datasource-pane&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.9&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-inject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-manual&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-simulator-select&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-undo-redo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-zh-en&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-set-ref-prop&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-react-renderer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.1.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-setter-behavior&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-setter-title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.2&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></div>
<p>接下来对各个包的功能进行简单的分析:</p>
<ul>
<li>lowcode-datasource-fetch-handler: 数据源获取处理 </li>
<li>lowcode-plugin-code-editor: 代码编辑器 <a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></li>
<li>lowcode-plugin-code-generator: 出码器 <a href="https://github.com/alibaba/lowcode-code-generator-demo">https://github.com/alibaba/lowcode-code-generator-demo</a> 有demo但应该不是完整的</li>
<li>lowcode-plugin-components-pane: 低代码组件面板 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-datasource-pane: 数据源面板 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-inject: 低代码引擎生态元素项目内调试用插件 <a href="https://github.com/alibaba/lowcode-tools.git">https://github.com/alibaba/lowcode-tools.git</a></li>
<li>lowcode-plugin-manual: 低代码产品使用手册 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-schema: 查看低代码引擎 schema <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-simulator-select: 画布切换 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-undo-redo: alibaba lowcode editor undo redo plugin <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-zh-en: alibaba lowcode editor zhong english plugin <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-set-ref-prop: alibaba lowcode editor plugin for setting ref-id <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-react-renderer: react renderer for ali lowcode engine <a href="https://github.com/alibaba/lowcode-engine/tree/main/packages/react-renderer">https://github.com/alibaba/lowcode-engine/tree/main/packages/react-renderer</a></li>
<li>lowcode-setter-behavior: 交互 setter</li>
<li>lowcode-setter-title: 标题 setter</li>
</ul>
<p>找到了npm包对应源码的地址</p>
<table>
<thead>
<tr>
<th><strong>包名</strong></th>
<th><strong>仓库</strong></th>
<th><strong>路径</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@alilc&#x2F;lowcode-code-generator</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>modules&#x2F;code-generator</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-material-parser</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>modules&#x2F;material-parser</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-designer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;designer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-editor-core</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;editor-core</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-editor-skeleton</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;editor-skeleton</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-engine</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;engine</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-designer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;plugin-designer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-outline-pane</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;plugin-outline-pane</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-react-renderer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;react-renderer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-react-simulator-renderer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;react-simulator-renderer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-renderer-core</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;renderer-core</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-shell</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;shell</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-types</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;types</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-utils</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;utils</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-engine</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-engine</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-fetch-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-fetch-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-jsonp-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-jsonp-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-mopen-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-mopen-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-mtop-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-mtop-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-types</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-types</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-universal-mtop-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-universal-mtop-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-url-params-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-url-params-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;build-plugin-alt</td>
<td><a href="https://github.com/alibaba/lowcode-tools">https://github.com/alibaba/lowcode-tools</a></td>
<td>packages&#x2F;build-plugin-alt</td>
</tr>
<tr>
<td>@alilc&#x2F;create-element</td>
<td><a href="https://github.com/alibaba/lowcode-tools">https://github.com/alibaba/lowcode-tools</a></td>
<td>packages&#x2F;create-element</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-inject</td>
<td><a href="https://github.com/alibaba/lowcode-tools">https://github.com/alibaba/lowcode-tools</a></td>
<td>packages&#x2F;lowcode-plugin-inject</td>
</tr>
<tr>
<td>@alilc&#x2F;action-block</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;action-block</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-base-monaco-editor</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-base-monaco-editor</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-block</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-block</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-code-editor</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-code-editor</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-components-pane</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-components-pane</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-datasource-pane</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-datasource-pane</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-manual</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-manual</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-schema</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-schema</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-undo-redo</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-undo-redo</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-zh-en</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-zh-en</td>
</tr>
<tr>
<td>@alifd&#x2F;fusion-ui</td>
<td><a href="https://github.com/alibaba/lowcode-materials">https://github.com/alibaba/lowcode-materials</a></td>
<td>packages&#x2F;fusion-ui</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-materials</td>
<td><a href="https://github.com/alibaba/lowcode-materials">https://github.com/alibaba/lowcode-materials</a></td>
<td>packages&#x2F;fusion-lowcode-materials</td>
</tr>
<tr>
<td>@alilc&#x2F;antd-lowcode-materials</td>
<td><a href="https://github.com/alibaba/lowcode-materials">https://github.com/alibaba/lowcode-materials</a></td>
<td>packages&#x2F;antd-lowcode-materials</td>
</tr>
<tr>
<td>@alifd&#x2F;layout（原 @alifd&#x2F;pro-layout 升级后的版本）</td>
<td><a href="https://github.com/alibaba-fusion/layout">https://github.com/alibaba-fusion/layout</a></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-2 日报 Day23</title>
    <url>/undefined/2024-12-2/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生，从外打破是压力，从内打破是成长。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P73-76 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、if语句：if (condition) statement1 else statement2<br>这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为 true，则执行语句statement1；如果条件求值为 false，则执行语句 statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greater than 25.&quot;</span>); <span class="comment">// 只有一行代码的语句</span></span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Less than or equal to 25.&quot;</span>); <span class="comment">// 一个语句块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以像这样连续使用多个 if 语句：</span></span><br><span class="line"><span class="comment">// if (condition1) statement1 else if (condition2) statement2 else statement3 </span></span><br><span class="line"><span class="comment">// 下面是一个例子：</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greater than 25.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Less than 0.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2、do-while 语句：do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试条件。因此，循环体内的代码至少会执行一次。do-while 语句的语法如下：<br>do {<br> statement<br>} while (condition);</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"> i += <span class="number">2</span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure></div>
<p>3、while 语句：while 语句是一种先测试循环语句，即在循环体内的代码被执行之前，就会先测试条件。如果条件为 true，则继续执行循环；如果条件为 false，则不执行循环。while 语句的语法如下：<br>while (condition) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123; </span><br><span class="line"> i += <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4、for 语句：for 语句是一种前测试循环语句，即在循环体内的代码被执行之前，就会先测试条件。如果条件为 true，则继续执行循环；如果条件为 false，则不执行循环。for 语句的语法如下：<br>for (initialization; condition; post-loop-expression) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>5、for-in 语句：for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。for-in 语句的语法如下：<br>for (property in expression) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> propName <span class="keyword">in</span> <span class="variable language_">window</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(propName); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>6、for-of 语句：for-of 语句是一种精准的迭代语句，可以用来遍历可迭代对象的元素。for-of 语句的语法如下：<br>for (variable of expression) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> data) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>7、for-of和for-in的区别：</p>
<ul>
<li>for-in 循环用来枚举对象的属性，包括原型链上的属性。</li>
<li>for-of 循环用来遍历可迭代对象的元素，包括数组、字符串、Map 和 Set 等。<br>8、标签语句<br>标签语句是一种标识语句的方法，可以在代码中添加标签，以便将来引用。标签语句的语法如下：<br>label: statement<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">start</span>: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
在 JavaScript 中，标签语句（Labeled Statement） 是一种给语句打上标签的语法结构，常用于配合 break 或 continue，跳出多层循环或控制流程。</li>
</ul>
<p>⸻</p>
<p>✅ 语法：</p>
<p>labelName:<br>  statement</p>
<p>⸻<br>🚩 使用场景：<br>多层嵌套循环中提前跳出某一层外部循环，这时候普通的 break 只能跳出一层，用标签可以指定跳出哪一层。<br>⸻<br>🧪 举个例子：<br>🚫 普通 break 只能跳出一层：<br>for (let i &#x3D; 0; i &lt; 3; i++) {<br>  for (let j &#x3D; 0; j &lt; 3; j++) {<br>    if (i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1) break;<br>    console.log(<code>i=$&#123;i&#125;, j=$&#123;j&#125;</code>);<br>  }<br>}<br>&#x2F;&#x2F; 输出：i&#x3D;0,j&#x3D;0 → i&#x3D;0,j&#x3D;1 → i&#x3D;0,j&#x3D;2 → i&#x3D;1,j&#x3D;0 → i&#x3D;1,j&#x3D;2 还继续了<br>⸻<br>✅ 用标签配合 break：<br>outerLoop: &#x2F;&#x2F; 给外层循环打标签<br>for (let i &#x3D; 0; i &lt; 3; i++) {<br>  for (let j &#x3D; 0; j &lt; 3; j++) {<br>    if (i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1) break outerLoop;<br>    console.log(<code>i=$&#123;i&#125;, j=$&#123;j&#125;</code>);<br>  }<br>}<br>&#x2F;&#x2F; 输出：i&#x3D;0,j&#x3D;0 → i&#x3D;0,j&#x3D;1 → i&#x3D;0,j&#x3D;2 → i&#x3D;1,j&#x3D;0（然后 break 了整个外层）<br>⸻<br>✅ continue 也可以配合标签使用：<br>outer:<br>for (let i &#x3D; 0; i &lt; 3; i++) {<br>  for (let j &#x3D; 0; j &lt; 3; j++) {<br>    if (j &#x3D;&#x3D;&#x3D; 1) continue outer;<br>    console.log(<code>i=$&#123;i&#125;, j=$&#123;j&#125;</code>);<br>  }<br>}<br>&#x2F;&#x2F; j&#x3D;1 时直接跳到下一轮外层 i++<br>⸻</p>
<p>⚠️ 注意事项：<br>    •	标签不能重复定义。<br>    •	标签 只能配合 break 或 continue 使用，不能像 goto 那样任意跳转。<br>    •	使用频率不高，但在复杂嵌套逻辑中可以提升可读性或性能。</p>
<p>⸻</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-20 日报 Day41</title>
    <url>/undefined/2024-12-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>不是因为看见了成功才坚持，是只有坚持才会看见成功。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P112-114 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、RegExp构造函数属性：RegExp 构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了RegExp 构造函数的属性。<br>｜全名｜简写｜说明｜<br>｜input｜$_｜最后搜索的字符串（非标准特性）｜<br>｜lastMatch｜$&amp;｜最后匹配的文本｜<br>｜lastParen｜$+｜最后匹配的捕获组（非标准特性）｜<br>｜leftContext｜$&#96;｜input 字符串中 lastMatch 之前的文本。｜<br>｜rightContext｜$’｜input 字符串中 lastMatch 之后的文本。｜<br>这些属性在正则表达式操作期间可能会变化，因此在使用它们时要小心。下面是一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">通过这些属性可以提取出与 <span class="title function_">exec</span>()和 <span class="title function_">test</span>()执行的操作相关的信息。来看下面的例子：</span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">input</span>); <span class="comment">// this has been a short summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">leftContext</span>); <span class="comment">// this has been a </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">rightContext</span>); <span class="comment">// summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">lastMatch</span>); <span class="comment">// short </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">lastParen</span>); <span class="comment">// s </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大<br>多数简写形式都不是合法的 ECMAScript 标识符：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 注意：Opera 不支持简写属性名</span></span><br><span class="line"><span class="comment"> * IE 不支持多行匹配</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$_</span>); <span class="comment">// this has been a short summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$`&quot;</span>]); <span class="comment">// this has been a </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$&#x27;&quot;</span>]); <span class="comment">// summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$&amp;&quot;</span>]); <span class="comment">// short </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$+&quot;</span>]); <span class="comment">// s </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>RegExp 还有其他几个构造函数属性，可以存储最多 9 个捕获组的匹配项。这些属性通过 RegExp. $1<del>RegExp.$9 来访问，分别包含第 1</del>9 个捕获组的匹配项。在调用 exec()或 test()时，这些属性就会被填充，然后就可以像下面这样使用它们：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(..)or(.)/g</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// sh </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>); <span class="comment">// t </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，模式包含两个捕获组。调用 test()搜索字符串之后，因为找到了匹配项所以返回true，而且可以打印出通过 RegExp 构造函数的$1 和$2 属性取得的两个捕获组匹配的内容。<br>2、为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：<br>let s1 &#x3D; “some text”;<br>let s2 &#x3D; s1.substring(2);<br>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring()方法，并把结果保存在 s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：<br>(1) 创建一个 String 类型的实例；<br>(2) 调用实例上的特定方法；<br>(3) 销毁实例。<br>可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：<br>let s1 &#x3D; new String(“some text”);<br>let s2 &#x3D; s1.substring(2);<br>s1 &#x3D; null;<br>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过<br>使用的是 Boolean 和 Number 包装类型而已。<br>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：<br>let s1 &#x3D; “some text”;<br>s1.color &#x3D; “red”;<br>console.log(s1.color); &#x2F;&#x2F; undefined<br>这里的第二行代码尝试给字符串 s1 添加了一个 color 属性。可是，第三行代码访问 color 属性时，它却不见了。原因就是第二行代码运行时会临时创建一个 String 对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的 String 对象，但这个对象没有 color 属性。<br>可以显式地使用 Boolean、Number 和 String 构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 typeof 会返回”object”，所有原始值包装对象都会转换为布尔值 true。<br>另外，Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实<br>例。比如：<br>let obj &#x3D; new Object(“some text”);<br>console.log(obj instanceof String); &#x2F;&#x2F; true<br>如果传给 Object 的是字符串，则会创建一个 String 的实例。如果是数值，则会创建 Number 的实例。布尔值则会得到 Boolean 的实例。<br>注意，使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：<br>let value &#x3D; “25”;<br>let number &#x3D; Number(value); &#x2F;&#x2F; 转型函数<br>console.log(typeof number); &#x2F;&#x2F; “number”<br>let obj &#x3D; new Number(value); &#x2F;&#x2F; 构造函数<br>console.log(typeof obj); &#x2F;&#x2F; “object”</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-21 日报 Day42</title>
    <url>/undefined/2024-12-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生如同浪潮，每一次触底，都是为下一次反弹蓄力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P115-119 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false，如下例所示：<br>let booleanObject &#x3D; new Boolean(true);<br>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>; </span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>在这段代码中，我们创建一个值为 false 的 Boolean 对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值 true 组合起来。在布尔算术中，false &amp;&amp; true 等于 false。可是，这个表达式是对 falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值。那么true &amp;&amp; true 当然是 true。<br>除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回 true，但对原始值则返回 false，如下所示：<br>console.log(typeof falseObject); &#x2F;&#x2F; object<br>console.log(typeof falseValue); &#x2F;&#x2F; boolean<br>console.log(falseObject instanceof Boolean); &#x2F;&#x2F; true<br>console.log(falseValue instanceof Boolean); &#x2F;&#x2F; false<br>2、Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，如下例所示：<br>let numberObject &#x3D; new Number(10);<br>与 Boolean 类型一样，Number 类型重写了 valueOf()、toLocaleString()和 toString()方、法。valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：<br>let num &#x3D; 10;<br>console.log(num.toString()); &#x2F;&#x2F; “10”<br>console.log(num.toString(2)); &#x2F;&#x2F; “1010”<br>console.log(num.toString(8)); &#x2F;&#x2F; “12”<br>console.log(num.toString(10)); &#x2F;&#x2F; “10”<br>console.log(num.toString(16)); &#x2F;&#x2F; “a”<br>除了继承的方法，Number 类型还提供了几个用于将数值格式化为字符串的方法。<br>toFixed()方法返回包含指定小数点位数的数值字符串，如：<br>let num &#x3D; 10;<br>console.log(num.toFixed(2)); &#x2F;&#x2F; “10.00”<br>这里的 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为”10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：<br>let num &#x3D; 10.005;<br>console.log(num.toFixed(2)); &#x2F;&#x2F; “10.01”<br>toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 &#x3D; 0.30000000000000004<br>另一个用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。与 toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。来看下面的例子：<br>let num &#x3D; 10;<br>console.log(num.toExponential(1)); &#x2F;&#x2F; “1.0e+1”<br>这段代码的输出为”1.0e+1”。一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用 toPrecision()。toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：<br>let num &#x3D; 99;<br>console.log(num.toPrecision(1)); &#x2F;&#x2F; “1e+2”<br>console.log(num.toPrecision(2)); &#x2F;&#x2F; “99”<br>console.log(num.toPrecision(3)); &#x2F;&#x2F; “99.0”<br>在处理原始数值和引用数值时，typeof 和 instacnceof操作符会返回不同的结果，如下所示：<br>let numberObject &#x3D; new Number(10);<br>let numberValue &#x3D; 10;<br>console.log(typeof numberObject); &#x2F;&#x2F; “object”<br>console.log(typeof numberValue); &#x2F;&#x2F; “number”<br>console.log(numberObject instanceof Number); &#x2F;&#x2F; true<br>console.log(numberValue instanceof Number); &#x2F;&#x2F; false<br>isInteger()方法与安全整数：ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0可能会让人误以为数值是一个浮点值：<br>console.log(Number.isInteger(1)); &#x2F;&#x2F; true<br>console.log(Number.isInteger(1.00)); &#x2F;&#x2F; true<br>console.log(Number.isInteger(1.01)); &#x2F;&#x2F; false<br>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从 Number.MIN_SAFE_INTEGER（-2^53 + 1）到 Number.MAX_SAFE_INTEGER（2^53 - 1）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的<br>数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法：<br>console.log(Number.isSafeInteger(-1 * (2 ** 53))); &#x2F;&#x2F; false<br>console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); &#x2F;&#x2F; true<br>console.log(Number.isSafeInteger(2 ** 53)); &#x2F;&#x2F; false<br>console.log(Number.isSafeInteger((2 ** 53) - 1)); &#x2F;&#x2F; true<br>3、String 是对应字符串的引用类型。要创建一个 String 对象，就使用 String 构造函数并传入一个字符串，如下例所示：<br>let stringObject &#x3D; new String(“hello world”);<br>String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf()、toLocaleString()和 toString()都返回对象的原始字符串值。<br>每个 String 对象都有一个 length 属性，表示字符串中字符的数量。来看下面的例子：<br>let stringValue &#x3D; “hello world”;<br>console.log(stringValue.length); &#x2F;&#x2F; “11”<br>JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元：<br>let message &#x3D; “abcde”;<br>console.log(message.length); &#x2F;&#x2F; 5<br>此外，charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。<br>let message &#x3D; “abcde”;<br>console.log(message.charAt(2)); &#x2F;&#x2F; “c”<br>使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。比如：<br>let message &#x3D; “abcde”;<br>console.log(message.charCodeAt(2)); &#x2F;&#x2F; 99<br>console.log(99 &#x3D;&#x3D;&#x3D; 0x63); &#x2F;&#x2F; true<br>fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode &quot;Latin small letter A&quot;的编码是 U+0061 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter B&quot;的编码是 U+0062 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter D&quot;的编码是 U+0064 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter E&quot;的编码是 U+0065 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"><span class="comment">// 0x0061 === 97 </span></span><br><span class="line"><span class="comment">// 0x0062 === 98 </span></span><br><span class="line"><span class="comment">// 0x0063 === 99 </span></span><br><span class="line"><span class="comment">// 0x0064 === 100 </span></span><br><span class="line"><span class="comment">// 0x0065 === 101 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了<br>表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。在涉及增补平面的字符时，前面讨论的字符串方法就会出问题。比如，下面的例子中使用了一个笑脸表情符号，也就是一个使用代理对编码的字符：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;smiling face with smiling eyes&quot; 表情符号的编码是 U+1F60A </span></span><br><span class="line"><span class="comment">// 0x1F60A === 128522 </span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">length</span>); <span class="comment">// 6 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">1</span>)); <span class="comment">// b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// &lt;?&gt; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">3</span>)); <span class="comment">// &lt;?&gt; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">4</span>)); <span class="comment">// d </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)); <span class="comment">// 98 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">2</span>)); <span class="comment">// 55357 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">3</span>)); <span class="comment">// 56842 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">4</span>)); <span class="comment">// 100 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">0x1F60A</span>)); <span class="comment">// 😊</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55357</span>, <span class="number">56842</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure></div>
<p>这些方法仍然将 16 位码元当作一个字符，事实上索引 2 和索引 3 对应的码元应该被看成一个代理对，只对应一个字符。fromCharCode()方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成），并正确地将其识别为一个Unicode 笑脸字符。<br>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。跟使用 charCodeAt()时类似，codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识。比如，”c”的码点是 0x0063，而”😊”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。<br>let message &#x3D; “ab😊de”;<br>console.log(message.codePointAt(1)); &#x2F;&#x2F; 98<br>console.log(message.codePointAt(2)); &#x2F;&#x2F; 128522<br>console.log(message.codePointAt(3)); &#x2F;&#x2F; 56842<br>console.log(message.codePointAt(4)); &#x2F;&#x2F; 100<br>注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：<br>console.log([…”ab😊de”]); &#x2F;&#x2F; [“a”, “b”, “😊”, “d”, “e”]<br>与charCodeAt()有对应的 codePointAt()一样，fromCharCode()也有一个对应的 fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：<br>console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); &#x2F;&#x2F; ab☺de<br>console.log(String.fromCodePoint(97, 98, 128522, 100, 101)); &#x2F;&#x2F; ab☺de</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-17 日报 Day38</title>
    <url>/undefined/2024-12-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你今天的一言一行，都是在为以后的成功谋篇布局。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P99-102 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、内存泄露：在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。<br>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。<br>定时器也会导致内存泄露。下面的代码中，定时器的回调通过闭包引用了外部变量：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name); </span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></div>
<p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。<br>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line"> &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>2、静态分配与对象池：为了提升 JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。<br>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运<br>行。下面是一个对象池的伪实现：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vectorPool 是已有的对象池 </span></span><br><span class="line"><span class="keyword">let</span> v1 = vectorPool.<span class="title function_">allocate</span>(); </span><br><span class="line"><span class="keyword">let</span> v2 = vectorPool.<span class="title function_">allocate</span>(); </span><br><span class="line"><span class="keyword">let</span> v3 = vectorPool.<span class="title function_">allocate</span>(); </span><br><span class="line">v1.<span class="property">x</span> = <span class="number">10</span>; </span><br><span class="line">v1.<span class="property">y</span> = <span class="number">5</span>; </span><br><span class="line">v2.<span class="property">x</span> = -<span class="number">3</span>; </span><br><span class="line">v2.<span class="property">y</span> = -<span class="number">6</span>; </span><br><span class="line"><span class="title function_">addVector</span>(v1, v2, v3); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([v3.<span class="property">x</span>, v3.<span class="property">y</span>]); <span class="comment">// [7, -1] </span></span><br><span class="line">vectorPool.<span class="title function_">free</span>(v1); </span><br><span class="line">vectorPool.<span class="title function_">free</span>(v2); </span><br><span class="line">vectorPool.<span class="title function_">free</span>(v3); </span><br><span class="line"><span class="comment">// 如果对象有属性引用了其他对象</span></span><br><span class="line"><span class="comment">// 则这里也需要把这些属性设置为 null </span></span><br><span class="line">v1 = <span class="literal">null</span>; </span><br><span class="line">v2 = <span class="literal">null</span>; </span><br><span class="line">v3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>
<p>3、小结:  JavaScript 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始数据类型之一：Undefined、Null、Boolean、Number、String 和 Symbol。原始值和引用值有以下特点。<br> 原始值大小固定，因此保存在栈内存上。<br> 从一个变量到另一个变量复制原始值会创建该值的第二个副本。<br> 引用值是对象，存储在堆内存上。<br> 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。<br> 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。<br> typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。<br>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。<br> 执行上下文分全局上下文、函数上下文和块级上下文。<br> 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。<br> 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。<br> 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。<br> 变量的执行上下文用于确定什么时候释放内存。<br>JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收程序可以总结如下。<br> 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。<br> 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。<br> 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）。<br> 引用计数在代码中存在循环引用时会出现问题。<br> 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-22 日报 Day43</title>
    <url>/undefined/2024-12-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>成功其实很简单，就是比失败击倒你们的次数多一次。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P120-124 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、某些 Unicode 字符可以有多种编码方式。有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// U+00C5：上面带圆圈的大写拉丁字母 A </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x00C5</span>)); <span class="comment">// Å </span></span><br><span class="line"><span class="comment">// U+212B：长度单位“埃”</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x212B</span>)); <span class="comment">// Å </span></span><br><span class="line"><span class="comment">// U+004：大写拉丁字母 A </span></span><br><span class="line"><span class="comment">// U+030A：上面加个圆圈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x0041</span>, <span class="number">0x030A</span>)); <span class="comment">// Å</span></span><br></pre></td></tr></table></figure></div>
<p>为解决这个问题，Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：”NFD”、”NFC”、”NFKD”或”NFKC”。<br>2、字符串操作方法：</p>
<ul>
<li>concat()：将一个或多个字符串拼接起来，返回拼接后的新字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>slice()：提取字符串的一部分，返回一个新字符串，不会改变原始字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>substr()：从字符串中提取指定数目的字符，返回新字符串。</li>
<li>substring()：提取字符串中两个指定的索引位置之间的字符，返回新字符串。<br>slice()、substr()和 substring()是以相同方式被调用的，而且多数情况下返<br>回的值也相同。如果只传一个参数 3，则所有方法都将返回”lo world”，因为”hello”中”l”位置为 3。如果传入两个参数 3 和 7，则 slice()和 substring()返回”lo w”（因为”world”中”o”在位置 7，不包含），而 substr()返回”lo worl”，因为第二个参数对它而言表示返回的字符数。<br>当某个参数是负值时，这 3 个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字符串长度加上负参数值。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(-<span class="number">3</span>)); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;hel&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure></div>
在给 slice()和 substr()传入负参数时，它们的返回结果相同。这是因为-3 会被转换为 8（长度加上负参数），实际上调用的是 slice(8)和 substr(8)。而substring()方法返回整个字符串，因为-3 会转换为 0。在第二个参数是负值时，这 3 个方法各不相同。slice()方法将第二个参数转换为 7，实际上相当于调用 slice(3, 7)，因此返回”lo w”。而 substring()方法会将第二个参数转换为 0，相当于调用substring(3, 0)，等价于 substring(0, 3)，这是因为这个方法会将较小的参数作为起点，将较大的参数作为终点。对 substr()来说，第二个参数会被转换为 0，意味着返回的字符串包含零个字符，因而会返回一个空字符串。</li>
<li>字符串位置方法：indexOf()、lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></div>
这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。下面看一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 7 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
在传入第二个参数 6 以后，结果跟前面的例子恰好相反。这一次，indexOf()返回 7，因为它从位置 6（字符”w”）开始向后搜索字符串，在位置 7 找到了”o”。而 lastIndexOf()返回 4，因为它从位置 6 开始反向搜索至字符串开头，因此找到了”hello”中的”o”。</li>
<li>字符串包含方法：startsWith()、endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而 includes()检查整个字符串：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></li>
<li>trim()：创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot; hello world &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot; hello world &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStringValue); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></div>
由于 trim()返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。另外，trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</li>
<li>repeat()：ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">repeat</span>(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>); </span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure></div></li>
<li>padStart()和 padEnd()：padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">6</span>)); <span class="comment">// &quot;   foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">6</span>)); <span class="comment">// &quot;foo   &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure></div>
可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;foobarba&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>字符串迭代与解构：字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></div>
在 for-of 循环中可以通过这个迭代器按序访问每个字符：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(c); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// a </span></span><br><span class="line"><span class="comment">// b </span></span><br><span class="line"><span class="comment">// c </span></span><br><span class="line"><span class="comment">// d </span></span><br><span class="line"><span class="comment">// e </span></span><br></pre></td></tr></table></figure></div>
有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...message]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure></div></li>
<li>字符串大小写转换：下一组方法涉及大小写转换，包括 4 个方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。toLowerCase()和toUpperCase()方法是原来就有的方法，与 java.lang.String 中的方法同名。toLocaleLowerCase()和 toLocaleUpperCase()方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。下面是几个例子：<br>let stringValue &#x3D; “hello world”;<br>console.log(stringValue.toLocaleUpperCase()); &#x2F;&#x2F; “HELLO WORLD”<br>console.log(stringValue.toUpperCase()); &#x2F;&#x2F; “HELLO WORLD”<br>console.log(stringValue.toLocaleLowerCase()); &#x2F;&#x2F; “hello world”<br>console.log(stringValue.toLowerCase()); &#x2F;&#x2F; “hello world”<br>这里，toLowerCase()和 toLocaleLowerCase()都返回 hello world，而 toUpperCase()和toLocaleUpperCase()都返回 HELLO WORLD。通常，如果不知道代码涉及什么语言，则最好使用地区特定的转换方法。<br>好嘞！我们来看看 土耳其语（Turkish） 是为什么要使用 toLocaleLowerCase() 和 toLocaleUpperCase() 的经典示例语言，以及它和普通 toLowerCase()&#x2F;toUpperCase() 的区别。<br>⸻<br>🇹🇷 土耳其语大小写转换的特别之处<br>在英文中：<br>  •	‘i’ → ‘I’<br>  •	‘I’ → ‘i’<br>这是我们熟悉的大小写规则。<br>但在 土耳其语 中：<br>  •	小写 ‘i’ → 大写 ‘İ’（带点的大写 i）<br>  •	大写 ‘I’ → 小写 ‘ı’（不带点的小写 i）<br>也就是说，土耳其语有两个不同的字母：<br>  •	‘i’（点的 i）<br>  •	‘ı’（无点的 i）<br>⸻</li>
</ul>
<p>✅ 举个代码例子：<br>let str &#x3D; “i”;<br>console.log(str.toUpperCase()); &#x2F;&#x2F; “I” —— 英文规则<br>console.log(str.toLocaleUpperCase(“tr-TR”)); &#x2F;&#x2F; “İ” —— 土耳其语规则<br>let str2 &#x3D; “I”;<br>console.log(str2.toLowerCase()); &#x2F;&#x2F; “i” —— 英文规则<br>console.log(str2.toLocaleLowerCase(“tr-TR”)); &#x2F;&#x2F; “ı” —— 土耳其语规则<br>⸻<br>📌 总结建议：<br>    •	如果你处理的是英文或默认语言环境，toUpperCase() 和 toLowerCase() 足够。<br>    •	如果你处理的是用户可能使用土耳其语、立陶宛语等语言的多语言应用，请使用 toLocaleUpperCase(locale) 和 toLocaleLowerCase(locale) 并显式指定区域，这样才能保证转换符合语言规则。<br>⸻</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-23 日报 Day44</title>
    <url>/undefined/2024-12-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每当事情推进一步，你的迷茫就会减少一分。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P125-127 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、字符串模式匹配方法：</p>
<ul>
<li>match()：这个方法本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>; </span><br><span class="line"><span class="comment">// 等价于 pattern.exec(text) </span></span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// &quot;cat&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
match()方法返回的数组与 RegExp 对象的 exec()方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。<br>另一个查找模式的字符串方法是 search()。这个方法唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回1。search()始终从字符串开头向后匹配模式。看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pos = text.<span class="title function_">search</span>(<span class="regexp">/at/</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pos); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>
为简化子字符串替换操作，ECMAScript 提供了 replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;cond, bat, sat, fat&quot; </span></span><br><span class="line">result = text.<span class="title function_">replace</span>(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure></div>
第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。</li>
<li>$&amp;：与正则表达式相匹配的子字符串。</li>
<li>$&#96;：位于匹配子字符串左侧的文本。</li>
<li>$’：位于匹配子字符串右侧的文本。</li>
<li>$n：匹配第 n 个捕获组的文本（如果有的话）。</li>
<li>$nn：匹配第 nn 个捕获组的文本（如果有的话）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line">result = text.<span class="title function_">replace</span>(<span class="regexp">/(.at)/g</span>, <span class="string">&quot;word ($1)&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure></div>
replace()的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">text</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> text.<span class="title function_">replace</span>(<span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) &#123; </span><br><span class="line"> <span class="keyword">switch</span>(match) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">htmlEscape</span>(<span class="string">&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;</span>)); </span><br><span class="line"><span class="comment">// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>split(): 这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">&quot;red,blue,green,yellow&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;] </span></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;] </span></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.<span class="title function_">split</span>(<span class="regexp">/[^,]+/</span>); <span class="comment">// [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure></div>
在这里，字符串 colorText 是一个逗号分隔的颜色名称符串。调用 split(“,”)会得到包含这些颜色名的数组，基于逗号进行拆分。要把数组元素限制为 2 个，传入第二个参数 2 即可。最后，使用正则表达式可以得到一个包含逗号的数组。注意在最后一次调用 split()时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（”red”）和末尾（”yellow”）。</li>
<li>localeCompare(): 这个方法比较两个字符串，并返回下列值中的一个：<br> 如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。）<br> 如果字符串与字符串参数相等，则返回 0。<br> 如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>
在这里，字符串”yellow”与 3 个不同的值进行了比较：”brick”、”yellow”和”zoo”。”brick”按字母表顺序应该排在”yellow”前头，因此 localeCompare()返回 1。”yellow”等于”yellow”，因此”localeCompare()”返回 0。最后，”zoo”在”yellow”后面，因此 localeCompare()返回-1。强调一下，因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用 localeCompare()：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">determineOrder</span>(<span class="params">value</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> result = stringValue.<span class="title function_">localeCompare</span>(value); </span><br><span class="line"> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The string &#x27;yellow&#x27; comes before the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>); </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The string &#x27;yellow&#x27; comes after the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The string &#x27;yellow&#x27; is equal to the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">determineOrder</span>(<span class="string">&quot;brick&quot;</span>); </span><br><span class="line"><span class="title function_">determineOrder</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="title function_">determineOrder</span>(<span class="string">&quot;zoo&quot;</span>);</span><br></pre></td></tr></table></figure></div>
localeCompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是 ECMAScript 实现的标准语言，localeCompare()区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-24 日报 Day45</title>
    <url>/undefined/2024-12-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>很多时候，能力决定你能走多快，人品决定你能走多远。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P128-131 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、HTML：早期的浏览器开发商认为使用 JavaScript 动态生成 HTML 标签是一个需求。因此，早期浏览器扩展了规范，增加了辅助生成 HTML 标签的方法。下表总结了这些 HTML 方法。不过，这些方法基本上已经没有人使用了，因为结果通常不是语义化的标记。</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>输 出</th>
</tr>
</thead>
<tbody><tr>
<td>anchor(name)</td>
<td><a name="name">string</a></td>
</tr>
<tr>
<td>big()</td>
<td><big>string</big></td>
</tr>
<tr>
<td>bold()</td>
<td><b>string</b></td>
</tr>
<tr>
<td>fixed()</td>
<td><tt>string</tt></td>
</tr>
<tr>
<td>fontcolor(color)</td>
<td><font color="color">string</font></td>
</tr>
<tr>
<td>fontsize(size)</td>
<td><font size="size">string</font></td>
</tr>
<tr>
<td>italics()</td>
<td><i>string</i></td>
</tr>
<tr>
<td>link(url)</td>
<td><a href="url">string</a></td>
</tr>
<tr>
<td>small()</td>
<td><small>string</small></td>
</tr>
<tr>
<td>strike()</td>
<td><strike>string</strike></td>
</tr>
<tr>
<td>sub()</td>
<td><sub>string</sub></td>
</tr>
<tr>
<td>sup()</td>
<td><sup>string</sup ></td>
</tr>
<tr>
<td>2、单例内置对象：ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括 Object、Array 和 String。本节介绍 ECMA-262定义的另外两个单例内置对象：Global 和 Math。</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Global：Global 对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定 Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本书前面介绍的函数，包括 isNaN()、isFinite()、parseInt()和 parseFloat()，实际上都是 Global 对象的方法。除了这些，Global 对象上还有另外一些方法。<br>URL编码方法：encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解它们，同时又以特殊的 UTF-8 编码替换掉所有无效字符。<br>ecnodeURI()方法用于对整个 URI 进行编码，比如”<a class="link"   href="http://www.wrox.com/illegal" >www.wrox.com/illegal <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> value.js”。而encodeURIComponent()方法用于编码 URI 中单独的组件，比如前面 URL 中的”illegal value.js”。这两个方法的主要区别是，encodeURI()不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而 encodeURIComponent()会编码它发现的所有非标准字符。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>; </span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURI</span>(uri)); </span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></div>
这里使用 encodeURI()编码后，除空格被替换为%20 之外，没有任何变化。而 encodeURIComponent()方法将所有非字母字符都替换成了相应的编码形式。这就是使用 encodeURI()编码整个URI，但只使用 encodeURIComponent()编码那些会追加到已有 URI 后面的字符串的原因。<br>与 encodeURI()和 encodeURIComponent()相对的是 decodeURI()和 decodeURIComponent()。decodeURI()只对使用 encodeURI()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由 encodeURI()替换的。类似地，decodeURIComponent()解码所有被 encodeURIComponent()编码的字符，基本上就是解码所有特殊值。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span>; </span><br><span class="line"><span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURI</span>(uri)); </span><br><span class="line"><span class="comment">// http:// www.wrox.com/illegal value.js#start </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></div>
这里，uri 变量中包含一个使用 encodeURIComponent()编码过的字符串。首先输出的是使用decodeURI()解码的结果，可以看到只用空格替换了%20。然后是使用 decodeURIComponent()解码的结果，其中替换了所有特殊字符，并输出了没有包含任何转义的字符串。（这个字符串不是有效的 URL。）<br>3、eval()方法：eval()方法是 ECMAScript 中最强大的函数之一，也是最容易被滥用的函数之一。它的用途是将对应的字符串解析成 JS 代码并运行。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>);</span><br></pre></td></tr></table></figure></div>
当解释器发现 eval()调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置。通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在 eval()调用内部被引用，比如下面这个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></div>
注意 解释代码字符串的能力是非常强大的，但也非常危险。在使用 eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。<br>4、Global对象属性：Global 对象有很多属性，其中一些前面已经提到过了。像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function，也都是Global 对象的属性。下表列出了所有这些属性。</li>
</ul>
<table>
<thead>
<tr>
<th>属 性</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>特殊值 undefined</td>
</tr>
<tr>
<td>NaN</td>
<td>特殊值 NaN</td>
</tr>
<tr>
<td>Infinity</td>
<td>特殊值 Infinity</td>
</tr>
<tr>
<td>Object</td>
<td>构造函数 Object</td>
</tr>
<tr>
<td>Array</td>
<td>构造函数 Array</td>
</tr>
<tr>
<td>Function</td>
<td>构造函数 Function</td>
</tr>
<tr>
<td>Boolean</td>
<td>构造函数 Boolean</td>
</tr>
<tr>
<td>String</td>
<td>构造函数 String</td>
</tr>
<tr>
<td>Number</td>
<td>构造函数 Number</td>
</tr>
<tr>
<td>Date</td>
<td>构造函数 Date</td>
</tr>
<tr>
<td>RegExp</td>
<td>构造函数 RegExp</td>
</tr>
<tr>
<td>Symbol</td>
<td>构造函数 Symbol</td>
</tr>
<tr>
<td>Error</td>
<td>构造函数 Error（所有错误类型的基类型）</td>
</tr>
<tr>
<td>EvalError</td>
<td>构造函数 EvalError</td>
</tr>
<tr>
<td>RangeError</td>
<td>构造函数 RangeError</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>构造函数 ReferenceError</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>构造函数 SyntaxError</td>
</tr>
<tr>
<td>TypeError</td>
<td>构造函数 TypeError</td>
</tr>
<tr>
<td>URIError</td>
<td>构造函数 URIError</td>
</tr>
<tr>
<td>5、window对象：虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。来看下面的例子：</td>
<td></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">color</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayColor</span>(); <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>另一种获取 Global 对象的方式是使用如下的代码：<br>let global &#x3D; function() {<br> return this;<br>}();<br>这段代码创建一个立即调用的函数表达式，返回了 this 的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过 call()&#x2F;apply()）指定 this 值的情况下执行时，this 值等于Global 对象。因此，调用一个简单返回 this 的函数是在任何执行上下文中获取 Global 对象的通用方式。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-25 日报 Day46</title>
    <url>/undefined/2024-12-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>不要只顾着欣赏他人的绚烂，而忘记了自己的芬芳。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P132-135 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象提供了一些辅助计算的属性和方法。<br>注意 Math 对象上提供的计算要比直接在 JavaScript 实现的快得多，因为 Math 对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用 Math 计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。<br>2、Math对象属性：</p>
<ul>
<li>Math.E：自然对数的底数，即常量e的值。</li>
<li>Math.LN2：2的自然对数。</li>
<li>Math.LN10：10的自然对数。</li>
<li>Math.LOG2E：以2为底e的对数。</li>
<li>Math.LOG10E：以10为底e的对数。</li>
<li>Math.PI：圆周率。</li>
<li>Math.SQRT1_2：1&#x2F;2的平方根。</li>
<li>Math.SQRT2：2的平方根。<br>3、Math对象方法：</li>
<li>min()和max方法：min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max); <span class="comment">// 54 </span></span><br><span class="line"><span class="keyword">let</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(min); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：<br>let values &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];<br>let max &#x3D; Math.max(…val);</li>
<li>舍入方法：接下来是用于把小数值舍入为整数的 4 个方法：Math.ceil()、Math.floor()、Math.round()和 Math.fround()。这几个方法处理舍入的方式如下所述。<br> Math.ceil()方法始终向上舍入为最接近的整数<br> Math.floor()方法始终向下舍入为最接近的整数<br> Math.round()方法把舍入为最接近的整数<br> Math.fround()方法返回最接近参数的单精度浮点数表示<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">25.9</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">25.5</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">25.1</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">25.9</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">25.5</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">25.1</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">fround</span>(<span class="number">0.4</span>)); <span class="comment">// 0.4000000059604645 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">fround</span>(<span class="number">0.5</span>)); <span class="comment">// 0.5 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">fround</span>(<span class="number">25.9</span>)); <span class="comment">// 25.899999618530273 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">25.9</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">25.5</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">25.1</span>)); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></div></li>
<li>random()方法：Math.random()方法返回大于等于 0 小于 1 的一个随机数。这个随机数是由一个均匀分布产生的，其平均值是 0.5。<br>注意 Math.random()方法在这里出于演示目的是没有问题的。如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用 window.crypto.getRandomValues()。</li>
<li>其他方法:<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abs()</td>
<td>返回数值的绝对值</td>
</tr>
<tr>
<td>cbrt()</td>
<td>返回数值的立方根</td>
</tr>
<tr>
<td>exp()</td>
<td>返回Math.E的x次幂</td>
</tr>
<tr>
<td>log()</td>
<td>返回数值的自然对数（以e为底）</td>
</tr>
<tr>
<td>pow()</td>
<td>返回数值的x次幂</td>
</tr>
<tr>
<td>sqrt()</td>
<td>返回数值的平方根</td>
</tr>
<tr>
<td>sign()</td>
<td>返回数值的符号，指示数值是正数、负数还是零</td>
</tr>
<tr>
<td>trunc()</td>
<td>返回数值的整数部分，去除小数部分</td>
</tr>
<tr>
<td>4、小结：</td>
<td></td>
</tr>
<tr>
<td>JavaScript 中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。</td>
<td></td>
</tr>
<tr>
<td> 引用值与传统面向对象编程语言中的类相似，但实现不同。</td>
<td></td>
</tr>
<tr>
<td> Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。</td>
<td></td>
</tr>
<tr>
<td> RegExp 类型是 ECMAScript 支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。</td>
<td></td>
</tr>
<tr>
<td>JavaScript 比较独特的一点是，函数实际上是 Function 类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类型：Boolean、Number 和 String。它们都具备如下特点。</td>
<td></td>
</tr>
<tr>
<td> 每种包装类型都映射到同名的原始类型。</td>
<td></td>
</tr>
<tr>
<td> 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相</td>
<td></td>
</tr>
<tr>
<td>应的数据。</td>
<td></td>
</tr>
<tr>
<td> 涉及原始值的语句执行完毕后，包装对象就会被销毁。</td>
<td></td>
</tr>
<tr>
<td>当代码开始执行时，全局上下文中会存在两个内置对象：Global 和 Math。其中，Global 对象在大多数 ECMAScript 实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是 Global 对象的属性。Math 对象包含辅助完成复杂计算的属性和方法。</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-26 日报 Day47</title>
    <url>/undefined/2024-12-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>当你成长为一株向日葵，才能吸引来更多的阳光与正能量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P136-138 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。显式地创建 Object 的实例有两种方式。<br>第一种是使用 new 操作符和 Object 构造函数，如下所示：<br>let person &#x3D; new Object();<br>person.name &#x3D; “Nicholas”;<br>person.age &#x3D; 29;<br>第二种方式是使用对象字面量表示法，如下所示：<br>let person &#x3D; {<br>  name: “Nicholas”,<br>  age: 29<br>};<br>在对象字面量表示法中，属性名可以是字符串或数值。注意，数值属性会自动转换为字符串。虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性，通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。<br>注意 在使用对象字面量表示法定义对象时，并不会实际调用 Object 构造函数。	当你用 对象字面量 {} 来定义对象时，JavaScript 引擎会在底层自动创建一个继承自 Object.prototype 的对象，但不会显式调用 new Object() 构造函数。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-27 日报 Day48</title>
    <url>/undefined/2024-12-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生的淡定和从容，都是从学到的本领修炼来的气定神闲。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P139-142 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、除了 Object，Array 应该就是 ECMAScript 中最常用的类型了。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。<br>2、创建数组的方式有两种。第一种是使用 Array 构造函数，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>第二种方式是使用数组字面量表示法，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br></pre></td></tr></table></figure></div>
<p>数组字面量表示法是数组创建方式中最常用的一种，因为它更简洁。数组字面量表示法中的数组项不必是常量，可以是任意表达式。数组项可以是任意类型的数据，也可以是对象或其他数组。注意 与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。<br>Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：from()和 of()。from()用于将类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。<br>Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。这种方式可用于很多场合：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;] </span></span><br><span class="line"><span class="comment">// 可以使用 from()将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="number">1</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">2</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">3</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(m)); <span class="comment">// [[1, 2], [3, 4]] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(s)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// Array.from()对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="title function_">alert</span>(a1 === a2); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123; </span><br><span class="line"> *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">4</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arguments 对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArgsArray</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getArgsArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// from()也能转换带有必要属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; </span><br><span class="line"> <span class="number">0</span>: <span class="number">1</span>, </span><br><span class="line"> <span class="number">1</span>: <span class="number">2</span>, </span><br><span class="line"> <span class="number">2</span>: <span class="number">3</span>, </span><br><span class="line"> <span class="number">3</span>: <span class="number">4</span>, </span><br><span class="line"> <span class="attr">length</span>: <span class="number">4</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLikeObject)); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></div>
<p>Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像<br>调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函<br>数中 this 的值。但这个重写的 this 值在箭头函数中不适用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="keyword">function</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x**<span class="variable language_">this</span>.<span class="property">exponent</span>&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 4, 9, 16] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3); <span class="comment">// [1, 4, 9, 16] </span></span><br></pre></td></tr></table></figure></div>
<p>Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype. slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：</p>
<p>console.log(Array.of(1, 2, 3, 4)); &#x2F;&#x2F; [1, 2, 3, 4]<br>console.log(Array.of(undefined)); &#x2F;&#x2F; [undefined]<br>3、要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如果把一个值设置给超过数组最大索引的索引，就像示例中的 colors[3]，则数组长度会自动扩展到该索引值加 1<br>数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">2</span>; </span><br><span class="line"><span class="title function_">alert</span>(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>注意 数组最多可以包含 4 294 967 295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。<br>4、检测数组：一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123; </span><br><span class="line"> <span class="comment">// 对数组执行某些操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。<br>为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value))&#123; </span><br><span class="line"> <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>5、迭代器方法：在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回索引&#x2F;值对的迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]; </span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容</span></span><br><span class="line"><span class="comment">// 通过 Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">keys</span>()); </span><br><span class="line"><span class="keyword">const</span> aValues = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">values</span>()); </span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">entries</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys); <span class="comment">// [0, 1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues); <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aEntries); <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]] </span></span><br><span class="line">使用 <span class="title class_">ES6</span> 的解构可以非常容易地在循环中拆分键/值对：</span><br><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(idx); </span><br><span class="line"> <span class="title function_">alert</span>(element); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// baz </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-29 日报 Day50</title>
    <url>/undefined/2024-12-29/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>愿你历经风霜，依然初心不改，坚定走在自己的路上。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P148-151 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、排序方法：数组有2个方法对元素进行重新排序reverse()和sort()。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line">values.<span class="title function_">reverse</span>(); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure></div>
<p>默认情况下，sort()会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。比如:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>();</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure></div>
<p>一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。因此，即使 5 小于 10，但字符串”10”在字符串”5”的前头，所以 10 还是会排到 5 前面。很明显，这在多数情况下都不是最合适的。为此，sort()方法可以接收一个比较函数，用于判断哪个值应该排在前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。比如:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(compare); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure></div>
<p>在给 sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也<br>可以产生降序效果，只要把返回值交换一下即可：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(compare); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure></div>
<p>此外，这个比较函数还可简写为一个箭头函数：<br>let values &#x3D; [0, 1, 5, 10, 15];<br>values.sort((a, b) &#x3D;&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0);<br>alert(values); &#x2F;&#x2F; 15,10,5,1,0<br>如果数组的元素是数值，或者是其 valueOf()方法返回数值的对象（如 Date 对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：<br>function compare(value1, value2){<br> return value2 - value1;<br>}<br>2、数组操作方法：</p>
<ul>
<li>concat()方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure></div>
打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">length</span>: <span class="number">2</span>, </span><br><span class="line"> <span class="number">0</span>: <span class="string">&quot;pink&quot;</span>, </span><br><span class="line"> <span class="number">1</span>: <span class="string">&quot;cyan&quot;</span> </span><br><span class="line">&#125;; </span><br><span class="line">newColors[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, newColors); </span><br><span class="line"><span class="comment">// 强制打平类数组对象</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">concat</span>(moreNewColors); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]</span></span><br></pre></td></tr></table></figure></div></li>
<li>slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line"><span class="title function_">alert</span>(colors2); <span class="comment">// green,blue,yellow,purple </span></span><br><span class="line"><span class="title function_">alert</span>(colors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure></div>
注意 如果 slice()的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如，在包含 5 个元素的数组上调用 slice(-2,-1)，就相当于调用 slice(3,4)。如果结束位置小于开始位置，则返回空数组。</li>
<li>最强大的数组方法就属 splice()了，使用它的方式可以有很多种。splice()的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。<br> 删除。需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。<br> 插入。需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2, 0, “red”, “green”)会从数组位置 2 开始插入字符串”red”和”green”。<br> 替换。splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始向数组中插入”red”和”green”。<br>splice()方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 在位置 1 插入两个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,yellow,orange,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,red,purple,orange,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-28 日报 Day49</title>
    <url>/undefined/2024-12-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>懂得适时转变位置，成为一束照亮别人的光，也才能被他人照耀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P143-147 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、复制和填充方法:批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。<br>使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; </span><br><span class="line"><span class="comment">// 用 5 填充整个数组</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [5, 5, 5, 5, 5] </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 6 填充索引大于等于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">6</span>, <span class="number">3</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 6, 6] </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 7, 7, 0, 0]; </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 8 填充索引大于等于 1 且小于 4 的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1) </span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4) </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure></div>
<p>fill()静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure></div>
<p>与 fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></div>
<p>copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, -<span class="number">15</span>, -<span class="number">12</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>() </span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引部分可用，复制、填充可用部分</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>) </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure></div>
<p>2、转换方法：所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf()返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。来看下面的<br>例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toString</span>()); <span class="comment">// red,blue,green </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">valueOf</span>()); <span class="comment">// red,blue,green </span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// red,blue,green</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123; </span><br><span class="line"> <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nikolaos&quot;</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">toString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person2 = &#123; </span><br><span class="line"> <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Grigorios&quot;</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">toString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> people = [person1, person2]; </span><br><span class="line"><span class="title function_">alert</span>(people); <span class="comment">// Nicholas,Greg </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toString</span>()); <span class="comment">// Nicholas,Greg </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toLocaleString</span>()); <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure></div>
<p>继承的方法 toLocaleString()以及 toString()都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用 join()方法。join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。来看下面的例子：<br>let colors &#x3D; [“red”, “green”, “blue”];<br>alert(colors.join(“,”)); &#x2F;&#x2F; red,green,blue<br>alert(colors.join(“||”)); &#x2F;&#x2F; red||green||blue<br>如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符。<br>注意 如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、toString()和 valueOf()返回的结果中会以空字符串表示。<br>3、栈方法：ECMAScript 给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了 push()和 pop()方法，以实现类似栈的行为。<br>push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// black </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
<p>3、队列方法：就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push()方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 shift()，它会删除数组的第一项并返回它，然后数组长度减 1。使用 shift()和 push()，可以把数组当成队列来使用：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// red </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
<p>ECMAScript 也为数组提供了 unshift()方法。顾名思义，unshift()就是执行跟 shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 unshift()和 pop()，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// green </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-3 日报 Day24</title>
    <url>/undefined/2024-12-3/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生，从外打破是压力，从内打破是成长。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P77-80 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、break和continue语句：break 和 continue 语句用于在循环中精确地控制代码的执行。break 语句会立即退出循环，强制终止循环的执行，而 continue 语句只会退出当前循环的一次迭代。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>; </span><br><span class="line"><span class="attr">outermost</span>: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span> outermost; </span><br><span class="line"> &#125; </span><br><span class="line"> num++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outermost</span>:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line"> <span class="keyword">continue</span> outermost;</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure></div>
<p>这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当 i 和 j 都等于 5 时，会执行 continue，跳到外部循环继续执行，从而导致内部循环少执行 5 次，结果 num 等于 95。<br>2、with 语句：with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statement</span><br></pre></td></tr></table></figure></div>
<p>3、switch语句：switch 语句是一种多分支语句，用于基于不同条件执行不同动作。switch 语句的语法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="attr">value1</span>: </span><br><span class="line">  statement </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="attr">value2</span>: </span><br><span class="line">  statement </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="attr">value3</span>: </span><br><span class="line">  statement </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line"> <span class="attr">default</span>: </span><br><span class="line">  statement </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为避免不必要的条件判断，最好给每个条件后面都加上 break 语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了 break，如下所示：</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="number">25</span>: </span><br><span class="line"> <span class="comment">/*跳过*/</span> </span><br><span class="line"> <span class="keyword">case</span> <span class="number">35</span>: </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;25 or 35&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="number">45</span>: </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;45&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-30 日报 Day51</title>
    <url>/undefined/2024-12-30/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>我们的人生不是只有成功和失败两个词，坚持和奋斗同样有意义。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P152-158 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、搜索和位置方法：ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p>
<ul>
<li>严格相等：ECMAScript 提供了 3 个严格相等的搜索方法：indexOf()、lastIndexOf()和 includes()。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项）开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索。<br>indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（&#x3D;&#x3D;&#x3D;）比较，也就是说两项必须严格相等。下面来看一些例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>, <span class="number">7</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;]; </span><br><span class="line"><span class="keyword">let</span> morePeople = [person]; </span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">indexOf</span>(person)); <span class="comment">// -1 </span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">indexOf</span>(person)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">includes</span>(person)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">includes</span>(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></li>
<li>断言函数：ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。<br>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [ </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span> </span><br><span class="line"> &#125; </span><br><span class="line">]; </span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125; </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
2、迭代方法：ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。数组的 5 个迭代方法如下。<br> every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。<br> filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。<br> forEach()：对数组每一项都运行传入的函数，没有返回值。<br> map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。<br> some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。<br>这些方法都不改变调用它们的数组。<br>3、归并方法：ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。而 reduceRight()从最后一项开始遍历至第一项。<br>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。<br>可以使用 reduce()函数执行累加数组中所有数值的操作，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></div>
第一次执行归并函数时，prev 是 1，cur 是 2。第二次执行时，prev 是 3（1 + 2），cur 是 3（数组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。<br>reduceRight()方法与之类似，只是方向相反。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduceRight</span>(<span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> prev + cur; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></div>
在这里，第一次调用归并函数时 prev 是 5，而 cur 是 4。究竟是使用 reduce()还是 reduceRight()，只取决于遍历数组元素的方向。<br>4、定型数组: 定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。用途：随着浏览器的流行，不难想象人们会满怀期待地通过它来运行复杂的 3D 应用程序。早在 2006 年，Mozilla、Opera 等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插件。其目标是开发一套 JavaScript API，从而充分利用 3D 图形 API 和 GPU 加速，以便在<canvas>元素上渲染复杂的图形。</li>
<li>WebGL: 在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript数组在内存中的格式。因此，每次 WebGL 与 JavaScript 运行时之间传递数组时，WebGL 绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费很多时间。</li>
<li>定型数组: 这当然是难以接受的，Mozilla 为解决这个问题而实现了 CanvasFloatArray。这是一个提供JavaScript 接口的、C 语言风格的浮点值数组。JavaScript 运行时使用这个类型可以分配、读取和写入数组。这个数组可以直接传给底层图形驱动程序 API，也可以直接从底层获取到。最终，CanvasFloatArray变成了 Float32Array，也就是今天定型数组中可用的第一个“类型”。<br>5、ArrayBuffer: Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。<br>ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 在内存中分配 16 字节</span></span><br><span class="line"><span class="title function_">alert</span>(buf.<span class="property">byteLength</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></div>
ArrayBuffer 一经创建就不能再调整大小。不过，可以使用 slice()复制其全部或部分到一个新实例中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); </span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.<span class="title function_">slice</span>(<span class="number">4</span>, <span class="number">12</span>); </span><br><span class="line"><span class="title function_">alert</span>(buf2.<span class="property">byteLength</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></div>
不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须通过视图。视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据。<br>6、DataView: 第一种允许你读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I&#x2F;O 和网络 I&#x2F;O 设计，其API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。<br>必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// DataView 默认使用整个 ArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteOffset</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteLength</span>); <span class="comment">// 16 </span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">buffer</span> === buf); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">// byteOffset=0 表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">// byteLength=8 限制视图为前 8 个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>); </span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteOffset</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">buffer</span> === buf); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不指定，则 DataView 会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">// byteOffset=8 表示视图从缓冲的第 9 个字节开始</span></span><br><span class="line"><span class="comment">// byteLength 未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">8</span>); </span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">byteOffset</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></div>
alert(secondHalfDataView.byteLength); &#x2F;&#x2F; 8<br>alert(secondHalfDataView.buffer &#x3D;&#x3D;&#x3D; buf); &#x2F;&#x2F; true<br>要通过 DataView 读取缓冲，还需要几个组件。<br> 首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地址”。<br> DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。<br> 最后是内存中值的字节序。默认为大端字节序。<br>DataView 对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读、写时指定一个ElementType，然后 DataView 就会忠实地为读、写而完成相应的转换。ECMAScript 6 支持 8 种不同的 ElementType:<table>
<thead>
<tr>
<th>ElementType</th>
<th>字节长度</th>
<th>描述</th>
<th>等价的C类型</th>
<th>值范围</th>
</tr>
</thead>
<tbody><tr>
<td>Int8</td>
<td>1</td>
<td>8 位有符号整数</td>
<td>signed char</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>Uint8</td>
<td>1</td>
<td>8 位无符号整数</td>
<td>unsigned char</td>
<td>0 到 255</td>
</tr>
<tr>
<td>Int16</td>
<td>2</td>
<td>16 位有符号整数</td>
<td>short</td>
<td>-32 768 到 32 767</td>
</tr>
<tr>
<td>Uint16</td>
<td>2</td>
<td>16 位无符号整数</td>
<td>unsigned short</td>
<td>0 到 65 535</td>
</tr>
<tr>
<td>Int32</td>
<td>4</td>
<td>32 位有符号整数</td>
<td>int</td>
<td>-2 147 483 648 到 2 147 483 647</td>
</tr>
<tr>
<td>Uint32</td>
<td>4</td>
<td>32 位无符号整数</td>
<td>unsigned int</td>
<td>0 到 4 294 967 295</td>
</tr>
<tr>
<td>Float32</td>
<td>4</td>
<td>32 位浮点数</td>
<td>float</td>
<td>-3.4e+38 到 +3.4e+38</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
<td>64 位浮点数</td>
<td>double</td>
<td>-1.7e+308 到 +1.7e+308</td>
</tr>
<tr>
<td>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView </span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 说明整个缓冲确实所有二进制位都是 0 </span></span><br><span class="line"><span class="comment">// 检查第一个和第二个字符</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">1</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 检查整个缓冲</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为 1 </span></span><br><span class="line"><span class="comment">// 255 的二进制表示是 11111111（2^8 - 1）</span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">255</span>); </span><br><span class="line"><span class="comment">// DataView 会自动将数据转换为特定的 ElementType </span></span><br><span class="line"><span class="comment">// 255 的十六进制表示是 0xFF </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0xFF</span>); </span><br><span class="line"><span class="comment">// 现在，缓冲里都是 1 了</span></span><br><span class="line"><span class="comment">// 如果把它当成二补数的有符号整数，则应该是-1 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>
7、字节序: 前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。<br>JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这个约定。对一段内存而言，DataView 是一个中立接口，它会遵循你指定的字节序。DataView 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView </span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 填充缓冲，让第一位和最后一位都是 1 </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左边的位等于 1 </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右边的位等于 1 </span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x8 0x0 0x0 0x1 </span></span><br><span class="line"><span class="comment">// 1000 0000 0000 0001 </span></span><br><span class="line"><span class="comment">// 按大端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x80 是高字节，0x01 是低字节</span></span><br><span class="line"><span class="comment">// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>)); <span class="comment">// 32769 </span></span><br><span class="line"><span class="comment">// 按小端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x01 是高字节，0x80 是低字节</span></span><br><span class="line"><span class="comment">// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 384 </span></span><br><span class="line"><span class="comment">// 按大端字节序写入 Uint16 </span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0004</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x0 0x0 0x4 </span></span><br><span class="line"><span class="comment">// 0000 0000 0000 0100 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 按小端字节序写入 Uint16 </span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x2 0x0 0x0 </span></span><br><span class="line"><span class="comment">// 0000 0010 0000 0000 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 2 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-31 日报 Day52</title>
    <url>/undefined/2024-12-31/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>从来没有一蹴而就的成功，所有熠熠闪光的背后都是默默的努力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P159-162 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、边界情况：DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">6</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">8</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(-<span class="number">1</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">setInt32</span>(<span class="number">4</span>, <span class="number">123</span>); </span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure></div>
<p>DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="number">1.5</span>); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 1 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, [<span class="number">4</span>]); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 4 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="title class_">Symbol</span>()); </span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></div>
<p>2、定型数组: 定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别在于，它特定于一种 ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API 和更高的性能。设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。<br>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过<ElementType>.from()和<ElementType>.of()也可以创建定型数组：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 12 字节的缓冲</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">12</span>); </span><br><span class="line"><span class="comment">// 创建一个引用该缓冲的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buf); </span><br><span class="line"><span class="comment">// 这个定型数组知道自己的每个元素需要 4 字节</span></span><br><span class="line"><span class="comment">// 因此长度为 3 </span></span><br><span class="line"><span class="title function_">alert</span>(ints.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 创建一个长度为 6 的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(<span class="number">6</span>); </span><br><span class="line"><span class="comment">// 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节</span></span><br><span class="line"><span class="title function_">alert</span>(ints2.<span class="property">length</span>); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 类似 DataView，定型数组也有一个指向关联缓冲的引用</span></span><br><span class="line"><span class="title function_">alert</span>(ints2.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 24 </span></span><br><span class="line"><span class="comment">// 创建一个包含[2, 4, 6, 8]的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]); </span><br><span class="line"><span class="title function_">alert</span>(ints3.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints3.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 16 </span></span><br><span class="line"><span class="title function_">alert</span>(ints3[<span class="number">2</span>]); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 通过复制 ints3 的值创建一个 Int16Array </span></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(ints3); </span><br><span class="line"><span class="comment">// 这个新类型数组会分配自己的缓冲</span></span><br><span class="line"><span class="comment">// 对应索引的每个值会相应地转换为新格式</span></span><br><span class="line"><span class="title function_">alert</span>(ints4.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints4.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(ints4[<span class="number">2</span>]); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 基于普通数组来创建一个 Int16Array </span></span><br><span class="line"><span class="keyword">const</span> ints5 = <span class="title class_">Int16Array</span>.<span class="title function_">from</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]); </span><br><span class="line"><span class="title function_">alert</span>(ints5.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints5.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(ints5[<span class="number">2</span>]); <span class="comment">// 7 </span></span><br><span class="line"><span class="comment">// 基于传入的参数创建一个 Float32Array </span></span><br><span class="line"><span class="keyword">const</span> floats = <span class="title class_">Float32Array</span>.<span class="title function_">of</span>(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>); </span><br><span class="line"><span class="title function_">alert</span>(floats.<span class="property">length</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(floats.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 12 </span></span><br><span class="line"><span class="title function_">alert</span>(floats[<span class="number">2</span>]); <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure></div>
<p>3、下溢和上溢：定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长度为 2 的有符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个二补数形式的有符号整数</span></span><br><span class="line"><span class="comment">// 范围是-128（-1 * 2^7）~127（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 长度为 2 的无符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个无符号整数</span></span><br><span class="line"><span class="comment">// 范围是 0~255（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 上溢的位不会影响相邻索引</span></span><br><span class="line"><span class="comment">// 索引只取最低有效位上的 8 位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>; <span class="comment">// 0x100 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 0] </span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>; <span class="comment">// 0x1FF </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 255] </span></span><br><span class="line"><span class="comment">// 下溢的位会被转换为其无符号的等价值</span></span><br><span class="line"><span class="comment">// 0xFF 是以二补数形式表示的-1（截取到 8 位）, </span></span><br><span class="line"><span class="comment">// 但 255 是一个无符号整数</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = -<span class="number">1</span> <span class="comment">// 0xFF (truncated to 8 bits) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 255] </span></span><br><span class="line"><span class="comment">// 上溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0x80 是无符号整数的 128，是二补数形式的-128 </span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>; <span class="comment">// 0x80 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, -128] </span></span><br><span class="line"><span class="comment">// 下溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0xFF 是无符号整数的 255，是二补数形式的-1 </span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>; <span class="comment">// 0xFF </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, -1]</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-4 日报 Day25</title>
    <url>/undefined/2024-12-4/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>真正困住你的不是困难本身，而是你对自己的负面暗示。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P81-82 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、函数：ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。函数的基本语法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, ..., argN</span>) &#123; </span><br><span class="line"> statements </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>return 语句也可以不带返回值。这时候，函数会立即停止执行并返回 undefined。这种用法最常用于提前终止函数执行，并不是为了返回值。比如在下面的例子中，console.log 不会执行：<br>function sayHi(name, message) {<br> return;<br> console.log(“Hello “ + name + “, “ + message); &#x2F;&#x2F; 不会执行<br>}<br>2、总结：ECMAScript包含所有基本语法、操作符、数据类型和对象<br> ECMAScript 中的基本数据类型包括 Undefined、Null、Boolean、Number、String 和 Symbol。<br> 与其他语言不同，ECMAScript 不区分整数和浮点值，只有 Number 一种数值数据类型。<br> Object 是一种复杂数据类型，它是这门语言中所有对象的基类。<br> 严格模式为这门语言中某些容易出错的部分施加了限制。<br> ECMAScript 提供了 C 语言和类 C 语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。<br> 这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如 if 语句、for 语句和 switch语句等。<br>ECMAScript 中的函数与其他语言中的函数不一样。<br> 不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。<br> 不指定返回值的函数实际上会返回特殊值 undefined。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-5 日报 Day26</title>
    <url>/undefined/2024-12-5/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>只有努力多一点，人生的遗憾才会少一点。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P83-86 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、原始值和引用值：ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值就是简单的数据，而引用值则是由多个值构成的对象。6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（by  value）访问的，因为我们操作的就是存储在变量中的实际值。<br>引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。<br>2、注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：<br>let name1 &#x3D; “Nicholas”;<br>let name2 &#x3D; new String(“Matt”);<br>name1.age &#x3D; 27;<br>name2.age &#x3D; 26;<br>console.log(name1.age); &#x2F;&#x2F; undefined<br>console.log(name2.age); &#x2F;&#x2F; 26<br>console.log(typeof name1); &#x2F;&#x2F; string<br>console.log(typeof name2); &#x2F;&#x2F; object<br>3、原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。<br>let num1 &#x3D; 5;<br>let num2 &#x3D; num1;<br>这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。<br>4、在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际<br>上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：<br>let obj1 &#x3D; new Object();<br>let obj2 &#x3D; obj1;<br>obj1.name &#x3D; “Nicholas”;<br>console.log(obj2.name); &#x2F;&#x2F; “Nicholas”<br>5、ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。变量有按值和按引用访问，而传参则只有按值传递。<br>注意 ECMAScript 中函数的参数就是局部变量。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-8 日报 Day29</title>
    <url>/undefined/2024-12-8/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>勇敢的人不是不落泪，而是含着泪继续前行。</p>

    </div>
  </div>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划是一种基于分治法与递归思想结合的优化方法。其主要核心思想就是将原问题分解为若干个子问题，然后在子问题上求解，将子问题的解组合起来，从而得到原问题的解。动态规划的核心思想是<strong>最优子结构</strong>，即问题的最优解可以通过子问题的最优解来求解。</p>
<p>以旅行商问题(TSP)为例:<br>首先 问题描述如下：给定 n 个城市，旅行商需要从某个起点城市出发，访问每个城市一次，最后返回起点，且总路径长度最短。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-01 日报 Day53</title>
    <url>/undefined/2025-01-01/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>接纳自己的不完美、肯定和认可自己，是我们这一生重要的课题。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P162-167 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Map: 在 JavaScript 中实现“键&#x2F;值”式存储可以使用 Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。Map 是一种新的集合类型，为这门语言带来了真正的键&#x2F;值存储机制。Map 的大多数特性都可以通过 Object 类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。<br>基本API：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 Map 构造函数可以创建一个空映射：</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">// 如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：</span></span><br><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(m1.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>(&#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>]; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>]; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(m2.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>([[]]); </span><br><span class="line"><span class="title function_">alert</span>(m3.<span class="title function_">has</span>(<span class="literal">undefined</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m3.<span class="title function_">get</span>(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>初始化之后，可以使用 set()方法再添加键&#x2F;值对。另外，可以使用 get()和 has()进行查询，可以通过 size 属性获取映射中的键&#x2F;值对的数量，还可以使用 delete()和 clear()删除值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// undefined </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 0 </span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 2 </span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&quot;firstName&quot;</span>); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">m.<span class="title function_">clear</span>(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为键。Map 内部使用 SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与 Object 类似，映射的值是没有限制的。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="title class_">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">m.<span class="title function_">set</span>(functionKey, <span class="string">&quot;functionValue&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(symbolKey, <span class="string">&quot;symbolValue&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(objectKey, <span class="string">&quot;objectValue&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(functionKey)); <span class="comment">// functionValue </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(symbolKey)); <span class="comment">// symbolValue </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(objectKey)); <span class="comment">// objectValue </span></span><br><span class="line"><span class="comment">// SameValueZero 比较意味着独立实例不冲突</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;, </span><br><span class="line"> objVal = &#123;&#125;, </span><br><span class="line"> arrKey = [], </span><br><span class="line"> arrVal = []; </span><br><span class="line">m.<span class="title function_">set</span>(objKey, objVal); </span><br><span class="line">m.<span class="title function_">set</span>(arrKey, arrVal); </span><br><span class="line">objKey.<span class="property">foo</span> = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line">objVal.<span class="property">bar</span> = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrKey.<span class="title function_">push</span>(<span class="string">&quot;foo&quot;</span>); </span><br><span class="line">arrVal.<span class="title function_">push</span>(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(objKey)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(arrKey)); <span class="comment">// [&quot;bar&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>SameValueZero 比较也可能导致意想不到的冲突：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN </span></span><br><span class="line"> b = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN </span></span><br><span class="line"> pz = +<span class="number">0</span>, </span><br><span class="line"> nz = -<span class="number">0</span>;</span><br><span class="line"> <span class="title function_">alert</span>(a === b); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(pz === nz); <span class="comment">// true </span></span><br><span class="line">m.<span class="title function_">set</span>(a, <span class="string">&quot;foo&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(pz, <span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(b)); <span class="comment">// foo </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(nz)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure></div>
<p>2、与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。<br>映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过 entries()方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">entries</span> === m[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br></pre></td></tr></table></figure></div>
<p>因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure></div>
<p>如果不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, key</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// key1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// key2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// key3 -&gt; val3</span></span><br></pre></td></tr></table></figure></div>
<p>keys()和 values()分别返回以插入顺序生成键和值的迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// key1 </span></span><br><span class="line"><span class="comment">// key2 </span></span><br><span class="line"><span class="comment">// key3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value1 </span></span><br><span class="line"><span class="comment">// value2 </span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure></div>
<p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> key = <span class="string">&quot;newKey&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(key); <span class="comment">// newKey </span></span><br><span class="line"> <span class="title function_">alert</span>(m1.<span class="title function_">get</span>(<span class="string">&quot;key1&quot;</span>)); <span class="comment">// val1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [keyObj, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> key.<span class="property">id</span> = <span class="string">&quot;newKey&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(key); <span class="comment">// &#123;id: &quot;newKey&quot;&#125; </span></span><br><span class="line"> <span class="title function_">alert</span>(m.<span class="title function_">get</span>(keyObj)); <span class="comment">// val1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">alert</span>(keyObj); <span class="comment">// &#123;id: &quot;newKey&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-6 日报 Day27</title>
    <url>/undefined/2024-12-6/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>失望和希望，常常在同一条路上朝你走来。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P87-94 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof 返回”object”，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>; </span><br><span class="line"><span class="keyword">let</span> u; </span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s); <span class="comment">// string </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> i); <span class="comment">// number </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b); <span class="comment">// boolean </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> u); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> n); <span class="comment">// object </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br></pre></td></tr></table></figure></div>
<p>typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下：<br>result &#x3D; variable instanceof constructor<br>如果变量是给定引用类型（由其原型链决定，将在第 8 章详细介绍）的实例，则 instanceof 操作符返回 true。来看下面的例子：<br>console.log(person instanceof Object); &#x2F;&#x2F; 变量 person 是 Object 吗？<br>console.log(colors instanceof Array); &#x2F;&#x2F; 变量 colors 是 Array 吗？<br>console.log(pattern instanceof RegExp); &#x2F;&#x2F; 变量 pattern 是 RegExp 吗？<br>按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象<br>注意 typeof 操作符在用于检测函数时也会返回”function”。当在 Safari（直到 Safari 5）和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回”function”。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在typeof 检测时返回”function”。因为上述浏览器中的正则表达式实现了这个方法，所以 typeof 对正则表达式也返回”function”。在 IE 和 Firefox 中，typeof 对正则表达式返回”object”。<br>2、变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。<br>全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象（第 12 章会详细介绍），因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。<br>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。<br>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。<br>3、执行上下文主要有全局上下文和函数上下文两种（eval（）调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：<br> try&#x2F;catch 语句的 catch 块<br> with 语句<br>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildUrl</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>; </span><br><span class="line"> <span class="title function_">with</span>(<span class="params">location</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> url = href + qs; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> url; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为函数上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块级作用域（稍后介绍），所以在 with 块之外没有定义。</p>
<p>注意 IE 的实现在 IE8 之前是有偏差的，即它们会将 catch 语句中捕获的错误添加到执行上下文的变量对象上，而不是 catch 语句的变量对象上，导致在 catch 块外部都可以访问到错误。IE9 纠正了这个问题。<br>4、在使用var作为函数作用域声明时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">var</span> sum = num1 + num2; </span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 报错：sum在这里不是有效变量</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，sum 是 add()函数的局部变量，只能在函数内部访问。如果在函数外部访问 sum，就会导致错误。这是因为 sum 是在函数上下文中定义的，而不是在全局上下文中定义的。如果在函数内部没有使用 var 声明 sum，那么 sum 就会被自动添加到全局上下文中，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> sum = num1 + num2; </span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，sum 是全局变量，因为它是在函数内部而没有使用 var 声明的。这种情况下，sum 会被添加到全局上下文中，因此在函数外部也可以访问到它。这种行为在严格模式下会导致错误，因为在严格模式下不能给未声明的变量赋值。<br>var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫做变量提升（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是Reference Error：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// undefined </span></span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>5、let的作用域是块级的，其由最近的一对包含花括号{}界定。换句话说，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferenceError: c is not defined</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure></div>
<p>let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; <span class="comment">// SyntaxError: Identifier &#x27;b&#x27; has already been declared</span></span><br></pre></td></tr></table></figure></div>
<p>let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。来看下面两个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 10 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// ReferenceError: j 没有定义</span></span><br></pre></td></tr></table></figure></div>
<p>严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提升跟 var是不一样的。</p>
<p>这是一个很容易产生误解但非常关键的 JavaScript 知识点，我们来详细讲讲：</p>
<p>⸻</p>
<p>🌟 为什么说 let 会被“提升”，但不能用？</p>
<p>✅ 提升的定义</p>
<p>“变量提升（Hoisting）” 是指：</p>
<pre><code>在 JavaScript 的编译阶段，变量的声明会被“提前”到当前作用域的顶部。
</code></pre>
<p>所以：let 声明的变量，其实也被提升了！<br>    •	但不同于 var 被提升后初始化为 undefined，<br>    •	let（和 const）在提升后不会立刻初始化，<br>    •	而是在真正的声明语句执行前处于“暂时性死区”（TDZ）中，<br>    •	只要在 TDZ 里访问这个变量，就会报错！</p>
<p>⸻</p>
<p>🧠 什么是“暂时性死区（TDZ）”？</p>
<p>TDZ 是从变量绑定开始，到代码执行到声明语句的那一刻之间的这段时间。</p>
<p>在这段时间内，访问变量会抛出 ReferenceError，因为它还没有被初始化。</p>
<p>示例一：</p>
<p>console.log(a); &#x2F;&#x2F; ❌ ReferenceError: Cannot access ‘a’ before initialization<br>let a &#x3D; 10;</p>
<p>尽管 a 被“提升”了，但在 let a &#x3D; 10 执行之前，你就是不能访问它！</p>
<p>⸻</p>
<p>🔁 和 var 的区别</p>
<p>console.log(b); &#x2F;&#x2F; ✅ undefined（不会报错）<br>var b &#x3D; 20;</p>
<p>var 的声明也被提升了，并且提前赋值为 undefined，所以访问不会报错。</p>
<p>⸻</p>
<p>✅ 小总结：</p>
<p>特性	var	let &#x2F; const<br>是否提升	是	是<br>提升后是否初始化	初始化为 undefined	不初始化，进入 TDZ<br>提升后能否访问	能（值为 undefined）	不能，访问会报 ReferenceError<br>是否有暂时性死区（TDZ）	❌ 没有	✅ 有，直到真正的声明位置才可用<br>6、除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 3 </span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> 除了要遵循以上规则，其他方面与 <span class="keyword">let</span> 声明是一样的：</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> a = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a 没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> b = <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: b 没有定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> c = <span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferenceError: c 没有定义</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">const</span> d = <span class="number">3</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// ReferenceError: d 没有定义</span></span><br></pre></td></tr></table></figure></div>
<p>const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;; </span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;; </span><br><span class="line">o2.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="property">name</span>); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;); </span><br><span class="line">o3.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。<br>7、标识符查找：当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-7 日报 Day28</title>
    <url>/undefined/2024-12-7/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>如果你不提前倒下，没有任何人可以打败你。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P95-98 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、垃圾回收机制：JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 C 和 C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。<br>我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。<br>2、标记清理：<br>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。<br>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。<br>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。<br>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。<br>3、引用计数：<br>另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则这个值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收程序下次运行时，它就会释放那些引用次数为 0 的值所占用的内存。<br>引用计数策略的一个问题是循环引用。循环引用指的是对象 A 持有一个指向对象 B 的引用，而对象 B 又持有一个指向对象 A 的引用。在这种情况下，这两个对象的引用次数永远不会是 0，因为它们互相引用着。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">problem</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  objectA.<span class="property">someOtherObject</span> = objectB;</span><br><span class="line">  objectB.<span class="property">anotherObject</span> = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种情况下，引用计数策略就会导致内存泄漏。在 IE8 及更早版本的 IE 中，并非所有对象都是原生 JavaScript 对象。BOM 和 DOM 中的对象是 C++实现的组件对象模型（COM，Component Object Model）对象，而 COM 对象使用引用计数实现垃圾回收。因此，即使这些版本 IE 的 JavaScript 引擎使用标记清理，JavaScript 存取的 COM 对象依旧使用引用计数。换句话说，只要涉及 COM 对象，就无法避开循环引用问题。下面这个简单的例子展示了涉及 COM对象的循环引用问题：<br>let element &#x3D; document.getElementById(“some_element”);<br>let myObject &#x3D; new Object();<br>myObject.element &#x3D; element;<br>element.someObject &#x3D; myObject;<br>这个例子在一个 DOM 对象（element）和一个原生 JavaScript 对象（myObject）之间制造了循环引用。myObject 变量有一个名为 element 的属性指向 DOM 对象 element，而 element 对象有一个someObject 属性指回 myObject 对象。由于存在循环引用，因此 DOM 元素的内存永远不会被回收，即使它已经被从页面上删除了也是如此。为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：<br>myObject.element &#x3D; null;<br>element.someObject &#x3D; null;<br>把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。为了补救这一点，IE9 把 BOM 和 DOM 对象都改成了 JavaScript 对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。<br>4、性能问题：<br>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。<br>现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，根据 V8 团队 2016 年的一篇博文的说法：“在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”</p>
<p>警告 在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 IE 中，window.CollectGarbage()方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾回收程序。<br>5、内存管理：将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，<br>如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> localPerson.<span class="property">name</span> = name; </span><br><span class="line"> <span class="keyword">return</span> localPerson; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> globalPerson = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>); </span><br><span class="line"><span class="comment">// 解除 globalPerson 对值的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>
<p>1、通过 const 和 let 声明提升性能<br>ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 const和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。<br>2、根据 JavaScript 所在的运行环境，有时候需要根据浏览器使用的 JavaScript 引擎来采取不同的性能优化策略。<br>V8 在将解释后的 JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很<br>重要。<br>运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。比如下面的代码：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br></pre></td></tr></table></figure></div>
<p>V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：<br>a2.author &#x3D; ‘Jake’;<br>此时两个 Article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。当然，解决方案就是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性，如下所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">opt_author</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">author</span> = opt_author; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>这样，两个实例基本上就一样了（不考虑 hasOwnProperty 的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过要记住，使用 delete 关键字会导致生成相同的隐藏类片段。看一下这个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">author</span> = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">delete</span> a1.<span class="property">author</span>;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-02 日报 Day54</title>
    <url>/undefined/2025-01-02/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>好书也许不能立马带给你想要的成功，但它们一定能让你成为更好的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P168-172 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、选择Object还是Map: 对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p>
<ul>
<li>内存占用: Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键&#x2F;值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键&#x2F;值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键&#x2F;值对</li>
<li>插入性能: 向 Object 和 Map 中插入新键&#x2F;值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键&#x2F;值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</li>
<li>查找速度: 与插入不同，从大型 Object 和 Map 中查找键&#x2F;值对的性能差异极小，但如果只包含少量键&#x2F;值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来说是不可能的。对这两个类型而言，查找速度不会随着键&#x2F;值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。</li>
<li>删除性能: 使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。<br>2、WeakMap: ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键&#x2F;值对存储机制。WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。<br>基本API:<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 WeakMap 构造函数可以创建一个空弱映射：</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="comment">// 弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。</span></span><br><span class="line"><span class="comment">// 如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中：</span></span><br><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line"> key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 使用嵌套数组初始化弱映射</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [key2, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key1)); <span class="comment">// val1 </span></span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key2)); <span class="comment">// val2 </span></span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key3)); <span class="comment">// val3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;BADKEY&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key </span></span><br><span class="line"><span class="keyword">typeof</span> wm2; </span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined </span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作键</span></span><br><span class="line"><span class="keyword">const</span> stringKey = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;key1&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> wm3 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> stringKey, <span class="string">&quot;val1&quot;</span> </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(wm3.<span class="title function_">get</span>(stringKey)); <span class="comment">// &quot;val1&quot;</span></span><br></pre></td></tr></table></figure></div>
初始化之后可以使用 set()再添加键&#x2F;值对，可以使用 get()和 has()查询，还可以使用 delete()删除：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;; </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// undefined </span></span><br><span class="line">wm.<span class="title function_">set</span>(key1, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(key2, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// Matt </span></span><br><span class="line">wm.<span class="title function_">delete</span>(key1); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
set()方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line"> key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>().<span class="title function_">set</span>(key1, <span class="string">&quot;val1&quot;</span>);</span><br><span class="line">wm.<span class="title function_">set</span>(key2, <span class="string">&quot;val2&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(key3, <span class="string">&quot;val3&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// val1 </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key2)); <span class="comment">// val2 </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key3)); <span class="comment">// val3</span></span><br></pre></td></tr></table></figure></div>
3、弱键: WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键&#x2F;值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。<br>来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line">wm.<span class="title function_">set</span>(&#123;&#125;, <span class="string">&quot;val&quot;</span>);</span><br></pre></td></tr></table></figure></div>
set()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键&#x2F;值对就从弱映射中消失了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键&#x2F;值被破坏以后，值本身也会成为垃圾回收的目标。<br>再看一个稍微不同的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> container = &#123; </span><br><span class="line"> <span class="attr">key</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">wm.<span class="title function_">set</span>(container.<span class="property">key</span>, <span class="string">&quot;val&quot;</span>); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) &#123; </span><br><span class="line"> container.<span class="property">key</span> = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键&#x2F;值对清理掉。<br>不可迭代键: 因为 WeakMap 中的键&#x2F;值对任何时候都可能被销毁，所以没必要提供迭代其键&#x2F;值对的能力。当然，也用不着像 clear()这样一次性销毁所有键&#x2F;值的方法。WeakMap 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问 WeakMap 实例，也没办法看到其中的内容。<br>WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了<br>4、弱映射的应用:</li>
<li>私有变量: 弱映射造就了在 JavaScript 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。下面是一个示例实现：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">idProperty</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setId</span>(id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">setPrivate</span>(<span class="params">property, value</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> privateMembers = wm.<span class="title function_">get</span>(<span class="variable language_">this</span>) || &#123;&#125;; </span><br><span class="line"> privateMembers[property] = value; </span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, privateMembers); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">getPrivate</span>(<span class="params">property</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>)[property]; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">setId</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>, id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">getId</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 123 </span></span><br><span class="line">user.<span class="title function_">setId</span>(<span class="number">456</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 456 </span></span><br><span class="line"><span class="comment">// 并不是真正私有的</span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(user)[user.<span class="property">idProperty</span>]); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure></div>
慧眼独具的读者会发现，对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以取得“私有”变量了。为了避免这种访问，可以用一个闭包把 WeakMap 包装起来，这样就可以把弱映射与外界完全隔离开了：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = (<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">idProperty</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setId</span>(id); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="title function_">setPrivate</span>(<span class="params">property, value</span>) &#123; </span><br><span class="line">        <span class="keyword">const</span> privateMembers = wm.<span class="title function_">get</span>(<span class="variable language_">this</span>) || &#123;&#125;; </span><br><span class="line">        privateMembers[property] = value; </span><br><span class="line">        wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, privateMembers); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getPrivate</span>(<span class="params">property</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>)[property]; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="title function_">setId</span>(<span class="params">id</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>, id); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="title function_">getId</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">User</span>; </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 123 </span></span><br><span class="line">user.<span class="title function_">setId</span>(<span class="number">456</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure></div>
这样，拿不到弱映射中的健，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但整个代码也完全陷入了 ES6 之前的闭包私有变量模式。</li>
<li>DOM节点元数据: 因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中使用了常规的 Map：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></div>
假设在上面的代码执行后，页面被 JavaScript 改变了，原来的登录按钮从 DOM 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的 DOM 节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。<br>如果这里使用的是弱映射，如以下代码所示，那么当节点从 DOM 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>); </span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.<span class="title function_">set</span>(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-9 日报 Day30</title>
    <url>/undefined/2024-12-9/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每次归程，都是为了更好出发;<br>每次停歇，都是为了积攒力量。</p>

    </div>
  </div>

<h3 id="近况描述"><a href="#近况描述" class="headerlink" title="近况描述"></a>近况描述</h3><p>挺更了将近三个礼拜，最近发生了很多事情，也是人生的一个低谷和迷茫期，但是我相信，这一切都会过去，我也要从中吸取教训、走出来变得更加强大。Just keep going on.</p>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P89-92
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>链表存储有序的元素集合，其存放的是当前元素和下一个元素的引用。链表的好处是在添加和移除元素的时候不需要移动其他元素。其缺点是访问元素时需要从头开始迭代链表直到找到所需的元素。</p>
<ul>
<li>简单链表实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">append</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head === <span class="literal">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">                current = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current.<span class="property">next</span> = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">position, element</span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length)&#123;</span><br><span class="line">            <span class="keyword">let</span> current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">                head = current.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.<span class="property">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previous.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">element</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getHead</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="VPN-Virtual-Private-Network"><a href="#VPN-Virtual-Private-Network" class="headerlink" title="VPN(Virtual Private Network)"></a>VPN(Virtual Private Network)</h3><p>VPN是一种通过公共网络建立私人网络的技术，通过加密通道将用户的数据传输到VPN服务器，再由VPN服务器转发到目标网站，从而实现用户的上网隐私和安全。</p>
<ul>
<li>为什么需要VPN?<ul>
<li>GFW(防火长城)：国内的网络审查系统，会屏蔽一些国外的网站，使用VPN可以突破GFW，访问国外网站。</li>
</ul>
</li>
</ul>
<p>正常没有GFW的情况下，网络包的传输过程是这样的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用户设备 (发起DNS请求) -&gt; 2. 路由器 (转发请求) -&gt; 3. ISP DNS服务器 (缓存或递归解析)</span><br><span class="line">     ↓</span><br><span class="line">4. 用户设备 (接收IP地址) -&gt; 5. 路由器 (发送数据包) -&gt; 6. ISP网络 -&gt; 7. 国际/区域骨干网</span><br><span class="line">     ↓</span><br><span class="line">8. 目标服务器网络 -&gt; 9. 目标服务器 (处理请求并返回数据)</span><br></pre></td></tr></table></figure></div>
<p>有了GFW之后，网络包的传输过程变成了这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用户设备 (发起DNS请求) -&gt; 2. 路由器 (转发请求) -&gt; 3. ISP DNS服务器 (缓存或递归解析，可能受到GFW干预)</span><br><span class="line">     ↓</span><br><span class="line">   - GFW可能拦截DNS请求，返回伪造的IP地址（DNS污染）。</span><br><span class="line">     ↓</span><br><span class="line">4. 用户设备 (接收IP地址，可能是错误的伪造地址) -&gt; 5. 路由器 (发送数据包) -&gt; 6. ISP网络</span><br><span class="line">     ↓</span><br><span class="line">   - GFW监控传输的数据包，发现敏感关键词时进行干预。（过滤关键字）。</span><br><span class="line">   - GFW对端口进行封锁，导致用户无法访问一些网站。（端口阻断）。</span><br><span class="line">   - GFW对IP地址进行封锁，导致用户无法访问一些网站。（IP地址封锁）。</span><br><span class="line">     ↓</span><br><span class="line">7. 国际/区域骨干网 (若未被阻断，数据包继续传输)</span><br><span class="line">     ↓</span><br><span class="line">   - GFW可能通过深度包检测（DPI）分析数据包内容，发现敏感流量特征时进行干预（丢包、限速、阻断IP等）。</span><br><span class="line">     ↓</span><br><span class="line">8. 目标服务器网络 (若数据包未被拦截，正常到达目标网络) -&gt; 9. 目标服务器 (处理请求并返回数据，回程时可能再次被GFW干预)</span><br></pre></td></tr></table></figure></div>

<p>VPN SSH HTTP代理的原理<br>1、用户设备会先和VPN服务器建立加密通道，使用SSH（Secure Shell）协议创建加密隧道。<br>2、在VPN服务器上使用HTTP代理，将用户的数据包转发到目标服务器。</p>
<p>Shadowsocks SSR v2ray等方式运作原理<br>1、在本地网络上进行加密，发送加密数据经过DNS解析后，到达VPN服务器。<br>2、VPN服务器解密数据，将数据包转发到目标服务器。<br>3、目标服务器返回数据，VPN服务器再次加密数据，发送到用户设备。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-05 日报 Day57</title>
    <url>/undefined/2025-01-05/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每个人都想有所成就，却不知信手拈来的从容都是厚积薄发的沉淀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P180-182 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、因为 WeakSet 中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然，也用不着像 clear()这样一次性销毁所有值的方法。WeakSet 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱集合中取得值。即便代码可以访问 WeakSet 实例，也没办法看到其中的内容。WeakSet 之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。<br>相比于 WeakMap 实例，WeakSet 实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。来看下面的例子，这里使用了一个普通 Set：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.<span class="title function_">add</span>(loginButton);</span><br></pre></td></tr></table></figure></div>
<p>这样，通过查询元素在不在 disabledElements 中，就可以知道它是不是被禁用了。不过，假如元素从 DOM 树中被删除了，它的引用却仍然保存在 Set 中，因此垃圾回收程序也不能回收它。为了让垃圾回收程序回收元素的内存，可以在这里使用 WeakSet：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>); </span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.<span class="title function_">add</span>(loginButton);</span><br></pre></td></tr></table></figure></div>
<p>这样，只要 WeakSet 中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。<br>2、ECMAScript 6 新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。如本章前面所示，有 4 种原生集合类型定义了默认迭代器：<br> Array<br> 所有定型数组<br> Map<br> Set</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableThings = [ </span><br><span class="line"> <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>), </span><br><span class="line"> typedArr = <span class="title class_">Int16Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">4</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">9</span>, <span class="number">10</span>]) </span><br><span class="line">]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterableThing <span class="keyword">of</span> iterableThings) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterableThing) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// [5, 6] </span></span><br><span class="line"><span class="comment">// [7, 8] </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div>
<p>这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1); <span class="comment">// [1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1 === arr2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：</span></span><br><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]); </span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(map1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125; </span></span><br><span class="line"><span class="comment">// 当然，也可以构建数组的部分元素：</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">0</span>, ...arr1, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [0, 1, 2, 3, 4, 5] </span></span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象引用：</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [&#123;&#125;]; </span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1]; </span><br><span class="line">arr1[<span class="number">0</span>].<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2[<span class="number">0</span>]); <span class="comment">// &#123; foo: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 上面的这些类型都支持多种构建方法，比如 Array.of()和 Array.from()静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">// 把数组复制到定型数组</span></span><br><span class="line"><span class="keyword">let</span> typedArr1 = <span class="title class_">Int16Array</span>.<span class="title function_">of</span>(...arr1); </span><br><span class="line"><span class="keyword">let</span> typedArr2 = <span class="title class_">Int16Array</span>.<span class="title function_">from</span>(arr1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArr1); <span class="comment">// Int16Array [1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArr2); <span class="comment">// Int16Array [1, 2, 3] </span></span><br><span class="line"><span class="comment">// 把数组复制到映射</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(arr1.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, <span class="string">&#x27;val&#x27;</span> + x])); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map &#123;1 =&gt; &#x27;val 1&#x27;, 2 =&gt; &#x27;val 2&#x27;, 3 =&gt; &#x27;val 3&#x27;&#125; </span></span><br><span class="line"><span class="comment">// 把数组复制到集合</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(typedArr2); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set &#123;1, 2, 3&#125; </span></span><br><span class="line"><span class="comment">// 把集合复制回数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...set]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></div>
<p>3、小结:<br>JavaScript 中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。<br> 引用类型与传统面向对象编程语言中的类相似，但实现不同。<br> Object 类型是一个基础类型，所有引用类型都从它继承了基本的行为。<br> Array 类型表示一组有序的值，并提供了操作和转换值的能力。<br> 定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。<br> Date 类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。<br> RegExp 类型是 ECMAScript 支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。<br>JavaScript 比较独特的一点是，函数其实是 Function 类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法。<br>因为原始值包装类型的存在，所以 JavaScript 中的原始值可以拥有类似对象的行为。有 3 种原始值包装类型：Boolean、Number 和 String。它们都具有如下特点。<br> 每种包装类型都映射到同名的原始类型。<br> 在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。<br> 涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。<br>JavaScript 还有两个在一开始执行代码时就存在的内置对象：Global 和 Math。其中，Global 对象在大多数 ECMAScript 实现中无法直接访问。不过浏览器将 Global 实现为 window 对象。所有全局变量和函数都是 Global 对象的属性。Math 对象包含辅助完成复杂数学计算的属性和方法。<br>ECMAScript 6 新增了一批引用类型：Map、WeakMap、Set 和 WeakSet。这些类型为组织应用程序数据和简化内存管理提供了新能力。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-06 日报 Day58</title>
    <url>/undefined/2025-01-06/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>生活无关他人，只有你是自己人生的主角，与其取悦别人，不如好好爱自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P183-189 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、在软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。<br>在 JavaScript 中，计数循环就是一种最简单的迭代：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。<br>迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是 JavaScript 中有序集合的最典型例子。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; collection.<span class="property">length</span>; ++index) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(collection[index]); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。由于如下原因，通过这种循环来执行例程并不理想。<br> 迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。<br> 遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。<br>ES5 新增了 Array.prototype.forEach()方法，向通用迭代需求迈进了一步（但仍然不够理想）：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line">collection.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item));</span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure></div>
<p>这个方法解决了单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止。因此这个方法只适用于数组，而且回调结构也比较笨拙。<br>在 ECMAScript 较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其他很多语言都对这个模式提供了完备的支持。JavaScript 在 ECMAScript 6 以后也支持了迭代器模式。<br>2、迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。<br>可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的元素是有限的</span></span><br><span class="line"><span class="comment">// 递增索引可以按序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="comment">// 集合的元素是有限的</span></span><br><span class="line"><span class="comment">// 可以按插入顺序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="number">3</span>).<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></div>
<p>任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）。<br>2、实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力。在 ECMAScript 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。<br>很多内置类型都实现了 Iterable 接口：<br> 字符串<br> 数组<br> 映射<br> 集合<br> arguments 对象<br> NodeList 等 DOM 集合类型<br>检查是否存在默认迭代器属性可以暴露这个工厂函数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;; </span><br><span class="line"><span class="comment">// 这两种类型没有实现迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>).<span class="title function_">set</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> els = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"><span class="comment">// 这些类型都实现了迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="comment">// 调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// StringIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// ArrayIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// MapIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// SetIterator &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：<br> for-of 循环<br> 数组解构<br> 扩展操作符<br> Array.from()<br> 创建集合<br> 创建映射<br> Promise.all()接收由期约组成的可迭代对象<br> Promise.race()接收由期约组成的可迭代对象<br> yield*操作符，在生成器中使用</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="comment">// for-of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> arr) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(el); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// baz </span></span><br><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// foo, bar, baz </span></span><br><span class="line"><span class="comment">// 扩展操作符</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;] </span></span><br><span class="line"><span class="comment">// Array.from() </span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;] </span></span><br><span class="line"><span class="comment">// Set 构造函数</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// Set(3) &#123;&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;&#125; </span></span><br><span class="line"><span class="comment">// Map 构造函数</span></span><br><span class="line"><span class="keyword">let</span> pairs = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">x, i</span>) =&gt;</span> [x, i]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pairs); <span class="comment">// [[&#x27;foo&#x27;, 0], [&#x27;bar&#x27;, 1], [&#x27;baz&#x27;, 2]] </span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(pairs); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// Map(3) &#123; &#x27;foo&#x27;=&gt;0, &#x27;bar&#x27;=&gt;1, &#x27;baz&#x27;=&gt;2 &#125;</span></span><br></pre></td></tr></table></figure></div>
<p>如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> fooArr = <span class="keyword">new</span> <span class="title class_">FooArray</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> fooArr) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(el); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure></div>
<p>3、迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。<br>next()方法返回的迭代器对象 IteratorResult 包含两个属性：done 和 value。done 是一个布尔值，表示是否还可以再次调用 next()取得下一个值；value 包含可迭代对象的下一个值（done 为false），或者 undefined（done 为 true）。done: true 状态称为“耗尽”。可以通过以下简单的数组来演示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter); <span class="comment">// ArrayIterator &#123;&#125; </span></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="keyword">let</span> iter2 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;baz&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure></div>
<p>注意 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类实现了可迭代接口（Iterable） </span></span><br><span class="line"><span class="comment">// 调用默认的迭代器工厂函数会返回</span></span><br><span class="line"><span class="comment">// 一个实现迭代器接口（Iterator）的迭代器对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;foo&#x27;</span> &#125;; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="comment">// 打印出实现了迭代器接口的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// &#123; next: f() &#123;&#125; &#125; </span></span><br><span class="line"><span class="comment">// Array 类型实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用 Array 类型的默认迭代器工厂函数</span></span><br><span class="line"><span class="comment">// 会创建一个 ArrayIterator 的实例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(); </span><br><span class="line"><span class="comment">// 打印出 ArrayIterator 的实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Array Iterator &#123;&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>自定义迭代器: 与 Iterable 接口类似，任何实现 Iterator 接口的对象都可以作为迭代器使用。下面这个例子中的 Counter 类只能被迭代一定的次数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123; </span><br><span class="line"> <span class="comment">// Counter 的实例应该迭代 limit 次</span></span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">1</span>; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &lt;= <span class="variable language_">this</span>.<span class="property">limit</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">count</span>++ &#125;; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>这个类实现了 Iterator 接口，但不理想。这是因为它的每个实例只能被迭代一次：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// (nothing logged)</span></span><br></pre></td></tr></table></figure></div>
<p>为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit; </span><br><span class="line">    &#125; </span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span>, </span><br><span class="line">            limit = <span class="variable language_">this</span>.<span class="property">limit</span>; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (count &lt;= limit) &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">            &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>每个以这种方式创建的迭代器也实现了 Iterable 接口。Symbol.iterator 属性引用的工厂函数会返回相同的迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// f values() &#123; [native code] &#125; </span></span><br><span class="line"><span class="keyword">let</span> iter2 = iter1[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter1 === iter2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 因为每个迭代器也实现了 Iterable 接口，所以它们可以用在任何期待可迭代对象的地方，比如for-of 循环：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item); &#125; </span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iter ) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item); &#125; </span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-03 日报 Day55</title>
    <url>/undefined/2025-01-03/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>往后时光，愿你能扛事、懂翻篇，有静下来的力量，也有向内看的能力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P173-175 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 6 新增的 Set 是一种新集合类型，为这门语言带来集合数据结构。Set 在很多方面都像是加强的 Map，这是因为它们的大多数 API 和行为都是共有的。<br>基本API:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 Set 构造函数可以创建一个空集合：</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="comment">// 如果想在创建的同时初始化实例，可以给 Set 构造函数传入一个可迭代对象，需要包含值数组。可迭代对象中的每个值都会按照迭代顺序插入到新集合实例中：</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="title function_">alert</span>(s1.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>(&#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(s2.<span class="property">size</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>初始化之后，可以使用 add()方法添加值。另外，可以使用 has()进行查询，可以通过 size 属性获取集合中的值的数量，还可以使用 delete()和 clear()删除值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 0 </span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 2 </span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="string">&quot;Matt&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">s.<span class="title function_">clear</span>(); <span class="comment">// 销毁集合实例中的所有值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
<p>与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作（ECMAScript 内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="title class_">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">s.<span class="title function_">add</span>(functionVal); </span><br><span class="line">s.<span class="title function_">add</span>(symbolVal); </span><br><span class="line">s.<span class="title function_">add</span>(objectVal); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(functionVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(symbolVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(objectVal)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// SameValueZero 检查意味着独立的实例不会冲突</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;, </span><br><span class="line"> arrVal = []; </span><br><span class="line">s.<span class="title function_">add</span>(objVal); </span><br><span class="line">s.<span class="title function_">add</span>(arrVal); </span><br><span class="line">objVal.<span class="property">bar</span> = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrVal.<span class="title function_">push</span>(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(objVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(arrVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>add()和 delete()操作是幂等的。delete()返回一个布尔值，表示集合中是否存在要删除的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 集合里有这个值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 集合里没有这个值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>Set 会维护值插入时的顺序，因此支持按顺序迭代。集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">values</span> === s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">keys</span> === s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3</span></span><br></pre></td></tr></table></figure></div>
<p>因为 values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...s];</span><br><span class="line"><span class="title function_">alert</span>(arr); <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>集合的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [&quot;val1&quot;, &quot;val1&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val2&quot;, &quot;val2&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val3&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>如果不使用迭代器，而是使用回调方式，则可以调用集合的 forEach()方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// val1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// val2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure></div>
<p>修改集合中值的属性不会影响其作为集合值的身份：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>]); </span><br><span class="line"><span class="comment">// 字符串原始值作为值不会被修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.<span class="title function_">values</span>()) &#123;</span><br><span class="line">     value = <span class="string">&quot;newVal&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(value); <span class="comment">// newVal </span></span><br><span class="line"> <span class="title function_">alert</span>(s1.<span class="title function_">has</span>(<span class="string">&quot;val1&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> valObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([valObj]); </span><br><span class="line"><span class="comment">// 修改值对象的属性，但对象仍然存在于集合中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s2.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> value.<span class="property">id</span> = <span class="string">&quot;newVal&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(value); <span class="comment">// &#123;id: &quot;newVal&quot;&#125; </span></span><br><span class="line"> <span class="title function_">alert</span>(s2.<span class="title function_">has</span>(valObj)); <span class="comment">// true </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">alert</span>(valObj); <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-04 日报 Day56</title>
    <url>/undefined/2025-01-04/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每个人都想有所成就，却不知信手拈来的从容都是厚积薄发的沉淀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P176-179 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、从各方面来看，Set 跟 Map 都很相似，只是 API 稍有调整。唯一需要强调的就是集合的 API 对自身的简单操作。很多开发者都喜欢使用 Set 操作，但需要手动实现：或者是子类化 Set，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。<br> 某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。<br> Set 保留插入顺序，所有方法返回的集合必须保证顺序。<br> 尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。<br> 不要修改已有的集合实例。union(a, b)或 a.union(b)应该返回包含结果的新集合实例。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Set</span> &#123;</span><br><span class="line">  <span class="title function_">union</span>(<span class="params">...sets</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">union</span>(<span class="variable language_">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">intersection</span>(<span class="params">...sets</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">intersection</span>(<span class="variable language_">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">difference</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">difference</span>(<span class="variable language_">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">symmetricDifference</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">symmetricDifference</span>(<span class="variable language_">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">cartesianProduct</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">cartesianProduct</span>(<span class="variable language_">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">powerSet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">powerSet</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的并集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">union</span>(<span class="params">a, ...bSets</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的交集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">intersection</span>(<span class="params">a, ...bSets</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b.<span class="title function_">has</span>(aValue)) &#123;</span><br><span class="line">          intersectionSet.<span class="title function_">delete</span>(aValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">difference</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.<span class="title function_">has</span>(bValue)) &#123;</span><br><span class="line">        differenceSet.<span class="title function_">delete</span>(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">symmetricDifference</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">union</span>(b).<span class="title function_">difference</span>(a.<span class="title function_">intersection</span>(b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line">  <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">cartesianProduct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> <span class="title class_">XSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        cartesianProductSet.<span class="title function_">add</span>([aValue, bValue]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartesianProductSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">powerSet</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> powerSet = <span class="keyword">new</span> <span class="title class_">XSet</span>().<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">XSet</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> set <span class="keyword">of</span> <span class="keyword">new</span> <span class="title class_">XSet</span>(powerSet)) &#123;</span><br><span class="line">        powerSet.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">XSet</span>(set).<span class="title function_">add</span>(aValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> powerSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2、WeakSet: ECMAScript 6 新增的“弱集合”（WeakSet）是一种新的集合类型，为这门语言带来了集合数据结构。WeakSet 是 Set 的“兄弟”类型，其 API 也是 Set 的子集。WeakSet 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱集合”中值的方式。<br>弱集合中的值只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置值会抛出 TypeError。</p>
<p>基本API:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 WeakSet 构造函数可以创建一个空集合：</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"><span class="comment">// 如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中：</span></span><br><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line"> val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line"> val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 使用数组初始化弱集合</span></span><br><span class="line"><span class="keyword">const</span> ws1 = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([val1, val2, val3]); </span><br><span class="line"><span class="title function_">alert</span>(ws1.<span class="title function_">has</span>(val1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws1.<span class="title function_">has</span>(val2)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws1.<span class="title function_">has</span>(val3)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([val1, <span class="string">&quot;BADVAL&quot;</span>, val3]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet </span></span><br><span class="line"><span class="keyword">typeof</span> ws2; </span><br><span class="line"><span class="comment">// ReferenceError: ws2 is not defined </span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作值</span></span><br><span class="line"><span class="keyword">const</span> stringVal = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;val1&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> ws3 = <span class="keyword">new</span> <span class="title class_">WeakSet</span>([stringVal]); </span><br><span class="line"><span class="title function_">alert</span>(ws3.<span class="title function_">has</span>(stringVal)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;; </span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// false </span></span><br><span class="line">ws.<span class="title function_">add</span>(val1)</span><br><span class="line"> .<span class="title function_">add</span>(val2); </span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val2)); <span class="comment">// true </span></span><br><span class="line">ws.<span class="title function_">delete</span>(val1); <span class="comment">// 只删除这一个值</span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val2)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// add()方法返回弱集合实例，因此可以把多个操作连缀起来，包括初始化声明：</span></span><br><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line"> val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>().<span class="title function_">add</span>(val1); </span><br><span class="line">ws.<span class="title function_">add</span>(val2) </span><br><span class="line"> .<span class="title function_">add</span>(val3); </span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val2)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(ws.<span class="title function_">has</span>(val3)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>3、弱值: WeakSet 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收。<br>来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line">ws.<span class="title function_">add</span>(&#123;&#125;);</span><br></pre></td></tr></table></figure></div>
<p>add()方法初始化了一个新对象，并将它用作一个值。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象值就会被当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为一个空集合。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">再看一个稍微不同的例子：</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(); </span><br><span class="line"><span class="keyword">const</span> container = &#123; </span><br><span class="line"> <span class="attr">val</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">ws.<span class="title function_">add</span>(container.<span class="property">val</span>); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) &#123; </span><br><span class="line"> container.<span class="property">val</span> = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这一次，container 对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁值对象的最后一个引用，垃圾回收程序就可以把这个值清理掉。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-07 日报 Day59</title>
    <url>/undefined/2025-01-07/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>多学一项技能，生活就多开一道出口；多长一点本领，人生就有更多选择权。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P190-193 第七章：迭代器与生成器</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、提前终止迭代器: 可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：<br> for-of 循环通过 break、continue、return 或 throw 提前退出；<br> 解构操作并未消费所有值。<br>return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。<br>因为这个返回值只会用在生成器的上下文中，所以本章后面再讨论这种情况。如下面的代码所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用return()方法。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>, </span><br><span class="line">    limit = <span class="variable language_">this</span>.<span class="property">limit</span>; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        <span class="title function_">next</span>(<span class="params"></span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (count &lt;= limit) &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="keyword">return</span>() &#123; </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting early&#x27;</span>); </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter1) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// Exiting early </span></span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter2) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;err&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// Exiting early </span></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3; </span><br><span class="line"><span class="comment">// Exiting early</span></span><br></pre></td></tr></table></figure></div>
<p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line"> <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></div>
<p>因为 return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line">iter.<span class="property">return</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting early&#x27;</span>); </span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line"> <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 提前退出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></div>
<p>2、生成器: 生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程。<br>生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="keyword">function</span>* () &#123;&#125; </span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123; </span><br><span class="line"> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line"> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价的生成器函数： </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFnA</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">generatorFnB</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFnC</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="comment">// 等价的生成器方法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line"> *<span class="title function_">generatorFnD</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"> * <span class="title function_">generatorFnE</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意 箭头函数不能用来定义生成器函数。</p>
<p>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">next</span>); <span class="comment">// f next() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure></div>
<p>next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure></div>
<p>value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 生成器函数只会在初次调用 next()方法后开始执行，如下所示：</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line">generatorObject.<span class="title function_">next</span>(); <span class="comment">// foobar</span></span><br><span class="line"><span class="comment">// 生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的：</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorFn); </span><br><span class="line"><span class="comment">// f* generatorFn() &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]);</span><br><span class="line"><span class="comment">// f [Symbol.iterator]() &#123;native code&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()); </span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); </span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g === g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-08 日报 Day60</title>
    <url>/undefined/2025-01-08/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人品是底子，行为是面子，只有底子好，面子来映衬，人生才有更多的可能。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P194-200 第七章：迭代器与生成器</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、通过 yield 中断执行: yield 关键字可以让生成器停止和开始执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="comment">// 通过 yield 关键字退出的生成器函数会处在 done: false 状态；通过 return 关键字退出的生成器函数会处于 done: true 状态。</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: &#x27;baz&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 next()不会影响其他生成器：</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject1 = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="keyword">let</span> generatorObject2 = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject2.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject1.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="comment">// yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的 return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：</span></span><br><span class="line"><span class="comment">// 有效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">validGeneratorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">invalidGeneratorFnA</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">invalidGeneratorFnB</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt; &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">invalidGeneratorFnC</span>(<span class="params"></span>) &#123; </span><br><span class="line"> (<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line"> &#125;)(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>生成器对象作为可迭代对象: 在生成器对象上显式调用 next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">while</span>(n--) &#123; </span><br><span class="line"> <span class="keyword">yield</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure></div></li>
<li>使用 yield 实现输入和输出: yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。这里有个地方不太好理解——第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params">initial</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(initial); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// foo </span></span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;baz&#x27;</span>); <span class="comment">// baz </span></span><br><span class="line">generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;qux&#x27;</span>); <span class="comment">// qux</span></span><br></pre></td></tr></table></figure></div>
yield 关键字可以同时用于输入和输出，如下例所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>(<span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// &#123; done: true, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div>
因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到 yield 关键字时暂停执行并计算出要产生的值：”foo”。下一次调用 next()传入了”bar”，作为交给同一个 yield 的值。然后这个值被确定为本次生成器函数要返回的值。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;;++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> i; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorObject.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></div></li>
<li>产生可迭代对象：可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价的 generatorFn： </span></span><br><span class="line"><span class="comment">// function* generatorFn() &#123; </span></span><br><span class="line"><span class="comment">// for (const x of [1, 2, 3]) &#123; </span></span><br><span class="line"><span class="comment">// yield x; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> generatorObject = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 与生成器函数的星号类似，yield 星号两侧的空格不影响其行为：</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]; </span><br><span class="line"> <span class="keyword">yield</span> *[<span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"> <span class="keyword">yield</span> * [<span class="number">5</span>, <span class="number">6</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFnA</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line"> <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFnA</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFnB</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFnB</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// yield*的值是关联迭代器返回 done: true 时的 value 属性。对于普通迭代器来说，这个值是 undefined：</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>, x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value: 1 </span></span><br><span class="line"><span class="comment">// value: 2 </span></span><br><span class="line"><span class="comment">// value: 3 </span></span><br><span class="line"><span class="comment">// iter value: undefined</span></span><br><span class="line"><span class="comment">// 对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">innerGeneratorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outerGeneratorFn</span>(<span class="params">genObj</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* <span class="title function_">innerGeneratorFn</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">outerGeneratorFn</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;value:&#x27;</span>, x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value: foo </span></span><br><span class="line"><span class="comment">// iter value: bar</span></span><br></pre></td></tr></table></figure></div></li>
<li>使用 yield<em>实现递归算法: yield</em>最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span>* <span class="title function_">nTimes</span>(n - <span class="number">1</span>); </span><br><span class="line"> <span class="keyword">yield</span> n - <span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
使用递归生成器结构和 yield*可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">neighbors</span> = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">connect</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (node !== <span class="variable language_">this</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">neighbors</span>.<span class="title function_">add</span>(node); </span><br><span class="line">    node.<span class="property">neighbors</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomGraph</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">size</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span> = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">Node</span>(i)); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 随机连接节点</span></span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">1</span> / size; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> y <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; threshold) &#123; </span><br><span class="line">                x.<span class="title function_">connect</span>(y); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 这个方法仅用于调试</span></span><br><span class="line"> <span class="title function_">print</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>) &#123; </span><br><span class="line">        <span class="keyword">const</span> ids = [...node.<span class="property">neighbors</span>] </span><br><span class="line">                            .<span class="title function_">map</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n.<span class="property">id</span>) </span><br><span class="line">                            .<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>); </span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;node.id&#125;</span>: <span class="subst">$&#123;ids&#125;</span>`</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">RandomGraph</span>(<span class="number">6</span>); </span><br><span class="line">g.<span class="title function_">print</span>(); </span><br><span class="line"><span class="comment">// 示例输出：</span></span><br><span class="line"><span class="comment">// 0: 2,3,5 </span></span><br><span class="line"><span class="comment">// 1: 2,3,4,5 </span></span><br><span class="line"><span class="comment">// 2: 1,3 </span></span><br><span class="line"><span class="comment">// 3: 0,1,2,4 </span></span><br><span class="line"><span class="comment">// 4: 2,3 </span></span><br><span class="line"><span class="comment">// 5: 0,4</span></span><br></pre></td></tr></table></figure></div>
图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line">    ... </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">connect</span>(<span class="params">node</span>) &#123; </span><br><span class="line">    ... </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomGraph</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">size</span>) &#123; </span><br><span class="line">    ... </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">print</span>(<span class="params"></span>) &#123; </span><br><span class="line">    ... </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">isConnected</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> visitedNodes = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line">    <span class="keyword">function</span>* <span class="title function_">traverse</span>(<span class="params">nodes</span>) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodes) &#123; </span><br><span class="line">            <span class="keyword">if</span> (!visitedNodes.<span class="title function_">has</span>(node)) &#123; </span><br><span class="line">                <span class="keyword">yield</span> node; </span><br><span class="line">                <span class="keyword">yield</span>* <span class="title function_">traverse</span>(node.<span class="property">neighbors</span>); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 取得集合中的第一个节点</span></span><br><span class="line">    <span class="keyword">const</span> firstNode = <span class="variable language_">this</span>.<span class="property">nodes</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]().<span class="title function_">next</span>().<span class="property">value</span>; </span><br><span class="line">    <span class="comment">// 使用递归生成器迭代每个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="title function_">traverse</span>([firstNode])) &#123; </span><br><span class="line">        visitedNodes.<span class="title function_">add</span>(node); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> visitedNodes.<span class="property">size</span> === <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="property">size</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-09 日报 Day61</title>
    <url>/undefined/2025-01-09/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>只有付出比别人更多的努力和功夫，你才能在一次次磨砺中，变得闪闪发光。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P201-204 第七章：迭代器与生成器</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、生成器作为默认迭代器: 因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">values</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">  &#125; </span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line">    <span class="keyword">yield</span> * <span class="variable language_">this</span>.<span class="property">values</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> foo) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>2、提前终止生成器: 与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next()方法，还有一个可选的 return()方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：throw()。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">next</span>); <span class="comment">// f next() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">return</span>); <span class="comment">// f return() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">throw</span>); <span class="comment">// f throw() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>return(): return()方法会强制生成器进入关闭状态。提供给 return()方法的值，就是终止迭代器对象的值：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">    <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">4</span>)); <span class="comment">// &#123; done: true, value: 4 &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure></div>
与迭代器不同，所有生成器对象都有 return()方法，只要通过它进入关闭状态，就无法恢复了。后续调用 next()会显示 done: true 状态，而提供的任何返回值都不会被存储或传播：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">    <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 1 &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">4</span>)); <span class="comment">// &#123; done: true, value: 4 &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="comment">// for-of 循环等内置语言结构会忽略状态为 done: true 的 IteratorObject 内部返回的值。</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">    <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> g) &#123; </span><br><span class="line"> <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123; </span><br><span class="line">    g.<span class="keyword">return</span>(<span class="number">4</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div></li>
<li>throw(): throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">    <span class="keyword">yield</span> x; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125; </span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> g.<span class="keyword">throw</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// foo </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure></div>
不过，假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield，因此在这个例子中会跳过一个值。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> x; </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 1&#125; </span></span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; done: false, value: 3&#125;</span></span><br></pre></td></tr></table></figure></div>
3、小结: ECMAScript 6 正式支持迭代模式并引入了两个新的语言特性：迭代器和生成器。<br>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现 Iterable接口的对象都有一个 Symbol.iterator 属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现 Iterator 接口的对象。<br>迭代器必须通过连续调用 next()方法才能连续取得值，这个方法返回一个 IteratorObject。这个对象包含一个 done 属性和一个 value 属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用 next()方法来消费，也可以通过原生消费者，比如 for-of 循环来自动消费。<br>生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了 Iterable 接口，因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持 yield 关键字，这个关键字能够暂停执行生成器函数。使用 yield 关键字还可以通过 next()方法接收输入和产生输出。在加上星号之后，yield 关键字可以将跟在它后面的可迭代对象序列化为一连串值。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-10 日报 Day62</title>
    <url>/undefined/2025-01-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生是一个不断提升自我的过程，你在哪里付出，就会在哪里收获。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P205-208 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未讨论的原因），可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名&#x2F;值对，值可以是数据或者函数。<br>创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line">person.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line">person.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>2、属性的类型: ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。<br>属性分两种：数据属性和访问器属性。</p>
<ul>
<li>数据属性: 数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4个特性描述它们的行为。<br> [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。<br> [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。<br> [[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。<br> [[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 undefined。<br>要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。比如<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure></div>
此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
因此，虽然可以对同一个属性多次调用 Object.defineProperty()，但在把 configurable 设置为 false 之后就会受限制了。在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。</li>
<li>访问器属性: 访问器属性不包含数据值；它们包含一对 getter 和 setter 函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值。在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有 4 个特性。<br> [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。<br> [[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。<br> [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。<br> [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。<br>访问器属性是不能直接定义的，必须使用 Object.defineProperty()。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员 year_和公共成员 edition </span></span><br><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line"> <span class="attr">year_</span>: <span class="number">2017</span>, </span><br><span class="line"> <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line"> &#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123; </span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">year_</span> = newValue; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line">book.<span class="property">year</span> = <span class="number">2018</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
在这个例子中，对象 book 有两个默认属性：year_和 edition。year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简单地返回 year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改为 2018 会导致 year_变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 undefined，严格模式下会抛出错误。在不支持 Object.defineProperty()的浏览器中没有办法修改[[Configurable]]或[[Enumerable]]。<br>3、定义多个属性: Object.defineProperties()方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123; </span><br><span class="line"> <span class="attr">year_</span>: &#123; </span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">edition</span>: &#123; </span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">year</span>: &#123; </span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>; </span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123; </span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">year_</span> = newValue; </span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
这段代码在 book 对象上定义了两个数据属性 year_和 edition，还有一个访问器属性 year。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的configurable、enumerable 和 writable 特性值都是 false。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-11 日报 Day63</title>
    <url>/undefined/2025-01-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有很多时刻，你惊心动魄，而世界一无所知；你翻山越岭，而大地寂静无声。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P209-212 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、读取属性的特性: 使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、writable 和 value 属性。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">year_</span> = newValue;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">value</span>); <span class="comment">// 2017</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">configurable</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> descriptor.<span class="property">get</span>); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(book, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">value</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">enumerable</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> descriptor.<span class="property">get</span>); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>ECMAScript 2017 新增了 Object.getOwnPropertyDescriptors()静态方法。这个方法实际上会在每个自有属性上调用 Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。对于前面的例子，使用这个静态方法会返回如下对象：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">year_</span> = newValue;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(book));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// edition: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// value: 1,</span></span><br><span class="line"><span class="comment">// writable: false</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// year: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// get: f(),</span></span><br><span class="line"><span class="comment">// set: f(newValue),</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// year_: &#123;</span></span><br><span class="line"><span class="comment">// configurable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// value: 2017,</span></span><br><span class="line"><span class="comment">// writable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>2、合并对象: JavaScript 开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象的属性得到了增强。ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true）和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。<br>以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">&quot;src&quot;</span> &#125;;</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// Object.assign 修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest !== src); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">a</span>: <span class="string">&quot;foo&quot;</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">&quot;bar&quot;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取函数与设置函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Invoked src getter&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 调用 src 的获取方法</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数&quot;foo&quot;</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123; <span class="attr">id</span>: <span class="string">&#x27;dest&#x27;</span> &#125;;</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;src1&#x27;</span>, <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;src2&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// Object.assign 会覆盖重复的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; id: src2, a: foo, b: bar &#125;</span></span><br><span class="line"><span class="comment">// 可以通过目标对象上的设置函数观察到覆盖的过程：</span></span><br><span class="line">dest = &#123;</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;first&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;second&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;third&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; a :&#123;&#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest.<span class="property">a</span> === src.<span class="property">a</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></div>

<p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">b</span>() &#123;</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; a: foo &#125;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-12 日报 Day64</title>
    <url>/undefined/2025-01-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>这个世界上的大部分传奇，不过是普普通通的人们，将心意化作了行动而已。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P213-219 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、对象标识及相等判定: 在 ECMAScript 6 之前，有些特殊情况即使是&#x3D;&#x3D;&#x3D;操作符也无能为力：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是===符合预期的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> === <span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span> === <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与&#x3D;&#x3D;&#x3D;很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="literal">true</span>, <span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 正确的 0、-0、+0 相等/不等判定</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 正确的 NaN 相等判定</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 要检查超过两个值，递归地利用相等性传递即可：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recursivelyCheckEqual</span>(<span class="params">x, ...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">is</span>(x, rest[<span class="number">0</span>]) &amp;&amp; (rest.<span class="property">length</span> &lt; <span class="number">2</span> || <span class="title function_">recursivelyCheckEqual</span>(...rest))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2、增强的对象语法: ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象的方便程度。</p>
<ul>
<li>属性值简写: 在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。例如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: name,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在 ECMAScript 6 中，可以简写成：</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">makePerson</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: a,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="title function_">makePerson</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>可计算属性: 在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&quot;job&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[nameKey] = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line">person[ageKey] = <span class="number">27</span>;</span><br><span class="line">person[jobKey] = <span class="string">&quot;Software engineer&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：</span></span><br><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&quot;job&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [nameKey]: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">  [ageKey]: <span class="number">27</span>,</span><br><span class="line">  [jobKey]: <span class="string">&quot;Software engineer&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</span></span><br><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&quot;job&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUniqueKey</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [<span class="title function_">getUniqueKey</span>(nameKey)]: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">  [<span class="title function_">getUniqueKey</span>(ageKey)]: <span class="number">27</span>,</span><br><span class="line">  [<span class="title function_">getUniqueKey</span>(jobKey)]: <span class="string">&quot;Software engineer&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name_0: &#x27;Matt&#x27;, age_1: 27, job_2: &#x27;Software engineer&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>注意 可计算属性表达式中抛出任何错误都会中断对象创建。如果计算属性的表达式有副作用，那就要小心了，因为如果表达式抛出错误，那么之前完成的计算是不能回滚的。</p>
<ul>
<li>简写方法名: 在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="title function_">sayName</span>(<span class="string">&quot;Matt&quot;</span>); <span class="comment">// My name is Matt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="title function_">sayName</span>(<span class="string">&quot;Matt&quot;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure></div>

<p>简写方法名对获取函数和设置函数也是适用的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name_</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name_&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure></div>

<p>简写方法名与可计算属性键相互兼容：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> methodKey = <span class="string">&quot;sayName&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [methodKey](name) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="title function_">sayName</span>(<span class="string">&quot;Matt&quot;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure></div>

<p>3、对象解构: ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。<br>下面的例子展示了两段等价的代码，首先是不使用对象解构的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName = person.<span class="property">name</span>,</span><br><span class="line">  personAge = person.<span class="property">age</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName); <span class="comment">// Matt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personAge); <span class="comment">// 27</span></span><br><span class="line"><span class="comment">// 然后，是使用对象解构的：</span></span><br><span class="line"><span class="comment">// 使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">27</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName); <span class="comment">// Matt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personAge); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure></div>
<p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure></div>
<p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, job &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(job); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>

<p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, job=<span class="string">&#x27;Software engineer&#x27;</span> &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(job); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure></div>
<p>解构在内部使用函数 ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 ToObject()的定义），null和 undefined 不能被解构，否则会抛出错误。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length); <span class="comment">// 6 </span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c === <span class="title class_">Number</span>); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span>; <span class="comment">// TypeError </span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></div>
<p>解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); <span class="comment">// Matt, 27</span></span><br></pre></td></tr></table></figure></div>

<p>3、嵌套解构: 解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>, </span><br><span class="line"> <span class="attr">job</span>: &#123; </span><br><span class="line"> <span class="attr">title</span>: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line">(&#123; <span class="attr">name</span>: personCopy.<span class="property">name</span>, <span class="attr">age</span>: personCopy.<span class="property">age</span>, <span class="attr">job</span>: personCopy.<span class="property">job</span> &#125; = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给 personCopy，所以修改</span></span><br><span class="line"><span class="comment">// person.job 对象的属性也会影响 personCopy </span></span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">&#x27;Hacker&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personCopy); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125;</span></span><br><span class="line"><span class="comment">// 解构赋值可以使用嵌套结构，以匹配嵌套的属性：</span></span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span>, </span><br><span class="line"> <span class="attr">job</span>: &#123; </span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 声明 title 变量并将 person.job.title 的值赋给它</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure></div>
<p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">job</span>: &#123; </span><br><span class="line"> <span class="attr">title</span>: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;; </span><br><span class="line"><span class="comment">// foo 在源对象上是 undefined </span></span><br><span class="line">(&#123; </span><br><span class="line"> <span class="attr">foo</span>: &#123; </span><br><span class="line"> <span class="attr">bar</span>: personCopy.<span class="property">bar</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; = person); </span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property &#x27;bar&#x27; of &#x27;undefined&#x27; or &#x27;null&#x27;. </span></span><br><span class="line"><span class="comment">// job 在目标对象上是 undefined </span></span><br><span class="line">(&#123; </span><br><span class="line"> <span class="attr">job</span>: &#123; </span><br><span class="line"> <span class="attr">title</span>: personCopy.<span class="property">job</span>.<span class="property">title</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125; = person); </span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;title&#x27; of undefined</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>部分解构: 需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="comment">// person.foo 是 undefined，因此会抛出错误</span></span><br><span class="line"> (&#123;<span class="attr">name</span>: personName, <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personBar &#125;, <span class="attr">age</span>: personAge&#125; = person); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personBar, personAge); </span><br><span class="line"><span class="comment">// Matt, undefined, undefined</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>参数上下文匹配: 在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params">foo, &#123;name, age&#125;, bar</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson2</span>(<span class="params">foo, &#123;name: personName, age: personAge&#125;, bar</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(personName, personAge); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">printPerson</span>(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>); </span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;] </span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27 </span></span><br><span class="line"><span class="title function_">printPerson2</span>(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>); </span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;] </span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-13 日报 Day65</title>
    <url>/undefined/2025-01-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在选择面前要有舍弃的勇气，有“众行”的智慧，更有超越小我、始终如一的方向。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P220-223 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、虽然使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。下面的例子展示了一种按照特定接口创建对象的方式：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> o.<span class="property">name</span> = name; </span><br><span class="line"> o.<span class="property">age</span> = age; </span><br><span class="line"> o.<span class="property">job</span> = job; </span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>这里，函数 createPerson()接收 3 个参数，根据这几个参数构建了一个包含 Person 信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。<br>2、构造函数模式: ECMAScript 中的构造函数是用于创建特定类型对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，Person()构造函数代替了 createPerson()工厂函数。实际上，Person()内部的代码跟 createPerson()基本是一样的，只是有如下区别。<br> 没有显式地创建对象。<br> 属性和方法直接赋值给了 this。<br> 没有 return。<br>另外，要注意函数名 Person 的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在 ECMAScript 中区分构造函数和普通函数。毕竟 ECMAScript 的构造函数就是能创建对象的函数。<br>要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。</p>
<ol>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。</li>
<li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。<br>上一个例子的最后，person1 和 person2 分别保存着 Person 的不同实例。这两个对象都有一个constructor 属性指向 Person，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
constructor 本来是用于标识对象类型的。不过，一般认为 instanceof 操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是 Object 的实例，同时也是 Person 的实例，如下面调用instanceof 操作符的结果所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Greg </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Jake&quot;</span>; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Jake </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Jake </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
3、构造函数也是函数: 构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操作符调用的函数就是普通函数。比如，前面的例子中定义的 Person()可以像下面这样调用：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数 </span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="comment">// 作为函数调用</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); <span class="comment">// 添加到 window 对象</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Greg&quot; </span></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>); </span><br><span class="line">o.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure></div>
4、构造函数的问题: 构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;console.log(this.name)&quot;</span>); <span class="comment">// 逻辑等价</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同实例上的函数虽然同名却不相等</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
因为都是做一样的事，所以没必要定义两个不同的 Function 实例。况且，this 对象可以把函数与对象的绑定推迟到运行时。要解决这个问题，可以把函数定义转移到构造函数外部：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// Nicholas </span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure></div>
在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局 sayName()函数。因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2共享了定义在全局作用域上的 sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</li>
</ol>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-14 日报 Day66</title>
    <url>/undefined/2025-01-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>成功者之所以能够登高望远，并不在于先天高人一筹，而是在于后天全力以赴。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P224-227 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、原型模式: 每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数表达式也可以：</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>这里，所有属性和 sayName()方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的都是相同的属性和相同的 sayName()函数。要理解这个过程，就必须理解 ECMAScript 中原型的本质。<br>2、理解原型: 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。<br>在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造函数可以是函数表达式</span></span><br><span class="line"><span class="comment"> * 也可以是函数声明，因此以下两种形式都可以：</span></span><br><span class="line"><span class="comment"> * function Person() &#123;&#125; </span></span><br><span class="line"><span class="comment"> * let Person = function() &#123;&#125; </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 声明之后，构造函数就有了一个</span></span><br><span class="line"><span class="comment"> * 与之关联的原型对象：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// constructor: f Person(), </span></span><br><span class="line"><span class="comment">// __proto__: Object</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如前所述，构造函数有一个 prototype 属性</span></span><br><span class="line"><span class="comment"> * 引用其原型对象，而这个原型对象也有一个</span></span><br><span class="line"><span class="comment"> * constructor 属性，引用这个构造函数</span></span><br><span class="line"><span class="comment"> * 换句话说，两者循环引用：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 正常的原型链都会终止于 Object 的原型对象</span></span><br><span class="line"><span class="comment"> * Object 原型的原型是 null </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="literal">null</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>); </span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// constructor: f Object(), </span></span><br><span class="line"><span class="comment">// toString: ... </span></span><br><span class="line"><span class="comment">// hasOwnProperty: ... </span></span><br><span class="line"><span class="comment">// isPrototypeOf: ... </span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(), </span><br><span class="line"> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造函数、原型对象和实例</span></span><br><span class="line"><span class="comment"> * 是 3 个完全不同的对象：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 !== <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 !== <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> !== <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 实例通过__proto__链接到原型对象，</span></span><br><span class="line"><span class="comment"> * 它实际上指向隐藏特性[[Prototype]] </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造函数通过 prototype 属性链接到原型对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 实例与构造函数没有直接联系，与原型对象有直接联系</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line">conosle.<span class="title function_">log</span>(person1.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 同一个构造函数创建的两个实例</span></span><br><span class="line"><span class="comment"> * 共享同一个原型对象：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span> === person2.<span class="property">__proto__</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * instanceof 检查实例的原型链中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  * 是否包含指定构造函数的原型：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person2)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1).<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line"> <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person, biped); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">numLegs</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === biped); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> biped = &#123; </span><br><span class="line"> <span class="attr">numLegs</span>: <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(biped); </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Matt </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">numLegs</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person) === biped); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>构造函数是创建对象的函数，原型对象（prototype）是这个构造函数“造出来”的所有对象所共享的属性和方法的集合。<br>你可以把构造函数 Person 看成一个「模具」，原型对象 Person.prototype 是这个模具自带的「说明书」，而通过这个模具造出来的每个实例对象（如 person1）都会自动连接到这份「说明书」。<br>       Person()  ← 构造函数（模具）<br>          |<br>          ↓<br>     Person.prototype  ← 原型对象（说明书）<br>          ↑<br>          |<br>    person1.<strong>proto</strong> → 指向 Person.prototype</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-15 日报 Day67</title>
    <url>/undefined/2025-01-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>读书可以改变一个人的气质和格局。有知识藏于心，便是对灵魂的顶级化妆。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P228-232 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、原型层级: 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。因此，在调用 person1.sayName()时，会发生两步搜索。首先，JavaScript 引擎会问：“person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“person1 的原型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上的这个函数。在调用 person2.sayName()时，会发生同样的搜索过程，而且也会返回相同的结果。这就是原型用于在多个对象实例间共享属性和方法的原理。<br>虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。下面看一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure></div>
<p>hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object的，会在属性存在于调用它的对象实例上时返回 true，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>注意 ECMAScript 的 Object.getOwnPropertyDescriptor()方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()。<br>2、原型和in操作符: 有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true </span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">delete</span> person1.<span class="property">name</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>在上面整个例子中，name 随时可以通过实例或通过原型访问到。因此，调用”name” in persoon1时始终返回 true，无论这个属性是否在实例上。如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用 hasOwnProperty()和 in 操作符：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypeProperty</span>(<span class="params">object, name</span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> !object.<span class="title function_">hasOwnProperty</span>(name) &amp;&amp; (name <span class="keyword">in</span> object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>只要通过对象可以访问，in 操作符就返回 true，而 hasOwnProperty()只有属性存在于实例上时才返回 true。因此，只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性是一个原型属性。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">&quot;name&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(person, <span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（[[Enumerable]]特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。<br>要获得对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys); <span class="comment">// &quot;name,age,job,sayName&quot; </span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&quot;Rob&quot;</span>; </span><br><span class="line">p1.<span class="property">age</span> = <span class="number">31</span>; </span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(p1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1keys); <span class="comment">// &quot;[name,age]&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys); <span class="comment">// &quot;[constructor,name,age,job,sayName]&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>在 ECMAScript 6 新增符号类型之后，相应地出现了增加一个 Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，Object.getOwnPropertySymbols()方法就出现了，这个方法与 Object.getOwnPropertyNames()类似，只是针对符号而已：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>), </span><br><span class="line"> k2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> o = &#123; </span><br><span class="line"> [k1]: <span class="string">&#x27;k1&#x27;</span>, </span><br><span class="line"> [k2]: <span class="string">&#x27;k2&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o)); </span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-19 日报 Day71</title>
    <url>/undefined/2025-01-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>那些夜以继日的奋斗，终将让你养成持续努力的习惯，成为你追求梦想的勇气和力量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P243-244 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、盗用构造函数: 原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和 call()方法以新创建的对象为上下文执行构造函数。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="comment">// 继承 SuperType </span></span><br><span class="line"> <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot; </span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>示例中加粗的代码展示了盗用构造函数的调用。通过使用 call()（或 apply()）方法，SuperType构造函数在为 SubType 的实例创建的新对象的上下文中执行了。这相当于新的 SubType 对象上运行了SuperType()函数中的所有初始化代码。</p>
<ul>
<li>传递参数: 相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="comment">// 继承 SuperType 并传参</span></span><br><span class="line"> <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;Nicholas&quot;</span>); </span><br><span class="line"> <span class="comment">// 实例属性</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">age</span>); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure></div></li>
<li>盗用构造函数的问题: 是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。<br>2、组合继承: 组合继承综合了原型链和盗用构造函数,基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123; </span><br><span class="line"> <span class="comment">// 继承属性</span></span><br><span class="line"> <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot; </span></span><br><span class="line">instance1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot;; </span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>(); <span class="comment">// 29 </span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green&quot; </span></span><br><span class="line">instance2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Greg&quot;; </span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure></div>
组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-16 日报 Day68</title>
    <url>/undefined/2025-01-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>衡量一个人成功的标志，不是看他登到顶峰的高度，而是看他跌到谷底的反弹力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P233-235 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、属性枚举顺序: for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别。for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。<br>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>), </span><br><span class="line"> k2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="number">1</span>: <span class="number">1</span>, </span><br><span class="line"> <span class="attr">first</span>: <span class="string">&#x27;first&#x27;</span>, </span><br><span class="line"> [k1]: <span class="string">&#x27;sym2&#x27;</span>, </span><br><span class="line"> <span class="attr">second</span>: <span class="string">&#x27;second&#x27;</span>, </span><br><span class="line"> <span class="number">0</span>: <span class="number">0</span> </span><br><span class="line">&#125;; </span><br><span class="line">o[k2] = <span class="string">&#x27;sym2&#x27;</span>; </span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>; </span><br><span class="line">o.<span class="property">third</span> = <span class="string">&#x27;third&#x27;</span>; </span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o)); </span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o)); </span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure></div>
<p>2、对象迭代: ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键&#x2F;值对的数组。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, </span><br><span class="line"> <span class="attr">baz</span>: <span class="number">1</span>, </span><br><span class="line"> <span class="attr">qux</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 1, &#123;&#125;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(o));</span><br><span class="line"><span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]]</span></span><br></pre></td></tr></table></figure></div>
<p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line"> <span class="attr">qux</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o)[<span class="number">0</span>] === o.<span class="property">qux</span>); </span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(o)[<span class="number">0</span>][<span class="number">1</span>] === o.<span class="property">qux</span>); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 符号属性会被忽略：</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line"> [sym]: <span class="string">&#x27;foo&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o)); </span><br><span class="line"><span class="comment">// [] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>((o))); </span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，Person.prototype 被设置为等于一个通过对象字面量创建的新对象。最终结果是一样的，只有一个问题：这样重写之后，Person.prototype 的 constructor 属性就不指向 Person了。在创建函数时，也会创建它的 prototype 对象，同时会自动给这个原型的 constructor 属性赋值。而上面的写法完全重写了默认的 prototype 对象，因此其 constructor 属性也指向了完全不同的新对象（Object 构造函数），不再指向原来的构造函数。虽然 instanceof 操作符还能可靠地返回值，但我们不能再依靠 constructor 属性来识别类型了，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(friend.<span class="property">constructor</span> == <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>这里，instanceof仍然对Object和Person都返回true。但constructor属性现在等于Object而不是 Person 了。如果 constructor 的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> <span class="attr">constructor</span>: <span class="title class_">Person</span>, </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>但要注意，以这种方式恢复 constructor 属性会创建一个[[Enumerable]]为 true 的属性。而原生 constructor 属性默认是不可枚举的。因此，如果你使用的是兼容 ECMAScript 的 JavaScript 引擎，那可能会改为使用 Object.defineProperty()方法来定义 constructor 属性：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 恢复 constructor 属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123; </span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">false</span>, </span><br><span class="line"> <span class="attr">value</span>: <span class="title class_">Person</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-20 日报 Day72</title>
    <url>/undefined/2025-01-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>愿意陪你笑的人很多，可愿意陪你哭的人却格外珍贵，能跟你共患难的人更是难得。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P245-248 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、原型式继承: 他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。文章最终给出了一个函数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"> F.<span class="property"><span class="keyword">prototype</span></span> = o; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个 object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">object</span>(person); </span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="title function_">object</span>(person); </span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>; </span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的 object()方法效果相同：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person); </span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person); </span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>; </span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>Object.create()的第二个参数与 Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123; </span><br><span class="line"> <span class="attr">name</span>: &#123; </span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Greg&quot;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherPerson.<span class="property">name</span>); <span class="comment">// &quot;Greg&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>2、寄生式继承: 寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> clone = <span class="title function_">object</span>(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line"> clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">createAnother</span>(person); </span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>3、寄生式组合继承: 组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。再来看一看这个组合继承的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123; </span><br><span class="line"> <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 第二次调用 SuperType() </span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); <span class="comment">// 第一次调用 SuperType() </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>; </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = subType; <span class="comment">// 增强对象 </span></span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123; </span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>); </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符和isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-18 日报 Day70</title>
    <url>/undefined/2025-01-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在所有高水平平台上，每一项令人瞩目的成就背后都有曾经记录过艰难割舍的努力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P240-242 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、默认原型: 默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向Object.prototype。<br>2、原型与继承关系: 原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true。如下例所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SuperType</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SubType</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>确定这种关系的第二种方式是使用 isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回 true：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>3、关于方法: </p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 继承 SuperType </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="comment">// 新方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 覆盖已有的方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 SuperType </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="comment">// 通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> <span class="title function_">getSubValue</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">someOtherMethod</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure></div>
<p>在这段代码中，子类的原型在被赋值为 SuperType 的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个 Object 的实例，而不再是 SuperType 的实例。因此之前的原型链就断了。SubType和 SuperType 之间也没有关系了。<br>4、原型链问题: 原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。下面的例子揭示了这个问题：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="comment">// 继承 SuperType </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot; </span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-17 日报 Day69</title>
    <url>/undefined/2025-01-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>能坚持别人无法坚持的，才会拥有别人无法拥有的，一点点改变，好过一成不变。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P236-239 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、原型的动态性: 因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。下面是一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line">friend.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;hi&quot;，没问题！</span></span><br></pre></td></tr></table></figure></div>
<p>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> <span class="attr">constructor</span>: <span class="title class_">Person</span>, </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">friend.<span class="title function_">sayName</span>(); <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，Person 的新实例是在重写原型对象之前创建的。在调用 friend.sayName()的时候，会导致错误。这是因为 firend 指向的原型还是最初的原型，而这个原型上并没有 sayName 属性。<br>重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。<br>2、原生对象原型: 原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括 Object、Array、String 等）都在原型上定义了实例方法。比如，数组实例的 sort()方法就是 Array.prototype 上定义的，而字符串包装对象的 substring()方法也是在 String.prototype 上定义的，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sort</span>); <span class="comment">// &quot;function&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">substring</span>); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。比如，下面的代码就给 String原始值包装类型的实例添加了一个 startsWith()方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span> = <span class="keyword">function</span> (<span class="params">text</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(text) === <span class="number">0</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;Hello world!&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="title function_">startsWith</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>3、原型问题: 原型模式弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共享特性。<br>真正的问题来自包含引用值的属性。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; </span><br><span class="line"> <span class="attr">constructor</span>: <span class="title class_">Person</span>, </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>, </span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>, </span><br><span class="line"> <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>], </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Van&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// &quot;Shelby,Court,Van&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span> === person2.<span class="property">friends</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>4、继承: 很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在 ECMAScript 中是不可能的，因为函数没有签名。实现继承是 ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。</p>
<ul>
<li>原型链: 通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 继承 SuperType </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-22 日报 Day74</title>
    <url>/undefined/2025-01-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>只要你开始思考、开始行动，你就已经走上了一条必然不易，但也充满希望的路途了。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P254-256 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p>
<ul>
<li>实例成员: 每次通过 new 调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这个例子先使用对象包装类型定义一个字符串</span></span><br><span class="line">    <span class="comment">// 为的是在下面测试两个对象的相等性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&quot;Jake&quot;</span>, <span class="string">&quot;J-Dog&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(),</span><br><span class="line">  p2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="title function_">sayName</span>(); <span class="comment">// Jack</span></span><br><span class="line">p2.<span class="title function_">sayName</span>(); <span class="comment">// Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span> === p2.<span class="property">name</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">sayName</span> === p2.<span class="property">sayName</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">nicknames</span> === p2.<span class="property">nicknames</span>); <span class="comment">// false</span></span><br><span class="line">p1.<span class="property">name</span> = p1.<span class="property">nicknames</span>[<span class="number">0</span>];</span><br><span class="line">p2.<span class="property">name</span> = p2.<span class="property">nicknames</span>[<span class="number">1</span>];</span><br><span class="line">p1.<span class="title function_">sayName</span>(); <span class="comment">// Jake</span></span><br><span class="line">p2.<span class="title function_">sayName</span>(); <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>原型方法与访问器: 为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">  <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prototype&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">locate</span>(); <span class="comment">// instance</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>(); <span class="comment">// prototype</span></span><br><span class="line"><span class="comment">// 可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token</span></span><br><span class="line"><span class="comment">// 类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</span></span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="title class_">Symbol</span>(<span class="string">&quot;symbolKey&quot;</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">stringKey</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;invoked stringKey&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  [symbolKey]() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;invoked symbolKey&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="string">&quot;computed&quot;</span> + <span class="string">&quot;Key&quot;</span>]() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;invoked computedKey&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">stringKey</span>(); <span class="comment">// invoked stringKey</span></span><br><span class="line">p[symbolKey](); <span class="comment">// invoked symbolKey</span></span><br><span class="line">p.<span class="title function_">computedKey</span>(); <span class="comment">// invoked computedKey</span></span><br><span class="line"><span class="comment">// 类定义也支持获取和设置访问器。语法与行为跟普通对象一样：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = newName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>静态类方法: 可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。<br>静态类成员在类定义中使用 static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 添加到 this 的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">  <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prototype&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类本身上</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;class&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">locate</span>(); <span class="comment">// instance, Person &#123;&#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>(); <span class="comment">// prototype, &#123;constructor: ... &#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">locate</span>(); <span class="comment">// class, class Person &#123;&#125;</span></span><br><span class="line"><span class="comment">// 静态类方法非常适合作为实例工厂：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age_</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age_</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用随机年龄创建并返回一个 Person 实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">create</span>()); <span class="comment">// Person &#123; age_: ... &#125;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>非函数原型和类成员: 虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 在类上定义数据成员</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">greeting</span> = <span class="string">&#x27;My name is&#x27;</span>;</span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">p.<span class="title function_">sayName</span>(); <span class="comment">// My name is Jake</span></span><br></pre></td></tr></table></figure></div>
<p>注意 类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 this引用的数据。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-21 日报 Day73</title>
    <url>/undefined/2025-01-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在任何一个你没有察觉的时刻，包括现在，通过行动去改变命运的机会，一直都存在。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P249-253 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、前几节深入讲解了如何只使用 ECMAScript 5 的特性来模拟类似于类（class-like）的行为。不难看出，各种策略都有自己的问题，也有相应的妥协。正因为如此，实现继承的代码也显得非常冗长和混乱。<br>为解决这些问题，ECMAScript 6 新引入的 class 关键字具有正式定义类的能力。类（class）是ECMAScript 中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然 ECMAScript 6 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。<br>2、类定义: 定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; </span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = <span class="keyword">class</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></div>
<p>与函数表达式类似，类表达式在它们被求值前也不能引用。不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionExpression</span>); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">FunctionExpression</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionExpression</span>); <span class="comment">// function() &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionDeclaration</span>); <span class="comment">// FunctionDeclaration() &#123;&#125; </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FunctionDeclaration</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionDeclaration</span>); <span class="comment">// FunctionDeclaration() &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassExpression</span>); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ClassExpression</span> = <span class="keyword">class</span> &#123;&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassExpression</span>); <span class="comment">// class &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// ReferenceError: ClassDeclaration is not defined </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassDeclaration</span> &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// class ClassDeclaration &#123;&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">FunctionDeclaration</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">ClassDeclaration</span> &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionDeclaration</span>); <span class="comment">// FunctionDeclaration() &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br></pre></td></tr></table></figure></div>
<p>类构成<br>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。<br>与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例（比如，通过 class Foo {}创建实例 foo）：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空类定义，有效 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125; </span><br><span class="line"><span class="comment">// 有构造函数的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 有获取函数的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> &#123; </span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">myBaz</span>() &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 有静态方法的类，有效</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Qux</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">myQux</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">PersonName</span> &#123; </span><br><span class="line"> <span class="title function_">identify</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>, <span class="title class_">PersonName</span>.<span class="property">name</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">p.<span class="title function_">identify</span>(); <span class="comment">// PersonName PersonName </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>); <span class="comment">// PersonName </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PersonName</span>); <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure></div>
<p>3、类的构造函数: constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p>
<ul>
<li>使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。唯一可感知的不同之处就是，JavaScript 解释器知道使用 new 和类意味着应该使用 constructor 函数进行实例化。<br>使用 new 调用类的构造函数会执行如下操作。<br>(1) 在内存中创建一个新对象。<br>(2) 这个新对象内部的[[Prototype]]指针被赋值为构造函数的 prototype 属性。<br>(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。<br>(4) 执行构造函数内部的代码（给新对象添加属性）。<br>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person ctor&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetable</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;orange&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>(); </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// person ctor </span></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vegetable</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="property">color</span>); <span class="comment">// orange</span></span><br></pre></td></tr></table></figure></div>
类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="literal">null</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>; <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>); <span class="comment">// null </span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">name</span>); <span class="comment">// null </span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jake&#x27;</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3.<span class="property">name</span>); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure></div>
默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">override</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">    <span class="keyword">if</span> (override) &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            <span class="attr">bar</span>: <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(), </span><br><span class="line"> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// Person&#123; foo: &#x27;foo&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// &#123; bar: &#x27;bar&#x27; &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符。而普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。调用类构造函数时如果忘了使用 new 则会抛出错误：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125; </span><br><span class="line"><span class="comment">// 把 window 作为 this 来构建实例</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Person</span>(); </span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Animal</span>(); </span><br><span class="line"><span class="comment">// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure></div>
类构造函数没有什么特殊之处，实例化之后，它会成为普通的实例方法（但作为类构造函数，仍然要使用 new 调用）。因此，实例化之后可以在实例上引用它：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; </span><br><span class="line"><span class="comment">// 使用类创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">p1.<span class="title function_">constructor</span>(<span class="params"></span>); </span><br><span class="line"><span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27; </span></span><br><span class="line"><span class="comment">// 使用对类构造函数的引用创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> p1.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure></div>
4、把类当成特殊函数: ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript 类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>); <span class="comment">// class Person &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>); <span class="comment">// function</span></span><br><span class="line"><span class="comment">// 类标识符有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123; constructor: f() &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>.<span class="title function_">constructor</span>(<span class="params"></span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类可以像函数一样在任何地方定义，比如在数组中</span></span><br><span class="line"><span class="keyword">let</span> classList = [ </span><br><span class="line"> <span class="keyword">class</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">id_</span> = id; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`instance <span class="subst">$&#123;<span class="variable language_">this</span>.id_&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">]; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">classDefinition, id</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">classDefinition</span>(id); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="title function_">createInstance</span>(classList[<span class="number">0</span>], <span class="number">3141</span>); <span class="comment">// instance 3141</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是一个类表达式，所以类名是可选的</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x</span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p); <span class="comment">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-25 日报 Day77</title>
    <url>/undefined/2025-01-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>正是因为那些看起来很难的努力、付出和坚持，才成就了那个不断变得更好的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P266-270 第九章：代理与反射</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。<br>2、代理基础: 代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。</p>
<ul>
<li>创建空代理: 代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// id 属性会访问同一个值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// target</span></span><br><span class="line"><span class="comment">// 给目标属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为两个对象访问的是同一个值</span></span><br><span class="line">target.<span class="property">id</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 给代理属性赋值会反映在两个对象上</span></span><br><span class="line"><span class="comment">// 因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.<span class="property">id</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方</span></span><br><span class="line"><span class="comment">// 都会应用到目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Proxy.prototype 是 undefined</span></span><br><span class="line"><span class="comment">// 因此不能使用 instanceof 操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">&#x27;undefined&#x27;</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype</span></span><br><span class="line"><span class="string">&#x27;undefined&#x27;</span> <span class="keyword">in</span> <span class="keyword">instanceof</span> check</span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>定义捕获器: 使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。<br>注意 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。<br>例如，可以定义一个 get()捕获器，在 ECMAScript 操作以某种形式调用 get()时触发。下面的例子定义了一个 get()捕获器：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;handler override&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure></div>

<p>这样，当通过代理对象执行 get()操作时，就会触发定义的 get()捕获器。当然，get()不是 ECMAScript 对象可以调用的方法。这个操作在 JavaScript 代码中可以通过多种形式触发并被 get()捕获器拦截到。proxy[property]、proxy.property 或 Object.create(proxy)[property]等操作都会触发基本的 get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;handler override&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// handler override</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target[<span class="string">&quot;foo&quot;</span>]); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy[<span class="string">&quot;foo&quot;</span>]); <span class="comment">// handler override</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(target)[<span class="string">&quot;foo&quot;</span>]); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(proxy)[<span class="string">&quot;foo&quot;</span>]); <span class="comment">// handler override</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>捕获器参数和反射 API: 所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(trapTarget === target);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(property);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(receiver === proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> trapTarget[property];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure></div>

<p>实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。<br>处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 API 也可以像下面这样定义出空代理对象：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至还可以写得更简洁一些：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="title class_">Reflect</span>.<span class="property">get</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure></div>

<p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, <span class="title class_">Reflect</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure></div>

<p>反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="string">&quot;qux&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> decoration = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">      decoration = <span class="string">&quot;!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + decoration;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// bar!!!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// qux</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">baz</span>); <span class="comment">// qux</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>捕获器不变式: 比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&quot;foo&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;qux&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>);</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>可撤销代理: 有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。撤销函数和代理对象是在实例化时同时生成的：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;intercepted&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// intercepted</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-23 日报 Day75</title>
    <url>/undefined/2025-01-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>生命因沉淀而厚重，人生因打磨更璀璨。从今天起静静蓄力，你想要的都将奔赴而来！</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P257-261 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、迭代器与生成器方法: 类定义语法支持在原型和类本身上定义生成器方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line">  *<span class="title function_">createNicknameIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;J-Dog&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在类上定义生成器方法</span></span><br><span class="line">  <span class="keyword">static</span> *<span class="title function_">createJobIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Butcher&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Baker&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Candlestick maker&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jobIter = <span class="title class_">Person</span>.<span class="title function_">createJobIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Butcher</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Baker</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jobIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Candlestick maker</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.<span class="title function_">createNicknameIterator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// Jake</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nicknameIter.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// J-Dog</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Jake&quot;</span>, <span class="string">&quot;J-Dog&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="variable language_">this</span>.<span class="property">nicknames</span>.<span class="title function_">entries</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br><span class="line"><span class="comment">// 也可以只返回迭代器实例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nicknames</span> = [<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Jake&quot;</span>, <span class="string">&quot;J-Dog&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nicknames</span>.<span class="title function_">entries</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure></div>

<p>2、继承: ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p>
<ul>
<li>继承基础: ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bus</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 继承普通构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> <span class="title class_">Engineer</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">Engineer</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反映调用相应方法的实例或者类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">identifyPrototype</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identifyClass</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line">b.<span class="title function_">identifyPrototype</span>(<span class="string">&quot;bus&quot;</span>); <span class="comment">// bus, Bus &#123;&#125;</span></span><br><span class="line">v.<span class="title function_">identifyPrototype</span>(<span class="string">&quot;vehicle&quot;</span>); <span class="comment">// vehicle, Vehicle &#123;&#125;</span></span><br><span class="line"><span class="title class_">Bus</span>.<span class="title function_">identifyClass</span>(<span class="string">&quot;bus&quot;</span>); <span class="comment">// bus, class Bus &#123;&#125;</span></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="title function_">identifyClass</span>(<span class="string">&quot;vehicle&quot;</span>); <span class="comment">// vehicle, class Vehicle &#123;&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>注意 extends 关键字也可以在类表达式中使用，因此 let Bar &#x3D; class extends Foo {}是有效的语法。<br>2、构造函数、HomeObject 和 super(): 派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hasEngine</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 不要在调用 super()之前引用 this，否则会抛出 ReferenceError</span></span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 相当于 super.constructor()</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"><span class="comment">// 在静态方法中可以通过 super 调用继承的类上定义的静态方法：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vehicle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">identify</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bus</span>.<span class="title function_">identify</span>(); <span class="comment">// vehicle</span></span><br></pre></td></tr></table></figure></div>

<p>注意 ES6 给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。super 始终会定义为[[HomeObject]]的原型。<br>在使用 super 时要注意几个问题。<br> super 只能在派生类构造函数和静态方法中使用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> 不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>);</span><br><span class="line"> <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> 调用 super()会调用父类构造函数，并将返回的实例赋值给 this。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p> super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">licensePlate</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">licensePlate</span> = licensePlate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">licensePlate</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(licensePlate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div>

<p> 如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">licensePlate</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">licensePlate</span> = licensePlate; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div>

<p> 在类构造函数中，不能在调用 super()之前引用 this。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>(); </span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class </span></span><br><span class="line"><span class="comment">// before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure></div>

<p> 如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Van</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Car</span>()); <span class="comment">// Car &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>()); <span class="comment">// Bus &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Van</span>()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-24 日报 Day76</title>
    <url>/undefined/2025-01-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>时间是坦诚的，也是公平的，一年如一日地做一件事确实很难，但这才是坚持的意义。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P262-265 第八章：对象、类与面向对象编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、抽象基类: 有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法 ，但通过 new.target 也很容易实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Vehicle cannot be directly instantiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>(); <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vehicle</span>(); <span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure></div>

<p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Vehicle cannot be directly instantiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">foo</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Inheriting class must define foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Van</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>(); <span class="comment">// success!</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Van</span>(); <span class="comment">// Error: Inheriting class must define foo()</span></span><br></pre></td></tr></table></figure></div>

<p>2、继承内置类型: ES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">shuffle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 洗牌算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line">      [<span class="variable language_">this</span>[i], <span class="variable language_">this</span>[j]] = [<span class="variable language_">this</span>[j], <span class="variable language_">this</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.<span class="title function_">shuffle</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [3, 1, 4, 5, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">filter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> !!(x % <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">filter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> !!(x % <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p>3、类混入: 把不同类的行为集中到一个类是一种常见的 JavaScript 模式。虽然 ES6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。<br>注意 Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用 Object.assign()就可以了。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getParentClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;evaluated expression&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Vehicle</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">getParentClass</span>() &#123;&#125;</span><br><span class="line"><span class="comment">// 可求值的表达式</span></span><br></pre></td></tr></table></figure></div>

<p>一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line"> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line"> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123;</span><br><span class="line"> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FooMixin</span>(<span class="title class_">BarMixin</span>(<span class="title class_">BazMixin</span>(<span class="title class_">Vehicle</span>))) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line">b.<span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line">b.<span class="title function_">bar</span>(); <span class="comment">// bar</span></span><br><span class="line">b.<span class="title function_">baz</span>(); <span class="comment">// baz</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>通过写一个辅助函数，可以把嵌套调用展开：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123; </span><br><span class="line"> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123; </span><br><span class="line"> <span class="title function_">bar</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BazMixin</span> = (<span class="params">Superclass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Superclass</span> &#123; </span><br><span class="line"> <span class="title function_">baz</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mix</span>(<span class="params">BaseClass, ...Mixins</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Mixins</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> <span class="title function_">current</span>(accumulator), <span class="title class_">BaseClass</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mix</span>(<span class="title class_">Vehicle</span>, <span class="title class_">FooMixin</span>, <span class="title class_">BarMixin</span>, <span class="title class_">BazMixin</span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>(); </span><br><span class="line">b.<span class="title function_">foo</span>(); <span class="comment">// foo </span></span><br><span class="line">b.<span class="title function_">bar</span>(); <span class="comment">// bar </span></span><br><span class="line">b.<span class="title function_">baz</span>(); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure></div>
<p>注意 很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。<br>4、小结: 对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。<br> 工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。<br> 使用构造函数模式可以自定义引用类型，可以使用 new 关键字像创建内置类型实例一样创建自定义类型的实例。不过，构造函数模式也有不足，主要是其成员无法重用，包括函数。考虑到函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享。<br> 原型模式解决了成员共享的问题，只要是添加到构造函数 prototype 上的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。</p>
<p>JavaScript 的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。</p>
<p>除上述模式之外，还有以下几种继承模式。<br> 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。<br> 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。<br> 寄生组合继承被认为是实现基于类型继承的最有效方式。<br>ECMAScript 6 新增的类很大程度上是基于既有原型机制的语法糖。类的语法让开发者可以优雅地定义向后兼容的类，既可以继承内置类型，也可以继承自定义类型。类有效地跨越了对象实例、对象原型和对象类之间的鸿沟。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-29 日报 Day81</title>
    <url>/undefined/2025-01-29/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生这趟旅程，你可以犯错，可以走岔路，但别忘了自己想要去的地方，和一定要见到的人。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P279-282 第九章：代理与反射</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、- ownKeys(): ownKeys()捕获器会在 Object.keys()及类似方法中被调用。对应的反射 API 方法为 Reflect. ownKeys()。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ownKeys()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy);</span><br><span class="line"><span class="comment">// ownKeys()</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>返回值<br>ownKeys()必须返回包含字符串或符号的可枚举对象。</li>
<li>拦截的操作<br> Object.getOwnPropertyNames(proxy)<br> Object.getOwnPropertySymbols(proxy)<br> Object.keys(proxy)<br> Reflect.ownKeys(proxy)</li>
<li>捕获器处理程序参数<br> target：目标对象。</li>
<li>捕获器不变式<br>返回的可枚举对象必须包含 target 的所有不可配置的自有属性。<br>如果 target 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</li>
</ol>
<ul>
<li>getPrototypeOf(): getPrototypeOf()捕获器会在 Object.getPrototypeOf()中被调用。对应的反射 API 方法为 Reflect.getPrototypeOf()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getPrototypeOf()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy);</span><br><span class="line"><span class="comment">// getPrototypeOf()</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>返回值<br>getPrototypeOf()必须返回对象或 null。</li>
<li>拦截的操作<br> Object.getPrototypeOf(proxy)<br> Reflect.getPrototypeOf(proxy)<br> proxy.<strong>proto</strong><br> Object.prototype.isPrototypeOf(proxy)<br> proxy instanceof Object</li>
<li>捕获器处理程序参数<br> target：目标对象。</li>
<li>捕获器不变式<br>如果 target 不可扩展，则 Object.getPrototypeOf(proxy)唯一有效的返回值就是 Object. getPrototypeOf(target)的返回值。</li>
</ol>
<ul>
<li>setPrototypeOf(): setPrototypeOf()捕获器会在 Object.setPrototypeOf()中被调用。对应的反射 API 方法为 Reflect.setPrototypeOf()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">setPrototypeOf</span>(<span class="params">target, prototype</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setPrototypeOf()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, <span class="title class_">Object</span>);</span><br><span class="line"><span class="comment">// setPrototypeOf()</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>返回值<br>setPrototypeOf()必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<br> Object.setPrototypeOf(proxy)<br> Reflect.setPrototypeOf(proxy)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> prototype：target 的替代原型，如果是顶级原型则为 null。</li>
<li>捕获器不变式<br>如果 target 不可扩展，则唯一有效的 prototype 参数就是 Object.getPrototypeOf(target)的返回值。</li>
</ol>
<ul>
<li>isExtensible(): isExtensible()捕获器会在 Object.isExtensible()中被调用。对应的反射 API 方法为 Reflect.isExtensible()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">isExtensible</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;isExtensible()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy);</span><br><span class="line"><span class="comment">// isExtensible()</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>返回值<br>isExtensible()必须返回布尔值，表示 target 是否可扩展。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<br> Object.isExtensible(proxy)<br> Reflect.isExtensible(proxy)</li>
<li>捕获器处理程序参数<br> target：目标对象。</li>
<li>捕获器不变式<br>如果 target 可扩展，则处理程序必须返回 true。<br>如果 target 不可扩展，则处理程序必须返回 false。</li>
</ol>
<ul>
<li>preventExtensions(): preventExtensions()捕获器会在 Object.preventExtensions()中被调用。对应的反射 API 方法为 Reflect.preventExtensions()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;preventExtensions()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy);</span><br><span class="line"><span class="comment">// preventExtensions()</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>返回值<br>preventExtensions()必须返回布尔值，表示 target 是否已经不可扩展。返回非布尔值会被转<br>型为布尔值。</li>
<li>拦截的操作<br> Object.preventExtensions(proxy)<br> Reflect.preventExtensions(proxy)</li>
<li>捕获器处理程序参数<br> target：目标对象。</li>
<li>捕获器不变式<br>如果 Object.isExtensible(proxy)是 false，则处理程序必须返回 true。</li>
</ol>
<ul>
<li>apply(): apply()捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;apply()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// apply()</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>返回值<br>返回值无限制。</li>
<li>拦截的操作<br> proxy(…argumentsList)<br> Function.prototype.apply(thisArg, argumentsList)<br> Function.prototype.call(thisArg, …argumentsList)<br> Reflect.apply(target, thisArgument, argumentsList)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> thisArg：调用函数时的 this 参数。<br> argumentsList：调用函数时的参数列表</li>
<li>捕获器不变式<br>target 必须是一个函数对象。</li>
</ol>
<ul>
<li>construct(): construct()捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;construct()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// construct()</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>返回值<br>construct()必须返回一个对象。</li>
<li>拦截的操作<br> new proxy(…argumentsList)<br> Reflect.construct(target, argumentsList, newTarget)</li>
<li>捕获器处理程序参数<br> target：目标构造函数。<br> argumentsList：传给目标构造函数的参数列表。<br> newTarget：最初被调用的构造函数。</li>
<li>捕获器不变式<br>target 必须可以用作构造函数。</li>
</ol>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-30 日报 Day82</title>
    <url>/undefined/2025-01-30/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>容言，则日有所进；容事，则事无不成；容人，则人无不和。宽容待人，也会被世界温柔相待。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P283-286 第九章：代理与反射</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、代理模式:</p>
<ul>
<li>跟踪属性访问: 通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jake&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>隐藏属性: 代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">bar</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">baz</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;baz&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>属性验证: 因为所有赋值操作都会触发 set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">onlyNumbersGoHere</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>函数与构造函数参数验证: 跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">median</span>(<span class="params">...nums</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="title function_">sort</span>()[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(median, &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Non-number argument provided&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">4</span>, <span class="string">&quot;7&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Error: Non-number argument provided</span></span><br><span class="line"><span class="comment">// 类似地，可以要求实例化时必须给构造函数传参：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id_</span> = id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;User cannot be instantiated without id&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>();</span><br><span class="line"><span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></table></figure></div>

<p>2、数据绑定与可观察对象: 通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。<br>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newUser = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    userList.<span class="title function_">push</span>(newUser);</span><br><span class="line">    <span class="keyword">return</span> newUser;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&quot;Jacob&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&quot;Jingleheimerschmidt&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userList); <span class="comment">// [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;]</span></span><br></pre></td></tr></table></figure></div>

<p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(userList, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="title function_">emit</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="string">&quot;Jacob&quot;</span>);</span><br><span class="line"><span class="comment">// Jacob</span></span><br></pre></td></tr></table></figure></div>
<p>3、小结:<br>代理是 ECMAScript 6 新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的 JavaScript 元编程及抽象的新天地。<br>从宏观上看，代理是真实 JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。<br>与代理如影随形的反射 API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 API看作一套基本操作，这些操作是绝大部分 JavaScript 对象 API 的基础。<br>代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-31 日报 Day83</title>
    <url>/undefined/2025-01-31/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>顺境时学会清空自己，逆境时学会提醒自己，向内清醒，向外谦逊，美好才会与你不期而遇。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P287-289 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、函数实际上是对象，每个函数都是Function类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (num1, num2) &#123; </span><br><span class="line"> <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function），如下所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123; </span><br><span class="line"> <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>
<p>最后一种定义函数的方式是使用 Function 构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>, <span class="string">&quot;return num1 + num2&quot;</span>); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure></div>
<p>2、箭头函数: ECMAScript 6 新增了使用胖箭头（&#x3D;&gt;）语法定义函数表达式的能力。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">arrowSum</span> = (<span class="params">a, b</span>) =&gt; &#123; </span><br><span class="line"> <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> functionExpressionSum = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrowSum</span>(<span class="number">5</span>, <span class="number">8</span>)); <span class="comment">// 13 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">functionExpressionSum</span>(<span class="number">5</span>, <span class="number">8</span>)); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure></div>
<p>箭头函数简洁的语法非常适合嵌入函数的场景：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">i</span>) &#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;)); <span class="comment">// [2, 3, 4] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123; <span class="keyword">return</span> i + <span class="number">1</span> &#125;)); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure></div>
<p>如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = (<span class="params">x</span>) =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">triple</span> = x =&gt; &#123; <span class="keyword">return</span> <span class="number">3</span> * x; &#125;; </span><br><span class="line"><span class="comment">// 没有参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getRandom</span> = (<span class="params"></span>) =&gt; &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>(); &#125;; </span><br><span class="line"><span class="comment">// 多个参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123; <span class="keyword">return</span> a + b; &#125;; </span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = a, <span class="function"><span class="params">b</span> =&gt;</span> &#123; <span class="keyword">return</span> a * b; &#125;;</span><br></pre></td></tr></table></figure></div>
<p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效，而且返回相应的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = (<span class="params">x</span>) =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">triple</span> = (<span class="params">x</span>) =&gt; <span class="number">3</span> * x; </span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line"><span class="keyword">let</span> value = &#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">setName</span> = (<span class="params">x</span>) =&gt; x.<span class="property">name</span> = <span class="string">&quot;Matt&quot;</span>; </span><br><span class="line"><span class="title function_">setName</span>(value); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">name</span>); <span class="comment">// &quot;Matt&quot; </span></span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">multiply</span> = (<span class="params">a, b</span>) =&gt; <span class="keyword">return</span> a * b;</span><br></pre></td></tr></table></figure></div>
<p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments、super 和new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。<br>3、函数名: 因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20 </span></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20 </span></span><br><span class="line">sum = <span class="literal">null</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></div>
<p>以上代码定义了一个名为 sum()的函数，用于求两个数之和。然后又声明了一个变量 anotherSum，并将它的值设置为等于 sum。注意，使用不带括号的函数名会访问函数指针，而不会执行函数。此时，anotherSum 和 sum 都指向同一个函数。调用 anotherSum()也可以返回结果。把 sum 设置为 null之后，就切断了它与函数之间的关联。而 anotherSum()还是可以照常调用，没有问题。<br>ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成”anonymous”：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; &#123;&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>); <span class="comment">// foo </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">name</span>); <span class="comment">// baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>); <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span>); <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure></div>
<p>如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>); <span class="comment">// bound foo </span></span><br><span class="line"><span class="keyword">let</span> dog = &#123; </span><br><span class="line"> <span class="attr">years</span>: <span class="number">1</span>, </span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">age</span>() &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">years</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">newAge</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">years</span> = newAge; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(dog, <span class="string">&#x27;age&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>); <span class="comment">// get age </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">set</span>.<span class="property">name</span>); <span class="comment">// set age</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-26 日报 Day78</title>
    <url>/undefined/2025-01-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>真正决定我们命运的，不是任何一次考试，而是我们内心对进步的渴望、对奋斗的坚持。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P271-272 第九章：代理与反射</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、反射 API 与对象 API<br>在使用反射 API 时，要记住：<br>(1) 反射 API 并不限于捕获处理程序；<br>(2) 大多数反射 API 方法在 Object 类型上有对应的方法。<br>通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。<br>2、很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 API 方法更有用。例如，可以使用反射API 对下面的代码进行重构：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始代码 </span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;; </span><br><span class="line"><span class="keyword">if</span>(<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;foo&#x27;</span>, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failure&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>以下反射方法都会提供状态标记：<br> Reflect.defineProperty()<br> Reflect.preventExtensions()<br> Reflect.setPrototypeOf()<br> Reflect.set()<br> Reflect.deleteProperty()<br>3、用一等函数替代操作符: 以下反射方法提供只有通过操作符才能完成的操作。<br> Reflect.get()：可以替代对象属性访问操作符。<br> Reflect.set()：可以替代&#x3D;赋值操作符。<br> Reflect.has()：可以替代 in 操作符或 with()。<br> Reflect.deleteProperty()：可以替代 delete 操作符。<br> Reflect.construct()：可以替代 new 操作符。<br>4、安全地应用函数:在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：<br>Function.prototype.apply.call(myFunc, thisVal, argumentList);<br>这种可怕的代码完全可以使用 Reflect.apply 来避免：<br>Reflect.apply(myFunc, thisVal, argumentsList);</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-27 日报 Day79</title>
    <url>/undefined/2025-01-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>没有谁的生活是一帆风顺，许多人都是在一路的披荆斩棘中，摸索属于自己的那一条路。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P273-275 第九章：代理与反射</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;first proxy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(firstProxy, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;second proxy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondProxy.<span class="property">foo</span>);</span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure></div>

<p>2、代理问题与不足:</p>
<ul>
<li>代理中的 this: 代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="title function_">thisValEqualsProxy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> === proxy;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">thisValEqualsProxy</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">thisValEqualsProxy</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">id</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">id</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInstanceProxy.<span class="property">id</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserClassProxy</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="title class_">UserClassProxy</span>(<span class="number">456</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxyUser.<span class="property">id</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>代理与内部槽位: 代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。<br>一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Date</span>); <span class="comment">// true</span></span><br><span class="line">proxy.<span class="title function_">getDate</span>(); <span class="comment">// TypeError: &#x27;this&#x27; is not a Date object</span></span><br></pre></td></tr></table></figure></div>

<p>3、代理捕获器与反射方法: 代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript 操作和不变式。</p>
<ul>
<li>get(): get()捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">foo</span>;</span><br><span class="line"><span class="comment">// get()</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>返回值<br>返回值无限制。</li>
<li>拦截的操作<br> proxy.property<br> proxy[property]<br> Object.create(proxy)[property]<br> Reflect.get(proxy, property, receiver)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> property：引用的目标对象上的字符串键属性。①<br> receiver：代理对象或继承代理对象的对象。</li>
<li>捕获器不变式<br>如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。<br>如果 target.property 不可配置且[[Get]]特性为 undefined，处理程序的返回值也必须是 undefined。</li>
</ol>
<ul>
<li>set(): set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set()&#x27;</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="comment">// set()</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>返回值<br>返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。</li>
<li>拦截的操作<br> proxy.property &#x3D; value<br> proxy[property] &#x3D; value<br> Object.create(proxy)[property] &#x3D; value<br> Reflect.set(proxy, property, value, receiver)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> property：引用的目标对象上的字符串键属性。<br> value：要赋给属性的值。<br> receiver：接收最初赋值的对象。</li>
<li>捕获器不变式<br>如果 target.property 不可写且不可配置，则不能修改目标属性的值。<br>如果 target.property 不可配置且[[Set]]特性为 undefined，则不能修改目标属性的值。<br>在严格模式下，处理程序中返回 false 会抛出 TypeError。</li>
</ol>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-28 日报 Day80</title>
    <url>/undefined/2025-01-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>无论遭遇什么，都别灰心丧气，乐观地面对它、积极地解决它，明天才有更好的故事。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P276-278 第九章：代理与反射</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、- has(): has()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line"> <span class="title function_">has</span>(<span class="params">target, property</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;has()&#x27;</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy; </span><br><span class="line"><span class="comment">// has() </span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>返回值<br>has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<br> property in proxy<br> property in Object.create(proxy)<br> with(proxy) {(property);}<br> Reflect.has(proxy, property)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> property：引用的目标对象上的字符串键属性。</li>
<li>捕获器不变式<br>如果 target.property 存在且不可配置，则处理程序必须返回 true。<br>如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</li>
</ol>
<ul>
<li>defineProperty(): defineProperty()捕获器会在 Object.defineProperty()中被调用。对应的反射 API 方法为 Reflect.defineProperty()。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line"> <span class="title function_">defineProperty</span>(<span class="params">target, property, descriptor</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty()&#x27;</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proxy, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span> &#125;); </span><br><span class="line"><span class="comment">// defineProperty()</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol>
<li>返回值<br>defineProperty()必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<br> Object.defineProperty(proxy, property, descriptor)<br> Reflect.defineProperty(proxy, property, descriptor)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> property：引用的目标对象上的字符串键属性。<br> descriptor：包含可选的 enumerable、configurable、writable、value、get 和 set<br>定义的对象。</li>
<li>捕获器不变式<br>如果目标对象不可扩展，则无法定义属性。<br>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。<br>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</li>
</ol>
<ul>
<li>getOwnPropertyDescriptor(): getOwnPropertyDescriptor()捕获器会在 Object.getOwnPropertyDescriptor()中被调用。对应的反射 API 方法为 Reflect.getOwnPropertyDescriptor()。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line"> <span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getOwnPropertyDescriptor()&#x27;</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor()</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol>
<li>返回值<br>getOwnPropertyDescriptor()必须返回对象，或者在属性不存在时返回 undefined。</li>
<li>拦截的操作<br> Object.getOwnPropertyDescriptor(proxy, property)<br> Reflect.getOwnPropertyDescriptor(proxy, property)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> property：引用的目标对象上的字符串键属性。</li>
<li>捕获器不变式<br>如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。<br>如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象。<br>如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存在的对象。<br>如果 target.property 不存在且 target 不可扩展，则处理程序必须返回 undefined 表示该属性不存在。<br>如果 target.property 不存在，则处理程序不能返回表示该属性可配置的对象</li>
</ol>
<ul>
<li>deleteProperty(): deleteProperty()捕获器会在 delete 操作符中被调用。对应的反射 API 方法为 Reflect.deleteProperty()。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123; </span><br><span class="line"> <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;deleteProperty()&#x27;</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(...<span class="variable language_">arguments</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">foo</span> </span><br><span class="line"><span class="comment">// deleteProperty()</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol>
<li>返回值<br>deleteProperty()必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<br> delete proxy.property<br> delete proxy[property]<br> Reflect.deleteProperty(proxy, property)</li>
<li>捕获器处理程序参数<br> target：目标对象。<br> property：引用的目标对象上的字符串键属性。</li>
<li>捕获器不变式<br>如果自有的 target.property 存在且不可配置，则处理程序不能删除这个属性。</li>
</ol>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-01 日报 Day84</title>
    <url>/undefined/2025-02-01/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>只要自己沉得住气，那些看似不起波澜的日复一日，终会在未来的某天里，让你看到坚持的意义。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P290-292 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、理解参数: ECMAScript 函数的参数跟大多数其他语言不同。ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。<br>之所以会这样，主要是因为 ECMAScript 函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。事实上，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。<br>arguments 对象是一个类数组对象（但不是 Array 的实例），因此可以使用中括号语法访问其中的元素（第一个参数是 arguments[0]，第二个参数是 arguments[1]）。而要确定传进来多少个参数，可以访问 arguments.length 属性。<br>在下面的例子中，sayHi()函数的第一个参数叫 name：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以通过 arguments[0]取得相同的参数值。因此，把函数重写成不声明参数也可以：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + <span class="variable language_">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + <span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在重写后的代码中，没有命名参数。name 和 message 参数都不见了，但函数照样可以调用。这就表明，ECMAScript 函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在 ECMAScript 中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。<br>也可以通过 arguments 对象的 length 属性检查传入的参数个数。下面的例子展示了在每调用一个函数时，都会打印出传入的参数个数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">howManyArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">howManyArgs</span>(); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="number">12</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>, <span class="literal">true</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>还有一个必须理解的重要方面，那就是 arguments 对象可以跟命名参数一起使用，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + <span class="number">10</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>arguments 对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个 doAdd()函数把第二个参数的值重写为 10。因为 arguments 对象的值会自动同步到对应的命名参数，所以修改 arguments[1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。另外还要记住一点：如果只传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。<br>2、箭头函数中的参数: 如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(<span class="number">5</span>); <span class="comment">// 5 </span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="title function_">bar</span>(<span class="number">5</span>); <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure></div>
<p>注意 ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。<br>2、没有重载: ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，ECMAScript 函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。<br>如果在 ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addSomeNumber</span>(<span class="params">num</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">100</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addSomeNumber</span>(<span class="params">num</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">200</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">addSomeNumber</span>(<span class="number">100</span>); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-02 日报 Day85</title>
    <url>/undefined/2025-02-02/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>这个世界上，从来就没有人能替你成长，未来要靠自己去奋力争取。只有自己有伞，才能少被雨淋。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P293-296 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、默认参数值: 实现默认参数的一种常用方式就是检测某个参数是否等于 undefined，如果是则意味着没有传这个参数，那就给它赋一个值：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> name = (<span class="keyword">typeof</span> name !== <span class="string">&#x27;undefined&#x27;</span>) ? name : <span class="string">&#x27;Henry&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry VIII&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>ECMAScript 6 之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价的 ES6 写法，只要在函数定义中的参数后面用&#x3D;就可以为参数赋一个默认值：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>给参数传 undefined 相当于没有传值，不过这样可以利用多个独立的默认值：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry VIII&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="literal">undefined</span>, <span class="string">&#x27;VI&#x27;</span>)); <span class="comment">// &#x27;King Henry VI&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟 ES5 严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) &#123; </span><br><span class="line"> name = <span class="string">&#x27;Louis&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;<span class="variable language_">arguments</span>[<span class="number">0</span>]&#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King undefined&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> romanNumerals = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> ordinality = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNumerals</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="comment">// 每次调用后递增</span></span><br><span class="line"> <span class="keyword">return</span> romanNumerals[ordinality++]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = getNumerals()</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry I&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>(<span class="string">&#x27;Louis&#x27;</span>, <span class="string">&#x27;XVI&#x27;</span>)); <span class="comment">// &#x27;King Louis XVI&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry II&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// &#x27;King Henry III&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">makeKing</span> = (<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) =&gt; <span class="string">`King <span class="subst">$&#123;name&#125;</span>`</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// King Henry</span></span><br></pre></td></tr></table></figure></div>
<p>2、默认参数作用域与暂时性死区: 因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。<br>给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// King Henry VIII</span></span><br></pre></td></tr></table></figure></div>
<p>因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = name</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">makeKing</span>()); <span class="comment">// King Henry Henry</span></span><br></pre></td></tr></table></figure></div>
<p>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第一个参数会报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = numerals, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>参数也存在于自己的作用域中，它们不能引用函数体的作用域：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = defaultNumeral</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> defaultNumeral = <span class="string">&#x27;VIII&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3、参数扩展与收集: </p>
<ul>
<li>扩展参数: 在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。假设有如下函数定义，它会将所有传入的参数累加起来：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> sum = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; ++i) &#123; </span><br><span class="line">    sum += <span class="variable language_">arguments</span>[i]; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
这个函数希望将所有加数逐个传进来，然后通过迭代 arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 apply()方法：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getSum.<span class="title function_">apply</span>(<span class="literal">null</span>, values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div>
但在 ECMAScript 6 中，可以通过扩展操作符极为简洁地实现这种操作。对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。<br>比如，使用扩展操作符可以将前面例子中的数组像这样直接传给函数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div>
因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(-<span class="number">1</span>, ...values)); <span class="comment">// 9 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...values, <span class="number">5</span>)); <span class="comment">// 15 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(-<span class="number">1</span>, ...values, <span class="number">5</span>)); <span class="comment">// 14 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])); <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countArguments</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">countArguments</span>(-<span class="number">1</span>, ...values); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">countArguments</span>(...values, <span class="number">5</span>); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">countArguments</span>(-<span class="number">1</span>, ...values, <span class="number">5</span>); <span class="comment">// 6 </span></span><br><span class="line"><span class="title function_">countArguments</span>(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProduct</span>(<span class="params">a, b, c = <span class="number">1</span></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> a * b * c; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getSum</span> = (<span class="params">a, b, c = <span class="number">0</span></span>) =&gt; &#123; </span><br><span class="line"> <span class="keyword">return</span> a + b + c; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProduct</span>(...[<span class="number">1</span>,<span class="number">2</span>])); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProduct</span>(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 6 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProduct</span>(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])); <span class="comment">// 6 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...[<span class="number">0</span>,<span class="number">1</span>])); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])); <span class="comment">// 3 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
4、收集参数: 在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...values</span>) &#123; </span><br><span class="line"> <span class="comment">// 顺序累加 values 中的所有值</span></span><br><span class="line"> <span class="comment">// 初始值的总和为 0 </span></span><br><span class="line"> <span class="keyword">return</span> values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></div>
收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getProduct</span>(<span class="params">...values, lastValue</span>) &#123;&#125; </span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ignoreFirst</span>(<span class="params">firstValue, ...values</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(values); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">ignoreFirst</span>(); <span class="comment">// [] </span></span><br><span class="line"><span class="title function_">ignoreFirst</span>(<span class="number">1</span>); <span class="comment">// [] </span></span><br><span class="line"><span class="title function_">ignoreFirst</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2] </span></span><br><span class="line"><span class="title function_">ignoreFirst</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></div>
箭头函数虽然不支持 arguments 对象，但支持收集参数的定义方式，因此也可以实现与使用arguments 一样的逻辑：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">getSum</span> = (<span class="params">...values</span>) =&gt; &#123; </span><br><span class="line"> <span class="keyword">return</span> values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></div>
另外，使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...values</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 3 </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// [1, 2, 3] </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(values); <span class="comment">// [1, 2, 3] </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-03 日报 Day86</title>
    <url>/undefined/2025-02-03/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>读过书的人眼界会开阔许多，他们见过世间的多样性，最终选择的更可能是自己想要的、认可的生活。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P297-299 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、函数声明和函数表达式: 本章到现在一直没有把函数声明和函数表达式区分得很清楚。事实上，JavaScript 引擎在加载数据时对它们是区别对待的。JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作函数声明提升（function declaration hoisting）。在执行代码时，JavaScript 引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部。如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会出错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会出错。这并不是因为使用 let 而导致的，使用 var 关键字也会碰到同样的问题：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>2、函数作为值: 因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">someFunction</span>(someArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add10</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">callSomeFunction</span>(add10, <span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">callSomeFunction</span>(getGreeting, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// &quot;Hello, Nicholas&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">object1, object2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Zachary&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, <span class="attr">age</span>: <span class="number">29</span> &#125;,</span><br><span class="line">];</span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Nicholas</span></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// Zachary</span></span><br></pre></td></tr></table></figure></div>

<p>3、函数内部: 函数内部存在两个特殊的对象：arguments 和 this。ECMAScript 6 又新增了 new.target 属性。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 arguments.callee 就可以让函数逻辑与函数名解耦：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-05 日报 Day88</title>
    <url>/undefined/2025-02-05/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>无论听了多少忠告，你的人生最终还是要靠自己去创造，靠自己去领悟，靠自己去努力，靠自己去坚持。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P304-311 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、函数表达式: 定义函数有两种方式：函数声明和函数表达式。函数声明是这样的：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, arg2</span>) &#123; </span><br><span class="line"> <span class="comment">// 函数体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。这意味着函数声明可以出现在调用它的代码之后：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>(); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个例子不会抛出错误，因为 JavaScript 引擎会先读取函数声明，然后再执行代码。<br>第二种创建函数的方式就是函数表达式。函数表达式有几种不同的形式，最常见的是这样的：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) &#123; </span><br><span class="line"> <span class="comment">// 函数体 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// Error! function doesn&#x27;t exist yet </span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎意料：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 千万别这样做！</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yo!&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>不过，如果把上面的函数声明换成函数表达式就没问题了：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没问题 </span></span><br><span class="line"><span class="keyword">let</span> sayHi; </span><br><span class="line"><span class="keyword">if</span> (condition) &#123; </span><br><span class="line"> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Yo!&quot;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2、递归: 递归函数通常的形式是一个函数通过名称调用自己，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num - <span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个函数赋值给其他变量，就会出问题：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherFactorial = factorial; </span><br><span class="line">factorial = <span class="literal">null</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherFactorial</span>(<span class="number">4</span>)); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></div>
<p>在写递归函数时使用 arguments.callee 可以避免这个问题。<br>arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可以使用命名函数表达式（named function expression）达到目的。比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> num * <span class="title function_">f</span>(num - <span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>3、尾调用优化: ECMAScript 6 规范新增了一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 ES6 优化之前，执行这个例子会在内存中发生如下操作。<br>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。<br>(2) 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。<br>(3) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。<br>(4) 执行 innerFunction 函数体，计算其返回值。<br>(5) 将返回值传回 outerFunction，然后 outerFunction 再返回值。<br>(6) 将栈帧弹出栈外。<br>在 ES6 优化之后，执行这个例子会在内存中发生如下操作。<br>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。<br>(2) 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction。<br>(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction的返回值。<br>(4) 弹出 outerFunction 的栈帧。<br>(5) 执行到 innerFunction 函数体，栈帧被推到栈上。<br>(6) 执行 innerFunction 函数体，计算其返回值。<br>(7) 将 innerFunction 的栈帧弹出栈外。<br>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。<br>4、尾调用优化的条件: 尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：<br> 代码在严格模式下执行；<br> 外部函数的返回值是对尾调用函数的调用；<br> 尾调用函数返回后不需要执行额外的逻辑；<br> 尾调用函数不是引用外部函数作用域中自由变量的闭包<br>下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; </span><br><span class="line"><span class="comment">// 无优化：尾调用没有返回 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="title function_">innerFunction</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> innerFunctionResult = <span class="title function_">innerFunction</span>(); </span><br><span class="line"> <span class="keyword">return</span> innerFunctionResult; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>().<span class="title function_">toString</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> foo = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> foo; &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 下面是几个符合尾调用优化条件的例子：</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>; </span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>(a + b); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (a &lt; b) &#123; </span><br><span class="line"> <span class="keyword">return</span> a; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">innerFunction</span>(a + b); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">condition</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> condition ? <span class="title function_">innerFunctionA</span>() : <span class="title function_">innerFunctionB</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。<br>4、可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归计算斐波纳契数列的函数：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> n; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib</span>(n - <span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">1</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">2</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">3</span>)); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">5</span>)); <span class="comment">// 5 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fib</span>(<span class="number">6</span>)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></div>
<p>当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; </span><br><span class="line"><span class="comment">// 基础框架 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">fibImpl</span>(<span class="number">0</span>, <span class="number">1</span>, n); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibImpl</span>(<span class="params">a, b, n</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> a; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">fibImpl</span>(b, a + b, n - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>5、闭包: 匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction()函数，注意其中加粗的代码：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> value1 = object1[propertyName]; </span><br><span class="line"> <span class="keyword">let</span> value2 = object2[propertyName]; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>理解作用域链创建和使用的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。<br>在函数执行时，要从作用域链中查找变量，以便读、写值。来看下面的代码：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">compare</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></div>
<p>注意 因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。V8 等优化的 JavaScript 引擎会努力回收被闭包困住的内存，不过我们还是建议在使用闭包时要谨慎。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-04 日报 Day87</title>
    <url>/undefined/2025-02-04/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在这个世上，一个人想要成功，就一定要去做难一点的事。比如不断地学习，不断地成长，不断地进步。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P300-303 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、this: 另一个特殊的对象是 this，它在标准函数和箭头函数中有不同的行为。<br>在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在网页的全局上下文中调用函数时，this 指向 windows）。在箭头函数中，this引用的是定义箭头函数的上下文。下来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// &#x27;red&#x27; </span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor; </span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">// &#x27;blue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sayColor</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>); </span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// &#x27;red&#x27; </span></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor; </span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>有读者知道，在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">royaltyName</span> = <span class="string">&#x27;Henry&#x27;</span>; </span><br><span class="line"> <span class="comment">// this 引用 King 的实例</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">royaltyName</span>), <span class="number">1000</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Queen</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">royaltyName</span> = <span class="string">&#x27;Elizabeth&#x27;</span>; </span><br><span class="line"> <span class="comment">// this 引用 window 对象</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">royaltyName</span>); &#125;, <span class="number">1000</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// Henry </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Queen</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>2、caller: ECMAScript 5 也会给函数对象上添加一个属性：caller。虽然 ECMAScript 3 中并没有定义，但所有浏览器除了早期版本的 Opera 都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="title function_">inner</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(inner.<span class="property">caller</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure></div>
<p>以上代码会显示 outer()函数的源代码。这是因为 ourter()调用了 inner()，inner.caller指向 outer()。如果要降低耦合度，则可以通过 arguments.callee.caller 来引用同样的值：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="title function_">inner</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">caller</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure></div>
<p>3、new.target: ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span> </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// King instantiated using &quot;new&quot; </span></span><br><span class="line"><span class="title class_">King</span>(); <span class="comment">// Error: King must be instantiated using &quot;new&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>4、函数属性与方法: ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length 和 prototype。其中，length 属性保存函数定义的命名参数的个数，如下例所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayName.<span class="property">length</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="property">length</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi.<span class="property">length</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
<p>prototype 属性也许是 ECMAScript 核心中最有趣的部分。prototype 是保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实例共享。这个属性在自定义类型时特别重要。（相关内容已经在第 8 章详细介绍过了。）在 ECMAScript 5中，prototype 属性是不可枚举的，因此使用 for-in 循环不会返回这个属性。<br>函数还有两个方法：apply()和 call()。这两个方法都会以指定的 this 值来调用函数，即会设置调用函数时函数体内 this 对象的值。apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callSum1</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> sum.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callSum2</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> sum.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">callSum1</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">callSum2</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></div>
<p>到底是使用 apply()还是 call()，完全取决于怎么给要调用的函数传参更方便。如果想直接传 arguments对象或者一个数组，那就用 apply()；否则，就用 call()。<br>apply()和 call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 this值的能力。考虑下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// red </span></span><br><span class="line">sayColor.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// red </span></span><br><span class="line">sayColor.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">// red </span></span><br><span class="line">sayColor.<span class="title function_">call</span>(o); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></div>
<p>使用 call()或 apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。<br>ECMAScript 5 出于同样的目的定义了一个新方法：bind()。bind()方法会创建一个新的函数实例，其 this 值会被绑定到传给 bind()的对象。比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.<span class="title function_">bind</span>(o); </span><br><span class="line"><span class="title function_">objectSayColor</span>(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-09 日报 Day92</title>
    <url>/undefined/2025-02-09/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>那些成长的磨砺、奋斗的汗水，都将化作你的底气和格局，累积成你向上攀爬的阶梯，支撑着你看到更高处的风景。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P332-338 第十一章：期约与异步函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Promise.prototype.catch(): Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype.then(null, onRejected)。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(); </span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="keyword">function</span>(<span class="params">e</span>) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;rejected&#x27;</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的方式是一样的：</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected); <span class="comment">// rejected </span></span><br><span class="line">p.<span class="title function_">catch</span>(onRejected); <span class="comment">// rejected</span></span><br></pre></td></tr></table></figure></div>
<p>Promise.prototype.catch()返回一个新的期约实例：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">catch</span>(); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>2、Promise.prototype.finally(): Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(); </span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;Finally!&#x27;</span>) </span><br><span class="line">&#125; </span><br><span class="line">p1.<span class="title function_">finally</span>(onFinally); <span class="comment">// Finally </span></span><br><span class="line">p2.<span class="title function_">finally</span>(onFinally); <span class="comment">// Finally </span></span><br><span class="line"><span class="comment">// Promise.prototype.finally()方法返回一个新的期约实例：</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 这里都会原样后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>(); </span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="literal">undefined</span>); </span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); </span><br><span class="line"><span class="keyword">let</span> p6 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p7 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line"><span class="keyword">let</span> p8 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure></div>
<p>如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); </span><br><span class="line"><span class="keyword">let</span> p10 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>()); </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: undefined </span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br></pre></td></tr></table></figure></div>
<p>返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 忽略解决的值</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">finally</span>( </span><br><span class="line"> <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>), <span class="number">100</span>))); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2), <span class="number">200</span>); </span><br><span class="line"><span class="comment">// 200 毫秒后：</span></span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure></div>
<p>3、非重入期约方法: 当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy）特性。下面的例子演示了这个特性：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建解决的期约</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(); </span><br><span class="line"><span class="comment">// 添加解决处理程序</span></span><br><span class="line"><span class="comment">// 直觉上，这个处理程序会等期约一解决就执行</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onResolved handler&#x27;</span>)); </span><br><span class="line"><span class="comment">// 同步输出，证明 then()已经返回</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then() returns&#x27;</span>); </span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// then() returns </span></span><br><span class="line"><span class="comment">// onResolved handler</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，在一个解决期约上调用 then()会把 onResolved 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在 then()后面的同步代码一定先于处理程序执行。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve; </span><br><span class="line"><span class="comment">// 创建一个期约并将解决函数保存在一个局部变量中</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; </span><br><span class="line"> synchronousResolve = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1: invoking resolve()&#x27;</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2: resolve() returns&#x27;</span>); </span><br><span class="line"> &#125;; </span><br><span class="line">&#125;); </span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4: then() handler executes&#x27;</span>)); </span><br><span class="line"><span class="title function_">synchronousResolve</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3: synchronousResolve() returns&#x27;</span>); </span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// 1: invoking resolve() </span></span><br><span class="line"><span class="comment">// 2: resolve() returns </span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns </span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让它出列时才会执行。<br>非重入适用于 onResolved&#x2F;onRejected 处理程序、catch()处理程序和 finally()处理程序。下面的例子演示了这些处理程序都只能异步执行：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1.then() onResolved&#x27;</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1.then() returns&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(); </span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2.then() onRejected&#x27;</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2.then() returns&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(); </span><br><span class="line">p3.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3.catch() onRejected&#x27;</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3.catch() returns&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(); </span><br><span class="line">p4.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4.finally() onFinally&#x27;</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p4.finally() returns&#x27;</span>); </span><br><span class="line"><span class="comment">// p1.then() returns </span></span><br><span class="line"><span class="comment">// p2.then() returns </span></span><br><span class="line"><span class="comment">// p3.catch() returns </span></span><br><span class="line"><span class="comment">// p4.finally() returns </span></span><br><span class="line"><span class="comment">// p1.then() onResolved </span></span><br><span class="line"><span class="comment">// p2.then() onRejected </span></span><br><span class="line"><span class="comment">// p3.catch() onRejected </span></span><br><span class="line"><span class="comment">// p4.finally() onFinally</span></span><br></pre></td></tr></table></figure></div>
<p>4、邻近处理程序的执行顺序: 如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 then()、catch()还是 finally()添加的处理程序都是如此。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">1</span>)); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">2</span>)); </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">3</span>)); </span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">4</span>)); </span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">5</span>)); </span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">6</span>)); </span><br><span class="line"><span class="comment">// 5 </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line">p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">7</span>)); </span><br><span class="line">p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">8</span>)); </span><br><span class="line"><span class="comment">// 7 </span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure></div>
<p>5、传递解决值和拒绝理由: 到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 JSON 是发送第二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失败的网络请求也应该把 HTTP 状态码传给 onRejected 处理程序。<br>在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一参数。下面的例子展示了上述传递过程：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// foo </span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// foo </span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure></div>
<p>6、拒绝契约与拒绝错误处理: 拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>))); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;); </span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;); </span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;rejected&gt;: Error: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: Error: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;rejected&gt;: Error: foo </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br></pre></td></tr></table></figure></div>
<p>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：Promise.resolve().then()的错误最后才出现，这是因为它需要在运行时消息队列中添加处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。<br>这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过 throw()关键字抛出错误时，JavaScript 运行时的错误处理机制会停止执行抛出错误之后的任何指令：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 这一行不会执行</span></span><br><span class="line"><span class="comment">// Uncaught Error: foo</span></span><br></pre></td></tr></table></figure></div>
<p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: foo</span></span><br></pre></td></tr></table></figure></div>
<p>如本章前面的 Promise.reject()示例所示，异步错误只能通过异步的 onRejected 处理程序捕获：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure></div>
<p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 try&#x2F;catch 在执行函数中捕获错误：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"> <span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br></pre></td></tr></table></figure></div>
<p>then()和 catch()的 onRejected 处理程序在语义上相当于 try&#x2F;catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;begin synchronous execution&#x27;</span>); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught error&#x27;</span>, e); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;continue synchronous execution&#x27;</span>); </span><br><span class="line"><span class="comment">// begin synchronous execution </span></span><br><span class="line"><span class="comment">// caught error Error: foo </span></span><br><span class="line"><span class="comment">// continue synchronous execution </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;begin asynchronous execution&#x27;</span>); </span><br><span class="line"> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught error&#x27;</span>, e); </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;continue asynchronous execution&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// begin asynchronous execution </span></span><br><span class="line"><span class="comment">// caught error Error: bar </span></span><br><span class="line"><span class="comment">// continue asynchronous execution</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-06 日报 Day89</title>
    <url>/undefined/2025-02-06/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>成长是一个不断自我提升的过程，而学会自我负责，意味着我们终于有能力去正视现实并不断努力提升自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P312-319 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、this 对象: 在闭包中使用 this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 this 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则 this 在非严格模式下等于 window，在严格模式下等于 undefined。如果作为某个对象的方法调用，则 this 等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着 this 会指向 window，除非在严格模式下 this 是 undefined。不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">identity</span> = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  <span class="attr">identity</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  <span class="title function_">getIdentityFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">identity</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">getIdentityFunc</span>()()); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>前面介绍过，每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。但是，如果把 this 保存到闭包可以访问的另一个变量中，则是行得通的。比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">identity</span> = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  <span class="attr">identity</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  <span class="title function_">getIdentityFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> that.<span class="property">identity</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">getIdentityFunc</span>()()); <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">identity</span> = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  <span class="attr">identity</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">  <span class="title function_">getIdentity</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">identity</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">object.<span class="title function_">getIdentity</span>(); <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">object.<span class="title function_">getIdentity</span>(); <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.<span class="property">getIdentity</span> = object.<span class="property">getIdentity</span>)(); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>2、内存泄露: 由于 IE 在 IE9 之前对 JScript 对象和 COM 对象使用了不同的垃圾回收机制（第 4 章讨论过），所以闭包在这些旧版本 IE 中可能会导致问题。在这些版本的 IE 中，把 HTML 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;someElement&quot;</span>);</span><br><span class="line">  element.<span class="property">onclick</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码创建了一个闭包，即 element 元素的事件处理程序。而这个处理程序又创建了一个循环引用。匿名函数引用着 assignHandler()的活动对象，阻止了对 element 的引用计数归零。只要这个匿名函数存在，element 的引用计数就至少等于 1。也就是说，内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;someElement&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> id = element.<span class="property">id</span>;</span><br><span class="line">  element.<span class="property">onclick</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">  element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个修改后的版本中，闭包改为引用一个保存着 element.id 的变量 id，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含 element。即使闭包没有直接引用 element，包含函数的活动对象上还是保存着对它的引用。因此，必须再把 element 设置为 null。这样就解除了对这个 COM 对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收。<br>3、立即调用函数表达式（IIFE，Immediately Invoked Function Expression）:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 块级作用域</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内嵌块级作用域</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">  divs[i].<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>4、私有变量: JavaScript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现，比如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">publicMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person.<span class="title function_">setName</span>(<span class="string">&quot;Greg&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Greg&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>5、静态私有变量: 特权方法可以通过私有作用域定义私有变量和函数来实现:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="title class_">MyObject</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有和特权方法</span></span><br><span class="line">  <span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">publicMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title class_">Person</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person1.<span class="title function_">setName</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Michael&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Michael&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Michael&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>6、模块模式: Douglas Crockford 所说的模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（singleton）就是只有一个实例的对象。按照惯例，JavaScript 是通过对象字面量来创建单例对象的，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = &#123;</span><br><span class="line">  <span class="attr">name</span>: value,</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法的代码</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">publicProperty</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">publicMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-10 日报 Day93</title>
    <url>/undefined/2025-02-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>如果自己的才华还撑不起梦想时，就应该静下来学习；如果自己的能力还驾驭不了目标时，就应该沉下心来历练。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P339-344 第十一章：期约与异步函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、期约连锁与期约合成: 多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</p>
<ul>
<li>期约连锁: 把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法（then()、catch()和 finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。比如：</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;second&quot;</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;third&quot;</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fourth&quot;</span>));</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="comment">// fourth</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p1 executor&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p2 executor&quot;</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">() =&gt;</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p3 executor&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">() =&gt;</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;p4 executor&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把生成期约的代码提取到一个工厂函数中，就可以写成这样：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delayedResolve</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">delayedResolve</span>(<span class="string">&quot;p1 executor&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&quot;p2 executor&quot;</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&quot;p3 executor&quot;</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">delayedResolve</span>(<span class="string">&quot;p4 executor&quot;</span>));</span><br><span class="line"><span class="comment">// p1 executor（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 executor（4 秒后）</span></span><br></pre></td></tr></table></figure></div>

<p>每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。假如这种情况下不使用期约，那么前面的代码可能就要这样写了：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delayedExecute</span>(<span class="params">str, callback = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">    callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">delayedExecute</span>(<span class="string">&quot;p1 callback&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">delayedExecute</span>(<span class="string">&quot;p2 callback&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">delayedExecute</span>(<span class="string">&quot;p3 callback&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">delayedExecute</span>(<span class="string">&quot;p4 callback&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// p1 callback（1 秒后）</span></span><br><span class="line"><span class="comment">// p2 callback（2 秒后）</span></span><br><span class="line"><span class="comment">// p3 callback（3 秒后）</span></span><br><span class="line"><span class="comment">// p4 callback（4 秒后）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 心明眼亮的开发者会发现，这不正是期约所要解决的回调地狱问题吗？</span></span><br><span class="line"><span class="comment">// 因为 then()、catch()和 finally()都返回期约，所以串联这些方法也很直观。下面的例子同时使用这 3 个实例方法：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;initial promise rejects&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>();</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject handler&quot;</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve handler&quot;</span>))</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally handler&quot;</span>));</span><br><span class="line"><span class="comment">// initial promise rejects</span></span><br><span class="line"><span class="comment">// reject handler</span></span><br><span class="line"><span class="comment">// resolve handler</span></span><br><span class="line"><span class="comment">// finally handler</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>期约图: 因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。<br>下面的例子展示了一种期约有向图，也就是二叉树：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A </span></span><br><span class="line"><span class="comment">// / \ </span></span><br><span class="line"><span class="comment">// B C </span></span><br><span class="line"><span class="comment">// /\ /\ </span></span><br><span class="line"><span class="comment">// D E F G </span></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A&#x27;</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">let</span> B = A.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B&#x27;</span>)); </span><br><span class="line"><span class="keyword">let</span> C = A.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C&#x27;</span>)); </span><br><span class="line">B.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;D&#x27;</span>)); </span><br><span class="line">B.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;E&#x27;</span>)); </span><br><span class="line">C.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;F&#x27;</span>)); </span><br><span class="line">C.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;G&#x27;</span>)); </span><br><span class="line"><span class="comment">// A </span></span><br><span class="line"><span class="comment">// B </span></span><br><span class="line"><span class="comment">// C </span></span><br><span class="line"><span class="comment">// D </span></span><br><span class="line"><span class="comment">// E </span></span><br><span class="line"><span class="comment">// F </span></span><br><span class="line"><span class="comment">// G</span></span><br></pre></td></tr></table></figure></div>
注意，日志的输出语句是对二叉树的层序遍历。如前所述，期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。<br>树只是期约图的一种形式。考虑到根节点不一定唯一，且多个期约也可以组合成一个期约（通过下一节介绍的 Promise.all()和 Promise.race()），所以有向非循环图是体现期约连锁可能性的最准确表达。</li>
<li>Promise.all()和Promise.race(): Promise 类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和 Promise.race()。而合成后期约的行为取决于内部期约的行为。<br>Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">3</span>, <span class="number">4</span>]); </span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 Promise.resolve() </span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([]); </span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">all</span>(); </span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合成的期约只会在每个包含的期约都解决之后才解决：</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;all() resolved!&#x27;</span>)); </span><br><span class="line"><span class="comment">// all() resolved!（大约 1 秒后）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝：</span></span><br><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="comment">// 一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt; </span></span><br><span class="line"><span class="comment">// Uncaught (in promise) undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>) </span><br><span class="line">]); </span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入 </span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason)); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure></div>
Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接受一个可迭代对象，返回一个新期约:<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="number">3</span>, <span class="number">4</span>]); </span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 new Promise(() =&gt; &#123;&#125;) </span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([]); </span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">race</span>(); </span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3 </span></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4 </span></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">5</span>), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>), </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>) </span><br><span class="line">]); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5</span></span><br></pre></td></tr></table></figure></div>
如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 Promise.all()类似，合成的期约会静默处理所有包含期约的拒绝操作，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入</span></span><br><span class="line"><span class="comment">// 拒绝处理程序，第二个期约的拒绝也</span></span><br><span class="line"><span class="comment">// 会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([ </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>), </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>)) </span><br><span class="line">]); </span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure></div></li>
<li>串行期约合成: 期约的另一个主要特性：异步产生值并将其传给处理程序。基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">addFive</span>(<span class="title function_">addTwo</span>(<span class="title function_">addThree</span>(x))); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addTen</span>(<span class="number">7</span>)); <span class="comment">// 17</span></span><br></pre></td></tr></table></figure></div>
在这个例子中，有 3 个函数基于一个值合成为一个函数。类似地，期约也可以像这样合成起来，渐进地消费一个值，并返回一个结果：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x) </span><br><span class="line"> .<span class="title function_">then</span>(addTwo) </span><br><span class="line"> .<span class="title function_">then</span>(addThree) </span><br><span class="line"> .<span class="title function_">then</span>(addFive); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Array.prototype.reduce()可以写成更简洁的形式：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> [addTwo, addThree, addFive] </span><br><span class="line"> .<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.<span class="title function_">then</span>(fn), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。这个通用的合成函数可以这样实现：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.<span class="title function_">then</span>(fn), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x)) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> addTen = <span class="title function_">compose</span>(addTwo, addThree, addFive);</span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">8</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-08 日报 Day91</title>
    <url>/undefined/2025-02-08/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在孤独的时候忍耐，在迷茫的时候坚持，在暂时困难的日子里善待自己，在黑暗的深夜里为自己点一盏心灯。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P322-331 第十一章：期约与异步函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 6 新增了正式的 Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用 async 和 await 关键字定义异步函数的机制。<br>异步编程: 特别是在 JavaScript 这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。<br>重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。<br>2、同步与异步: 同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。<br>以前的异步编程模式:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure></div>

<p>这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。setTimeout 可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000 毫秒之后，JavaScript 运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 JavaScript 代码就完全不可见了。还有一点，double()函数在 setTimeout 成功调度异步操作之后会立即退出。</p>
<ul>
<li>异步返回值: 假设 setTimeout 操作会返回一个有用的值。给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value, callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>(value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I was given: <span class="subst">$&#123;x&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I was given: 6（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure></div>

<p>这里的 setTimeout 调用告诉 JavaScript 运行时在 1000 毫秒之后把一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。</p>
<ul>
<li>失败处理: 异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value, success, failure</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Must provide number as first argument&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">success</span>(<span class="number">2</span> * value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">failure</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">successCallback</span> = (<span class="params">x</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Success: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">failureCallback</span> = (<span class="params">e</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line"><span class="title function_">double</span>(<span class="string">&quot;b&quot;</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 6（大约 1000 毫秒之后）</span></span><br><span class="line"><span class="comment">// Failure: Must provide number as first argument（大约 1000 毫秒之后）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>嵌套异步回调: 如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这就要求嵌套回调：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">value, success, failure</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Must provide number as first argument&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">success</span>(<span class="number">2</span> * value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">failure</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">successCallback</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">double</span>(x, <span class="function">(<span class="params">y</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Success: <span class="subst">$&#123;y&#125;</span>`</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">failureCallback</span> = (<span class="params">e</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line"><span class="title function_">double</span>(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 12（大约 2000 毫秒之后）</span></span><br></pre></td></tr></table></figure></div>

<p>3、期约: 期约是对尚不存在结果的一个替身。ECMAScript 6 增加了对 Promises&#x2F;A+规范的完善支持，即 Promise 类型。一经推出，Promise 就大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持 ES6 期约，很多其他浏览器 API（如fetch()和 Battery Status API）也以期约为基础。<br>期约基础: ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解释器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt; </span></span><br></pre></td></tr></table></figure></div>
<p>之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 SyntaxError。</p>
<ul>
<li>期约状态机: 在把一个期约实例传给 console.log()时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一：<br> 待定（pending）<br> 兑现（fulfilled，有时候也称为“解决”，resolved）<br> 拒绝（rejected）</li>
<li>解决值、拒绝理由及期约用例: 期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</li>
<li>通过执行函数控制期约状态: 由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve()和 reject()。调用resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误（后面会讨论这个错误）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>()); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt; </span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>()); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught error (in promise)</span></span><br></pre></td></tr></table></figure></div>
执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;executor&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&#x27;promise initialized&#x27;</span>); </span><br><span class="line"><span class="comment">// executor </span></span><br><span class="line"><span class="comment">// promise initialized</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 setTimeout 可以推迟切换状态：</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>)); </span><br><span class="line"><span class="comment">// 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">// 无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销了。</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="title function_">resolve</span>();</span><br><span class="line"> <span class="title function_">reject</span>(); <span class="comment">// 没有效果</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure></div>
为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 setTimeout 设置一个10 秒钟后无论如何都会拒绝期约的回调：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(reject, <span class="number">10000</span>); <span class="comment">// 10 秒后调用 reject() </span></span><br><span class="line"> <span class="comment">// 执行函数的逻辑</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">11000</span>, p); <span class="comment">// 11 秒后再检查状态</span></span><br><span class="line"><span class="comment">// (After 10 seconds) Uncaught error </span></span><br><span class="line"><span class="comment">// (After 11 seconds) Promise &lt;rejected&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>Promise.resolve(): 期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>()); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br></pre></td></tr></table></figure></div>
这个解决的期约的值对应着传给 Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); </span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 3 </span></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)); </span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 4</span></span><br></pre></td></tr></table></figure></div>
对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">7</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); </span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p))); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个幂等性会保留传入期约的状态：</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p === <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></li>
<li>Promise.reject(): 与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 try&#x2F;catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>()); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise &lt;rejected&gt;: 3 </span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, e)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>())); </span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>同步&#x2F;异步执行的二元性:<br>Promise 的设计很大程度上会导致一种完全不同于 JavaScript 的计算模式。下面的例子完美地展示了这一点，其中包含了两种模式下抛出错误的情形：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// Error: foo </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure></div>
第一个 try&#x2F;catch 抛出并捕获了错误，第二个 try&#x2F;catch 抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。<br>在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try&#x2F;catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。</li>
</ul>
<p>4、期约的实例方法: 期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p>
<ul>
<li>实现Thenable接口: 在 ECMAScript 暴露的异步结构中，任何对象都有一个 then()方法。这个方法被认为实现了Thenable 接口。下面的例子展示了实现这一接口的最简单的类：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThenable</span> &#123; </span><br><span class="line"> <span class="title function_">then</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>Promise.prototype.then(): Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onResolved</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>)); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>)); </span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">onResolved</span>(<span class="string">&#x27;p1&#x27;</span>), </span><br><span class="line"> <span class="function">() =&gt;</span> <span class="title function_">onRejected</span>(<span class="string">&#x27;p1&#x27;</span>)); </span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">onResolved</span>(<span class="string">&#x27;p2&#x27;</span>), </span><br><span class="line"> <span class="function">() =&gt;</span> <span class="title function_">onRejected</span>(<span class="string">&#x27;p2&#x27;</span>)); </span><br><span class="line"><span class="comment">//（3 秒后）</span></span><br><span class="line"><span class="comment">// p1 resolved </span></span><br><span class="line"><span class="comment">// p2 rejected</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onResolved</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>)); </span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>)); </span><br><span class="line"><span class="comment">// 非函数处理程序会被静默忽略，不推荐</span></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="string">&#x27;gobbeltygook&#x27;</span>); </span><br><span class="line"><span class="comment">// 不传 onResolved 处理程序的规范写法</span></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title function_">onRejected</span>(<span class="string">&#x27;p2&#x27;</span>)); </span><br><span class="line"><span class="comment">// p2 rejected（3 秒后）</span></span><br><span class="line"><span class="comment">// Promise.prototype.then()方法返回一个新的期约实例：</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 若调用 then()时不传处理程序，则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;resolved&gt;: foo </span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="literal">undefined</span>); </span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有显式的返回值，则 Promise.resolve()会包装这个值：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p7 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); </span><br><span class="line"><span class="keyword">let</span> p9 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>()); </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出异常会返回拒绝的期约：</span></span><br><span class="line"><span class="keyword">let</span> p10 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt; baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：</span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用 then()时不传处理程序则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(); </span><br><span class="line"><span class="comment">// Uncaught (in promise) foo</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: foo </span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="literal">undefined</span>); </span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;); </span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p5); <span class="comment">// Promise &lt;resolved&gt;: undefined </span></span><br><span class="line"><span class="comment">// 这些都一样</span></span><br><span class="line"><span class="keyword">let</span> p6 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> p7 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p6); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p7); <span class="comment">// Promise &lt;resolved&gt;: bar </span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); </span><br><span class="line"><span class="keyword">let</span> p9 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>()); </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p8); <span class="comment">// Promise &lt;pending&gt; </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p9); <span class="comment">// Promise &lt;rejected&gt;: undefined </span></span><br><span class="line"><span class="keyword">let</span> p10 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: baz </span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title class_">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p11); <span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-07 日报 Day90</title>
    <url>/undefined/2025-02-07/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>那些读过的书，都会在未来铺就你脚下的路；学过的每一点知识，都会在某一天，以意想不到的方式回馈到你身上。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P320-321 第十章：函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、模块增强模式: 另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">let</span> object = <span class="keyword">new</span> <span class="title class_">CustomType</span>();</span><br><span class="line">  <span class="comment">// 添加特权/公有属性和方法</span></span><br><span class="line">  object.<span class="property">publicProperty</span> = <span class="literal">true</span>;</span><br><span class="line">  object.<span class="property">publicMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">privateFunction</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> application = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BaseComponent</span>());</span><br><span class="line">  <span class="comment">// 创建局部变量保存实例</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="keyword">new</span> ]();</span><br><span class="line">  <span class="comment">// 公共接口</span></span><br><span class="line">  app.<span class="property">getComponentCount</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.<span class="property">registerComponent</span> = <span class="keyword">function</span> (<span class="params">component</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      components.<span class="title function_">push</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回实例</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>
<p>2、函数是 JavaScript 编程中最有用也最通用的工具。ECMAScript 6 新增了更加强大的语法特性，从而让开发者可以更有效地使用函数。<br> 函数表达式与函数声明是不一样的。函数声明要求写出函数名称，而函数表达式并不需要。没有名称的函数表达式也被称为匿名函数。<br> ES6 新增了类似于函数表达式的箭头函数语法，但两者也有一些重要区别。<br> JavaScript 中函数定义与调用时的参数极其灵活。arguments 对象，以及 ES6 新增的扩展操作符，<br>可以实现函数定义和调用的完全动态化。<br> 函数内部也暴露了很多对象和引用，涵盖了函数被谁调用、使用什么调用，以及调用时传入了什么参数等信息。<br> JavaScript 引擎可以优化符合尾调用条件的函数，以节省栈空间。<br> 闭包的作用域链中包含自己的一个变量对象，然后是包含函数的变量对象，直到全局上下文的变量对象。<br> 通常，函数作用域及其中的所有变量在函数执行完毕后都会被销毁。<br> 闭包在被函数返回之后，其作用域会一直保存在内存中，直到闭包被销毁。<br> 函数可以在创建之后立即调用，执行其中代码之后却不留下对函数的引用。<br> 立即调用的函数表达式如果不在包含作用域中将返回值赋给一个变量，则其包含的所有变量都会被销毁。<br> 虽然 JavaScript 没有私有对象属性的概念，但可以使用闭包实现公共方法，访问位于包含作用域中定义的变量。<br> 可以访问私有变量的公共方法叫作特权方法。<br> 特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-11 日报 Day94</title>
    <url>/undefined/2025-02-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你向往什么，就向着那里努力；你期待什么，就全身心地追寻。只要你不认输，就没有什么能阻挡你的脚步。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P345-352 第十一章：期约与异步函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、期约扩展: ES6 期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而 ECMAScript 规范却未涉及的两个特性：期约取消和进度追踪。</p>
<ul>
<li>期约取消: 我们经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。这时候如果能够取消期约就好了。某些第三方库，比如 Bluebird，就提供了这个特性。实际上，TC39 委员会也曾准备增加这个特性，但相关提案最终被撤回了。结果，ES6 期约被认为是“激进的”：只要期约的逻辑开始执行，就没有办法阻止它执行到完成。<br>实际上，可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。这可以用到 Kevin Smith 提到的“取消令牌”（cancel token）。生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CancelToken</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">cancelFn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cancelFn</span>(resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个类包装了一个期约，把解决方法暴露给了 cancelFn 参数。这样，外部代码就可以向构造函数中传入一个函数，从而控制什么情况下可以取消期约。这里期约是令牌类的公共成员，因此可以给它添加处理程序以取消期约。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span>&gt;</span>Start<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">CancelToken</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">constructor</span>(<span class="params">cancelFn</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">cancelFn</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;delay cancelled&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">resolve</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> startButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#start&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> cancelButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#cancel&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">cancellableDelayedResolve</span>(<span class="params">delay</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;set delay&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> id = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;delayed resolve&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">resolve</span>();</span></span><br><span class="line"><span class="language-javascript">      &#125;, delay);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> cancelToken = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="function">(<span class="params">cancelCallback</span>) =&gt;</span></span></span><br><span class="line"><span class="language-javascript">        cancelButton.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, cancelCallback)</span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">      cancelToken.<span class="property">promise</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(id));</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  startButton.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> <span class="title function_">cancellableDelayedResolve</span>(<span class="number">1000</span>));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>每次单击“Start”按钮都会开始计时，并实例化一个新的 CancelToken 的实例。此时，“Cancel”按钮一旦被点击，就会触发令牌实例中的期约解决。而解决之后，单击“Start”按钮设置的超时也会被取消。<br>2、期约进度通知: 执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。某些情况下，监控期约的执行进度会很有用。ECMAScript 6 期约并不支持进度追踪，但是可以通过扩展来实现。一种实现方式是扩展 Promise 类，为它添加 notify()方法，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrackablePromise</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line">    <span class="variable language_">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">executor</span>(resolve, reject, <span class="function">(<span class="params">status</span>) =&gt;</span> &#123;</span><br><span class="line">        notifyHandlers.<span class="title function_">map</span>(<span class="function">(<span class="params">handler</span>) =&gt;</span> <span class="title function_">handler</span>(status));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">notifyHandlers</span> = notifyHandlers;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">notifyHandler</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">notifyHandlers</span>.<span class="title function_">push</span>(notifyHandler);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样，TrackablePromise 就可以在执行函数中使用 notify()函数了。可以像下面这样使用这个函数来实例化一个期约：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">TrackablePromise</span>(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">notify</span>(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">countdown</span>(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>这个期约会连续 5 次递归地设置 1000 毫秒的超时。每个超时回调都会调用 notify()并传入状态值。假设通知处理程序简单地这样写：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">TrackablePromise</span>(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">notify</span>(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">countdown</span>(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">notify</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;progress:&quot;</span>, x));</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;completed&quot;</span>));</span><br><span class="line"><span class="comment">// （约 1 秒后）80% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后）60% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后）40% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后）20% remaining</span></span><br><span class="line"><span class="comment">// （约 5 秒后）completed</span></span><br></pre></td></tr></table></figure></div>

<p>notify()函数会返回期约，所以可以连缀调用，连续添加处理程序。多个处理程序会针对收到的每条消息分别执行一遍，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">notify</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;a:&quot;</span>, x)).<span class="title function_">notify</span>(<span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;b:&quot;</span>, x)</span><br><span class="line">);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;completed&quot;</span>));</span><br><span class="line"><span class="comment">// （约 1 秒后） a: 80% remaining</span></span><br><span class="line"><span class="comment">// （约 1 秒后） b: 80% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后） a: 60% remaining</span></span><br><span class="line"><span class="comment">// （约 2 秒后） b: 60% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后） a: 40% remaining</span></span><br><span class="line"><span class="comment">// （约 3 秒后） b: 40% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后） a: 20% remaining</span></span><br><span class="line"><span class="comment">// （约 4 秒后） b: 20% remaining</span></span><br><span class="line"><span class="comment">// （约 5 秒后） completed</span></span><br></pre></td></tr></table></figure></div>

<p>3、异步函数: 异步函数，也称为“async&#x2F;await”（语法关键字），是 ES6 期约模式在 ECMAScript 函数中的应用。<br>下面来看一个最简单的例子，这个期约在超时之后会解决为一个值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure></div>

<p>这个期约在 1000 毫秒之后解决为数值 3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个解决处理程序：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序定义为一个函数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.<span class="title function_">then</span>(handler); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>异步函数: ES8 的 async&#x2F;await 旨在解决利用异步结构组织代码的问题。为此，ECMAScript 对函数进行了扩展，为其增加了两个新关键字：async 和 await。<br>async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Qux</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通 JavaScript 函数的正常行为。正如下面的例子所示，foo()函数仍然会在后面的指令之前被求值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>

<p>不过，异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这个值会被 Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>当然，直接返回一个期约对象也是一样的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>异步函数的返回值期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then()的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。下面的代码演示了这些情况：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 返回一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&quot;bar&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 返回一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;qux&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">qux</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure></div>

<p>与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>不过，拒绝期约的错误不会被异步函数捕获：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Attach a rejected handler to the returned promise</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>await: 因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。来看下面这个本章开始就出现过的例子：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>注意，await 关键字会暂停执行异步函数后面的代码，让出 JavaScript 运行时的执行线程。这个行为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。<br>await 关键字的用法与 JavaScript 的一元操作一样。它可以单独使用，也可以在表达式中使用，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步打印&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 异步打印&quot;bar&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 1000 毫秒后异步打印&quot;baz&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>();</span><br><span class="line"><span class="comment">// baz（1000 毫秒后）</span></span><br></pre></td></tr></table></figure></div>

<p>await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 等待一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> [<span class="string">&quot;bar&quot;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 等待一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> thenable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">baz</span>();</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 等待一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;qux&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">qux</span>();</span><br><span class="line"><span class="comment">// qux</span></span><br><span class="line"><span class="comment">// 等待会抛出错误的同步操作，会返回拒绝的期约：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如前面的例子所示，单独的 Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用 await 则会释放（unwrap）错误值（将拒绝期约返回）：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 这行代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>await 的限制: await 关键字必须在异步函数中使用，不能在顶级上下文如<script>标签或模块中使用。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 立即调用的异步函数表达式</span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>));</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>await 关键字也只能直接出现在异步函数的定义中。在同步函数内部使用 await 会抛出 SyntaxError。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许：await 出现在了箭头函数中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">syncFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数声明中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">syncFn</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：await 出现在了同步函数表达式中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> syncFn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">syncFn</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：IIFE 使用同步函数表达式或箭头函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">qux</span>(<span class="params"></span>) &#123;</span><br><span class="line"> (<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>)); &#125;)();</span><br><span class="line"> (<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;qux&#x27;</span>)))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-12 日报 Day95</title>
    <url>/undefined/2025-02-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>真正厉害的人，是在避开车马喧嚣后，还可以在心中修篱种菊；是在面对不如意时，还可以戒掉抱怨，学会自愈。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P353-360 第十一章：期约与异步函数</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、停止和恢复执行: 使用 await 关键字之后的区别其实比看上去的还要微妙一些。比如，下面的例子中按顺序调用了 3 个函数，但它们的输出结果顺序是相反的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="title function_">bar</span>(); </span><br><span class="line"><span class="title function_">baz</span>(); </span><br><span class="line"><span class="comment">// baz </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure></div>
<p>async&#x2F;await 中真正起作用的是 await。async 关键字，无论从哪方面来看，都不过是一个标识符。毕竟，异步函数如果不包含 await 关键字，其执行基本上跟普通函数没有什么区别：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>要完全理解 await 关键字，必须知道它并非只是等待一个值可用那么简单。JavaScript 运行时在碰到 await 关键字时，会记录在哪里暂停执行。等到 await 右边的值可用了，JavaScript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。<br>因此，即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); </span><br><span class="line"> <span class="keyword">await</span> <span class="literal">null</span>; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>); </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
<p>控制台中输出结果的顺序很好地解释了运行时的工作过程：<br>(1) 打印 1；<br>(2) 调用异步函数 foo()；<br>(3)（在 foo()中）打印 2；<br>(4)（在 foo()中）await 关键字暂停执行，为立即可用的值 null 向消息队列中添加一个任务；<br>(5) foo()退出；<br>(6) 打印 3；<br>(7) 同步线程的代码执行完毕；<br>(8) JavaScript 运行时从消息队列中取出任务，恢复异步函数执行；<br>(9)（在 foo()中）恢复执行，await 取得 null 值（这里并没有使用）；<br>(10)（在 foo()中）打印 4；<br>(11) foo()返回。<br>如果 await 后面是一个期约，则问题会稍微复杂一些。此时，为了执行异步函数，实际上会有两个任务被添加到消息队列并被异步求值。下面的例子虽然看起来很反直觉，但它演示了真正的执行顺序：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">8</span>)); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="number">6</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>); </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>); </span><br><span class="line"><span class="title function_">bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>); </span><br><span class="line"><span class="comment">// 123458967</span></span><br></pre></td></tr></table></figure></div>
<p>本例中的 Promise.resolve(8)只会生成一个异步任务。因此在新版浏览器中，这个示例的输出结果为 123458967。实际开发中，对于并行的异步操作我们通常更关注结果，而不依赖执行顺序。<br>2、异步函数策略: </p>
<ul>
<li>实现sleep(): <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1500</span>); <span class="comment">// 暂停约 1500 毫秒</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="comment">// 1502</span></span><br></pre></td></tr></table></figure></div></li>
<li>利用平行执行: 如果使用 await 时不留心，则很可能错过平行加速的机会。来看下面的例子，其中顺序等待了 5 个随机的超时：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(); </span><br><span class="line"> &#125;, delay)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">0</span>); </span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">1</span>); </span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">2</span>); </span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">3</span>); </span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">randomDelay</span>(<span class="number">4</span>); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="comment">// 0 finished </span></span><br><span class="line"><span class="comment">// 1 finished </span></span><br><span class="line"><span class="comment">// 2 finished </span></span><br><span class="line"><span class="comment">// 3 finished </span></span><br><span class="line"><span class="comment">// 4 finished </span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(); </span><br><span class="line"> &#125;, delay)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">randomDelay</span>(i); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="comment">// 0 finished </span></span><br><span class="line"><span class="comment">// 1 finished </span></span><br><span class="line"><span class="comment">// 2 finished </span></span><br><span class="line"><span class="comment">// 3 finished </span></span><br><span class="line"><span class="comment">// 4 finished </span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。<br>如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(); </span><br><span class="line"> &#125;, delay)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"> <span class="keyword">const</span> p0 = <span class="title function_">randomDelay</span>(<span class="number">0</span>); </span><br><span class="line"> <span class="keyword">const</span> p1 = <span class="title function_">randomDelay</span>(<span class="number">1</span>); </span><br><span class="line"> <span class="keyword">const</span> p2 = <span class="title function_">randomDelay</span>(<span class="number">2</span>); </span><br><span class="line"> <span class="keyword">const</span> p3 = <span class="title function_">randomDelay</span>(<span class="number">3</span>); </span><br><span class="line"> <span class="keyword">const</span> p4 = <span class="title function_">randomDelay</span>(<span class="number">4</span>); </span><br><span class="line"> <span class="keyword">await</span> p0; </span><br><span class="line"> <span class="keyword">await</span> p1; </span><br><span class="line"> <span class="keyword">await</span> p2; </span><br><span class="line"> <span class="keyword">await</span> p3; </span><br><span class="line"> <span class="keyword">await</span> p4; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 4 finished </span></span><br><span class="line"><span class="comment">// 3 finished </span></span><br><span class="line"><span class="comment">// 0 finished </span></span><br><span class="line"><span class="comment">// 2 finished </span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(); </span><br><span class="line"> &#125;, delay)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"> <span class="keyword">const</span> promises = <span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">randomDelay</span>(i)); </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123; </span><br><span class="line"> <span class="keyword">await</span> p; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="comment">// 4 finished </span></span><br><span class="line"><span class="comment">// 2 finished </span></span><br><span class="line"><span class="comment">// 1 finished </span></span><br><span class="line"><span class="comment">// 0 finished </span></span><br><span class="line"><span class="comment">// 3 finished </span></span><br><span class="line"><span class="comment">// 877ms elapsed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，虽然期约没有按照顺序执行，但 await 按顺序收到了每个期约的值：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="comment">// 延迟 0~1000 毫秒</span></span><br><span class="line"> <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>); </span><br><span class="line"> <span class="title function_">resolve</span>(id); </span><br><span class="line"> &#125;, delay)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>(); </span><br><span class="line"> <span class="keyword">const</span> promises = <span class="title class_">Array</span>(<span class="number">5</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">randomDelay</span>(i)); </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`awaited <span class="subst">$&#123;<span class="keyword">await</span> p&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// 1 finished </span></span><br><span class="line"><span class="comment">// 2 finished </span></span><br><span class="line"><span class="comment">// 4 finished </span></span><br><span class="line"><span class="comment">// 3 finished </span></span><br><span class="line"><span class="comment">// 0 finished </span></span><br><span class="line"><span class="comment">// awaited 0 </span></span><br><span class="line"><span class="comment">// awaited 1 </span></span><br><span class="line"><span class="comment">// awaited 2 </span></span><br><span class="line"><span class="comment">// awaited 3 </span></span><br><span class="line"><span class="comment">// awaited 4 </span></span><br><span class="line"><span class="comment">// 645ms elapsed</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>串行执行期约:<br>使用 async&#x2F;await，期约连锁会变得很简单：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123; </span><br><span class="line">    x = <span class="keyword">await</span> <span class="title function_">fn</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure></div>
这里，await 直接传递了每个函数的返回值，结果通过迭代产生。当然，这个例子并没有使用期约，如果要使用期约，则可以把所有函数都改成异步函数。这样它们就都返回期约了：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123; </span><br><span class="line">    x = <span class="keyword">await</span> <span class="title function_">fn</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure></div></li>
<li>栈追踪与内存管理: <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(fooPromiseExecutor); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); </span><br><span class="line"><span class="comment">// Uncaught (in promise) bar </span></span><br><span class="line"><span class="comment">// setTimeout </span></span><br><span class="line"><span class="comment">// setTimeout (async) </span></span><br><span class="line"><span class="comment">// fooPromiseExecutor </span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure></div>
3、小结： 期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。<br>异步函数是将期约应用于 JavaScript 函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代 JavaScript 工具箱中最重要的工具之一。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-13 日报 Day96</title>
    <url>/undefined/2025-02-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生本来就有无数种可能，有少年得志，也有大器晚成。多一点耐心，认真做好自己，踏实前行，所有美好定会不期而遇。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P361-371 第十二章：BOM</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、虽然 ECMAScript 把浏览器对象模型（BOM，Browser Object Model）描述为 JavaScript 的核心，但实际上 BOM 是使用 JavaScript 开发 Web 应用程序的核心。BOM 提供了与网页无关的浏览器功能对象。<br>2、window 对象: BOM 的核心是 window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是 ECMAScript 中的 Global 对象，另一个就是浏览器窗口的 JavaScript 接口。这意味着网页中定义的所有对象、变量和函数都以 window 作为其 Global 对象，都可以访问其上定义的 parseInt()等全局方法</p>
<ul>
<li>Global 作用域: 因为 window 对象被复用为 ECMAScript 的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sayAge</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">age</span>); <span class="comment">// 29</span></span><br><span class="line"><span class="title function_">sayAge</span>(); <span class="comment">// 29</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayAge</span>(); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure></div>

<p>如果在这里使用 let 或 const 替代 var，则不会把变量添加给全局对象：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sayAge</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">age</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">sayAge</span>(); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayAge</span>(); <span class="comment">// TypeError: window.sayAge is not a function</span></span><br></pre></td></tr></table></figure></div>

<p>记住，JavaScript 中有很多对象都暴露在全局作用域中，比如 location 和 navigator（本章后面都会讨论），因而它们也是 window 对象的属性。</p>
<ul>
<li>窗口关系: top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top（都等于 window）。最上层的 window 如果不是通过 window.open()打开的，那么其 name 属性就不会包含值。</li>
<li>窗口位置与像素比: window 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 screenLeft 和 screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素。<br>可以使用 moveTo()和 moveBy()方法移动窗口。这两个方法都接收两个参数，其中 moveTo()接收要移动到的新位置的绝对坐标 x 和 y；而 moveBy()则接收相对当前位置在两个方向上移动的像素数。<br>比如：<br>&#x2F;&#x2F; 把窗口移动到左上角<br>window.moveTo(0,0);<br>&#x2F;&#x2F; 把窗口向下移动 100 像素<br>window.moveBy(0, 100);<br>&#x2F;&#x2F; 把窗口移动到坐标位置(200, 300)<br>window.moveTo(200, 300);<br>&#x2F;&#x2F; 把窗口向左移动 50 像素<br>window.moveBy(-50, 0);<br>举个例子，手机屏幕的物理分辨率可能是 1920×1080，但因为其像素可能非常小，所以浏览器就需要将其分辨率降为较低的逻辑分辨率，比如 640×320。这个物理像素与 CSS 像素之间的转换比率由 window.devicePixelRatio 属性提供。对于分辨率从 1920×1080 转换为 640×320 的设备，window. devicePixelRatio 的值就是 3。这样一来，12 像素（CSS 像素）的文字实际上就会用 36 像素的物理像素来显示。<br>window.devicePixelRatio 实际上与每英寸像素数（DPI，dots per inch）是对应的。DPI 表示单位像素密度，而 window.devicePixelRatio 表示物理像素与逻辑像素之间的缩放系数。</li>
<li>窗口大小: 所有现代浏览器都支持 4 个属性：innerWidth、innerHeight、outerWidth 和 outerHeight。outerWidth 和 outerHeight 返回浏览器窗口自身的大小（不管是在最外层 window 上使用，还是在窗格<frame>中使用）。innerWidth 和 innerHeight 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。<br>document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回页面视口的宽度和高度。<br>浏览器窗口自身的精确尺寸不好确定，但可以确定页面视口的大小，如下所示</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">  pageHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>) &#123;</span><br><span class="line">    pageWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">    pageHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">    pageHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意 手机视口的概念比较复杂，有各种各样的问题。如果读者在做移动开发，推荐阅读 Peter-Paul Koch 发表在 QuirksMode 网站上的文章“A Tale of Two Viewports— Part Two”。</p>
<ul>
<li>视口位置: 浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文档。度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset&#x2F;window.scrollX 和 window.pageYoffset&#x2F;window.scrollY。<br>可以使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。这 3 个方法都接收表示相对视口距离的 x 和 y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</li>
<li>导航与打开新窗口: window.open()方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。这个方法接收 4 个参数：要加载的 URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前 3 个参数，最后一个参数只有在不打开新窗口时才会使用。<br>如果 window.open()的第二个参数是一个已经存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开 URL。下面是一个例子：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与&lt;a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;/&gt;相同</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.wrox.com/&quot;</span>, <span class="string">&quot;topFrame&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>执行这行代码的结果就如同用户点击了一个 href 属性为”<a class="link"   href="http://www.wrox.com" ,target/">http://www.wrox.com&quot;，target <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 属性为”topFrame”的链接。如果有一个窗口名叫”topFrame”，则这个窗口就会打开这个 URL；否则就会打开一个新窗口并将其命名为”topFrame”。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top 或_blank。</p>
<ul>
<li>弹出窗口:</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(</span><br><span class="line">  <span class="string">&quot;http://www.wrox.com/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;wroxWindow&quot;</span>,</span><br><span class="line">  <span class="string">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(</span><br><span class="line">  <span class="string">&quot;http://www.wrox.com/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;wroxWindow&quot;</span>,</span><br><span class="line">  <span class="string">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line">wroxWin.<span class="title function_">resizeTo</span>(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line"><span class="comment">// 移动</span></span><br><span class="line">wroxWin.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">wroxWin.<span class="title function_">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(</span><br><span class="line">  <span class="string">&quot;http://www.wrox.com/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;wroxWindow&quot;</span>,</span><br><span class="line">  <span class="string">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="title function_">alert</span>(wroxWin.<span class="property">opener</span> === <span class="variable language_">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>在某些浏览器中，每个标签页会运行在独立的进程中。如果一个标签页打开了另一个，而 window 对象需要跟另一个标签页通信，那么标签便不能运行在独立的进程中。在这些浏览器中，可以将新打开的标签页的 opener 属性设置为 null，表示新打开的标签页可以运行在独立的进程中。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(</span><br><span class="line">  <span class="string">&quot;http://www.wrox.com/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;wroxWindow&quot;</span>,</span><br><span class="line">  <span class="string">&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;</span></span><br><span class="line">);</span><br><span class="line">wroxWin.<span class="property">opener</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>

<p>把 opener 设置为 null 表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。这个连接一旦切断，就无法恢复了。</p>
<ul>
<li>安全限制:</li>
<li>弹窗屏蔽程序: 所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。在浏览器屏蔽弹窗时，可能会发生一些事。如果浏览器内置的弹窗屏蔽程序阻止了弹窗，那么 window.open()很可能会返回 null。此时，只要检查这个方法的返回值就可以知道弹窗是否被屏蔽了，比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.wrox.com&quot;</span>, <span class="string">&quot;_blank&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;The popup was blocked!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> wroxWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.wrox.com&quot;</span>, <span class="string">&quot;_blank&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;The popup was blocked!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>定时器: JavaScript 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。setTimeout()用于指定在一定时间后执行某些代码，而 setInterval()用于指定每隔一段时间执行某些代码。<br>setTimeout()方法通常接收两个参数：要执行的代码和在执行回调函数前等待的时间（毫秒）。第一个参数可以是包含 JavaScript 代码的字符串（类似于传给 eval()的字符串）或者一个函数，比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 1 秒后显示警告框</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div>

<p>第二个参数是要等待的毫秒数，而不是要执行代码的确切时间。JavaScript 是单线程的，所以每次只能执行一段代码。为了调度不同代码的执行，JavaScript 维护了一个任务队列。其中的任务会按照添加到队列的先后顺序执行。setTimeout()的第二个参数只是告诉 JavaScript 引擎在指定的毫秒数过后把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待前面的任务执行完才能执行。</p>
<p>调用 setTimeout()时，会返回一个表示该超时排期的数值 ID。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 clearTimeout()方法并传入超时 ID，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置超时任务</span></span><br><span class="line"><span class="keyword">let</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="number">1000</span>); </span><br><span class="line"><span class="comment">// 取消超时任务</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timeoutId);</span><br></pre></td></tr></table></figure></div>
<p>setInterval()与 setTimeout()的使用方法类似，只不过指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。setInterval()同样可以接收两个参数：要执行的代码（字符串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）。下面是一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>), <span class="number">10000</span>);</span><br></pre></td></tr></table></figure></div>

<p>注意 这里的关键点是，第二个参数，也就是间隔时间，指的是向队列添加新任务之前等待的时间。比如，调用 setInterval()的时间为 01:00:00，间隔时间为 3000 毫秒。这意味着 01:00:03 时，浏览器会把任务添加到执行队列。浏览器不关心这个任务什么时候执行或者执行要花多长时间。因此，到了 01:00:06，它会再向队列中添加一个任务。由此可看出，执行时间短、非阻塞的回调函数比较适合 setInterval()。</p>
<p>setInterval()方法也会返回一个循环定时 ID，可以用于在未来某个时间点上取消循环定时。要取消循环定时，可以调用 clearInterval()并传入定时 ID。相对于 setTimeout()而言，取消定时的能力对 setInterval()更加重要。毕竟，如果一直不管它，那么定时任务会一直执行到页面卸载。下面是一个常见的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>, intervalId = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> max = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">let</span> incrementNumber = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> num++; </span><br><span class="line"> <span class="comment">// 如果达到最大值，则取消所有未执行的任务</span></span><br><span class="line"> <span class="keyword">if</span> (num == max) &#123; </span><br><span class="line"> <span class="built_in">clearInterval</span>(intervalId); </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Done&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">intervalId = <span class="built_in">setInterval</span>(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>系统对话框: 使用 alert()、confirm()和 prompt()方法，可以让浏览器调用系统对话框向用户显示消息。这些对话框与浏览器中显示的网页无关，而且也不包含 HTML。它们的外观由操作系统或者浏览器决定，无法使用 CSS 设置。此外，这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。</li>
<li>alert(): alert()方法用于显示一个消息框，包含一个消息和一个“确定”按钮。这个方法接收一个参数：要显示的消息。比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>confirm(): confirm()方法用于显示一个消息框，包含一个消息和两个按钮：“确定”和“取消”。这个方法接收一个参数：要显示的消息。比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">confirm</span>(<span class="string">&quot;Are you sure?&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>要知道用户单击了 OK 按钮还是 Cancel 按钮，可以判断 confirm()方法的返回值：true 表示单击了 OK 按钮，false 表示单击了 Cancel 按钮或者通过单击某一角上的 X 图标关闭了确认框。确认框的典型用法如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">confirm</span>(<span class="string">&quot;Are you sure?&quot;</span>)) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;I&#x27;m so glad you&#x27;re sure!&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;I&#x27;m sorry to hear you&#x27;re not sure.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>prompt(): prompt()方法用于显示一个消息框，包含一个消息、一个文本输入框和两个按钮：“确定”和“取消”。这个方法接收两个参数：要显示的消息和默认值。比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">prompt</span>(<span class="string">&quot;What is your name?&quot;</span>, <span class="string">&quot;John Doe&quot;</span>);</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-15 日报 Day98</title>
    <url>/undefined/2025-02-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你想要的一切，终究只能靠自己；你想要的人生，也只能自己给自己。愿你靠着努力，成为自己想成为的那个人，奔向向往的生活。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P379-381 第十二章：BOM</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、screen对象: window 的另一个属性 screen 对象，是为数不多的几个在编程中很少用的 JavaScript 对象。这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度。<br>2、history对象: history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性，所以每个 window 都有自己的 history 对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退。</p>
<ul>
<li>导航: go()方法可以在历史记录中前进或后退指定的页数。正数表示前进，负数表示后退。比如： <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前进两页</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></div>
go()有两个简写方法：back()和 forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和前进按钮：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.<span class="title function_">back</span>(); </span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.<span class="title function_">forward</span>();</span><br></pre></td></tr></table></figure></div>
history 对象还有一个 length 属性，表示历史记录中有多个条目。<br>3、历史状态管理:<br>hashchange 会在页面 URL 的散列变化时被触发，开发者可以在此时执行某些操作。而状态管理API 则可以让开发者改变浏览器 URL 而不会加载新页面。为此，可以使用 history.pushState()方法。这个方法接收 3 个参数：一个 state 对象、一个新状态的标题和一个（可选的）相对 URL。例如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stateObject = &#123;<span class="attr">foo</span>:<span class="string">&quot;bar&quot;</span>&#125;; </span><br><span class="line">history.<span class="title function_">pushState</span>(stateObject, <span class="string">&quot;My title&quot;</span>, <span class="string">&quot;baz.html&quot;</span>);</span><br></pre></td></tr></table></figure></div>
因为 pushState()会创建新的历史记录，所以也会相应地启用“后退”按钮。此时单击“后退”按钮，就会触发 window 对象上的 popstate 事件。popstate 事件的事件对象有一个 state 属性，其中包含通过 pushState()第一个参数传入的 state 对象：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> state = event.<span class="property">state</span>; </span><br><span class="line"> <span class="keyword">if</span> (state) &#123; <span class="comment">// 第一个页面加载时状态是 null </span></span><br><span class="line"> <span class="title function_">processState</span>(state); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
基于这个状态，应该把页面重置为状态对象所表示的状态（因为浏览器不会自动为你做这些）。记住，页面初次加载时没有状态。因此点击“后退”按钮直到返回最初页面时，event.state 会为 null。<br>可以通过 history.state 获取当前的状态对象，也可以使用 replaceState()并传入与<br>pushState()同样的前两个参数来更新状态。更新状态不会创建新历史记录，只会覆盖当前状态：<br>history.replaceState({newFoo: “newBar”}, “New title”);<br>传给 pushState()和 replaceState()的 state 对象应该只包含可以被序列化的信息。因此，DOM 元素之类并不适合放到状态对象里保存。</li>
</ul>
<p>注意 使用 HTML5 状态管理时，要确保通过 pushState()创建的每个“假”URL 背后都对应着服务器上一个真实的物理 URL。否则，单击“刷新”按钮会导致 404 错误。所有单页应用程序（SPA，Single Page Application）框架都必须通过服务器或客户端的某些配置解决这个问题。</p>
<p>4、浏览器对象模型（BOM，Browser Object Model）是以 window 对象为基础的，这个对象代表了浏览器窗口和页面可见的区域。window 对象也被复用为 ECMAScript 的 Global 对象，因此所有全局变量和函数都是它的属性，而且所有原生类型的构造函数和普通函数也都从一开始就存在于这个对象之上。本章讨论了 BOM 的以下内容。<br> 要引用其他 window 对象，可以使用几个不同的窗口指针。<br> 通过 location 对象可以以编程方式操纵浏览器的导航系统。通过设置这个对象上的属性，可以改变浏览器 URL 中的某一部分或全部。<br> 使用 replace()方法可以替换浏览器历史记录中当前显示的页面，并导航到新 URL。<br> navigator 对象提供关于浏览器的信息。提供的信息类型取决于浏览器，不过有些属性如userAgent 是所有浏览器都支持的。<br>BOM 中的另外两个对象也提供了一些功能。screen 对象中保存着客户端显示器的信息。这些信息通常用于评估浏览网站的设备信息。history 对象提供了操纵浏览器历史记录的能力，开发者可以确定历史记录中包含多少个条目，并以编程方式实现在历史记录中导航，而且也可以修改历史记录。</p>
<p>5、navigator对象属性:</p>
<ul>
<li>appName: 浏览器的名称</li>
<li>appVersion: 浏览器的版本号</li>
<li>buildId: 浏览器的构建编号</li>
<li>userAgent: 浏览器的用户代理字符串</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-16 日报 Day99</title>
    <url>/undefined/2025-02-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>该养精蓄锐时，别着急出人头地；该奋斗拼搏时，别企图一鸣惊人。因为通往成功最快的路，不是加速，而是脚踏实地地走好每一天。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P382-392 第十三章：客户端检测</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、客户端检测：</p>
<ul>
<li>能力检测: 能力检测（又称特性检测）即在 JavaScript 运行时中使用一套简单的检测逻辑，测试浏览器是否支持某种特性。这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可。能力检测的基本模式如下：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.<span class="property">propertyInQuestion</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 object.propertyInQuestion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>比如，IE5 之前的版本中没有 document.getElementById()这个 DOM 方法，但可以通过 document.all 属性实现同样的功能。为此，可以进行如下能力检测：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElement</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">getElementById</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">all</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="property">all</span>[id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;No way to retrieve element!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>安全能力检测:</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要这样做！错误的能力检测，只能检测到能力是否存在</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSortable</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !!object.<span class="property">sort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">isSortable</span>(&#123; <span class="attr">sort</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好一些，检测 sort 是不是函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSortable</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object.<span class="property">sort</span> == <span class="string">&quot;function&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不适用于 IE8 及更低版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasCreateElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="variable language_">document</span>.<span class="property">createElement</span> == <span class="string">&quot;function&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>基于能力检测进行浏览器分析: 使用能力检测而非用户代理检测的优点在于，伪造用户代理字符串很简单，而伪造能够欺骗能力检测的浏览器特性却很难。</li>
<li>检测特性: 可以按照能力将浏览器归类。如果你的应用程序需要使用特定的浏览器能力，那么最好集中检测所有能力，而不是等到用的时候再重复检测。比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测浏览器是否支持 Netscape 式的插件</span></span><br><span class="line"><span class="keyword">let</span> hasNSPlugins = !!(navigator.<span class="property">plugins</span> &amp;&amp; navigator.<span class="property">plugins</span>.<span class="property">length</span>);</span><br><span class="line"><span class="comment">// 检测浏览器是否具有 DOM Level 1 能力</span></span><br><span class="line"><span class="keyword">let</span> hasDOM1 = !!(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">getElementById</span> &amp;&amp;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">createElement</span> &amp;&amp;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">getElementsByTagName</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检测浏览器: 可以根据对浏览器特性的检测并与已知特性对比，确认用户使用的是什么浏览器。这样可以获得比用户代码嗅探（稍后讨论）更准确的结果。<br>下面来看一个例子，根据不同浏览器独有的行为推断出浏览器的身份。这里故意没有使用 navigator. userAgent 属性，后面会讨论它：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrowserDetector</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 测试条件编译</span></span><br><span class="line">    <span class="comment">// IE6~10 支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isIE_Gte6Lte10</span> = <span class="comment">/*@cc_on!@*/</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 测试 documentMode</span></span><br><span class="line">    <span class="comment">// IE7~11 支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isIE_Gte7Lte11</span> = !!<span class="variable language_">document</span>.<span class="property">documentMode</span>;</span><br><span class="line">    <span class="comment">// 测试 StyleMedia 构造函数</span></span><br><span class="line">    <span class="comment">// Edge 20 及以上版本支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isEdge_Gte20</span> = !!<span class="variable language_">window</span>.<span class="property">StyleMedia</span>;</span><br><span class="line">    <span class="comment">// 测试 Firefox 专有扩展安装 API</span></span><br><span class="line">    <span class="comment">// 所有版本的 Firefox 都支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isFirefox_Gte1</span> = <span class="keyword">typeof</span> <span class="title class_">InstallTrigger</span> !== <span class="string">&quot;undefined&quot;</span>;</span><br><span class="line">    <span class="comment">// 测试 chrome 对象及其 webstore 属性</span></span><br><span class="line">    <span class="comment">// Opera 的某些版本有 window.chrome，但没有 window.chrome.webstore</span></span><br><span class="line">    <span class="comment">// 所有版本的 Chrome 都支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isChrome_Gte1</span> = !!<span class="variable language_">window</span>.<span class="property">chrome</span> &amp;&amp; !!<span class="variable language_">window</span>.<span class="property">chrome</span>.<span class="property">webstore</span>;</span><br><span class="line">    <span class="comment">// Safari 早期版本会给构造函数的标签符追加&quot;Constructor&quot;字样，如：</span></span><br><span class="line">    <span class="comment">// window.Element.toString(); // [object ElementConstructor]</span></span><br><span class="line">    <span class="comment">// Safari 3~9.1 支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isSafari_Gte3Lte9_1</span> = <span class="regexp">/constructor/i</span>.<span class="title function_">test</span>(<span class="variable language_">window</span>.<span class="property">Element</span>);</span><br><span class="line">    <span class="comment">// 推送通知 API 暴露在 window 对象上</span></span><br><span class="line">    <span class="comment">// 使用默认参数值以避免对 undefined 调用 toString()</span></span><br><span class="line">    <span class="comment">// Safari 7.1 及以上版本支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isSafari_Gte7_1</span> = (<span class="function">(<span class="params">&#123; pushNotification = &#123;&#125; &#125; = &#123;&#125;</span>) =&gt;</span></span><br><span class="line">      pushNotification.<span class="title function_">toString</span>() == <span class="string">&quot;[object SafariRemoteNotification]&quot;</span>)(</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">safari</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 测试 addons 属性</span></span><br><span class="line">    <span class="comment">// Opera 20 及以上版本支持</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isOpera_Gte20</span> = !!<span class="variable language_">window</span>.<span class="property">opr</span> &amp;&amp; !!<span class="variable language_">window</span>.<span class="property">opr</span>.<span class="property">addons</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isIE</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isIE_Gte6Lte10</span> || <span class="variable language_">this</span>.<span class="property">isIE_Gte7Lte11</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEdge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isEdge_Gte20</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="title function_">isIE</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isFirefox</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isFirefox_Gte1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isChrome</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isChrome_Gte1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isSafari</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isSafari_Gte3Lte9_1</span> || <span class="variable language_">this</span>.<span class="property">isSafari_Gte7_1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isOpera</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isOpera_Gte20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>能力检测的局限: 通过检测一种或一组能力，并不总能确定使用的是哪种浏览器。</li>
</ul>
<p>2、用户代理检测: 用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。用户代理字符串包含在每个HTTP 请求的头部，在 JavaScript 中可以通过 navigator.userAgent 访问。在服务器端，常见的做法是根据接收到的用户代理字符串确定浏览器并执行相应操作。而在客户端，用户代理检测被认为是不可靠的，只应该在没有其他选项时再考虑。<br>用户代理字符串最受争议的地方就是，在很长一段时间里，浏览器都通过在用户代理字符串包含错误或误导性信息来欺骗服务器。要理解背后的原因，必须回顾一下自 Web 出现之后用户代理字符串的历史。</p>
<ul>
<li>用户代理的历史: HTTP 规范（1.0 和 1.1）要求浏览器应该向服务器发送包含浏览器名称和版本信息的简短字符串。<br>iOS 和 Android 移动操作系统上默认的浏览器都是基于 WebKit 的，因此具有与相应桌面浏览器一样的用户代理字符串。iOS 设备遵循以下基本格式：</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-18 日报 Day101</title>
    <url>/undefined/2025-02-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>成才之路不一定会创造人生奇迹，但一定要有奋发向上的轨迹；成才之路不一定非要跑得最快，但一定需要屡败屡战的韧性；成才之路不一定拥有鲜花掌声，但应进一寸有一寸的欢喜。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P401-413 第十四章：DOM</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。<br>2、节点层级: 任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的 HTML为例：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。</p>
<ul>
<li>Node类型: 每个节点都有 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示：<ul>
<li>Node.ELEMENT_NODE: 1</li>
<li>Node.ATTRIBUTE_NODE: 2</li>
<li>Node.TEXT_NODE: 3</li>
<li>Node.CDATA_SECTION_NODE: 4</li>
<li>Node.ENTITY_REFERENCE_NODE: 5</li>
<li>Node.ENTITY_NODE: 6</li>
<li>Node.PROCESSING_INSTRUCTION_NODE: 7</li>
<li>Node.COMMENT_NODE: 8</li>
<li>Node.DOCUMENT_NODE: 9</li>
<li>Node.DOCUMENT_TYPE_NODE: 10</li>
<li>Node.DOCUMENT_FRAGMENT_NODE: 11</li>
<li>Node.NOTATION_NODE: 12<br>nodeName与nodeValue: nodeName 与 nodeValue 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>)&#123; </span><br><span class="line"> value = someNode.<span class="property">nodeName</span>; <span class="comment">// 会显示元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
节点关系: 文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。在 HTML 中，<body>元素是<html>元素的子元素，而<html>元素则是<body>元素的父元素。<head>元素是<body>元素的同胞元素，因为它们有共同的父元素<html>。<br>每个节点都有一个 childNodes 属性，其中包含一个 NodeList 的实例。NodeList 是一个类数组对象，用于存储可以按位置存取的有序节点。注意，NodeList 并不是 Array 的实例，但可以使用中括号访问它的值，而且它也有 length 属性。NodeList 对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在 NodeList 中反映出来。我们通常说 NodeList 是实时的活动对象，而不是第一次访问时所获得内容的快照。<br>每个节点都有一个 parentNode 属性，指向其 DOM 树中的父元素。childNodes 中的所有节点都有同一个父元素，因此它们的 parentNode 属性都指向同一个节点。此外，childNodes 列表中的每个节点都是同一列表中其他节点的同胞节点。而使用 previousSibling 和 nextSibling 可以在这个列表的节点间导航。这个列表中第一个节点的 previousSibling 属性是 null，最后一个节点的nextSibling 属性也是 null，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nextSibling</span> === <span class="literal">null</span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Last node in the parent&#x27;s childNodes list.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.<span class="property">previousSibling</span> === <span class="literal">null</span>)&#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;First node in the parent&#x27;s childNodes list.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
因为所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法。最常用的方法是appendChild()，用于在 childNodes 列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。appendChild()方法返回新添加的节点，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(newNode); </span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(someNode.<span class="property">lastChild</span> == newNode); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 someNode 有多个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(someNode.<span class="property">firstChild</span>); </span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">firstChild</span>); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, <span class="literal">null</span>); </span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">lastChild</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 作为新的第一个子节点插入</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">firstChild</span>); </span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">firstChild</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 插入最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">lastChild</span>); </span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">childNodes</span>[someNode.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">2</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
所有节点类型还共享了两个方法。第一个是 cloneNode()，会返回与调用它的节点一模一样的节点。cloneNode()方法接收一个布尔值参数，表示是否深复制。在传入 true 参数时，会进行深复制，即复制节点及其整个子 DOM 树。如果传入 false，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。可以通过 appendChild()、insertBefore()或 replaceChild()方法把孤儿节点添加到文档中。以下面的 HTML 片段为例：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
如果myList保存着对这个<ul>元素的引用，则下列代码展示了使用cloneNode()方法的两种方式：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deepList = myList.<span class="title function_">cloneNode</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="title function_">alert</span>(deepList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 3（IE9 之前的版本）或 7（其他浏览器）</span></span><br><span class="line"><span class="keyword">let</span> shallowList = myList.<span class="title function_">cloneNode</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="title function_">alert</span>(shallowList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
本节要介绍的最后一个方法是 normalize()。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用 normalize()方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。</li>
</ul>
</li>
</ul>
<p>3、Document类型: 在浏览器中，文档对象 document 是HTMLDocument 的实例（HTMLDocument 继承 Document），表示整个 HTML 页面。document 是 window对象的属性，因此是一个全局对象。Document 类型的节点有以下特征：<br>    - nodeType: 9<br>    - nodeName: “#document”<br>    - nodeValue: null<br>    - parentNode: null<br>    - ownerDocument: null<br>    - 子节点可以是 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或 Comment 类型。</p>
<ul>
<li>文档子节点: 虽然 DOM 规范规定 Document 节点的子节点可以是 DocumentType、Element、ProcessingInstruction 或 Comment，但也提供了两个访问子节点的快捷方式。第一个是 documentElement 属性，始终指向 HTML 页面中的<html>元素。虽然 document.childNodes 中始终有<html>元素，但使用 documentElement 属性可以更快更直接地访问该元素。假如有以下简单的页面：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
浏览器解析完这个页面之后，文档只有一个子节点，即<html>元素。这个元素既可以通过documentElement 属性获取，也可以通过 childNodes 列表访问，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span>; <span class="comment">// 取得对&lt;html&gt;的引用</span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">childNodes</span>[<span class="number">0</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(html === <span class="variable language_">document</span>.<span class="property">firstChild</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
作为 HTMLDocument 的实例，document 对象还有一个 body 属性，直接指向<body>元素。因为这个元素是开发者使用最多的元素，所以 JavaScript 代码中经常可以看到 document.body，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="property">body</span>; <span class="comment">// 取得对&lt;body&gt;的引用</span></span><br></pre></td></tr></table></figure></div>
Document 类型另一种可能的子节点是 DocumentType。&lt;!doctype&gt;标签是文档中独立的部分，其信息可以通过 doctype 属性（在浏览器中是 document.doctype）来访问，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> doctype = <span class="variable language_">document</span>.<span class="property">doctype</span>; <span class="comment">// 取得对&lt;!doctype&gt;的引用</span></span><br></pre></td></tr></table></figure></div>
另外，严格来讲出现在<html>元素外面的注释也是文档的子节点，它们的类型是 Comment。不过，由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下 HTML 页面：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一条注释 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 第二条注释 --&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>文档信息: document 作为 HTMLDocument 的实例，还有一些标准 Document 对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是 title，包含<title>元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改 title 属性并不会改变<title>元素。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文档标题</span></span><br><span class="line"><span class="keyword">let</span> originalTitle = <span class="variable language_">document</span>.<span class="property">title</span>; </span><br><span class="line"><span class="comment">// 修改文档标题</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;New page title&quot;</span>;</span><br></pre></td></tr></table></figure></div>
接下来要介绍的 3 个属性是 URL、domain 和 referrer。其中，URL 包含当前页面的完整 URL（地址栏中的 URL），domain 包含页面的域名，而 referrer 包含链接到当前页面的那个页面的 URL。如果当前页面没有来源，则 referrer 属性包含空字符串。所有这些信息都可以在请求的 HTTP 头部信息中获取，只是在 JavaScript 中通过这几个属性暴露出来而已，如下面的例子所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得完整的 URL </span></span><br><span class="line"><span class="keyword">let</span> url = <span class="variable language_">document</span>.<span class="property">URL</span>; </span><br><span class="line"><span class="comment">// 取得域名</span></span><br><span class="line"><span class="keyword">let</span> domain = <span class="variable language_">document</span>.<span class="property">domain</span>; </span><br><span class="line"><span class="comment">// 取得来源</span></span><br><span class="line"><span class="keyword">let</span> referrer = <span class="variable language_">document</span>.<span class="property">referrer</span>;</span><br></pre></td></tr></table></figure></div></li>
<li>定位元素: 使用 DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。document 对象上暴露了一些方法，可以实现这些操作。getElementById()和 getElementsByTagName()就是 Document 类型提供的两个方法。HTMLDocument 类型上定义的获取元素的第三个方法是getElementsByName()。顾名思义，这个方法会返回具有给定 name 属性的所有元素。</li>
<li>特殊集合: document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。<br> document.anchors 包含文档中所有带 name 属性的<a>元素。<br> document.applets 包含文档中所有<applet>元素（因为<applet>元素已经不建议使用，所以这个集合已经废弃）。<br> document.forms 包含文档中所有<form>元素（与 documentgetElementsByTagName (“form”)返回的结果相同）。<br> document.images 包含文档中所有<img>元素（与 document.getElementsByTagName (“img”)返回的结果相同）。<br> document.links 包含文档中所有带 href 属性的<a>元素。</li>
<li>DOM兼容性检测: document.implementation 属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。</li>
<li>文档写入: document 对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法：write()、writeln()、open()和 close()。其中，write()和 writeln()方法都接收一个字符串参数，可以将这个字符串写入网页中。write()简单地写入文本，而 writeln()还会在字符串末尾追加一个换行符（\n）。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-20 日报 Day103</title>
    <url>/undefined/2025-02-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>我将玫瑰藏于身后，<br>风起花落，<br>从此鲜花赠自己，<br>纵马踏花向自由。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P423-425 第十四章：DOM</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Comment类型: DOM 中的注释通过 Comment 类型表示。Comment 类型的节点具有以下特征：</p>
<ul>
<li>nodeType: 8</li>
<li>nodeName: “#comment”</li>
<li>nodeValue: 注释的内容</li>
<li>parentNode: 指向父节点<br>Comment 类型与 Text 类型继承同一个基类（CharacterData），因此拥有除 splitText()之外<br>Text 节点所有的字符串操作方法。与 Text 类型相似，注释的实际内容可以通过 nodeValue 或 data属性获得。<br>注释节点可以作为父节点的子节点来访问。比如下面的 HTML 代码：<div id="myDiv"><!-- A comment --></div> 
这里的注释是<div>元素的子节点，这意味着可以像下面这样访问它：
let div = document.getElementById("myDiv"); 
let comment = div.firstChild; 
alert(comment.data); // "A comment" 
可以使用 document.createComment()方法创建注释节点，参数为注释文本，如下所示：
let comment = document.createComment("A comment"); 
显然，注释节点很少通过 JavaScrpit 创建和访问，因为注释几乎不涉及算法逻辑。此外，浏览器不承认结束的</html>标签之后的注释。如果要访问注释节点，则必须确定它们是<html>元素的后代。
2、CDATASection类型: CDATASection 类型表示 XML 中特有的 CDATA 区块。CDATASection 类型继承 Text 类型，因此拥有包括 splitText()在内的所有字符串操作方法。CDATASection 类型的节点具有以下特征：</li>
<li>nodeType: 4</li>
<li>nodeName: “#cdata-section”</li>
<li>nodeValue: CDATA 区块的内容</li>
<li>parentNode: Document 或 Element 对象<br>CDATA 区块只在 XML 文档中有效，因此某些浏览器比较陈旧的版本会错误地将 CDATA 区块解析为 Comment 或 Element。比如下面这行代码：<div id="myDiv"><![CDATA[This is some content.]]></div>
3、DocumentType类型: DocumentType 类型的节点包含文档的文档类型（doctype）信息，具有以下特征：</li>
<li>nodeType: 10</li>
<li>nodeName: 文档类型的名称</li>
<li>nodeValue: null</li>
<li>parentNode: Document 对象<br>DocumentType 对象在 DOM Level 1 中不支持动态创建，只能在解析文档代码时创建。<br>4、DocumentFragment类型: DocumentFragment 类型表示一个轻量级的文档对象，具有以下特征：</li>
<li>nodeType: 11</li>
<li>nodeName: “#document-fragment”</li>
<li>nodeValue: null</li>
<li>parentNode: null</li>
<li>子节点: 可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>(); </span><br><span class="line"><span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myList&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123; </span><br><span class="line"> <span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>); </span><br><span class="line"> li.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">`Item <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>`</span>)); </span><br><span class="line"> fragment.<span class="title function_">appendChild</span>(li); </span><br><span class="line">&#125; </span><br><span class="line">ul.<span class="title function_">appendChild</span>(fragment);</span><br></pre></td></tr></table></figure></div>

<p>5、Attr类型: 元素数据在 DOM 中通过 Attr 类型表示。Attr 类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素 attributes 属性中的节点。Attr 节点具有以下特征：</p>
<ul>
<li>nodeType: 2</li>
<li>nodeName: 属性的名称</li>
<li>nodeValue: 属性的值</li>
<li>parentNode: null<br>属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。Attr 节点很少直接被引用，通常开发者更喜欢使用 getAttribute()、removeAttribute()和 setAttribute()方法操作属性。<br>Attr 对象上有 3 个属性：name、value 和 specified。其中，name 包含属性名（与 nodeName一样），value 包含属性值（与 nodeValue 一样），而 specified 是一个布尔值，表示属性使用的是默认值还是被指定的值。<br>可以使用 document.createAttribute()方法创建新的 Attr 节点，参数为属性名。比如，要给元素添加 align 属性，可以使用下列代码：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&quot;align&quot;</span>); </span><br><span class="line">attr.<span class="property">value</span> = <span class="string">&quot;left&quot;</span>; </span><br><span class="line">element.<span class="title function_">setAttributeNode</span>(attr); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">attributes</span>[<span class="string">&quot;align&quot;</span>].<span class="property">value</span>); <span class="comment">// &quot;left&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="title function_">getAttributeNode</span>(<span class="string">&quot;align&quot;</span>).<span class="property">value</span>); <span class="comment">// &quot;left&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="title function_">getAttribute</span>(<span class="string">&quot;align&quot;</span>)); <span class="comment">// &quot;left&quot;</span></span><br></pre></td></tr></table></figure></div>
注意 将属性作为节点来访问多数情况下并无必要。推荐使用 getAttribute()、removeAttribute()和 setAttribute()方法操作属性，而不是直接操作属性节点。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-19 日报 Day102</title>
    <url>/undefined/2025-02-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>往后岁月，愿你摆正自己，见天地之大、众生之广，行稳致远，活出精彩人生。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P414-422 第十四章：DOM</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Element类型: 除了Document 类型，Element 类型就是Web开发中最常用的类型了。Element 表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力。Element 类型的节点具有以下特征：</p>
<ul>
<li><p>nodeType: 1</p>
</li>
<li><p>nodeName: 元素的标签名</p>
</li>
<li><p>nodeValue: null</p>
</li>
<li><p>parentNode: 指向父元素</p>
</li>
<li><p>HTML元素: 所有 HTML 元素都通过 HTMLElement 类型表示，包括其直接实例和间接实例。另外，HTMLElement直接继承 Element 并增加了一些属性。每个属性都对应下列属性之一，它们是所有 HTML 元素上都有的标准属性：</p>
</li>
<li><p>id，元素在文档中的唯一标识符；</p>
</li>
<li><p>title，包含元素的额外信息，通常以提示条形式展示；</p>
</li>
<li><p>lang，元素内容的语言代码（很少用）；</p>
</li>
<li><p>dir，语言的书写方向（”ltr”表示从左到右，”rtl”表示从右到左，同样很少用）；</p>
</li>
<li><p>className，元素的类名（class 属性）；<br>所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的 HTML 元素：</p>
<div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"></div>
这个元素中的所有属性都可以使用下列 JavaScript 代码读取：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">id</span>); <span class="comment">// &quot;myDiv&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">className</span>); <span class="comment">// &quot;bd&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">title</span>); <span class="comment">// &quot;Body text&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">lang</span>); <span class="comment">// &quot;en&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">dir</span>); <span class="comment">// &quot;ltr&quot;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>取得属性: 每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 DOM 方法主要有 3 个：getAttribute()、setAttribute()和 removeAttribute()。这些方法主要用于操纵属性，包括在 HTMLElement 类型上定义的属性。下面看一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;id&quot;</span>)); <span class="comment">// &quot;myDiv&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;class&quot;</span>)); <span class="comment">// &quot;bd&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>)); <span class="comment">// &quot;Body text&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;lang&quot;</span>)); <span class="comment">// &quot;en&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;dir&quot;</span>)); <span class="comment">// &quot;ltr&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>设置属性: 通过 setAttribute() 方法可以设置元素的属性值。这个方法接受两个参数：要设置的属性名和要设置的值。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;someOtherId&quot;</span>); </span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;ft&quot;</span>); </span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Some other text&quot;</span>); </span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;lang&quot;</span>,<span class="string">&quot;fr&quot;</span>); </span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&quot;dir&quot;</span>, <span class="string">&quot;rtl&quot;</span>);</span><br></pre></td></tr></table></figure></div>
注意，在 DOM 对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">mycolor</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="title function_">alert</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;mycolor&quot;</span>)); <span class="comment">// null（IE 除外）</span></span><br></pre></td></tr></table></figure></div>
这个例子添加了一个自定义属性 mycolor 并将其值设置为”red”。在多数浏览器中，这个属性不会自动变成元素属性。因此调用 getAttribute()取得 mycolor 的值会返回 null。<br>最后一个方法 removeAttribute()用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉，如下所示：<br>div.removeAttribute(“class”);<br>这个方法用得并不多，但在序列化 DOM 元素时可以通过它控制要包含的属性。</li>
<li>attributes属性: Element 类型是唯一使用 attributes 属性的 DOM 节点类型。attributes 属性包含一个NamedNodeMap 实例，是一个类似 NodeList 的“实时”集合。元素的每个属性都表示为一个 Attr 节点，并保存在这个 NamedNodeMap 对象中。NamedNodeMap 对象包含下列方法：<br> getNamedItem(name)，返回 nodeName 属性等于 name 的节点；<br> removeNamedItem(name)，删除 nodeName 属性等于 name 的节点；<br> setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引；<br> item(pos)，返回索引位置 pos 处的节点。<br>attributes 属性中的每个节点的 nodeName 是对应属性的名字，nodeValue 是属性的值。比如，要取得元素 id 属性的值，可以使用以下代码：<br>let id &#x3D; element.attributes.getNamedItem(“id”).nodeValue;<br>下面是使用中括号访问属性的简写形式：<br>let id &#x3D; element.attributes[“id”].nodeValue;<br>同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值，如下所示：<br>element.attributes[“id”].nodeValue &#x3D; “someOtherId”;<br>removeNamedItem()方法与元素上的 removeAttribute()方法类似，也是删除指定名字的属性。<br>下面的例子展示了这两个方法唯一的不同之处，就是removeNamedItem()返回表示被删除属性的Attr节点：<br>let oldAttr &#x3D; element.attributes.removeNamedItem(“id”);<br>setNamedItem()方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：<br>element.attributes.setNamedItem(newAttr);<br>一般来说，因为使用起来更简便，通常开发者更喜欢使用 getAttribute()、removeAttribute() 和 setAttribute()方法，而不是刚刚介绍的 NamedNodeMap 对象的方法。</li>
<li>创建元素: 可以使用 document.createElement()方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在 HTML 文档中，标签名是不区分大小写的，而 XML 文档（包括 XHTML）是区分大小写的。要创建<div>元素，可以使用下面的代码：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="property">id</span> = <span class="string">&quot;myNewDiv&quot;</span>; </span><br><span class="line">div.<span class="property">className</span> = <span class="string">&quot;box&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br></pre></td></tr></table></figure></div>
元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。</li>
<li>元素后代: 元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。childNodes属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现有明显不同。比如下面的代码：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
在解析以上代码时，<ul>元素会包含 7 个子元素，其中 3 个是<li>元素，还有 4 个 Text 节点（表示<li>元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点：<ul id="myList"><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>
2、Text类型: Text 节点由 Text 类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。Text 类型的节点具有以下特征：</li>
<li>nodeType: 3</li>
<li>nodeName: “#text”</li>
<li>nodeValue: 文本内容</li>
<li>parentNode: 指向父节点</li>
<li>不支持子节点<br>Text 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问，这两个属性包含相同的值。修改 nodeValue 或 data 的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法：<br> appendData(text)，向节点末尾添加文本 text；<br> deleteData(offset, count)，从位置 offset 开始删除 count 个字符；<br> insertData(offset, text)，在位置 offset 插入 text；<br> replaceData(offset, count, text)，用 text 替换从位置 offset 到 offset + count 的文本；<br> splitText(offset)，在位置 offset 将当前文本节点拆分为两个文本节点；<br> substringData(offset, count)，提取从位置 offset 到 offset + count 的文本。<br>除了这些方法，还可以通过 length 属性获取文本节点中包含的字符数量。这个值等于 nodeValue.length 和 data.length。</li>
<li>创建文本节点: document.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。跟设置已有文本节点的值一样，这些要插入的文本也会应用 HTML 或 XML 编码，如下面的例子所示：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>规范化文本节点: DOM 文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，DOM 文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法叫 normalize()，是在 Node 类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用 normalize()时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的 nodeValue 就等于之前所有同胞节点 nodeValue 拼接在一起得到的字符串。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode); </span><br><span class="line"><span class="keyword">let</span> anotherTextNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Yippee!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(anotherTextNode); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2 </span></span><br><span class="line">element.<span class="title function_">normalize</span>(); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello world!Yippee!&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>拆分文本节点: splitText()方法可以将一个文本节点拆分为两个文本节点。这个方法接收一个参数，表示要拆分的位置。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">element.<span class="property">className</span> = <span class="string">&quot;message&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line">element.<span class="title function_">appendChild</span>(textNode); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(element); </span><br><span class="line"><span class="keyword">let</span> newNode = element.<span class="property">firstChild</span>.<span class="title function_">splitText</span>(<span class="number">5</span>); </span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">firstChild</span>.<span class="property">nodeValue</span>); <span class="comment">// &quot;Hello&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(newNode.<span class="property">nodeValue</span>); <span class="comment">// &quot; world!&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(element.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-21 日报 Day104</title>
    <url>/undefined/2025-02-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>市井长巷，<br>聚拢来是烟火，<br>摊开是人间。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P426-442 第十四章：DOM编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、动态脚本: <script>元素用于向网页中插入 JavaScript 代码，可以是 src 属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过 DOM 包含的脚本。与对应的HTML 元素一样，有两种方式通过<script>动态为网页添加脚本：引入外部文件和直接插入源代码。<br>动态加载外部文件很容易实现，比如下面的<script>元素：</p>
<script src="foo.js"></script> 
<p>可以像这样通过 DOM 编程创建这个节点：<br>let script = document.createElement("script");<br>script.src = "foo.js";<br>document.body.appendChild(script);<br>注意，在上面最后一行把<script>元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到<head>元素，同样可以实现动态脚本加载。这个过程可以抽象为一个函数，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">url</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line"> script.<span class="property">src</span> = url; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另一个动态插入 JavaScript 的方式是嵌入源代码，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"> &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">script.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>)); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure></div>
<p>但<script>元素上有一个 text 属性，可以用来添加 JavaScript 代码，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line">script.<span class="property">text</span> = <span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure></div>
<p>这样修改后，上面的代码可以在 IE、Firefox、Opera 和 Safari 3 及更高版本中运行。Safari 3 之前的版本不能正确支持这个 text 属性，但这些版本却支持文本节点赋值。对于早期的 Safari 版本，需要使用以下代码：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> code = <span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> script.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;code&quot;</span>)); </span><br><span class="line">&#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line"> script.<span class="property">text</span> = <span class="string">&quot;code&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadScriptString</span>(<span class="params">code</span>)&#123; </span><br><span class="line"> <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>); </span><br><span class="line"> script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> script.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(code)); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (ex)&#123; </span><br><span class="line"> script.<span class="property">text</span> = code; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loadScriptString</span>(<span class="string">&quot;function sayHi()&#123;alert(&#x27;hi&#x27;);&#125;&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>2、动态样式: CSS 样式在 HTML 页面中可以通过两个元素加载。<link>元素用于包含 CSS 外部文件，而<style>元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。<br>到页面中的。<br>来看下面这个典型的<link>元素：</p>
<link rel="stylesheet" type="text/css" href="styles.css"> 
这个元素很容易使用 DOM 编程创建出来：

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>); </span><br><span class="line">link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>; </span><br><span class="line">link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">link.<span class="property">href</span> = <span class="string">&quot;styles.css&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line">head.<span class="title function_">appendChild</span>(link);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadStyles</span>(<span class="params">url</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>); </span><br><span class="line"> link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>; </span><br><span class="line"> link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line"> link.<span class="property">href</span> = url; </span><br><span class="line"> <span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>]; </span><br><span class="line"> head.<span class="title function_">appendChild</span>(link); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">loadStyles</span>(<span class="string">&quot;styles.css&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 JavaScript 代码并没有先后<br>顺序。一般来说，也没有必要知道样式什么时候加载完成。</p>
<p>3、操作表格: 表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建<table>元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过 DOM 编程创建和修改表格时可能要写很多代码。假设要通过DOM 来创建以下 HTML 表格：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">tbody</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>); </span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>; </span><br><span class="line">table.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>; </span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tbody&quot;</span>); </span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody); </span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line"><span class="keyword">let</span> row1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>); </span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row1); </span><br><span class="line"><span class="keyword">let</span> cell1_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell1_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,1&quot;</span>)); </span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell1_1); </span><br><span class="line"><span class="keyword">let</span> cell2_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell2_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,1&quot;</span>)); </span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell2_1); </span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line"><span class="keyword">let</span> row2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>); </span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row2); </span><br><span class="line"><span class="keyword">let</span> cell1_2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell1_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,2&quot;</span>)); </span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell1_2); </span><br><span class="line"><span class="keyword">let</span> cell2_2= <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>); </span><br><span class="line">cell2_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,2&quot;</span>)); </span><br><span class="line">row2.<span class="title function_">appendChild</span>(cell2_2); </span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure></div>

<p>4、使用NodeList: 理解 NodeList 对象和相关的 NamedNodeMap、HTMLCollection，是理解 DOM 编程的关键。这3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，NodeList 就是基于 DOM 文档的实时查询。</p>
<p>5、MutationObserver接口: 不久前添加到 DOM 规范中的 MutationObserver 接口，可以在 DOM 被修改时异步执行回调。使用 MutationObserver 可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p>
<ul>
<li><p>基本用法: MutationObserver 的实例要通过调用 MutationObserver 构造函数并传入一个回调函数来创建：<br>let observer = new MutationObserver(() => console.log('DOM was mutated!'));</p>
</li>
<li><p>observe()方法: 通过调用 observe()方法来观察 DOM 变化。这个方法接受两个参数：要观察的目标节点和一个配置对象。配置对象指定要观察的 DOM 变化类型，比如子节点的添加或删除、属性的修改等。下面是一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM was mutated!&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> targetNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myElement&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> config = &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">attributes</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">observer.<span class="title function_">observe</span>(targetNode, config);</span><br></pre></td></tr></table></figure></div></li>
<li><p>回调与MutationRecord: 每个回调都会收到一个 MutationRecord 实例的数组。MutationRecord 实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 MutationRecord 实例的数组。下面展示了反映一个属性变化的 MutationRecord 实例的数组：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList [],</span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// previousSibling: null </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList [], </span></span><br><span class="line"><span class="comment">// target: body </span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttributeNS</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList [], </span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;, </span></span><br><span class="line"><span class="comment">// attributeNamespace: &quot;baz&quot;, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// previousSibling: null </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList [], </span></span><br><span class="line"><span class="comment">// target: body </span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords, mutationObserver</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords,</span><br><span class="line">mutationObserver)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="comment">// [MutationRecord], MutationObserver</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>disconnect()方法: 通过调用 disconnect()方法来停止观察 DOM 变化。这个方法不接受参数，调用后会停止所有观察。下面是一个例子：默认情况下，只要被观察的元素不被垃圾回收，MutationObserver 的回调就会响应 DOM 变化事件，从而被执行。要提前终止执行回调，可以调用 disconnect()方法。下面的例子演示了同步调用disconnect()之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要想让已经加入任务队列的回调执行，可以使用 setTimeout()让已经入列的回调执行完毕再调用disconnect()：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes changed&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure></div></li>
<li><p>复用MutationObserver: 多次调用 observe()方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点。此时，MutationRecord 的 target 属性可以标识发生变化事件的目标节点。下面的示例演示了这个过程：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> </span><br><span class="line">x.<span class="property">target</span>))); </span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> childB = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childA); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childB); </span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.<span class="title function_">observe</span>(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">childB.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;span&gt;] </span></span><br><span class="line"><span class="comment">// disconnect()方法是一个“一刀切”的方案，调用它会停止观察所有目标：</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> </span><br><span class="line">x.<span class="property">target</span>))); </span><br><span class="line"><span class="comment">// 向页面主体添加两个子节点</span></span><br><span class="line"><span class="keyword">let</span> childA = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> childB = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childA); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(childB); </span><br><span class="line"><span class="comment">// 观察两个子节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(childA, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.<span class="title function_">observe</span>(childB, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line">observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"><span class="comment">// 修改两个子节点的属性</span></span><br><span class="line">childA.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">childB.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// （没有日志输出）</span></span><br></pre></td></tr></table></figure></div></li>
<li><p>重用MutationObserver: 调用 disconnect()并不会结束 MutationObserver 的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与<body>元素的关联：</p>
</li>
</ul>
 <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&lt;body&gt; attributes </span></span><br><span class="line"><span class="string">changed&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> observer.<span class="title function_">disconnect</span>(); </span><br><span class="line"> <span class="comment">// 这行代码不会触发变化事件</span></span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// Reattach </span></span><br><span class="line"> observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"> <span class="comment">// 这行代码会触发变化事件</span></span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line">&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed </span></span><br><span class="line"><span class="comment">// &lt;body&gt; attributes changed</span></span><br></pre></td></tr></table></figure></div>

<p>6、MutationObserverInit与观察范围: MutationObserverInit 对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</p>
<ul>
<li>观察属性: MutationObserver 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在MutationObserverInit 对象中将 attributes 属性设置为 true，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 添加属性 </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="comment">// 移除属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeFilter</span>: [<span class="string">&#x27;foo&#x27;</span>] &#125;); </span><br><span class="line"><span class="comment">// 添加白名单属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 添加被排除的属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="comment">// 只有 foo 属性的变化被记录了</span></span><br><span class="line"><span class="comment">// [MutationRecord] </span></span><br><span class="line">如果想在变化记录中保存属性原来的值，可以将 attributeOldValue 属性设置为 <span class="literal">true</span>：</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>))); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributeOldValue</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [null, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure></div></li>
<li>观察字符数据: MutationObserver 可以观察文本节点（如 Text、Comment 或 ProcessingInstruction 节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在 MutationObserverInit 对象中将characterData 属性设置为 true，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建要观察的文本节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterData</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 赋值为相同的字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="comment">// 赋值为新字符串</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="comment">// 通过节点设置函数赋值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// 以上变化都被记录下来了</span></span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="property">oldValue</span>))); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>, &#123; <span class="attr">characterDataOldValue</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerText</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="property">textContent</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="comment">// 每次变化都保留了上一次的值</span></span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;]</span></span><br></pre></td></tr></table></figure></div></li>
<li>观察子节点: MutationObserver 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 MutationObserverInit 对象中将 childList 属性设置为 true。<br>下面的例子演示了添加子节点：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[div], </span></span><br><span class="line"><span class="comment">// attributeName: null, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// previousSibling: null, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// target: body, </span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// attributeName: null, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// previousSibling: null, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[div], </span></span><br><span class="line"><span class="comment">// target: body, </span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建两个初始子节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 交换子节点顺序</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">lastChild</span>, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>); </span><br><span class="line"><span class="comment">// 发生了两次变化：第一次是节点被移除，第二次是节点被添加</span></span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// attributeName: null, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// previousSibling: div, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[span], </span></span><br><span class="line"><span class="comment">// target: body, </span></span><br><span class="line"><span class="comment">// type: childList, </span></span><br><span class="line"><span class="comment">// &#125;, </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[span], </span></span><br><span class="line"><span class="comment">// attributeName: null, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: div, </span></span><br><span class="line"><span class="comment">// previousSibling: null, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// target: body, </span></span><br><span class="line"><span class="comment">// type: &quot;childList&quot;, </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure></div></li>
<li>观察子树: MutationObserver 将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点），这需要在 MutationObserverInit 对象中将 subtree属性设置为 true。<br>下面的代码展示了观察元素及其后代节点属性的变化：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="comment">// 创建一个后代</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"><span class="comment">// 观察&lt;body&gt;元素及其子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 修改&lt;body&gt;元素的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 记录了子树变化的事件</span></span><br><span class="line"><span class="comment">// [ </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">// addedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// attributeName: &quot;foo&quot;, </span></span><br><span class="line"><span class="comment">// attributeNamespace: null, </span></span><br><span class="line"><span class="comment">// oldValue: null, </span></span><br><span class="line"><span class="comment">// nextSibling: null, </span></span><br><span class="line"><span class="comment">// previousSibling: null, </span></span><br><span class="line"><span class="comment">// removedNodes: NodeList[], </span></span><br><span class="line"><span class="comment">// target: div, </span></span><br><span class="line"><span class="comment">// type: &quot;attributes&quot;, </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line">下面的代码演示了这种情况：</span><br><span class="line"><span class="comment">// 清空主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line"><span class="keyword">let</span> subtreeRoot = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>), </span><br><span class="line"> subtreeLeaf = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>); </span><br><span class="line"><span class="comment">// 创建包含两层的子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(subtreeRoot); </span><br><span class="line">subtreeRoot.<span class="title function_">appendChild</span>(subtreeLeaf); </span><br><span class="line"><span class="comment">// 观察子树</span></span><br><span class="line">observer.<span class="title function_">observe</span>(subtreeRoot, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="comment">// 把节点转移到其他子树</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(subtreeLeaf, subtreeRoot); </span><br><span class="line">subtreeLeaf.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 移出的节点仍然触发变化事件</span></span><br><span class="line"><span class="comment">// [MutationRecord]</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-14 日报 Day97</title>
    <url>/undefined/2025-02-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>一个人经过不同程度的锻炼，就获得不同程度的修养，不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P372-378 第十二章：BOM</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、location 对象: location 是最有用的 BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这个对象独特的地方在于，它既是 window 的属性，也是 document 的属性。也就是说，window.location 和 document.location 指向同一个对象。location 对象不仅保存着当前加载文档的信息，也保存着把 URL 解析为离散片段后能够通过属性访问的信息。这些解析后的属性在下表中有详细说明（location 前缀是必需的）。</p>
<p>假设浏览器当前加载的 URL 是 <a class="link"   href="http://foouser:barpassword@www.wrox.com/WileyCDA/?q=javascript#contents%EF%BC%8Clocation" >http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents，location <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 对象的内容如下表所示。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>location.hash</td>
<td>“#contents”</td>
<td>URL 散列值（井号后跟零或多个字符），如果没有则为空字符串</td>
</tr>
<tr>
<td>location.host</td>
<td>“<a class="link"   href="http://www.wrox.com/" >www.wrox.com:80 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“</td>
<td>服务器名及端口号</td>
</tr>
<tr>
<td>location.hostname</td>
<td>“<a class="link"   href="http://www.wrox.com/" >www.wrox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“</td>
<td>服务器名</td>
</tr>
<tr>
<td>location.href</td>
<td>“<a class="link"   href="http://www.wrox.com/WileyCDA/?q=javascript#contents" >http://www.wrox.com:80/WileyCDA/?q=javascript#contents <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“</td>
<td>当前加载页面的完整 URL。location 的 toString()方法返回这个值</td>
</tr>
<tr>
<td>location.pathname</td>
<td>“&#x2F;WileyCDA&#x2F;“</td>
<td>URL 中的路径和（或）文件名</td>
</tr>
<tr>
<td>location.port</td>
<td>“80”</td>
<td>请求的端口。如果 URL 中没有端口，则返回空字符串</td>
</tr>
<tr>
<td>location.protocol</td>
<td>“http:”</td>
<td>页面使用的协议。通常是”http:”或”https:”</td>
</tr>
<tr>
<td>location.search</td>
<td>“?q&#x3D;javascript”</td>
<td>URL 的查询字符串。这个字符串以问号开头</td>
</tr>
<tr>
<td>location.username</td>
<td>“foouser”</td>
<td>域名前指定的用户名</td>
</tr>
<tr>
<td>location.password</td>
<td>“barpassword”</td>
<td>域名前指定的密码</td>
</tr>
<tr>
<td>location.origin</td>
<td>“<a class="link"   href="http://www.wrox.com/" >http://www.wrox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“</td>
<td>URL 的源地址。只读</td>
</tr>
</tbody></table>
<ul>
<li>查询字符串: location 的多数信息都可以通过上面的属性获取。但是 URL 中的查询字符串并不容易使用。虽然 location.search 返回了从问号开始直到 URL 末尾的所有内容，但没有办法逐个访问每个查询参数。下面的函数解析了查询字符串，并返回一个以每个查询参数为属性的对象：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getQueryStringArgs = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 取得没有开头问号的查询字符串</span></span><br><span class="line">  <span class="keyword">let</span> qs = location.<span class="property">search</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? location.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>) : <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">// 保存数据的对象</span></span><br><span class="line">    args = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 把每个参数添加到 args 对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> qs.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">kv</span>) =&gt;</span> kv.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]),</span><br><span class="line">      value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (name.<span class="property">length</span>) &#123;</span><br><span class="line">      args[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设查询字符串为?q=javascript&amp;num=10</span></span><br><span class="line"><span class="keyword">let</span> args = <span class="title function_">getQueryStringArgs</span>();</span><br><span class="line"><span class="title function_">alert</span>(args[<span class="string">&quot;q&quot;</span>]); <span class="comment">// &quot;javascript&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(args[<span class="string">&quot;num&quot;</span>]); <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>URLSearchParams 提供了一组标准 API 方法，通过它们可以检查和修改查询字符串。给 URLSearchParams 构造函数传入一个查询字符串，就可以创建一个实例。这个实例上暴露了 get()、set()和 delete()等方法，可以对查询字符串执行相应操作。下面来看一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = <span class="string">&quot;?q=javascript&amp;num=10&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(qs);</span><br><span class="line"><span class="title function_">alert</span>(searchParams.<span class="title function_">toString</span>()); <span class="comment">// &quot; q=javascript&amp;num=10&quot;</span></span><br><span class="line">searchParams.<span class="title function_">has</span>(<span class="string">&quot;num&quot;</span>); <span class="comment">// true</span></span><br><span class="line">searchParams.<span class="title function_">get</span>(<span class="string">&quot;num&quot;</span>); <span class="comment">// 10</span></span><br><span class="line">searchParams.<span class="title function_">set</span>(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(searchParams.<span class="title function_">toString</span>()); <span class="comment">// &quot; q=javascript&amp;num=10&amp;page=3&quot;</span></span><br><span class="line">searchParams.<span class="title function_">delete</span>(<span class="string">&quot;q&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(searchParams.<span class="title function_">toString</span>()); <span class="comment">// &quot; num=10&amp;page=3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> qs = <span class="string">&quot;?q=javascript&amp;num=10&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(qs);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> param <span class="keyword">of</span> searchParams) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;q&quot;, &quot;javascript&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;num&quot;, &quot;10&quot;]</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>操作地址: 可以通过修改 location 对象修改浏览器的地址。首先，最常见的是使用 assign()方法并传入一个 URL，如下所示：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">location.<span class="title function_">assign</span>(<span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这行代码会立即启动导航到新 URL 的操作，同时在浏览器历史记录中增加一条记录。如果给 location.href 或 window.location 设置一个 URL，也会以同一个 URL 值调用 assign()方法。比如，下面两行代码都会执行与显式调用 assign()一样的操作：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;http://www.wrox.com&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>在这 3 种修改浏览器地址的方法中，设置 location.href 是最常见的。<br>修改 location 对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname 和 port 属性被设置为新值之后都会修改当前 URL，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设当前 URL 为 http://www.wrox.com/WileyCDA/</span></span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.wrox.com/WileyCDA/#section1</span></span><br><span class="line">location.<span class="property">hash</span> = <span class="string">&quot;#section1&quot;</span>;</span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.wrox.com/WileyCDA/?q=javascript</span></span><br><span class="line">location.<span class="property">search</span> = <span class="string">&quot;?q=javascript&quot;</span>;</span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.somewhere.com/WileyCDA/</span></span><br><span class="line">location.<span class="property">hostname</span> = <span class="string">&quot;www.somewhere.com&quot;</span>;</span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.somewhere.com/mydir/</span></span><br><span class="line">location.<span class="property">pathname</span> = <span class="string">&quot;mydir&quot;</span>;</span><br><span class="line"><span class="comment">// 把 URL 修改为 http://www.somewhere.com:8080/WileyCDA/</span></span><br><span class="line">location.<span class="property">port</span> = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></div>

<p>除了 hash 之外，只要修改 location 的一个属性，就会导致页面重新加载新 URL<br>注意 修改 hash 的值会在浏览器历史中增加一条新记录。在早期的 IE 中，点击“后退”和“前进”按钮不会更新 hash 属性，只有点击包含散列的 URL 才会更新 hash 的值。<br>在以前面提到的方式修改 URL 之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退”按钮时，就会导航到前一个页面。如果不希望增加历史记录，可以使用 replace()方法。这个方法接收一个 URL 参数，但重新加载后不会增加历史记录。调用 replace()之后，用户不能回到前一页。比如下面的例子：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>You won&#x27;t be able to get back here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Enjoy this page for a second, because you won&#x27;t be coming back here.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> location.<span class="title function_">replace</span>(<span class="string">&quot;http://www.wrox.com/&quot;</span>), <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>最后一个修改地址的方法是 reload()，它能重新加载当前显示的页面。调用 reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给 reload()传个 true：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">location.<span class="title function_">reload</span>(); <span class="comment">// 重新加载，可能是从缓存加载</span></span><br><span class="line">location.<span class="title function_">reload</span>(<span class="literal">true</span>); <span class="comment">// 重新加载，从服务器加载</span></span><br></pre></td></tr></table></figure></div>

<p>脚本中位于 reload()调用之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素。为此，最好把 reload()作为最后一行代码。<br>2、navigator 对象: navigator 对象实现了 NavigatorID 、 NavigatorLanguage 、 NavigatorOnLine 、NavigatorContentUtils 、 NavigatorStorage 、 NavigatorStorageUtils 、 NavigatorConcurrentHardware、NavigatorPlugins 和 NavigatorUserMedia 接口定义的属性和方法。</p>
<ul>
<li>检测插件: 检测浏览器是否安装了某个插件是开发中常见的需求。除 IE10 及更低版本外的浏览器，都可以通过 plugins 数组来确定。这个数组中的每一项都包含如下属性。<br> name：插件名称。<br> description：插件介绍。<br> filename：插件的文件名。<br> length：由当前插件处理的 MIME 类型数量。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件检测，IE10 及更低版本无效</span></span><br><span class="line"><span class="keyword">let</span> hasPlugin = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  name = name.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> plugin <span class="keyword">of</span> <span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">plugins</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (plugin.<span class="property">name</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(name) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 检测 Flash</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasPlugin</span>(<span class="string">&quot;Flash&quot;</span>));</span><br><span class="line"><span class="comment">// 检测 QuickTime</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasPlugin</span>(<span class="string">&quot;QuickTime&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在旧版本 IE 中检测插件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasIEPlugin</span>(<span class="params">name</span>) &#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(name); </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"> &#125; <span class="keyword">catch</span> (ex) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 检测 Flash </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasIEPlugin</span>(<span class="string">&quot;ShockwaveFlash.ShockwaveFlash&quot;</span>)); </span><br><span class="line"><span class="comment">// 检测 QuickTime </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasIEPlugin</span>(<span class="string">&quot;QuickTime.QuickTime&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在所有浏览器中检测 Flash </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasFlash</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">var</span> result = <span class="title function_">hasPlugin</span>(<span class="string">&quot;Flash&quot;</span>); </span><br><span class="line"> <span class="keyword">if</span> (!result)&#123; </span><br><span class="line"> result = <span class="title function_">hasIEPlugin</span>(<span class="string">&quot;ShockwaveFlash.ShockwaveFlash&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 在所有浏览器中检测 QuickTime </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasQuickTime</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">var</span> result = <span class="title function_">hasPlugin</span>(<span class="string">&quot;QuickTime&quot;</span>); </span><br><span class="line"> <span class="keyword">if</span> (!result)&#123; </span><br><span class="line"> result = <span class="title function_">hasIEPlugin</span>(<span class="string">&quot;QuickTime.QuickTime&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 检测 Flash </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasFlash</span>()); </span><br><span class="line"><span class="comment">// 检测 QuickTime </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">hasQuickTime</span>());</span><br></pre></td></tr></table></figure></div>
<p>3、注册处理程序: 现代浏览器支持 navigator 上的（在 HTML5 中定义的）registerProtocolHandler()方法。这个方法可以把一个网站注册为处理某种特定类型信息应用程序。随着在线 RSS 阅读器和电子邮件客户端的流行，可以借助这个方法将 Web 应用程序注册为像桌面软件一样的默认应用程序。要使用 registerProtocolHandler()方法，必须传入 3 个参数：要处理的协议（如”mailto”或”ftp”）、处理该协议的 URL，以及应用名称。比如，要把一个 Web 应用程序注册为默认邮件客户端，可以这样做：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">navigator.<span class="title function_">registerProtocolHandler</span>(<span class="string">&quot;mailto&quot;</span>, </span><br><span class="line"> <span class="string">&quot;http://www.somemailclient.com?cmd=%s&quot;</span>, </span><br><span class="line"> <span class="string">&quot;Some Mail Client&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>这个例子为”mailto”协议注册了一个处理程序，这样邮件地址就可以通过指定的 Web 应用程序打开。注意，第二个参数是负责处理请求的 URL，%s 表示原始的请求。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-17 日报 Day100</title>
    <url>/undefined/2025-02-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每一个优秀背后，都有一段默默扎根的时光；每一次成长背后，都有一段奋斗拼搏的日子。只要度过山重水复，岁月自会赠你柳暗花明。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P393-400 第十三章：客户端检测</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、浏览器分析: 想要知道自己代码运行在什么浏览器上，大部分开发者会分析 window.navigator.userAgent 返回的字符串值。所有浏览器都会提供这个值，如果相信这些返回值并基于给定的一组浏览器检测这个字符串，最终会得到关于浏览器和操作系统的比较精确的结果。</p>
<ul>
<li>伪造用户代理: 通过检测用户代理来识别浏览器并不是完美的方式，毕竟这个字符串是可以造假的。只不过实现 window.navigator 对象的浏览器（即所有现代浏览器）都会提供 userAgent 这个只读属性。因此，简单地给这个属性设置其他值不会有效：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>);</span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)</span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span> = <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>);</span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)</span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span></span><br></pre></td></tr></table></figure></div>

<p>不过，通过简单的办法可以绕过这个限制。比如，有些浏览器提供伪私有的<strong>defineGetter</strong>方法，利用它可以篡改用户代理字符串：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>);</span><br><span class="line"><span class="comment">// Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)</span></span><br><span class="line"><span class="title class_">Chrome</span>/<span class="number">65.0</span><span class="number">.3325</span><span class="number">.181</span> <span class="title class_">Safari</span>/<span class="number">537.36</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="title function_">__defineGetter__</span>(<span class="string">&#x27;userAgent&#x27;</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">userAgent</span>);</span><br><span class="line"><span class="comment">// foobar</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>分析浏览器: 通过解析浏览器返回的用户代理字符串，可以极其准确地推断出下列相关的环境信息：<br> 浏览器<br> 浏览器版本<br> 浏览器渲染引擎<br> 设备类型（桌面&#x2F;移动）<br> 设备生产商<br> 设备型号<br> 操作系统<br> 操作系统版本<br>GitHub 上维护比较频繁的第三方用户代理解析程序：<br> Bowser<br> UAParser.js<br> Platform.js<br> CURRENT-DEVICE<br> Google Closure<br> Mootools<br>2、软件与硬件检测: 现代浏览器提供了一组与页面执行环境相关的信息，包括浏览器、操作系统、硬件和周边设备信息。这些属性可以通过暴露在 window.navigator 上的一组 API 获得。不过，这些 API 的跨浏览器支持还不够好，远未达到标准化的程度。<br>注意 强烈建议在使用这些 API 之前先检测它们是否存在，因为其中多数都不是强制性的，且很多浏览器没有支持。另外，本节介绍的特性有时候不一定可靠。</li>
<li>识别浏览器与操作系统: 特性检测和用户代理字符串解析是当前常用的两种识别浏览器的方式。而 navigator 和 screen 对象也提供了关于页面所在软件环境的信息。<ul>
<li>navigator.oscpu: navigator.oscpu 属性是一个字符串，通常对应用户代理字符串中操作系统&#x2F;系统架构相关信息。根据 HTML 实时标准：oscpu 属性的获取方法必须返回空字符串或者表示浏览器所在平台的字符串，比如”Windows NT 10.0; Win64; x64”或”Linux x86_64”。</li>
</ul>
</li>
<li>navigator.vendor: navigator.vendor 属性是一个字符串，通常包含浏览器开发商信息。返回这个字符串是浏览器 navigator 兼容模式的一个功能。根据 HTML 实时标准：navigator.vendor 返回一个空字符串，也可能返回字符串”Apple Computer, Inc.”或字符串”Google Inc.”。<br>例如，Chrome 中的这个 navigator.vendor 属性返回下面的字符串：<br>console.log(navigator.vendor); &#x2F;&#x2F; “Google Inc.”</li>
<li>navigator.platform: navigator.platform 属性是一个字符串，通常表示浏览器所在的操作系统。根据 HTML 实时标准：navigator.platform 必须返回一个字符串或表示浏览器所在平台的字符串，例如”MacIntel”、”Win32”、”FreeBSD i386”或”WebTV OS”。例如，Windows 系统下 Chrome 中的这个 navigator.platform 属性返回下面的字符串：<br>console.log(navigator.platform); &#x2F;&#x2F; “Win32”</li>
<li>screen.colorDepth 和 screen.pixelDepth: screen.colorDepth 和 screen.pixelDepth 返回一样的值，即显示器每像素颜色的位深。根据 CSS 对象模型（CSSOM）规范：screen.colorDepth 和 screen.pixelDepth 属性应该返回输出设备中每像素用于显示颜色的位数，不包含 alpha 通道</li>
<li>screen.orientation: screen.orientation 属性返回一个 ScreenOrientation 对象，其中包含 Screen Orientation API 定义的屏幕信息。这里面最有意思的属性是 angle 和 type，前者返回相对于默认状态下屏幕的角度，后者返回以下 4 种枚举值之一：<br> portrait-primary: 设备处于竖屏（纵向）模式，且这是设备默认的“主”方向（如手机竖着拿）<br> portrait-secondary: 竖屏模式，但设备被“上下颠倒”了（相对于主方向）<br> landscape-primary: 横屏（横向）模式，且是设备默认的主横屏方向（如部分平板或笔记本）<br> landscape-secondary: 横屏模式，但设备被“反转”了（例如屏幕旋转了 180 度）<br>根据规范，这些值的初始化取决于浏览器和设备状态。因此，不能假设 portrait-primary 和 0 始终是初始值。这两个值主要用于确定设备旋转后浏览器的朝向变化。</li>
<li>浏览器元数据: navigator 对象暴露出一些 API，可以提供浏览器和操作系统的状态信息。</li>
<li>Geolocation API: navigator.geolocation 属性暴露了 Geolocation API，可以让浏览器脚本感知当前设备的地理位置。这个 API 只在安全执行环境（通过 HTTPS 获取的脚本）中可用。这个 API 可以查询宿主系统并尽可能精确地返回设备的位置信息。<br>要获取浏览器当前的位置，可以使用 getCurrentPosition()方法。这个方法返回一个 Coordinates 对象，其中包含的信息不一定完全依赖宿主系统的能力：<br>&#x2F;&#x2F; getCurrentPosition()会以 position 对象为参数调用传入的回调函数<br>navigator.geolocation.getCurrentPosition((position) &#x3D;&gt; p &#x3D; position);<br>获取浏览器地理位置并不能保证成功。因此 getCurrentPosition()方法也接收失败回调函数作为第二个参数，这个函数会收到一个 PositionError 对象。在失败的情况下，PositionError 对象中会包含一个 code 属性和一个 message 属性，后者包含对错误的简短描述。code 属性是一个整数，表示以下 3 种错误。<ol>
<li>PERMISSION_DENIED: 用户拒绝了地理位置请求</li>
<li>POSITION_UNAVAILABLE: 无法获取地理位置</li>
<li>TIMEOUT: 获取地理位置超时<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器会弹出确认对话框请用户允许访问 Geolocation API</span></span><br><span class="line"><span class="comment">// 这个例子显示了用户拒绝之后的结果</span></span><br><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>); <span class="comment">// User denied Geolocation</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 这个例子展示了在不安全的上下文中执行代码的结果</span></span><br><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>); <span class="comment">// 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>); <span class="comment">// Only secure origins are allowed</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li>Connection State 和 NetworkInformation API: 浏览器会跟踪网络连接状态并以两种方式暴露这些信息：连接事件和 navigator.onLine 属性。在设备连接到网络时，浏览器会记录这个事实并在 window 对象上触发 online 事件。断开网络连接后，浏览器会在 window 对象上触发 offline 事件。任何时候，都可以通过 navigator. onLine 属性来确定浏览器的联网状态。这个属性返回一个布尔值，表示浏览器是否联网。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">connectionStateChange</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">onLine</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;online&quot;</span>, connectionStateChange);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;offline&quot;</span>, connectionStateChange);</span><br><span class="line"><span class="comment">// 设备联网时：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 设备断网时：</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p>navigator 对象还暴露了 NetworkInformation API，可以通过 navigator.connection 属性使用。这个 API 提供了一些只读属性，并为连接属性变化事件处理程序定义了一个事件对象。以下是 NetworkInformation API 暴露的属性。<br> downlink：整数，表示当前设备的带宽（以 Mbit&#x2F;s 为单位），舍入到最接近的 25kbit&#x2F;s。这个值可能会根据历史网络吞吐量计算，也可能根据连接技术的能力来计算。<br> downlinkMax：整数，表示当前设备最大的下行带宽（以 Mbit&#x2F;s 为单位），根据网络的第一跳来确定。因为第一跳不一定反映端到端的网络速度，所以这个值只能用作粗略的上限值。<br> effectiveType：字符串枚举值，表示连接速度和质量。这些值对应不同的蜂窝数据网络连接技术，但也用于分类无线网络。这个值有以下 4 种可能。 1. slow-2g：2G 蜂窝网络 2. 2g：2G 蜂窝网络 3. 3g：3G 蜂窝网络 4. 4g：4G 蜂窝网络<br> rtt：毫秒，表示当前网络实际的往返时间，舍入为最接近的 25 毫秒。这个值可能根据历史网络吞吐量计算，也可能根据连接技术的能力来计算。<br> type：字符串枚举值，表示网络连接技术。这个值可能为下列值之一。<br>1、bluetooth: 蓝牙连接<br>2、cellular: 蜂窝网络连接<br>3、ethernet: 有线以太网连接<br>4、none: 没有网络连接.相当于 navigator.onLine &#x3D;&#x3D;&#x3D; false。<br>5、mixed: 混合连接<br>6、other: 其他连接<br>7、unknown: 未知连接<br>8、wifi: 无线网络连接<br>9、wimax: WiMax 连接<br> saveData：布尔值，表示用户设备是否启用了“节流”（reduced data）模式。<br> onchange：事件处理程序，会在任何连接状态变化时激发一个 change 事件。可以通过 navigator. connection.addEventListener(‘change’,changeHandler)或 navigator.connection.onchange &#x3D; changeHandler 等方式使用。</p>
<ul>
<li>Battery Status API: 浏览器可以访问设备电池及充电状态的信息。navigator.getBattery()方法会返回一个期约实例，解决为一个 BatteryManager 对象。<br>navigator.getBattery().then((b) &#x3D;&gt; console.log(b));<br>&#x2F;&#x2F; BatteryManager { … }<br>BatteryManager 包含 4 个只读属性，提供了设备电池的相关信息。<br> charging：布尔值，表示设备当前是否正接入电源充电。如果设备没有电池，则返回 true。<br> chargingTime：整数，表示预计离电池充满还有多少秒。如果电池已充满或设备没有电池，则返回 0。<br> dischargingTime：整数，表示预计离电量耗尽还有多少秒。如果设备没有电池，则返回 Infinity。<br> level：浮点数，表示电量百分比。电量完全耗尽返回 0.0，电池充满返回 1.0。如果设备没有电池，则返回 1.0。<br>这个 API 还提供了 4 个事件属性，可用于设置在相应的电池事件发生时调用的回调函数。可以通过给 BatteryManager 添加事件监听器，也可以通过给事件属性赋值来使用这些属性。<br> onchargingchange<br> onchargingtimechange<br> ondischargingtimechange<br> onlevelchange</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">navigator.<span class="title function_">getBattery</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">battery</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 添加充电状态变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">chargingChangeHandler</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;chargingchange&quot;</span>);</span><br><span class="line">  battery.<span class="property">onchargingchange</span> = chargingChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.<span class="title function_">addEventListener</span>(<span class="string">&quot;chargingchange&quot;</span>, chargingChangeHandler);</span><br><span class="line">  <span class="comment">// 添加充电时间变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">chargingTimeChangeHandler</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;chargingtimechange&quot;</span>);</span><br><span class="line">  battery.<span class="property">onchargingtimechange</span> = chargingTimeChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.<span class="title function_">addEventListener</span>(<span class="string">&quot;chargingtimechange&quot;</span>, chargingTimeChangeHandler);</span><br><span class="line">  <span class="comment">// 添加放电时间变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dischargingTimeChangeHandler</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dischargingtimechange&quot;</span>);</span><br><span class="line">  battery.<span class="property">ondischargingtimechange</span> = dischargingTimeChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.<span class="title function_">addEventListener</span>(</span><br><span class="line">    <span class="string">&quot;dischargingtimechange&quot;</span>,</span><br><span class="line">    dischargingTimeChangeHandler</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 添加电量百分比变化时的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">levelChangeHandler</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;levelchange&quot;</span>);</span><br><span class="line">  battery.<span class="property">onlevelchange</span> = levelChangeHandler;</span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  battery.<span class="title function_">addEventListener</span>(<span class="string">&quot;levelchange&quot;</span>, levelChangeHandler);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>硬件: 浏览器检测硬件的能力相当有限。不过，navigator 对象还是通过一些属性提供了基本信息。</li>
<li>处理器核心数: navigator.hardwareConcurrency 属性返回浏览器支持的逻辑处理器核心数量。关键在于，这个值表示浏览器可以并行执行的最大工作线程数量，不一定是实际的 CPU 核心数。</li>
<li>设备内存大小: navigator.deviceMemory 属性返回设备的内存大小（以 GiB 为单位）。这个值是一个整数，表示设备的内存大小。这个值不是强制性的，可能会被浏览器忽略。</li>
<li>最大触点数: navigator.maxTouchPoints 属性返回设备支持的最大触点数。这个值是一个整数，表示设备支持的最大触点数。这个值不是强制性的，可能会被浏览器忽略。<br>2、小结: 客户端检测是 JavaScript 中争议最多的话题之一。因为不同浏览器之间存在差异，所以经常需要根据浏览器的能力来编写不同的代码。客户端检测有不少方式，但下面两种用得最多。<br>能力检测，在使用之前先测试浏览器的特定能力。<br>用户代理检测，通过用户代理字符串确定浏览器。<br>在选择客户端检测方法时，首选是使用能力检测。特殊能力检测要放在次要位置，作为决定代码逻辑的参考。用户代理检测是最后一个选择，因为它过于依赖用户代理字符串<br>浏览器也提供了一些软件和硬件相关的信息。这些信息通过 screen 和 navigator 对象暴露出来。利用这些 API，可以获取关于操作系统、浏览器、硬件、设备位置、电池状态等方面的准确信息。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-22 日报 Day105</title>
    <url>/undefined/2025-02-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>落日沉溺于橘色的海，<br>晚风沦陷于赤诚的爱。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P443-444 第十四章：DOM编程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、异步回调与记录队列: MutationObserver 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 MutationRecord实例中，然后添加到记录队列。这个队列对每个 MutationObserver 实例都是唯一的，是所有 DOM变化事件的有序列表。</p>
<ul>
<li>记录队列: 每次 MutationRecord 被添加到 MutationObserver 的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 MutationObserver 时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。<br>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个 MutationRecord 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 MutationRecord 就用不着了，因此记录队列会被清空，其内容会被丢弃。</li>
<li>takeRecords()方法: 调用 MutationObserver 实例的 takeRecords()方法可以清空记录队列，取出并返回其中的所有 MutationRecord 实例。看这个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>( </span><br><span class="line"> <span class="function">(<span class="params">mutationRecords</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(mutationRecords)); </span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;bar&#x27;</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&#x27;baz&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(observer.<span class="title function_">takeRecords</span>()); </span><br><span class="line"><span class="comment">// [MutationRecord, MutationRecord, MutationRecord] </span></span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure></div>
这在希望断开与观察目标的联系，但又希望处理由于调用 disconnect()而被抛弃的记录队列中的MutationRecord 实例时比较有用。<br>2、性能、内存与垃圾回收: </li>
<li>MutationObserver的引用: MutationObserver 实例与目标节点之间的引用关系是非对称的。MutationObserver 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。<br>然而，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。</li>
<li>MutationRecord的引用: 记录队列中的每个 MutationRecord 实例至少包含对已有 DOM 节点的一个引用。如果变化是childList 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个 MutationRecord，然后让它们超出作用域并被垃圾回收。<br>有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存 它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个 MutationRecord中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。</li>
</ul>
<p>上述概念比较抽象举例如下:<br>⸻<br>📌 假设场景：<br>你有一个页面上某个 <div> 被插入了新的子节点，你用 MutationObserver 观察这个变化，并想把变化记录保存下来。<br>⸻<br>✅ 示例代码：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> targetNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationsList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将整个记录列表保存起来</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">savedMutations</span> = mutationsList;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(targetNode, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 DOM 变化</span></span><br><span class="line"><span class="keyword">const</span> newNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">newNode.<span class="property">textContent</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">targetNode.<span class="title function_">appendChild</span>(newNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍后移除 container 节点</span></span><br><span class="line">targetNode.<span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure></div>


<p>⸻</p>
<p>📎 问题分析：<br>    1.	MutationObserver 回调中触发的 mutationsList 是一组 MutationRecord。<br>    2.	对于 childList 类型的变化，每个 MutationRecord 都会引用新插入或删除的子节点（比如上面的 newNode）。<br>    3.	如果你 将整个 mutationsList 保存下来（如 window.savedMutations &#x3D; mutationsList），这些 MutationRecord 就还在内存中。<br>    4.	那么：<br>    •	MutationRecord → 引用 newNode<br>    •	newNode → 本应随着 DOM 清理被回收<br>    •	但因为你保留了 MutationRecord，newNode 的引用还在，于是它就 不会被垃圾回收！</p>
<p>⸻</p>
<p>💡 正确做法（释放引用）：</p>
<p>如果你只需要变化的一些信息，比如变化类型和添加了多少个节点，可以这样处理：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationsList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> summary = mutationsList.<span class="title function_">map</span>(<span class="function"><span class="params">record</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">type</span>: record.<span class="property">type</span>,</span><br><span class="line">    <span class="attr">addedCount</span>: record.<span class="property">addedNodes</span>.<span class="property">length</span>,</span><br><span class="line">    <span class="attr">removedCount</span>: record.<span class="property">removedNodes</span>.<span class="property">length</span>,</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只保存简单对象，MutationRecord 被丢弃</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">summary</span> = summary;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>这样做之后，MutationRecord 实例就会失去引用，垃圾回收机制就能正常回收其中引用的 DOM 节点。</p>
<p>3、小结: 文档对象模型（DOM，Document Object Model）是语言中立的 HTML 和 XML 文档的 API。DOM Level 1 将 HTML 和 XML 文档定义为一个节点的多层级结构，并暴露出 JavaScript 接口以操作文档的底层结构和外观。<br>DOM 由一系列节点类型构成，主要包括以下几种。<br> Node 是基准节点类型，是文档一个部分的抽象表示，所有其他类型都继承 Node。<br> Document 类型表示整个文档，对应树形结构的根节点。在 JavaScript 中，document 对象是Document 的实例，拥有查询和获取节点的很多方法。<br> Element 节点表示文档中所有 HTML 或 XML 元素，可以用来操作它们的内容和属性。<br> 其他节点类型分别表示文本内容、注释、文档类型、CDATA 区块和文档片段。</p>
<p>Node<br>├── Document<br>├── Element<br>│   └── HTMLElement（例如 <div>、<p>）<br>├── Text<br>├── Comment<br>└── DocumentFragment</p>
<p>DOM 编程在多数情况下没什么问题，在涉及<script>和<style>元素时会有一点兼容性问题。因为这些元素分别包含脚本和样式信息，所以浏览器会将它们与其他元素区别对待。<br>要理解 DOM，最关键的一点是知道影响其性能的问题所在。DOM 操作在 JavaScript 代码中是代价比较高的，NodeList 对象尤其需要注意。NodeList 对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少 DOM 操作的数量。<br>MutationObserver 是为代替性能不好的 MutationEvent 而问世的。使用它可以有效精准地监控DOM 变化，而且 API 也相对简单。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-26 日报 Day109</title>
    <url>/undefined/2025-02-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>囿于市井，面向山海，<br>远隔巷弄，且看花开。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P476-489 第十六章：DOM2和DOM3</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、遍历: DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型—— NodeIterator 和 TreeWalker——从某个起点开始执行对 DOM 结构的深度优先遍历。</p>
<ul>
<li>NodeIterator: NodeIterator 类型是两个类型中比较简单的，可以通过 document.createNodeIterator()方法创建其实例。这个方法接收以下 4 个参数。<br> root，作为遍历根节点的节点。<br> whatToShow，数值代码，表示应该访问哪些节点。<br> filter，NodeFilter 对象或函数，表示是否接收或跳过特定节点。<br> entityReferenceExpansion，布尔值，表示是否扩展实体引用。这个参数在 HTML 文档中没有效果，因为实体引用永远不扩展。<br>whatToShow 参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在 NodeFilter 类型中定义的。<br> NodeFilter.SHOW_ALL，所有节点。<br> NodeFilter.SHOW_ELEMENT，元素节点。<br> NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上。<br> NodeFilter.SHOW_TEXT，文本节点。<br> NodeFilter.SHOW_CDATA_SECTION，CData 区块节点。不是在 HTML 页面中使用的。<br> NodeFilter.SHOW_ENTITY_REFERENCE，实体引用节点。不是在 HTML 页面中使用的。<br> NodeFilter.SHOW_ENTITY，实体节点。不是在 HTML 页面中使用的。<br> NodeFilter.SHOW_PROCESSING_INSTRUCTION，处理指令节点。不是在 HTML 页面中使用的。<br> NodeFilter.SHOW_COMMENT，注释节点。<br> NodeFilter.SHOW_DOCUMENT，文档节点。<br> NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。<br> NodeFilter.SHOW_DOCUMENT_FRAGMENT，文档片段节点。不是在 HTML 页面中使用的。<br> NodeFilter.SHOW_NOTATION，记号节点。不是在 HTML 页面中使用的。<br>这些值除了 NodeFilter.SHOW_ALL 之外，都可以组合使用。比如，可以像下面这样使用按位或<br>操作组合多个选项：<br>let whatToShow &#x3D; NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;<br>createNodeIterator()方法的 filter 参数可以用来指定自定义 NodeFilter 对象，或者一个作为节点过滤器的函数。NodeFilter 对象只有一个方法 acceptNode()，如果给定节点应该访问就返回 NodeFilter.FILTER_ACCEPT，否则返回 NodeFilter.FILTER_SKIP。因为 NodeFilter 是一个抽象类型，所以不可能创建它的实例。只要创建一个包含 acceptNode()的对象，然后把它传给createNodeIterator()就可以了。以下代码定义了只接收<p>元素的节点过滤器对象：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filter = &#123; </span><br><span class="line"> <span class="title function_">acceptNode</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;p&quot;</span> ?</span><br><span class="line">  <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(root, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, filter, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter 参数还可以是一个函数，与 acceptNode()的形式一样，如下面的例子所示：</span></span><br><span class="line"><span class="keyword">let</span> filter = <span class="keyword">function</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;p&quot;</span> ? </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(root, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, filter, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要创建一个简单的遍历所有节点的 NodeIterator，可以使用以下代码：</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(root, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ALL</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>
NodeIterator 的两个主要方法是 nextNode()和 previousNode()。nextNode()方法在 DOM子树中以深度优先方式进前一步，而 previousNode()则是在遍历中后退一步。创建 NodeIterator对象的时候，会有一个内部指针指向根节点，因此第一次调用 nextNode()返回的是根节点。当遍历到达 DOM 树最后一个节点时，nextNode()返回 null。previousNode()方法也是类似的。当遍历到达DOM 树最后一个节点时，调用 previousNode()返回遍历的根节点后，再次调用也会返回 null。<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
假设想要遍历<div>元素内部的所有元素，那么可以使用如下代码：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, <span class="literal">null</span>, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); <span class="comment">// 输出标签名</span></span><br><span class="line"> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
这个例子中第一次调用 nextNode()返回<div>元素。因为 nextNode()在遍历到达 DOM 子树末尾时返回 null，所以这里通过 while 循环检测每次调用 nextNode()的返回值是不是 null。以上代码执行后会输出以下标签名：<br>DIV<br>P<br>B<br>UL<br>LI<br>LI<br>LI<br>如果只想遍历<li>元素，可以传入一个过滤器，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> filter = <span class="keyword">function</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;li&quot;</span> ? </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, </span><br><span class="line"> filter, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); <span class="comment">// 输出标签名</span></span><br><span class="line"> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
nextNode()和 previousNode()方法共同维护 NodeIterator 对 DOM 结构的内部指针，因此修改 DOM 结构也会体现在遍历中。<br>2、TreeWalker: TreeWalker 是 NodeIterator 的高级版。除了包含同样的 nextNode()、previousNode()方法，TreeWalker 还添加了如下在 DOM 结构中向不同方向遍历的方法。<br> parentNode()，遍历到当前节点的父节点。<br> firstChild()，遍历到当前节点的第一个子节点。<br> lastChild()，遍历到当前节点的最后一个子节点。<br> nextSibling()，遍历到当前节点的下一个同胞节点。<br> previousSibling()，遍历到当前节点的上一个同胞节点。<br>TreeWalker 对象要调用 document.createTreeWalker()方法来创建，这个方法接收与document.createNodeIterator()同样的参数：作为遍历起点的根节点、要查看的节点类型、节点过滤器和一个表示是否扩展实体引用的布尔值。因为两者很类似，所以 TreeWalker 通常可以取代NodeIterator，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> filter = <span class="keyword">function</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;li&quot;</span> ? </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line"> <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> walker = <span class="variable language_">document</span>.<span class="title function_">createTreeWalker</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, </span><br><span class="line"> filter, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); <span class="comment">// 输出标签名</span></span><br><span class="line"> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
不同的是，节点过滤器（filter）除了可以返回 NodeFilter.FILTER_ACCEPT 和 NodeFilter. FILTER_SKIP，还可以返回 NodeFilter.FILTER_REJECT。在使用 NodeIterator 时，NodeFilter.FILTER_SKIP 和 NodeFilter.FILTER_REJECT 是一样的。但在使用 TreeWalker 时，NodeFilter.FILTER_SKIP 表示跳过节点，访问子树中的下一个节点，而 NodeFilter.FILTER_REJECT 则表示跳过该节点以及该节点的整个子树。例如，如果把前面示例中的过滤器函数改为返回 NodeFilter.FILTER_REJECT（而不是 NodeFilter.FILTER_SKIP），则会导致遍历立即返回，不会访问任何节点。这是因为第一个返回的元素是<div>，其中标签名不是”li”，因此过滤函数返回 NodeFilter.FILTER_ REJECT，表示要跳过整个子树。因为<div>本身就是遍历的根节点，所以遍历会就此结束。<br>当然，TreeWalker 真正的威力是可以在 DOM 结构中四处游走。如果不使用过滤器，单纯使用TreeWalker 的漫游能力同样可以在 DOM 树中访问<li>元素，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> walker = <span class="variable language_">document</span>.<span class="title function_">createTreeWalker</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, <span class="literal">null</span>, <span class="literal">false</span>); </span><br><span class="line">walker.<span class="title function_">firstChild</span>(); <span class="comment">// 前往&lt;p&gt; </span></span><br><span class="line">walker.<span class="title function_">nextSibling</span>(); <span class="comment">// 前往&lt;ul&gt; </span></span><br><span class="line"><span class="keyword">let</span> node = walker.<span class="title function_">firstChild</span>(); <span class="comment">// 前往第一个&lt;li&gt; </span></span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); </span><br><span class="line"> node = walker.<span class="title function_">nextSibling</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
TreeWalker 类型也有一个名为 currentNode 的属性，表示遍历过程中上一次返回的节点（无论使用的是哪个遍历方法）。可以通过修改这个属性来影响接下来遍历的起点，如下面的例子所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = walker.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node === walker.<span class="property">currentNode</span>); <span class="comment">// true </span></span><br><span class="line">walker.<span class="property">currentNode</span> = <span class="variable language_">document</span>.<span class="property">body</span>; <span class="comment">// 修改起点</span></span><br></pre></td></tr></table></figure></div>
3、范围: 为了支持对页面更细致的控制，DOM2 Traversal and Range 模块定义了范围接口。范围可用于在文档中选择内容，而不用考虑节点之间的界限。（选择在后台发生，用户是看不到的。）范围在常规 DOM操作的粒度不够时可以发挥作用。</li>
<li>DOM范围: DOM2 在 Document 类型上定义了一个 createRange()方法，暴露在 document 对象上。使用这个方法可以创建一个 DOM 范围对象，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>();</span><br></pre></td></tr></table></figure></div>
与节点类似，这个新创建的范围对象是与创建它的文档关联的，不能在其他文档中使用。然后可以使用这个范围在后台选择文档特定的部分。创建范围并指定它的位置之后，可以对范围的内容执行一些操作，从而实现对底层 DOM 树更精细的控制。<br>每个范围都是 Range 类型的实例，拥有相应的属性和方法。下面的属性提供了与范围在文档中位置相关的信息。<br> startContainer，范围起点所在的节点（选区中第一个子节点的父节点）。<br> startOffset，范围起点在 startContainer 中的偏移量。如果 startContainer 是文本节点、注释节点或 CData 区块节点，则 startOffset 指范围起点之前跳过的字符数；否则，表示范围中第一个节点的索引。<br> endContainer，范围终点所在的节点（选区中最后一个子节点的父节点）。<br> endOffset，范围起点在 startContainer 中的偏移量（与 startOffset 中偏移量的含义相同）。<br> commonAncestorContainer，文档中以startContainer和endContainer为后代的最深的节点。</li>
<li>属性选择: 通过范围选择文档中某个部分最简单的方式，就是使用 selectNode()或 selectNodeContents()方法。这两个方法都接收一个节点作为参数，并将该节点的信息添加到调用它的范围。selectNode()方法选择整个节点，包括其后代节点，而 selectNodeContents()只选择节点的后代。假设有如下 HTML：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(), </span><br><span class="line"> range2 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(), </span><br><span class="line"> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>); </span><br><span class="line">range1.<span class="title function_">selectNode</span>(p1); </span><br><span class="line">range2.<span class="title function_">selectNodeContents</span>(p1);</span><br></pre></td></tr></table></figure></div>
例子中的这两个范围包含文档的不同部分。range1 包含<p>元素及其所有后代，而 range2 包含<b>元素、文本节点”Hello”和文本节点” world!”.<br>4、复杂选择: 要创建复杂的范围，需要使用 setStart()和 setEnd()方法。这两个方法都接收两个参数：参照节点和偏移量。对 setStart()来说，参照节点会成为 startContainer，而偏移量会赋值给 startOffset。对 setEnd()而言，参照节点会成为 endContainer，而偏移量会赋值给 endOffset。<br>5、清理: 在使用完范围之后，最好调用 detach()方法把范围从创建它的文档中剥离。调用 detach()之后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">range.<span class="title function_">detach</span>(); <span class="comment">// 从文档中剥离范围</span></span><br><span class="line">range = <span class="literal">null</span>; <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure></div>
6、小结: DOM2 Style 模块定义了如何操作元素的样式信息。<br> 每个元素都有一个关联的 style 对象，可用于确定和修改元素特定的样式。<br> 要确定元素的计算样式，包括应用到元素身上的所有 CSS规则，可以使用getComputedStyle()方法。<br> 通过 document.styleSheets 集合可以访问文档上所有的样式表。DOM2 Traversal and Range 模块定义了与 DOM 结构交互的不同方式。<br> NodeIterator 和 TreeWalker 可以对 DOM 树执行深度优先的遍历。<br> NodeIterator 接口很简单，每次只能向前和向后移动一步。TreeWalker 除了支持同样的行为，还支持在 DOM 结构的所有方向移动，包括父节点、同胞节点和子节点。<br> 范围是选择 DOM 结构中特定部分并进行操作的一种方式。<br> 通过范围的选区可以在保持文档结构完好的同时从文档中移除内容，也可复制文档中相应的部分。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-25 日报 Day108</title>
    <url>/undefined/2025-02-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>慢慢来，<br>好戏都在烟火里。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P460-475 第十六章：DOM2和DOM3</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、DOM1（DOM Level 1）主要定义了 HTML 和 XML 文档的底层结构。DOM2（DOM Level 2）和DOM3（DOM Level 3）在这些结构之上加入更多交互能力，提供了更高级的 XML 特性。实际上，DOM2和 DOM3 是按照模块化的思路来制定标准的，每个模块之间有一定关联，但分别针对某个 DOM 子集。这些模式如下所示。<br> DOM Core：在 DOM1 核心部分的基础上，为节点增加方法和属性。<br> DOM Views：定义基于样式信息的不同视图。<br> DOM Events：定义通过事件实现 DOM 文档交互。<br> DOM Style：定义以编程方式访问和修改 CSS 样式的接口。<br> DOM Traversal and Range：新增遍历 DOM 文档及选择文档内容的接口。<br> DOM HTML：在 DOM1 HTML 部分的基础上，增加属性、方法和新接口。<br> DOM Mutation Observers：定义基于 DOM 变化触发回调的接口。这个模块是 DOM4 级模块，用于取代 Mutation Events。</p>
<p>2、XML命名空间:<br>在节点使用命名空间前缀的情况下，nodeName 等于 prefix + “:” + localName。比如下面这个例子：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">s:svg</span> <span class="attr">xmlns:s</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%; height:100%&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">s:rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill:red&quot;</span> /&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">s:svg</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>其中的<html>元素的 localName 和 tagName 都是”html”，namespaceURL 是”<a class="link"   href="http://www.w3.org/1999/xhtml%22%EF%BC%8C%E8%80%8C" >http://www.w3.org/1999/xhtml&quot;，而 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> prefix 是 null。对于&lt;s:svg&gt;元素，localName 是”svg”，tagName 是”s:svg”，namespaceURI 是”<a class="link"   href="https://www.w3.org/2000/svg%22%EF%BC%8C%E8%80%8C" >https://www.w3.org/2000/svg&quot;，而 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> prefix 是”s”。<br>DOM2 HTML 给 HTMLIFrameElement（即<iframe>，内嵌窗格）类型新增了一个属性，叫contentDocument。这个属性包含代表子内嵌窗格中内容的 document 对象的指针。下面的例子展示了如何使用这个属性：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myIframe&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> iframeDoc = iframe.<span class="property">contentDocument</span>;</span><br></pre></td></tr></table></figure></div>
<p>contentDocument 属性是 Document 的实例，拥有所有文档属性和方法，因此可以像使用其他HTML 文档一样使用它。还有一个属性 contentWindow，返回相应窗格的 window 对象，这个对象上有一个 document 属性。所有现代浏览器都支持 contentDocument 和 contentWindow 属性。<br>注意 跨源访问子内嵌窗格的 document 对象会受到安全限制。如果内嵌窗格中加载了不同域名（或子域名）的页面，或者该页面使用了不同协议，则访问其 document 对象会抛出错误。</p>
<p>3、样式: 外部样式表(通过<link>元素)、文档样式表(使用<style></style>元素)和元素特定样式(使用style属性)。</p>
<ul>
<li>存取元素样式: 任何支持 style 属性的 HTML 元素在 JavaScript 中都会有一个对应的 style 属性。这个 style 属性是 CSSStyleDeclaration 类型的实例，其中包含通过 HTML style 属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式。HTML style 属性中的 CSS 属性在 JavaScript style 对象中都有对应的属性。因为 CSS 属性名使用连字符表示法（用连字符分隔两个单词，如 background-image），所以在 JavaScript 中这些属性必须转换为驼峰大小写形式（如backgroundImage）。下表给出了几个常用的 CSS 属性与 style 对象中等价属性的对比。<table>
<thead>
<tr>
<th>CSS属性</th>
<th>JavaScript属性</th>
</tr>
</thead>
<tbody><tr>
<td>background-image</td>
<td>style.backgroundImage</td>
</tr>
<tr>
<td>color</td>
<td>style.color</td>
</tr>
<tr>
<td>display</td>
<td>style.display</td>
</tr>
<tr>
<td>font-size</td>
<td>style.fontSize</td>
</tr>
<tr>
<td>font-family</td>
<td>style.fontFamily</td>
</tr>
</tbody></table>
</li>
</ul>
<p>DOM2 Style 规范也在 style 对象上定义了一些属性和方法。这些属性和方法提供了元素 style 属性的信息并支持修改，列举如下。<br> cssText，包含 style 属性中的 CSS 代码。<br> length，应用给元素的 CSS 属性数量。<br> parentRule，表示 CSS 信息的 CSSRule 对象（下一节会讨论 CSSRule 类型）。<br> getPropertyCSSValue(propertyName)，返回包含 CSS 属性 propertyName 值的 CSSValue对象（已废弃）。<br> getPropertyPriority(propertyName)，如果 CSS 属性 propertyName 使用了!important则返回”important”，否则返回空字符串。<br> getPropertyValue(propertyName)，返回属性 propertyName 的字符串值。<br> item(index)，返回索引为 index 的 CSS 属性名。<br> removeProperty(propertyName)，从样式中删除 CSS 属性 propertyName。<br> setProperty(propertyName, value, priority)，设置 CSS 属性 propertyName 的值为value，priority 是”important”或空字符串。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">myDiv.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">&quot;width: 25px; height: 100px; background-color: green&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDiv.<span class="property">style</span>.<span class="property">cssText</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = myDiv.<span class="property">style</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(myDiv.<span class="property">style</span>[i]); <span class="comment">// 或者用 myDiv.style.item(i) </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prop, value, i, len; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = myDiv.<span class="property">style</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> prop = myDiv.<span class="property">style</span>[i]; <span class="comment">// 或者用 myDiv.style.item(i) </span></span><br><span class="line"> value = myDiv.<span class="property">style</span>.<span class="title function_">getPropertyValue</span>(prop); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`prop: <span class="subst">$&#123;value&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prop, value, i, len; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = myDiv.<span class="property">style</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> prop = myDiv.<span class="property">style</span>[i]; <span class="comment">// alternately, myDiv.style.item(i) </span></span><br><span class="line"> value = myDiv.<span class="property">style</span>.<span class="title function_">getPropertyCSSValue</span>(prop); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`prop: <span class="subst">$&#123;value.cssText&#125;</span> (<span class="subst">$&#123;value.cssValueType&#125;</span>)`</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4、操作样式表: CSSStyleSheet 类型表示 CSS 样式表，包括使用<link>元素和通过<style>元素定义的样式表。注意，这两个元素本身分别是 HTMLLinkElement 和 HTMLStyleElement。CSSStyleSheet 类型是一个通用样式表类型，可以表示以任何方式在 HTML 中定义的样式表。另外，元素特定的类型允许修改HTML 属性，而 CSSStyleSheet 类型的实例则是一个只读对象（只有一个属性例外）。<br>div.box {<br> background-color: blue;<br> width: 100px;<br> height: 200px;<br>}</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> rules = sheet.<span class="property">cssRules</span> || sheet.<span class="property">rules</span>; <span class="comment">// 取得规则集合</span></span><br><span class="line"><span class="keyword">let</span> rule = rules[<span class="number">0</span>]; <span class="comment">// 取得第一条规则</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">selectorText</span>); <span class="comment">// &quot;div.box&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">cssText</span>); <span class="comment">// 完整的 CSS 代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">backgroundColor</span>); <span class="comment">// &quot;blue&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">width</span>); <span class="comment">// &quot;100px&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">height</span>); <span class="comment">// &quot;200px&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> rules = sheet.<span class="property">cssRules</span> || sheet.<span class="property">rules</span>; <span class="comment">// 取得规则集合</span></span><br><span class="line"><span class="keyword">let</span> rule = rules[<span class="number">0</span>]; <span class="comment">// 取得第一条规则</span></span><br><span class="line">rule.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>5、元素尺寸: </p>
<ul>
<li>偏移尺寸: 第一组属性涉及偏移尺寸包含元素在屏幕上占用的所有视觉空间。元素在页面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框（但不包含外边距）。以下 4 个属性用于取得元素的偏移尺寸。</li>
<li>offsetHeight，元素的高度（包括边框和内边距）。</li>
<li>offsetWidth，元素的宽度（包括边框和内边距）。</li>
<li>offsetLeft，元素左边缘到其包含块左边缘的距离。</li>
<li>offsetTop，元素上边缘到其包含块上边缘的距离。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElementLeft</span>(<span class="params">element</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> actualLeft = element.<span class="property">offsetLeft</span>; </span><br><span class="line"> <span class="keyword">let</span> current = element.<span class="property">offsetParent</span>; </span><br><span class="line"> <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123; </span><br><span class="line">    actualLeft += current.<span class="property">offsetLeft</span>; </span><br><span class="line">    current = current.<span class="property">offsetParent</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> actualLeft; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElementTop</span>(<span class="params">element</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> actualTop = element.<span class="property">offsetTop</span>; </span><br><span class="line"> <span class="keyword">let</span> current = element.<span class="property">offsetParent</span>; </span><br><span class="line"> <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123; </span><br><span class="line">    actualTop += current.<span class="property">offsetTop</span>; </span><br><span class="line">    current = current.<span class="property">offsetParent</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> actualTop; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>客户端尺寸: 元素的客户端尺寸（client dimensions）包含元素内容及其内边距所占用的空间。客户端尺寸只有两个相关属性：clientWidth 和 clientHeight。其中，clientWidth 是内容区宽度加左、右内边距宽度，clientHeight 是内容区高度加上、下内边距高度。</li>
<li>滚动尺寸: 最后一组尺寸是滚动尺寸（scroll dimensions），提供了元素内容滚动距离的信息。有些元素，比如<html>无须任何代码就可以自动滚动，而其他元素则需要使用 CSS 的 overflow 属性令其滚动。滚动尺寸相关的属性有如下 4 个。</li>
<li>scrollHeight，没有滚动条出现时，元素内容的总高度。</li>
<li>scrollLeft, 内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li>
<li>scrollTop, 内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li>
<li>scrollWidth, 没有滚动条出现时，元素内容的总宽度。</li>
</ul>
<p>6、确定元素尺寸: 浏览器在每个元素上都暴露了 getBoundingClientRect()方法，返回一个 DOMRect 对象，包含6 个属性：left、top、right、bottom、height 和 width。这些属性给出了元素在页面中相对于视<br>口的位置。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-24 日报 Day107</title>
    <url>/undefined/2025-02-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>追光的人，<br>终会光芒万丈。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P456-459 第十五章：DOM扩展</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、专有扩展: </p>
<ul>
<li>children属性: children 属性是一个 HTMLCollection，只包含元素的 Element 类型的子节点。如果元素的子节点类型全部是元素类型，那 children 和 childNodes 中包含的节点应该是一样的。可以像下面这样使用 children 属性：<br>let childCount &#x3D; element.children.length;<br>let firstChild &#x3D; element.children[0];</li>
<li>contains()方法: DOM 编程中经常需要确定一个元素是不是另一个元素的后代。IE 首先引入了 contains()方法，让开发者可以在不遍历 DOM 的情况下获取这个信息。contains()方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。<br>如果目标节点是被搜索节点的后代，contains()返回 true，否则返回 false。下面看一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">contains</span>(<span class="variable language_">document</span>.<span class="property">body</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure></div>
这个例子测试<html>元素中是否包含<body>元素，在格式正确的 HTML 中会返回 true。<br>另外，使用 DOM Level 3 的 compareDocumentPosition()方法也可以确定节点间的关系。这个方法会返回表示两个节点关系的位掩码。下表给出了这些位掩码的说明。<br>掩 码 节点关系<br>0x1 断开（传入的节点不在文档中）<br>0x2 领先（传入的节点在 DOM 树中位于参考节点之前）<br>0x4 随后（传入的节点在 DOM 树中位于参考节点之后）<br>0x8 包含（传入的节点是参考节点的祖先）<br>0x10 被包含（传入的节点是参考节点的后代）<br>2、插入标记: HTML5 将 IE 发明的 innerHTML 和 outerHTML 纳入了标准，但还有两个属性没有入选。这两个剩下的属性是 innerText 和 outerText。</li>
<li>innerText属性: innerText 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时，innerText 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，innerText会移除元素的所有后代并插入一个包含该值的文本节点。来看下面的 HTML 代码：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
对这个例子中的<div>而言，innerText 属性会返回以下字符串：<br>This is a paragraph with a list following it. Item 1 Item 2 Item 3</li>
<li>outerText属性: outerText 与 innerText 是类似的，只不过作用范围包含调用它的节点。要读取文本值时，outerText 与 innerText 实际上会返回同样的内容。但在写入文本值时，outerText 就大不相同了。写入文本值时，outerText 不止会移除所有后代节点，而是会替换整个元素。比如：<br>div.outerText &#x3D; “Hello world!”;<br>这行代码的执行效果就相当于以下两行代码：<br>let text &#x3D; document.createTextNode(“Hello world!”);<br>div.parentNode.replaceChild(text, div);<br>本质上，这相当于用新的文本节点替代 outerText 所在的元素。此时，原来的元素会与文档脱离关系，因此也无法访问。<br>outerText 是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。除 Firefox 之外所有主流浏览器都支持 outerText。<br>3、滚动:<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不可见，则将元素可见</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>].<span class="title function_">scrollIntoViewIfNeeded</span>();</span><br></pre></td></tr></table></figure></div>
4、小结:<br>虽然 DOM 规定了与 XML 和 HTML 文档交互的核心 API，但其他几个规范也定义了对 DOM 的扩展。很多扩展都基于之前的已成为事实标准的专有特性标准化而来。本章主要介绍了以下 3 个规范。<br> Selectors API 为基于 CSS 选择符获取 DOM 元素定义了几个方法：querySelector()、querySelectorAll()和 matches()。<br> Element Traversal 在 DOM 元素上定义了额外的属性，以方便对 DOM 元素进行遍历。这个需求是因浏览器处理元素间空格的差异而产生的。<br> HTML5 为标准 DOM 提供了大量扩展。其中包括对 innerHTML 属性等事实标准进行了标准化，还有焦点管理、字符集、滚动等特性。<br>DOM 扩展的数量总体还不大，但随着 Web 技术的发展一定会越来越多。浏览器仍然没有停止对专有扩展的探索，如果出现成功的扩展，那么就可能成为事实标准，或者最终被整合到未来的标准中。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-23 日报 Day106</title>
    <url>/undefined/2025-02-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>愿你千山暮雪海棠依旧，<br>不为岁月惊扰平添忧愁。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P445-455 第十五章：DOM扩展</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、DOM 扩展的两个标准：Selectors API 与 HTML5。<br>2、Selectors API: JavaScript 库中最流行的一种能力就是根据 CSS 选择符的模式匹配 DOM 元素。比如，jQuery 就完全以 CSS 选择符查询 DOM 获取元素引用，而不是使用 getElementById()和 getElementsByTagName()。<br>Selectors API是 W3C 推荐标准，规定了浏览器原生支持的 CSS 查询 API。Selectors API Level 1 的核心是两个方法：querySelector()和 querySelectorAll()。在兼容浏览器中，Document 类型和 Element 类型的实例上都会暴露这两个方法。Selectors API Level 2 规范在 Element 类型上新增了更多方法，比如 matches()、find()和findAll()。不过，目前还没有浏览器实现或宣称实现 find()和 findAll()。</p>
<ul>
<li>querySelector()方法: querySelector()方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 null。下面是一些例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得&lt;body&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;body&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#myDiv&quot;</span>);</span><br><span class="line"><span class="comment">// 取得类名为&quot;selected&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得类名为&quot;button&quot;的图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;img.button&quot;</span>);</span><br></pre></td></tr></table></figure></div>
在 Document 上使用 querySelector()方法时，会从文档元素开始搜索；在 Element 上使用querySelector()方法时，则只会从当前元素的后代中查询。<br>用于查询模式的 CSS 选择符可繁可简，依需求而定。如果选择符有语法错误或碰到不支持的选择符，则 querySelector()方法会抛出错误。</li>
<li>querySelectorAll(): querySelectorAll()方法跟 querySelector()一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 NodeList 的静态实例。<br>再强调一次，querySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 NodeList 对象可能造成的性能问题。<br>以有效 CSS 选择符调用 querySelectorAll()都会返回 NodeList，无论匹配多少个元素都可以。如果没有匹配项，则返回空的 NodeList 实例。<br>与 querySelector()一样，querySelectorAll()也可以在 Document、DocumentFragment 和Element 类型上使用。下面是几个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> ems = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">querySelectorAll</span>(<span class="string">&quot;em&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有类名中包含&quot;selected&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> selecteds = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> strongs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p strong&quot;</span>);</span><br><span class="line"><span class="comment">// 返回的 NodeList 对象可以通过 for-of 循环、item()方法或中括号语法取得个别元素。比如：</span></span><br><span class="line"><span class="keyword">let</span> strongElements = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p strong&quot;</span>); </span><br><span class="line"><span class="comment">// 以下 3 个循环的效果一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> strong <span class="keyword">of</span> strongElements) &#123; </span><br><span class="line"> strong.<span class="property">className</span> = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.<span class="property">length</span>; ++i) &#123; </span><br><span class="line"> strongElements.<span class="title function_">item</span>(i).<span class="property">className</span> = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.<span class="property">length</span>; ++i) &#123; </span><br><span class="line"> strongElements[i].<span class="property">className</span> = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
与 querySelector()方法一样，如果选择符有语法错误或碰到不支持的选择符，则 querySelectorAll()方法会抛出错误。</li>
<li>matches(): matches()方法接收一个 CSS 选择符参数，返回一个布尔值，表示当前元素是否匹配该模式。matches()方法可以在 Document、DocumentFragment 和 Element 类型上使用。下面是几个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">matches</span>(<span class="string">&quot;body.page1&quot;</span>))&#123; </span><br><span class="line"> <span class="comment">// true </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
使用这个方法可以方便地检测某个元素会不会被 querySelector()或 querySelectorAll()方法返回。所有主流浏览器都支持 matches()。<br>2、元素遍历: Element Traversal API 为 DOM 元素添加了 5 个属性：<br> childElementCount，返回子元素数量（不包含文本节点和注释）；<br> firstElementChild，指向第一个 Element 类型的子元素（Element 版 firstChild）；<br> lastElementChild，指向最后一个 Element 类型的子元素（Element 版 lastChild）；<br> previousElementSibling ，指向前一个 Element 类型的同胞元素（ Element 版previousSibling）；<br> nextElementSibling，指向后一个 Element 类型的同胞元素（Element 版 nextSibling）。<br>举个例子，过去要以跨浏览器方式遍历特定元素的所有子元素，代码大致是这样写的：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> currentChildNode = parentElement.<span class="property">firstChild</span>; </span><br><span class="line"><span class="comment">// 没有子元素，firstChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildNode) &#123; </span><br><span class="line"> <span class="keyword">if</span> (currentChildNode.<span class="property">nodeType</span> === <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="comment">// 如果有元素节点，则做相应处理</span></span><br><span class="line"> <span class="title function_">processChild</span>(currentChildNode); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (currentChildNode === parentElement.<span class="property">lastChild</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> currentChildNode = currentChildNode.<span class="property">nextSibling</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
使用 Element Traversal 属性之后，以上代码可以简化如下：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parentElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> currentChildElement = parentElement.<span class="property">firstElementChild</span>;</span><br><span class="line"><span class="comment">// 没有子元素，firstElementChild 返回 null，跳过循环</span></span><br><span class="line"><span class="keyword">while</span> (currentChildElement) &#123; </span><br><span class="line"> <span class="comment">// 这就是元素节点，做相应处理</span></span><br><span class="line"> <span class="title function_">processChild</span>(currentChildElement); </span><br><span class="line"> <span class="keyword">if</span> (currentChildElement === parentElement.<span class="property">lastElementChild</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> currentChildElement = currentChildElement.<span class="property">nextElementSibling</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
3、HTML5CSS类扩展: </li>
<li>getElementsByClassName(): getElementsByClassName()方法接收一个类名参数，返回一个 NodeList 实例，包含所有匹配该类名的元素。这个方法在 Document 和 Element 类型上都可以使用。下面是几个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素</span></span><br><span class="line"><span class="comment">// 这两个类名的顺序无关紧要</span></span><br><span class="line"><span class="keyword">let</span> allCurrentUsernames = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;username current&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;selected&quot;</span>);</span><br></pre></td></tr></table></figure></div>
这个方法只会返回以调用它的对象为根元素的子树中所有匹配的元素。在 document 上调用getElementsByClassName()返回文档中所有匹配的元素，而在特定元素上调用 getElementsByClassName()则返回该元素后代中匹配的元素。</li>
<li>classList属性: 要操作类名，可以通过 className 属性实现添加、删除和替换。但 className 是一个字符串，所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。以下面的 HTML代码为例：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;bd user disabled&quot;</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>
HTML5 通过给所有元素增加 classList 属性为这些操作提供了更简单也更安全的实现方式。classList 是一个新的集合类型 DOMTokenList 的实例。与其他 DOM 集合类型一样，DOMTokenList也有 length 属性表示自己包含多少项，也可以通过 item()或中括号取得个别的元素。此外，DOMTokenList 还增加了以下方法。<br> add(value)，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。<br> contains(value)，返回布尔值，表示给定的 value 是否存在。<br> remove(value)，从类名列表中删除指定的字符串值 value。<br> toggle(value)，如果类名列表中已经存在指定的 value，则删除；如果不存在，则添加。<br>这样以来，前面的例子中那么多行代码就可以简化成下面的一行：<br>div.classList.remove(“user”);<br>这行代码可以在不影响其他类名的情况下完成删除。其他方法同样极大地简化了操作类名的复杂性，如下面的例子所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除&quot;disabled&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;disabled&quot;</span>); </span><br><span class="line"><span class="comment">// 添加&quot;current&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;current&quot;</span>);</span><br><span class="line"><span class="comment">// 切换&quot;user&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&quot;user&quot;</span>); </span><br><span class="line"><span class="comment">// 检测类名 </span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;bd&quot;</span>) &amp;&amp; !div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;disabled&quot;</span>))&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代类名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">class</span> <span class="title class_">of</span> div.<span class="property">classList</span>)&#123; </span><br><span class="line"> <span class="title function_">doStuff</span>(<span class="keyword">class</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
4、焦点管理: HTML5 增加了辅助 DOM 焦点管理的功能。首先是 document.activeElement，始终包含当前拥有焦点的 DOM 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 focus()方法）让某个元素自动获得焦点。例如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.<span class="title function_">focus</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">activeElement</span> === button); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
默认情况下，document.activeElement 在页面刚加载完之后会设置为 document.body。而在页面完全加载之前，document.activeElement 的值为 null。<br>其次是 document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.<span class="title function_">focus</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">hasFocus</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
确定文档是否获得了焦点，就可以帮助确定用户是否在操作页面<br>第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点，而这对于保证 Web 应用程序的无障碍使用是非常重要的。无障碍 Web 应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。<br>5、HTMLDocument扩展: </li>
<li>readyState属性: document.readyState 属性有两个可能的值：<br> loading，表示文档正在加载；<br> complete，表示文档加载完成。<br>实际开发中，最好是把 document.readState 当成一个指示器，以判断文档是否加载完毕。在这个属性得到广泛支持以前，通常要依赖 onload 事件处理程序设置一个标记，表示文档加载完了。这个属性的基本用法如下：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>)&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>compatMode属性: 自从 IE6 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。IE 为 document 添加了 compatMode 属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。<br>如下面的例子所示，标准模式下 document.compatMode 的值是”CSS1Compat”，而在混杂模式下，document.compatMode 的值是”BackCompat”：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>)&#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Standards mode&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Quirks mode&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>head属性: 作为对 document.body（指向文档的<body>元素）的补充，HTML5 增加了 document.head 属性，指向文档的<head>元素。可以像下面这样直接取得<head>元素：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="property">head</span>;</span><br></pre></td></tr></table></figure></div>
6、文字集属性: HTML5 增加了几个与文档字符集有关的新属性。其中，characterSet 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是”UTF-16”，但可以通过<meta>元素或响应头，以及新增的 characterSeet 属性来修改。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">characterSet</span>); <span class="comment">// &quot;UTF-16&quot; </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">characterSet</span> = <span class="string">&quot;UTF-8&quot;</span>;</span><br></pre></td></tr></table></figure></div>
7、自定义数据属性: HTML5 允许给元素指定非标准的属性，但要使用前缀 data-以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，data-后面跟什么都可以。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span> data-appId=<span class="string">&quot;12345&quot;</span> data-myname=<span class="string">&quot;Nicholas&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>
定义了自定义数据属性后，可以通过元素的 dataset 属性来访问。dataset 属性是一个DOMStringMap 的实例，包含一组键&#x2F;值对映射。元素的每个 data-name 属性在 dataset 中都可以通过 data-后面的字符串作为键来访问（例如，属性 data-myname、data-myName 可以通过 myname 访问，但要注意 data-my-name、data-My-Name 要通过 myName 来访问）。下面是一个使用自定义数据属性的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本例中使用的方法仅用于示范</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="comment">// 取得自定义数据属性的值</span></span><br><span class="line"><span class="keyword">let</span> appId = div.<span class="property">dataset</span>.<span class="property">appId</span>; </span><br><span class="line"><span class="keyword">let</span> myName = div.<span class="property">dataset</span>.<span class="property">myname</span>; </span><br><span class="line"><span class="comment">// 设置自定义数据属性的值</span></span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">appId</span> = <span class="number">23456</span>; </span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">myname</span> = <span class="string">&quot;Michael&quot;</span>; </span><br><span class="line"><span class="comment">// 有&quot;myname&quot;吗？</span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">dataset</span>.<span class="property">myname</span>)&#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;div.dataset.myname&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
自定义数据属性非常适合需要给元素附加某些数据的场景，比如链接追踪和在聚合应用程序中标识页面的不同部分。另外，单页应用程序框架也非常多地使用了自定义数据属性。<br>8、插入标记: DOM 虽然已经为操纵节点提供了很多 API，但向文档中一次性插入大量 HTML 时还是比较麻烦。相比先创建一堆节点，再把它们以正确的顺序连接起来，直接插入一个 HTML 字符串要简单（快速）得多。HTML5 已经通过以下 DOM 扩展将这种能力标准化了。</li>
<li>innerHTML属性: 在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点。而在写入 innerHTML 时，则会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有节点。比如下面的 HTML 代码：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
对于这里的<div>元素而言，其 innerHTML 属性会返回以下字符串：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
在写入模式下，赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点。因为所赋的值默认为 HTML，所以其中的所有标签都会以浏览器处理 HTML 的方式转换为元素（同样，转换结果也会因浏览器不同而不同）。如果赋值中不包含任何 HTML 标签，则直接生成一个文本节点，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure></div>
因为浏览器会解析设置的值，所以给 innerHTML 设置包含 HTML 的字符串时，结果会大不一样。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;</span>;</span><br></pre></td></tr></table></figure></div>
这个操作的结果相当于：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>Hello <span class="symbol">&amp;amp;</span> welcome, <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="symbol">&amp;quot;</span>reader<span class="symbol">&amp;quot;</span>!<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure></div>
设置完 innerHTML，马上就可以像访问其他节点一样访问这些新节点。</li>
</ul>
<p>注意 设置 innerHTML 会导致浏览器将 HTML 字符串解析为相应的 DOM 树。这意味着设置 innerHTML 属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的 DOM 子树序列化之后的结果。</p>
<ul>
<li><p>outerHTML属性: 读取 outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。在写入outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。比如下面的 HTML 代码：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>在这个<div>元素上调用 outerHTML 会返回相同的字符串，包括<div>本身。注意，浏览器因解析和解释 HTML 代码的机制不同，返回的字符串也可能不同。（跟 innerHTML 的情况是一样的。）<br>如果使用 outerHTML 设置 HTML，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">outerHTML</span> = <span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// 则会得到与执行以下脚本相同的结果：</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>); </span><br><span class="line">p.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;This is a paragraph.&quot;</span>)); </span><br><span class="line">div.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(p, div);</span><br></pre></td></tr></table></figure></div>
<p>新的<p>元素会取代 DOM 树中原来的<div>元素。</p>
</li>
<li><p>insertAdjacentHTML()与insertAdjacentText(): 关于插入标签的最后两个新增方法是 insertAdjacentHTML()和 insertAdjacentText()。这两个方法最早源自 IE，它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本。第一个参数必须是下列值中的一个：<br> “beforebegin”，插入当前元素前面，作为前一个同胞节点；<br> “afterbegin”，插入当前元素内部，作为新的子节点或放在第一个子节点前面；<br> “beforeend”，插入当前元素内部，作为新的子节点或放在最后一个子节点后面；<br> “afterend”，插入当前元素后面，作为下一个同胞节点。<br>第二个参数会作为 HTML 字符串解析（与 innerHTML 和outerHTML 相同）或者作为纯文本解析（与 innerText 和 outerText 相同）。如果是 HTML，则会在解析出错时抛出错误。下面展示了基本用法①：<br>① 假设当前元素是<p>Hello world!</p>，则”beforebegin”和”afterbegin”中的”begin”指开始标签<p>；而”afterend”和”beforeend”中的”end”指结束标签</p>。——译者注</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为前一个同胞节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为第一个子节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为最后一个子节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); </span><br><span class="line">element.<span class="title function_">insertAdjacentText</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"><span class="comment">// 作为下一个同胞节点插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>); element. </span><br><span class="line"><span class="title function_">insertAdjacentText</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure></div></li>
<li><p>内存与性能问题: 使用本节介绍的方法替换子节点可能在浏览器（特别是 IE）中导致内存问题。比如，如果被移除的子树元素中之前有关联的事件处理程序或其他 JavaScript 对象（作为元素的属性），那它们之间的绑定关系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用 innerHTML、outerHTML 和 insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和JavaScript 对象。<br>使用这些属性当然有其方便之处，特别是 innerHTML。一般来讲，插入大量的新 HTML 使用innerHTML 比使用多次 DOM 操作创建节点再插入来得更便捷。这是因为 HTML 解析器会解析设置给innerHTML（或 outerHTML）的值。解析器在浏览器中是底层代码（通常是 C++代码），比 JavaScript快得多。不过，HTML 解析器的构建与解构也不是没有代价，因此最好限制使用 innerHTML 和outerHTML 的次数。</p>
</li>
<li><p>跨站点脚本: 尽管 innerHTML 不会执行自己创建的<script>标签，但仍然向恶意用户暴露了很大的攻击面，因为通过它可以毫不费力地创建元素并执行 onclick 之类的属性。如果页面中要使用用户提供的信息，则不建议使用 innerHTML。与使用 innerHTML 获得的方便相比，防止 XSS 攻击更让人头疼。此时一定要隔离要插入的数据，在插入页面前必须毫不犹豫地使用相关的库对它们进行转义。</p>
</li>
<li><p>scrollIntoView(): DOM 规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5 选择了标准化 scrollIntoView()。<br>scrollIntoView()方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下：<br> alignToTop 是一个布尔值。<br> true：窗口滚动后元素的顶部与视口顶部对齐。<br> false：窗口滚动后元素的底部与视口底部对齐。<br> scrollIntoViewOptions 是一个选项对象。<br> behavior：定义过渡动画，可取的值为"smooth"和"auto"，默认为"auto"。<br> block：定义垂直方向的对齐，可取的值为"start"、"center"、"end"和"nearest"，默认为 "start"。<br> inline：定义水平方向的对齐，可取的值为"start"、"center"、"end"和"nearest"，默认为 "nearest"。<br> 不传参数等同于 alignToTop 为 true。<br>来看几个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保元素可见</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(); </span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;); </span><br><span class="line"><span class="comment">// 尝试将元素平滑地滚入视口</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>, <span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure></div>
<p>这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览器将元素滚动到可见位置。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-27 日报 Day110</title>
    <url>/undefined/2025-02-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>辞暮尔尔，<br>烟火年年。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P490-504 第十七章：事件</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、JavaScript 与 HTML 的交互是通过事件实现的，事件代表文档或浏览器窗口中某个有意义的时刻。可以使用仅在事件发生时执行的监听器（也叫处理程序）订阅事件。在传统软件工程领域，这个模型叫“观察者模式”，其能够做到页面行为（在 JavaScript 中定义）与页面展示（在 HTML 和 CSS 中定义）的分离。<br>2、事件流: 事件流描述了页面接收事件的顺序。</p>
<ul>
<li>事件冒泡: IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。比如有如下 HTML 页面：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在点击页面中的<div>元素后，click 事件会以如下顺序发生<br>(1) <div><br>(2) <body><br>(3) <html><br>(4) document<br>也就是说，<div>元素，即被点击的元素，最先触发 click 事件。然后，click 事件沿 DOM 树一路向上，在经过的每个节点上依次触发，直至到达 document 对象。所有现代浏览器都支持事件冒泡，现代浏览器中的事件会一直冒泡到 window 对象。</p>
<ul>
<li>事件捕获: 事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。如果前面的例子使用事件捕获，则点击<div>元素会以下列顺序触发 click 事件：<br>(1) document<br>(2) <html><br>(3) <body><br>(4) <div><br>在事件捕获中，click 事件首先由 document 元素捕获，然后沿 DOM 树依次向下传播，直至到达实际的目标元素<div>。<br>3、DOM 事件流: DOM2 Events 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。<br>在 DOM 事件流中，实际的目标（<div>元素）在捕获阶段不会接收到事件。这是因为捕获阶段从 document 到<html>再到<body>就结束了。下一阶段，即会在<div>元素上触发事件的“到达目标”阶段，通常在事件处理时被认为是冒泡阶段的一部分（稍后讨论）。然后，冒泡阶段开始，事件反向传播至文档。<br>4、事件处理程序: 事件意味着用户或浏览器执行的某种动作。比如，单击（click）、加载（load）、鼠标悬停（mouseover）。为响应事件而调用的函数被称为事件处理程序（或事件监听器）。事件处理程序的名字以”on”开头，因此 click 事件的处理程序叫作 onclick，而 load 事件的处理程序叫作 onload。有很多方式可以指定事件处理程序。</li>
<li>HTML 事件处理程序: 使用 HTML 指定事件处理程序的最后一个问题是 HTML 与 JavaScript 强耦合。如果需要修改事件处理程序，则必须在两个地方，即 HTML 和 JavaScript 中，修改代码。这也是很多开发者不使用 HTML 事件处理程序，而使用 JavaScript 指定事件处理程序的主要原因。</li>
<li>DOM0 事件处理程序: 像这样使用 DOM0 方式为事件处理程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域中运行，即 this 等于元素。下面的例子演示了使用 this 引用元素本身：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); <span class="comment">// &quot;myBtn&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过将事件处理程序属性的值设置为 null，可以移除通过 DOM0 方式添加的事件处理程序，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>; <span class="comment">// 移除事件处理程序</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>DOM2 事件处理程序: DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>以上代码为按钮添加了会在事件冒泡阶段触发的 onclick 事件处理程序（因为最后一个参数值为 false）。使用 DOM2 方式的主要优势是可以为同一个事件添加多个事件处理程序。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()并传入与添加时同样的参数来移除。这意味着使用 addEventListener()添加的匿名函数无法移除，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 没有效果！</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>这个例子通过 addEventListener()添加了一个匿名函数作为事件处理程序。然后，又以看起来相同的参数调用了 removeEventListener()。但实际上，第二个参数与传给 addEventListener()的完全不是一回事。传给 removeEventListener()的事件处理函数必须与传给 addEventListener()的是同一个，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>); <span class="comment">// 有效果！</span></span><br></pre></td></tr></table></figure></div>

<p>这个例子有效，因为调用 addEventListener()和 removeEventListener()时传入的是同一个函数。<br>大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。</p>
<ul>
<li>IE 事件处理程序: IE 实现了与 DOM 类似的方法，即 attachEvent()和 detachEvent()。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用 attachEvent()添加的事件处理程序会添加到冒泡阶段。</li>
<li>跨浏览器事件处理程序: 为了以跨浏览器兼容的方式处理事件，很多开发者会选择使用一个 JavaScript 库，其中抽象了不同浏览器的差异。要确保事件处理代码具有最大兼容性，只需要让代码在冒泡阶段运行即可。以下就是包含这两个方法的 EventUtil 对象：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123;</span><br><span class="line">  <span class="attr">addHandler</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">addEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">attachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">removeHandler</span>: <span class="keyword">function</span> (<span class="params">element, type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">removeEventListener</span>) &#123;</span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">detachEvent</span>) &#123;</span><br><span class="line">      element.<span class="title function_">detachEvent</span>(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>) </span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">addHandler</span>(btn, <span class="string">&quot;click&quot;</span>, handler); </span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">removeHandler</span>(btn, <span class="string">&quot;click&quot;</span>, handler);</span><br></pre></td></tr></table></figure></div>
<p>5、事件对象: 在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 event 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。例如，鼠标操作导致的事件会生成鼠标位置信息，而键盘操作导致的事件会生成与被按下的键有关的信息。所有浏览器都支持这个 event 对象，尽管支持方式不同。</p>
<ul>
<li>DOM事件对象: 在 DOM 合规的浏览器中，event 对象是传给事件处理程序的唯一参数。不管以哪种方式（DOM0或 DOM2）指定事件处理程序，都会传入这个 event 对象。下面的例子展示了在两种方式下都可以使用事件对象：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;; </span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &quot;click&quot; </span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>
如前所述，事件对象包含与特定事件相关的属性和方法。不同的事件生成的事件对象也会包含不同的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性&#x2F;方法</th>
<th align="center">类 型</th>
<th align="center">读&#x2F;写</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bubbles</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td align="center">表示事件是否冒泡</td>
</tr>
<tr>
<td align="center">cancelable</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td align="center">表示是否可以取消事件的默认行为</td>
</tr>
<tr>
<td align="center">currentTarget</td>
<td align="center">元素</td>
<td align="center">只读</td>
<td align="center">当前事件处理程序所在的元素</td>
</tr>
<tr>
<td align="center">defaultPrevented</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td align="center">true 表示已经调用 preventDefault()方法（DOM3 Events 中新增）</td>
</tr>
<tr>
<td align="center">detail</td>
<td align="center">整数</td>
<td align="center">只读</td>
<td align="center">事件相关的其他信息</td>
</tr>
<tr>
<td align="center">eventPhase</td>
<td align="center">整数</td>
<td align="center">只读</td>
<td align="center">表示调用事件处理程序的阶段：1 代表捕获阶段，2 代表到达目标，3 代表冒泡阶段</td>
</tr>
<tr>
<td align="center">preventDefault()</td>
<td align="center">函数</td>
<td align="center">只读</td>
<td align="center">用于取消事件的默认行为。只有 cancelable 为 true 才可以调用这个方法</td>
</tr>
<tr>
<td align="center">stopImmediatePropagation()</td>
<td align="center">函数</td>
<td align="center">只读</td>
<td align="center">用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序（DOM3 Events 中新增）</td>
</tr>
<tr>
<td align="center">stopPropagation()</td>
<td align="center">函数</td>
<td align="center">只读</td>
<td align="center">用于取消事件的冒泡。只有 bubbles 为 true 才可以调用这个方法</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">元素</td>
<td align="center">只读</td>
<td align="center">事件目标</td>
</tr>
<tr>
<td align="center">trusted</td>
<td align="center">布尔值</td>
<td align="center">只读</td>
<td align="center">true 表示事件是由浏览器生成的。false 表示事件是开</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">字符串</td>
<td align="center">只读</td>
<td align="center">被触发的事件类型，比如 click、load、mouseover</td>
</tr>
<tr>
<td align="center">View</td>
<td align="center">AbstractView</td>
<td align="center">只读</td>
<td align="center">与事件相关的抽象视图。等于事件所发生的 window 对象</td>
</tr>
<tr>
<td align="center">在事件处理程序内部，this 对象始终等于 currentTarget 的值，而 target 只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标，则 this、currentTarget 和 target 的值是一样的。下面的例子展示了这两个属性都等于 this 的情形：</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span> === <span class="variable language_">this</span>); <span class="comment">// true </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span> === <span class="variable language_">this</span>); <span class="comment">// true </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>如果这个事件处理程序是添加到按钮的父节点（如 document.body）上，那么它们的值就不一样了。比如下面的例子在 document.body 上添加了单击处理程序：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">currentTarget</span> === <span class="variable language_">document</span>.<span class="property">body</span>); <span class="comment">// true </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">document</span>.<span class="property">body</span>); <span class="comment">// true </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span> === <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这种情况下点击按钮，this 和 currentTarget 都等于 document.body，这是因为它是注册事件处理程序的元素。而 target 属性等于按钮本身，这是因为那才是 click 事件真正的目标。由于按钮本身并没有注册事件处理程序，因此 click 事件冒泡到 document.body，从而触发了在它上面注册的处理程序。<br>type 属性在一个处理程序处理多个事件时很有用。比如下面的处理程序中就使用了 event.type：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="keyword">switch</span>(event.<span class="property">type</span>) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;click&quot;</span>: </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;mouseover&quot;</span>:</span><br><span class="line">     event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;mouseout&quot;</span>: </span><br><span class="line"> event.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;&quot;</span>; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">btn.<span class="property">onclick</span> = handler; </span><br><span class="line">btn.<span class="property">onmouseover</span> = handler; </span><br><span class="line">btn.<span class="property">onmouseout</span> = handler;</span><br></pre></td></tr></table></figure></div>
<p>preventDefault()方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导航到 href 属性指定的 URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLink&quot;</span>); </span><br><span class="line">link.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>任何可以通过 preventDefault()取消默认行为的事件，其事件对象的 cancelable 属性都会设置为 true。<br>stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。例如，直接添加到按钮的事件处理程序中调用 stopPropagation()，可以阻止 document.body 上注册的事件处理程序执行。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked&quot;</span>); </span><br><span class="line"> event.<span class="title function_">stopPropagation</span>(); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body clicked&quot;</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>eventPhase 属性可用于确定事件流当前所处的阶段。如果事件处理程序在捕获阶段被调用，则eventPhase 等于 1；如果事件处理程序在目标上被调用，则 eventPhase 等于 2；如果事件处理程序在冒泡阶段被调用，则 eventPhase 等于 3。不过要注意的是，虽然“到达目标”是在冒泡阶段发生的，但其 eventPhase 仍然等于 2。<br>注意 event 对象只在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-02-28 日报 Day111</title>
    <url>/undefined/2025-02-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>倘若南风知我意，<br>莫将晚霞落黄昏。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P505-522 第十七章：事件</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、事件类型: Web 浏览器中可以发生很多种事件。如前所述，所发生事件的类型决定了事件对象中会保存什么信息。DOM3 Events 定义了如下事件类型。<br> 用户界面事件（UIEvent）：涉及与 BOM 交互的通用浏览器事件。<br> 焦点事件（FocusEvent）：在元素获得和失去焦点时触发。<br> 鼠标事件（MouseEvent）：使用鼠标在页面上执行某些操作时触发。<br> 滚轮事件（WheelEvent）：使用鼠标滚轮（或类似设备）时触发。<br> 输入事件（InputEvent）：向文档中输入文本时触发。<br> 键盘事件（KeyboardEvent）：使用键盘在页面上执行某些操作时触发。<br> 合成事件（CompositionEvent）：在使用某种 IME（Input Method Editor，输入法编辑器）输入字符时触发。</p>
<ul>
<li>用户界面事件: 用户界面事件或 UI 事件不一定跟用户操作有关。这类事件在 DOM 规范出现之前就已经以某种形式存在了，保留它们是为了向后兼容。UI 事件主要有以下几种。<br> load：在 window 上当页面加载完成后触发，在窗套（<frameset>）上当所有窗格（<frame>）都加载完成后触发，在<img>元素上当图片加载完成后触发，在<object>元素上当相应对象加载完成后触发。<br> unload：在 window 上当页面完全卸载后触发，在窗套上当所有窗格都卸载完成后触发，在<object>元素上当相应对象卸载完成后触发。<br> abort：在<object>元素上当相应对象加载完成前被用户提前终止下载时触发。<br> error：在 window 上当 JavaScript 报错时触发，在<img>元素上当无法加载指定图片时触发，<br>在<object>元素上当无法加载相应对象时触发，在窗套上当一个或多个窗格无法完成加载时触发。<br> select：在文本框（<input>或 textarea）上当用户选择了一个或多个字符时触发。<br> resize：在 window 或窗格上当窗口或窗格被缩放时触发。<br> scroll：当用户滚动包含滚动条的元素时在元素上触发。<body>元素包含已加载页面的滚动条。大多数 HTML 事件与 window 对象和表单控件有关。</li>
<li>load事件: load 事件可能是 JavaScript 中最常用的事件。在 window 对象上，load 事件会在整个页面（包括所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发。可以通过两种方式指定 load 事件处理程序。第一种是 JavaScript 方式，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Loaded!&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
这是使用 addEventListener()方法来指定事件处理程序。与其他事件一样，事件处理程序会接收到一个 event 对象。这个 event 对象并没有提供关于这种类型事件的额外信息，虽然在 DOM 合规的浏览器中，event.target 会被设置为 document<br>第二种指定 load 事件处理程序的方式是向<body>元素添加 onload 属性，如下所示：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Load Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(&#x27;Loaded!&#x27;)&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
图片上也会触发load事件，包括DOM中的图片和非DOM中的图片。可以在HTML中直接给<img>元素的 onload 属性指定事件处理程序，比如：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;smile.gif&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(&#x27;Image loaded.&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
这个例子会在图片加载完成后输出一条消息。同样，使用 JavaScript 也可以为图片指定事件处理程序：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myImage&quot;</span>); </span><br><span class="line">image.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">src</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>unload事件: 与 load 事件相对的是 unload 事件，unload 事件会在文档卸载完成后触发。unload 事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏。与 load 事件类似，unload 事件处理程序也有两种指定方式。第一种是 JavaScript 方式，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Unloaded!&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>resize事件: 当浏览器窗口被缩放到新高度或宽度时，会触发 resize 事件。这个事件在 window 上触发，因此可以通过 JavaScript 在 window 上或者为<body>元素添加 onresize 属性来指定事件处理程序。优先使用 JavaScript 方式：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resized&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
注意 浏览器窗口在最大化和最小化时也会触发 resize 事件。</li>
<li>scroll事件: 虽然 scroll 事件发生在 window 上，但实际上反映的是页面中相应元素的变化。在混杂模式下，可以通过<body>元素检测 scrollLeft 和 scrollTop 属性的变化。而在标准模式下，这些变化在除早期版的 Safari 之外的所有浏览器中都发生在<html>元素上（早期版的 Safari 在<body>上跟踪滚动位置）。下面的代码演示了如何处理这些差异：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
2、焦点事件: 焦点事件在页面元素获得或失去焦点时触发。这些事件可以与 document.hasFocus()和document.activeElement 一起为开发者提供用户在页面中导航的信息。<br> blur：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持。<br> DOMFocusIn：当元素获得焦点时触发。这个事件是 focus 的冒泡版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了 DOMFocusIn，推荐 focusin。<br> DOMFocusOut：当元素失去焦点时触发。这个事件是 blur 的通用版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了 DOMFocusOut，推荐 focusout。<br> focus：当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。<br> focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版。<br> focusout：当元素失去焦点时触发。这个事件是 blur 的通用版。<br>焦点事件中的两个主要事件是 focus 和 blur。IE 新增的这两个事件已经被 DOM3 Events 标准化。<br>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。<br>(1) focuscout 在失去焦点的元素上触发。<br>(2) focusin 在获得焦点的元素上触发。<br>(3) blur 在失去焦点的元素上触发。<br>(4) DOMFocusOut 在失去焦点的元素上触发。<br>(5) focus 在获得焦点的元素上触发。<br>(6) DOMFocusIn 在获得焦点的元素上触发。<br>其中，blur、DOMFocusOut 和 focusout 的事件目标是失去焦点的元素，而 focus、DOMFocusIn和 focusin 的事件目标是获得焦点的元素。<br>3、鼠标和滚轮事件: 鼠标事件是 Web 开发中最常用的一组事件，这是因为鼠标是用户的主要定位设备。<br> click：在用户单击鼠标主键（通常是左键）或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发 onclick 事件处理程序。<br> dblclick：在用户双击鼠标主键（通常是左键）时触发。这个事件不是在 DOM2 Events 中定义的，但得到了很好的支持，DOM3 Events 将其进行了标准化。<br> mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。<br> mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseenter 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events中新增的事件。<br> mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。mouseleave 事件不是在 DOM2 Events 中定义的，而是 DOM3 Events中新增的事件。<br> mousemove：在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发。<br> mouseout：在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。<br> mouseover：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发。<br> mouseup：在用户释放鼠标键时触发。这个事件不能通过键盘触发。<br>页面中的所有元素都支持鼠标事件。除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。<br>比如，click 事件触发的前提是 mousedown 事件触发后，紧接着又在同一个元素上触发了 mouseup事件。如果 mousedown 和 mouseup 中的任意一个事件被取消，那么 click 事件就不会触发。类似地，两次连续的 click 事件会导致 dblclick 事件触发。只要有任何逻辑阻止了这两个 click 事件发生（比如取消其中一个 click 事件或者取消 mousedown 或 mouseup 事件中的任一个），dblclick 事件就不会发生。这 4 个事件永远会按照如下顺序触发：<br>(1) mousedown<br>(2) mouseup<br>(3) click<br>(4) mousedown<br>(5) mouseup<br>(6) click<br>(7) dblclick<br>click 和 dblclick 在触发前都依赖其他事件触发，mousedown 和 mouseup 则不会受其他事件影响。<br>IE8 及更早版本的实现中有个问题，这会导致双击事件跳过第二次 mousedown 和 click 事件。相应的顺序变成了：<br>(1) mousedown<br>(2) mouseup<br>(3) click<br>(4) mouseup<br>(5) dblclick<br>鼠标事件在 DOM3 Events 中对应的类型是”MouseEvent”，而不是”MouseEvents”。<br>鼠标事件还有一个名为滚轮事件的子类别。滚轮事件只有一个事件 mousewheel，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的交互。</li>
<li>客户端坐标: 鼠标事件都是在浏览器视口中的某个位置上发生的。这些信息被保存在 event 对象的 clientX 和 clientY 属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标，所有浏览器都支持。<br>可以通过下面的方式获取鼠标事件的客户端坐标：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Client coordinates: <span class="subst">$&#123;event.clientX&#125;</span>, <span class="subst">$&#123;event.clientY&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>页面坐标: 客户端坐标是事件发生时鼠标光标在客户端视口中的坐标，而页面坐标是事件发生时鼠标光标在页面上的坐标，通过 event 对象的 pageX 和 pageY 可以获取。这两个属性表示鼠标光标在页面上的位置，因此反映的是光标到页面而非视口左边与上边的距离。<br>可以像下面这样取得鼠标事件的页面坐标：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Page coordinates: <span class="subst">$&#123;event.pageX&#125;</span>, <span class="subst">$&#123;event.pageY&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>屏幕坐标: 屏幕坐标是事件发生时鼠标光标在屏幕上的坐标，通过 event 对象的 screenX 和 screenY 属性可以获取。这两个属性表示鼠标光标到屏幕左边与上边的距离。<br>可以像下面这样取得鼠标事件的屏幕坐标：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Screen coordinates: <span class="subst">$&#123;event.screenX&#125;</span>, <span class="subst">$&#123;event.screenY&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>修饰键: 虽然鼠标事件主要是通过鼠标触发的，但有时候要确定用户想实现的操作，还要考虑键盘按键的状态。键盘上的修饰键 Shift、Ctrl、Alt 和 Meta 经常用于修改鼠标事件的行为。DOM 规定了 4 个属性来表示这几个修饰键的状态：shiftKey、ctrlKey、altKey 和 metaKey。这几属性会在各自对应的修饰键被按下时包含布尔值 true，没有被按下时包含 false。在鼠标事件发生的，可以通过这几个属性来检测修饰键是否被按下。来看下面的例子，其中在 click 事件发生时检测了每个修饰键的状态：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> keys = <span class="keyword">new</span> <span class="title class_">Array</span>(); </span><br><span class="line"> <span class="keyword">if</span> (event.<span class="property">shiftKey</span>) &#123; </span><br><span class="line"> keys.<span class="title function_">push</span>(<span class="string">&quot;shift&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (event.<span class="property">ctrlKey</span>) &#123; </span><br><span class="line"> keys.<span class="title function_">push</span>(<span class="string">&quot;ctrl&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (event.<span class="property">altKey</span>) &#123; </span><br><span class="line"> keys.<span class="title function_">push</span>(<span class="string">&quot;alt&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (event.<span class="property">metaKey</span>) &#123; </span><br><span class="line"> keys.<span class="title function_">push</span>(<span class="string">&quot;meta&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Keys: &quot;</span> + keys.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>)); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>相关元素: 对 mouseover 和 mouseout 事件而言，还存在与事件相关的其他元素。这两个事件都涉及从一个元素的边界之内把光标移到另一个元素的边界之内。对 mouseover 事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。类似地，对 mouseout 事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。</li>
<li>鼠标按键: 只有在元素上单击鼠标主键（或按下键盘上的回车键）时 click 事件才会触发，因此按键信息并不是必需的。对 mousedown 和 mouseup 事件来说，event 对象上会有一个 button 属性，表示按下或释放的是哪个按键。DOM 为这个 button 属性定义了 3 个值：0 表示鼠标主键、1 表示鼠标中键（通常也是滚轮键）、2 表示鼠标副键。按照惯例，鼠标主键通常是左边的按键，副键通常是右边的按键。</li>
<li>额外事件信息: DOM2 Events 规范在 event 对象上提供了 detail 属性，以给出关于事件的更多信息。对鼠标事件来说，detail 包含一个数值，表示在给定位置上发生了多少次单击。</li>
<li>mousewheel事件: mousewheel事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动。可以为页面上的任何元素或文档添加 onmousewheel 事件处理程序，以处理所有鼠标滚轮交互，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousewheel&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">wheelDelta</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>触摸屏设备: iOS 和 Android 等触摸屏设备的实现大相径庭，因为触摸屏通常不支持鼠标操作。在为触摸屏设备开发时，要记住以下事项。<br> 不支持 dblclick 事件。双击浏览器窗口可以放大，但没有办法覆盖这个行为。<br> 单指点触屏幕上的可点击元素会触发 mousemove 事件。如果操作会导致内容变化，则不会再触发其他事件。如果屏幕上没有变化，则会相继触发 mousedown、mouseup 和 click 事件。点触不可点击的元素不会触发事件。可点击元素是指点击时有默认动作的元素（如链接）或指定了 onclick 事件处理程序的元素。<br> mousemove 事件也会触发 mouseover 和 mouseout 事件。<br> 双指点触屏幕并滑动导致页面滚动时会触发 mousewheel 和 scroll 事件。</li>
<li>无障碍问题: 如果 Web 应用或网站必须考虑残障人士，特别是使用屏幕阅读器的用户，那么必须小心使用鼠标事件。如前所述，按回车键可以触发 click 事件，但其他鼠标事件不能通过键盘触发。因此，建议不要使用 click 事件之外的其他鼠标事件向用户提示功能或触发代码执行，这是因为其他鼠标事件会严格妨碍盲人或视障用户使用。以下是几条使用鼠标事件时应该遵循的无障碍建议。<br> 使用 click 事件执行代码。有人认为，当使用 onmousedown 执行代码时，应用程序会运行得更快。对视力正常用户来说确实如此。但在屏幕阅读器上，这样会导致代码无法执行，这是因为屏幕阅读器无法触发 mousedown 事件。<br> 不要使用 mouseover 向用户显示新选项。同样，原因是屏幕阅读器无法触发 mousedown 事件。如果必须要通过这种方式显示新选项，那么可以考虑显示相同信息的键盘快捷键。<br> 不要使用 dblclick 执行重要的操作，这是因为键盘不能触发这个事件。<br>4、键盘与输入事件: 键盘事件是用户操作键盘时触发的。DOM2 Events 最初定义了键盘事件，键盘事件包含 3 个事件：<br> keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。<br> keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发。Esc 键也会触发这个事件。DOM3 Events 废弃了 keypress 事件，而推荐 textInput 事件。<br> keyup，用户释放键盘上某个键时触发。<br>输入事件只有一个，即 textInput。这个事件是对 keypress 事件的扩展，用于在文本显示给用户之前更方便地截获文本输入。textInput 会在文本被插入到文本框之前触发。<br>当用户按下键盘上的某个字符键时，首先会触发 keydown 事件，然后触发 keypress 事件，最后触发 keyup 事件。注意，这里 keydown 和 keypress 事件会在文本框出现变化之前触发，而 keyup事件会在文本框出现变化之后触发。如果一个字符键被按住不放，keydown 和 keypress 就会重复触发，直到这个键被释放。</li>
<li>键码: 对于 keydown 和 keyup 事件，event 对象的 keyCode 属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，keyCode 的值与小写字母和数字的 ASCII 编码一致。比如数字 7 键的keyCode 为 55，而字母 A 键的 keyCode 为 65，而且跟是否按了 Shift 键无关。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myText&quot;</span>); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">keyCode</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>字符编码: 在 keypress 事件发生时，意味着按键会影响屏幕上显示的文本。对插入或移除字符的键，所有浏览器都会触发 keypress 事件，其他键则取决于浏览器。浏览器在 event 对象上支持 charCode 属性，只有发生 keypress 事件时这个属性才会被设置值，包含的是按键字符对应的 ASCII 编码。通常，charCode 属性的值是 0，在 keypress 事件发生时则是对应按键的键码。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventUtil</span> = &#123; </span><br><span class="line"> <span class="comment">// 其他代码</span></span><br><span class="line"> <span class="attr">getCharCode</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> event.<span class="property">charCode</span> == <span class="string">&quot;number&quot;</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> event.<span class="property">charCode</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> event.<span class="property">keyCode</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="comment">// 其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>DOM3的变化: 尽管所有浏览器都实现了某种形式的键盘事件，DOM3 Events 还是做了一些修改。比如，DOM3 Events 规范并未规定 charCode 属性，而是定义了 key 和 char 两个新属性。<br>DOM3 Events 也支持一个名为 location 的属性，该属性是一个数值，表示是在哪里按的键。可能的值为：0 是默认键，1 是左边（如左边的 Alt 键），2 是右边（如右边的 Shift 键），3 是数字键盘，4 是移动设备（即虚拟键盘），5 是游戏手柄（如任天堂 Wii 控制器）。</li>
<li>textInput事件: DOM3 Events 规范增加了一个名为 textInput 的事件，其在字符被输入到可编辑区域时触发。作为对 keypress 的替代，textInput 事件的行为有些不一样。一个区别是 keypress 会在任何可以获得焦点的元素上触发，而 textInput 只在可编辑区域上触发。另一个区别是 textInput 只在有新字符被插入时才会触发，而 keypress 对任何可能影响文本的键都会触发（包括退格键）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myText&quot;</span>); </span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;textInput&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
event 对象上还有一个名为 inputMethod 的属性，该属性表示向控件中输入文本的手段。可能的值如下：<br> 0，表示浏览器不能确定是什么输入手段；<br> 1，表示键盘；<br> 2，表示粘贴；<br> 3，表示拖放操作；<br> 4，表示 IME；<br> 5，表示表单选项；<br> 6，表示手写（如使用手写笔）；<br> 7，表示语音；<br> 8，表示组合方式；<br> 9，表示脚本。<br>5、合成事件: 合成事件是 DOM3 Events 中新增的，用于处理通常使用 IME 输入时的复杂输入序列。IME 可以让用户输入物理键盘上没有的字符。<br>6、变化事件： DOM2 的变化事件（Mutation Events）是为了在 DOM 发生变化时提供通知。<br>注意 这些事件已经被废弃，浏览器已经在有计划地停止对它们的支持。变化事件已经被Mutation Observers 所取代，可以参考第 14 章中的介绍。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-02 日报 Day113</title>
    <url>/undefined/2025-03-02/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>花会沿路盛开，<br>你以后的路也是。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P543-548 第十七章：事件</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、模拟事件: 事件就是为了表示网页中某个有意义的时刻。通常，事件都是由用户交互或浏览器功能触发。事实上，可能很少有人知道可以通过 JavaScript 在任何时候触发任意事件，而这些事件会被当成浏览器创建的事件。这意味着同样会有事件冒泡，因而也会触发相应的事件处理程序。这种能力在测试 Web 应用时特别有用。</p>
<ul>
<li>DOM事件模拟: 任何时候，都可以使用 document.createEvent()方法创建一个 event 对象。这个方法接收一个参数，此参数是一个表示要创建事件类型的字符串。在 DOM2 中，所有这些字符串都是英文复数形式，但在 DOM3 中，又把它们改成了英文单数形式。可用的字符串值是以下值之一。<br> “UIEvents”（DOM3 中是”UIEvent”）：通用用户界面事件（鼠标事件和键盘事件都继承自这个事件）。<br> “MouseEvents”（DOM3 中是”MouseEvent”）：通用鼠标事件。<br> “HTMLEvents”（DOM3 中没有）：通用 HTML 事件（HTML 事件已经分散到了其他事件大类中）。<br>创建 event 对象之后，需要使用事件相关的信息来初始化。每种类型的 event 对象都有特定的方法，可以使用相应数据来完成初始化。方法的名字并不相同，这取决于调用 createEvent()时传入的参数。<br>事件模拟的最后一步是触发事件。为此要使用 dispatchEvent()方法，这个方法存在于所有支持事件的 DOM 节点之上。dispatchEvent()方法接收一个参数，即表示要触发事件的 event 对象。调用 dispatchEvent()方法之后，事件就“转正”了，接着便冒泡并触发事件处理程序执行。</li>
<li>模拟鼠标事件: 模拟鼠标事件需要先创建一个新的鼠标 event 对象，然后再使用必要的信息对其进行初始化。要创建鼠标 event 对象，可以调用 createEvent()方法并传入”MouseEvents”参数。这样就会返回一个 event 对象，这个对象有一个 initMouseEvent()方法，用于为新对象指定鼠标的特定信息。initMouseEvent()方法接收 15 个参数，分别对应鼠标事件会暴露的属性。这些参数列举如下。<br> type（字符串）：要触发的事件类型，如”click”。<br> bubbles（布尔值）：表示事件是否冒泡。为精确模拟鼠标事件，应该设置为 true。<br> cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为 true。<br> view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。<br> detail（整数）：关于事件的额外信息。只被事件处理程序使用，通常为 0。<br> screenX（整数）：事件相对于屏幕的 x 坐标。<br> screenY（整数）：事件相对于屏幕的 y 坐标。<br> clientX（整数）：事件相对于视口的 x 坐标。<br> clientY（整数）：事件相对于视口的 y 坐标。<br> ctrlkey（布尔值）：表示是否按下了 Ctrl 键。默认为 false。<br> altkey（布尔值）：表示是否按下了 Alt 键。默认为 false。<br> shiftkey（布尔值）：表示是否按下了 Shift 键。默认为 false。<br> metakey（布尔值）：表示是否按下了 Meta 键。默认为 false。<br> button（整数）：表示按下了哪个按钮。默认为 0。<br> relatedTarget（对象）：与事件相关的对象。只在模拟 mouseover 和 mouseout 时使用。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>); </span><br><span class="line"><span class="comment">// 创建 event 对象</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;MouseEvents&quot;</span>); </span><br><span class="line"><span class="comment">// 初始化 event 对象</span></span><br><span class="line">event.<span class="title function_">initMouseEvent</span>(<span class="string">&quot;click&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="variable language_">document</span>.<span class="property">defaultView</span>, </span><br><span class="line"> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>); </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure></div></li>
<li>模拟键盘事件: 在 DOM3 中创建键盘事件的方式是给 createEvent()方法传入参数”KeyboardEvent”。这样会返回一个 event 对象，这个对象有一个 initKeyboardEvent()方法。这个方法接收以下参数。<br> type（字符串）：要触发的事件类型，如”keydown”。<br> bubbles（布尔值）：表示事件是否冒泡。为精确模拟键盘事件，应该设置为 true。<br> cancelable（布尔值）：表示事件是否可以取消。为精确模拟键盘事件，应该设置为 true。<br> view（AbstractView）：与事件关联的视图。基本上始终是 document.defaultView。<br> key（字符串）：按下按键的字符串代码。<br> location（整数）：按下按键的位置。0 表示默认键，1 表示左边，2 表示右边，3 表示数字键盘，4 表示移动设备（虚拟键盘），5 表示游戏手柄。<br> modifiers（字符串）：空格分隔的修饰键列表，如”Shift”。<br> repeat（整数）：连续按了这个键多少次。<br>注意，DOM3 Events 废弃了 keypress 事件，因此只能通过上述方式模拟 keydown 和 keyup 事件：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myTextbox&quot;</span>), </span><br><span class="line"> event; </span><br><span class="line"><span class="comment">// 按照 DOM3 的方式创建 event 对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;KeyboardEvents&quot;</span>, <span class="string">&quot;3.0&quot;</span>)) &#123; </span><br><span class="line"> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;KeyboardEvent&quot;</span>); </span><br><span class="line"> <span class="comment">// 初始化 event 对象</span></span><br><span class="line"> event.<span class="title function_">initKeyboardEvent</span>(<span class="string">&quot;keydown&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="variable language_">document</span>.<span class="property">defaultView</span>, <span class="string">&quot;a&quot;</span>, </span><br><span class="line"> <span class="number">0</span>, <span class="string">&quot;Shift&quot;</span>, <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure></div></li>
<li>模拟其它事件: 鼠标事件和键盘事件是浏览器中最常见的模拟对象。不过，有时候可能也需要模拟 HTML 事件。模 拟 HTML 事件要调用 createEvent()方法并传入”HTMLEvents”，然后再使用返回对象的initEvent()方法来初始化：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;HTMLEvents&quot;</span>); </span><br><span class="line">event.<span class="title function_">initEvent</span>(<span class="string">&quot;focus&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>); </span><br><span class="line">target.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure></div>
这个例子模拟了在给定目标上触发 focus 事件。</li>
<li>自定义DOM事件: 自定义事件不会触发原生 DOM 事件，但可以让开发者定义自己的事件。要创建自定义事件，需要调用 createEvent(“CustomEvent”) 。返回的对象包含initCustomEvent()方法，该方法接收以下 4 个参数。<br> type（字符串）：要触发的事件类型，如”myevent”。<br> bubbles（布尔值）：表示事件是否冒泡。<br> cancelable（布尔值）：表示事件是否可以取消。<br> detail（对象）：任意值。作为 event 对象的 detail 属性。<br>自定义事件可以像其他事件一样在 DOM 中派发，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>), </span><br><span class="line"> event; </span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&quot;myevent&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DIV: &quot;</span> + event.<span class="property">detail</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;myevent&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DOCUMENT: &quot;</span> + event.<span class="property">detail</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;CustomEvents&quot;</span>, <span class="string">&quot;3.0&quot;</span>)) &#123; </span><br><span class="line"> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;CustomEvent&quot;</span>); </span><br><span class="line"> event.<span class="title function_">initCustomEvent</span>(<span class="string">&quot;myevent&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;Hello world!&quot;</span>); </span><br><span class="line"> div.<span class="title function_">dispatchEvent</span>(event); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
2、小结: 事件是 JavaScript 与网页结合的主要方式。最常见的事件是在 DOM3 Events 规范或 HTML5 中定义的。虽然基本的事件都有规范定义，但很多浏览器在规范之外实现了自己专有的事件，以方便开发者更好地满足用户交互需求，其中一些专有事件直接与特殊的设备相关。<br>围绕着使用事件，需要考虑内存与性能问题。例如：<br> 最好限制一个页面中事件处理程序的数量，因为它们会占用过多内存，导致页面响应缓慢；<br> 利用事件冒泡，事件委托可以解决限制事件处理程序数量的问题；<br> 最好在页面卸载之前删除所有事件处理程序。<br>使用 JavaScript 也可以在浏览器中模拟事件。DOM2 Events 和 DOM3 Events 规范提供了模拟方法，可以模拟所有原生 DOM 事件。键盘事件一定程度上也是可以模拟的，有时候需要组合其他技术。IE8及更早版本也支持事件模拟，只是接口与 DOM 方式不同。<br>事件是 JavaScript 中最重要的主题之一，理解事件的原理及其对性能的影响非常重要。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-05 日报 Day116</title>
    <url>/undefined/2025-03-05/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>且以青春赴山海,<br>青舟无惧万重山。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>LeetCode 双指针之移动零、盛最多水的容器、三数之和</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-01 日报 Day112</title>
    <url>/undefined/2025-03-01/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在心里种花，<br>人生才不会荒芜。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P523-542 第十七章：事件</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、HTML5 事件:</p>
<ul>
<li>contextmenu 事件: contextmenu 事件冒泡，因此只要给 document 指定一个事件处理程序就可以处理页面上的所有同类事件。事件目标是触发操作的元素。这个事件在所有浏览器中都可以取消，在 DOM 合规的浏览器中使用 event.preventDefault()。<br>通常，自定义的上下文菜单都是通过 oncontextmenu 事件处理程序触发显示，并通过 onclick 事件处理程序触发隐藏的。来看下面的例子：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ContextMenu Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span></span><br><span class="line">      Right click or Ctrl+click me to get a custom context menu. Click anywhere</span><br><span class="line">      else to get the default context menu.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;myMenu&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;position:absolute;visibility:hidden;background-color: </span></span></span><br><span class="line"><span class="string"><span class="tag"> silver&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere.com&quot;</span>&gt;</span> somewhere<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.wrox.com&quot;</span>&gt;</span>Wrox site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.somewhere-else.com&quot;</span>&gt;</span>somewhere-else<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这个例子中的<div>元素有一个上下文菜单<ul>。作为上下文菜单，<ul>元素初始时是隐藏的。以下是实现上下文菜单功能的 JavaScript 代码：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line">  div.<span class="title function_">addEventListener</span>(<span class="string">&quot;contextmenu&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">let</span> menu = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myMenu&quot;</span>);</span><br><span class="line">    menu.<span class="property">style</span>.<span class="property">left</span> = event.<span class="property">clientX</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    menu.<span class="property">style</span>.<span class="property">top</span> = event.<span class="property">clientY</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    menu.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&quot;visible&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myMenu&quot;</span>).<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&quot;hidden&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>这里在<div>元素上指定了一个 oncontextmenu 事件处理程序。这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单。接着基于 event 对象的 clientX 和 clientY 属性把<ul>元素放到适当位置。最后一步通过将 visibility 属性设置为”visible”让自定义上下文菜单显示出来。另外，又给 document 添加了一个 onclick 事件处理程序，以便在单击事件发生时隐藏上下文菜单（系统上下文菜单就是这样隐藏的）。</p>
<ul>
<li>beforeunload事件: beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面需要继续使用，则可以不被卸载。这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上。<br>需要将 event.returnValue 设置为要在确认框中显示的字符串（对于 IE 和 Firefox 来说），并将其作为函数值返回（对于 Safari 和 Chrome 来说），如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> message = <span class="string">&quot;I&#x27;m really going to miss you if you go.&quot;</span>; </span><br><span class="line"> event.<span class="property">returnValue</span> = message; </span><br><span class="line"> <span class="keyword">return</span> message; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>DOMContentLoaded事件: window 的 load 事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而 DOMContentLoaded 事件会在 DOM 树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS 文件或其他资源加载完成。相对于 load 事件，DOMContentLoaded 可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与页面交互。<br>要处理 DOMContentLoaded 事件，需要给 document 或 window 添加事件处理程序（实际的事件目标是 document，但会冒泡到 window）。下面是一个在 document 上监听 DOMContentLoaded 事件的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DOM fully loaded and parsed&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
DOMContentLoaded 事件的 event 对象中不包含任何额外信息（除了 target 等于 document）。<br>DOMContentLoaded 事件通常用于添加事件处理程序或执行其他 DOM操作。这个事件始终在 load事件之前触发。<br>对于不支持 DOMContentLoaded 事件的浏览器，可以使用超时为 0 的 setTimeout()函数，通过其回调来设置事件处理程序，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// 在这里添加事件处理程序</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>readystatechange事件: 这个有点神秘的事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定。支持 readystatechange 事件的每个对象都有一个 readyState 属性，该属性具有一个以下列出的可能的字符串值。<br> uninitialized：对象存在并尚未初始化。<br> loading：对象正在加载数据。<br> loaded：对象已经加载完数据。<br> interactive：对象可以交互，但尚未加载完成。<br> complete：对象加载完成。</li>
<li>pageshow与pagehide事件: Firefox 和 Opera 开发了一个名为往返缓存（bfcache，back-forward cache）的功能，此功能旨在使用浏览器“前进”和“后退”按钮时加快页面之间的切换。这个缓存不仅存储页面数据，也存储 DOM 和JavaScript 状态，实际上是把整个页面都保存在内存里。如果页面在缓存中，那么导航到这个页面时就不会触发 load 事件。通常，这不会导致什么问题，因为整个页面状态都被保存起来了。不过，Firefx决定提供一些事件，把往返缓存的行为暴露出来。<br>第一个事件是 pageshow，其会在页面显示时触发，无论是否来自往返缓存。在新加载的页面上，pageshow 会在 load 事件之后触发；在来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发。注意，虽然这个事件的目标是 document，但事件处理程序必须添加到 window 上。下面的例子展示了追踪这些事件的代码：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> showCount = <span class="number">0</span>; </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Load fired&quot;</span>); </span><br><span class="line"> &#125;); </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    showCount++; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Show has been fired <span class="subst">$&#123;showCount&#125;</span> times.`</span>); </span><br><span class="line"> &#125;); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>
除了常用的属性，pageshow 的 event 对象中还包含一个名为 persisted 的属性。这个属性是一个布尔值，如果页面存储在了往返缓存中就是 true，否则就是 false。可以像下面这样在事件处理程序中检测这个属性：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> showCount = <span class="number">0</span>; </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Load fired&quot;</span>); </span><br><span class="line"> &#125;); </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> showCount++; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Show has been fired <span class="subst">$&#123;showCount&#125;</span> times.`</span>, </span><br><span class="line"> <span class="string">`Persisted? <span class="subst">$&#123;event.persisted&#125;</span>`</span>); </span><br><span class="line"> &#125;); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>
与 pageshow 对应的事件是 pagehide，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发。与 pageshow 事件一样，pagehide 事件同样是在 document 上触发，但事件处理程序必须被添加到 window。event 对象中同样包含 persisted 属性，但用法稍有不同。比如，以下代码检测了event.persisted 属性：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pagehide&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hiding. Persisted? &quot;</span> + event.<span class="property">persisted</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>hashchange事件: HTML5 增加了 hashchange 事件，用于在 URL 散列值（URL 最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在 Ajax 应用程序中使用 URL 散列值存储状态信息或路由导航信息。<br>onhashchange 事件处理程序必须添加给 window，每次 URL 散列值发生变化时会调用它。event对象有两个新属性：oldURL 和 newURL。这两个属性分别保存变化前后的 URL，而且是包含散列值的完整 URL。下面的例子展示了如何获取变化前后的 URL：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Old URL: <span class="subst">$&#123;event.oldURL&#125;</span>, New URL: <span class="subst">$&#123;event.newURL&#125;</span>`</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 如果想确定当前的散列值，最好使用 location 对象：</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;hashchange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current hash: <span class="subst">$&#123;location.hash&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
2、设备事件: 随着智能手机和平板计算机的出现，用户与浏览器交互的新方式应运而生。设备事件可以用于确定用户使用设备的方式。</li>
<li>orientationchange事件: 苹果公司在移动 Safari 浏览器上创造了 orientationchange 事件，以方便开发者判断用户的设备是处于垂直模式还是水平模式。移动 Safari 在 window 上暴露了 window.orientation 属性，它有以下 3 种值之一：0 表示垂直模式，90 表示左转水平模式（主屏幕键在右侧），–90 表示右转水平模式（主屏幕键在左）。所有 iOS 设备都支持 orientationchange 事件和 window.orientation 属性。</li>
<li>deviceorientation事件: 如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在 window 上触发。要注意的是，deviceorientation 事件只反映设备在空间中的朝向，而不涉及移动相关的信息。设备本身处于 3D 空间即拥有 x 轴、y 轴和 z 轴的坐标系中。如果把设备静止放在水平的表面上，那么三轴的值均为 0，其中，x 轴方向为从设备左侧到右侧，y 轴方向为从设备底部到上部，z 轴方向为从设备背面到正面。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;deviceorientation&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>); </span><br><span class="line"> output.<span class="property">innerHTML</span> = </span><br><span class="line"> <span class="string">`Alpha=<span class="subst">$&#123;event.alpha&#125;</span>, Beta=<span class="subst">$&#123;event.beta&#125;</span>, Gamma=<span class="subst">$&#123;event.gamma&#125;</span>&lt;br&gt;`</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>devicemotion事件: DeviceOrientationEvent 规范也定义了 devicemotion 事件。这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。例如，devicemotion 事件可以用来确定设备正在掉落或者正拿在一个行走的人手里。<br>当 devicemotion 事件触发时，event 对象中包含如下额外的属性。<br> acceleration：对象，包含 x、y 和 z 属性，反映不考虑重力情况下各个维度的加速信息。<br> accelerationIncludingGravity：对象，包含 x、y 和 z 属性，反映各个维度的加速信息，包含 z 轴自然重力加速度。<br> interval：毫秒，距离下次触发 devicemotion 事件的时间。此值在事件之间应为常量。<br> rotationRate：对象，包含 alpha、beta 和 gamma 属性，表示设备朝向。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;devicemotion&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>); </span><br><span class="line"> output.<span class="property">innerHTML</span> = </span><br><span class="line"> <span class="string">`Acceleration: X=<span class="subst">$&#123;event.acceleration.x&#125;</span>, Y=<span class="subst">$&#123;event.acceleration.y&#125;</span>, Z=<span class="subst">$&#123;event.acceleration.z&#125;</span>&lt;br&gt;`</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
3、触摸及手势事件： 因为 iOS 设备没有鼠标和键盘，所以常规的鼠标和键盘事件不足以创建具有完整交互能力的网页。同时，WebKit 也为 Android 定制了很多专有事件，成为了事实标准，并被纳入 W3C 的 Touch Events 规范。本节介绍的事件只适用于触屏设备。</li>
<li>触摸事件:<br> touchstart：手指放到屏幕上时触发（即使有一个手指已经放在了屏幕上）。<br> touchmove：手指在屏幕上滑动时连续触发。在这个事件中调用 preventDefault()可以阻止滚动<br> touchend：手指从屏幕上移开时触发。<br> touchcancel：系统停止跟踪触摸时触发。文档中并未明确什么情况下停止跟踪。</li>
<li>手势事件:<br>手势事件会在两个手指触碰屏幕且相对距离或旋转角度变化时触发。手势事件有以下 3 种。<br> gesturestart：一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。<br> gesturechange：任何一个手指在屏幕上的位置发生变化时触发。<br> gestureend：其中一个手指离开屏幕时触发。<br>4、内存与性能: 因为事件处理程序在现代 Web 应用中可以实现交互，所以很多开发者会错误地在页面中大量使用它们。在 JavaScript 中，页面中事件处理程序的数量与页面整体性能直接相关。原因有很多。首先，每个函数都是对象，都占用内存空间，对象越多，性能越差。其次，为指定事件处理程序所需访问 DOM 的次数会先期造成整个页面交互的延迟。只要在使用事件处理程序时多注意一些方法，就可以改善页面性能。</li>
<li>事件委托: “过多事件处理程序”的解决方案是使用事件委托。事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。例如，click 事件冒泡到 document。这意味着可以为整个页面指定一个 onclick 事件处理程序，而不用为每个可点击元素分别指定事件处理程序。比如有以下 HTML：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myLinks&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;goSomewhere&quot;</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;sayHi&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
这里的 HTML 包含 3 个列表项，在被点击时应该执行某个操作。对此，通常的做法是像这样指定 3个事件处理程序：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> item1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;goSomewhere&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;doSomething&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> item3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sayHi&quot;</span>); </span><br><span class="line">item1.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> location.<span class="property">href</span> = <span class="string">&quot;http:// www.wrox.com&quot;</span>; </span><br><span class="line">&#125;); </span><br><span class="line">item2.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>; </span><br><span class="line">&#125;); </span><br><span class="line">item3.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
如果对页面中所有需要使用 onclick 事件处理程序的元素都如法炮制，结果就会出现大片雷同的只为指定事件处理程序的代码。使用事件委托，只要给所有元素共同的祖先节点添加一个事件处理程序，就可以解决问题。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myLinks&quot;</span>); </span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> target = event.<span class="property">target</span>; </span><br><span class="line"> <span class="keyword">switch</span>(target.<span class="property">id</span>) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;doSomething&quot;</span>: </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&quot;I changed the document&#x27;s title&quot;</span>; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;goSomewhere&quot;</span>: </span><br><span class="line"> location.<span class="property">href</span> = <span class="string">&quot;http:// www.wrox.com&quot;</span>; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;sayHi&quot;</span>: </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
只要可行，就应该考虑只给 document 添加一个事件处理程序，通过它处理页面中所有某种类型的事件。相对于之前的技术，事件委托具有如下优点。<br> document 对象随时可用，任何时候都可以给它添加事件处理程序（不用等待 DOMContentLoaded或 load 事件）。这意味着只要页面渲染出可点击的元素，就可以无延迟地起作用。<br> 节省花在设置页面事件处理程序上的时间。只指定一个事件处理程序既可以节省 DOM 引用，也可以节省时间。<br> 减少整个页面所需的内存，提升整体性能。</li>
<li>删除事件处理程序: 把事件处理程序指定给元素后，在浏览器代码和负责页面交互的 JavaScript 代码之间就建立了联系。这种联系建立得越多，页面性能就越差。除了通过事件委托来限制这种连接之外，还应该及时删除不用的事件处理程序。很多 Web 应用性能不佳都是由于无用的事件处理程序长驻内存导致的。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-03 日报 Day114</title>
    <url>/undefined/2025-03-03/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>花会沿路盛开，<br>你以后的路也是。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P549-562 第十八章：动画与 Canvas 图形</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、图形和动画已经日益成为浏览器中现代 Web 应用程序的必备功能，但实现起来仍然比较困难。视觉上复杂的功能要求性能调优和硬件加速，不能拖慢浏览器。<canvas>是 HTML5 最受欢迎的新特性。这个元素会占据一块页面区域，让 JavaScript可以动态在上面绘制图片。<canvas>自身提供了一些 API，但并非所有浏览器都支持这些<br>PI，其中包括支持基础绘图能力的 2D 上下文和被称为 WebGL 的 3D 上下文。支持的浏览器的最新版本现在都支持 2D 上下文和 WebGL。</p>
<p>2、使用requestAnimationFrame: 很长时间以来，计时器和定时执行都是 JavaScript 动画最先进的工具。这个方法会告诉浏览器要执行动画了，于是浏览器可以通过最优方式确定重绘的时序。</p>
<ul>
<li>早期定时动画: 以前，在 JavaScript 中创建动画基本上就是使用 setInterval()来控制动画的执行。下面的例子展示了使用 setInterval()的基本模式：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">updateAnimations</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="title function_">doAnimation1</span>(); </span><br><span class="line"> <span class="title function_">doAnimation2</span>(); </span><br><span class="line"> <span class="comment">// 其他任务</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">setInterval</span>(updateAnimations, <span class="number">100</span>); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>
这种定时动画的问题在于无法准确知晓循环之间的延时。定时间隔必须足够短，这样才能让不同的动画类型都能平滑顺畅，但又要足够长，以便产生浏览器可以渲染出来的变化。一般计算机显示器的屏幕刷新率都是 60Hz，基本上意味着每秒需要重绘 60 次。大多数浏览器会限制重绘频率，使其不超出屏幕的刷新率，这是因为超过刷新率，用户也感知不到。<br>因此，实现平滑动画最佳的重绘间隔为 1000 毫秒&#x2F;60，大约 17 毫秒。以这个速度重绘可以实现最平滑的动画，因为这已经是浏览器的极限了。如果同时运行多个动画，可能需要加以限流，以免 17 毫秒的重绘间隔过快，导致动画过早运行完。<br>无论 setInterval()还是 setTimeout()都是不能保证时间精度的。作为第二个参数的延时只能保证何时会把代码添加到浏览器的任务队列，不能保证添加到队列就会立即运行。如果队列前面还有其他任务，那么就要等这些任务执行完再执行。简单来讲，这里毫秒延时并不是说何时这些代码会执行，而只是说到时候会把回调加到任务队列。如果添加到队列后，主线程还被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行。</li>
<li>时间间隔的问题: 知道何时绘制下一帧是创造平滑动画的关键。浏览器自身计时器的精度让这个问题雪上加霜。浏览器的计时器精度不足毫秒。以下是几个浏览器计时器的精度情况：<br> IE8 及更早版本的计时器精度为 15.625 毫秒；<br> IE9 及更晚版本的计时器精度为 4 毫秒；<br> Firefox 和 Safari 的计时器精度为约 10 毫秒；<br> Chrome 的计时器精度为 4 毫秒。<br>更麻烦的是，浏览器又开始对切换到后台或不活跃标签页中的计时器执行限流。因此即使将时间间隔设定为最优，也免不了只能得到近似的结果。</li>
<li>requestAnimationFrame: 浏览器知道 CSS过渡和动画应该什么时候开始，并据此计算出正确的时间间隔，到时间就去刷新用户界面。但对于 JavaScript动画，浏览器不知道动画什么时候开始。他给出的方案是创造一个名为 mozRequestAnimationFrame()的新方法，用以通知浏览器某些 JavaScript 代码要执行动画了。这样浏览器就可以在运行某些代码后进行适当的优化。目前所有浏览器都支持这个方法不带前缀的版本，即 requestAnimationFrame()。<br>requestAnimationFrame()方法接收一个参数，此参数是一个要在重绘屏幕前调用的函数。这个函数就是修改 DOM 样式以反映下一次重绘有什么变化的地方。为了实现动画循环，可以把多个requestAnimationFrame()调用串联起来，就像以前使用 setTimeout()时一样：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>); </span><br><span class="line"> div.<span class="property">style</span>.<span class="property">width</span> = (<span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">width</span>, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">&quot;%&quot;</span>; </span><br><span class="line"> <span class="keyword">if</span> (div.<span class="property">style</span>.<span class="property">left</span> != <span class="string">&quot;100%&quot;</span>) &#123; </span><br><span class="line"> <span class="title function_">requestAnimationFrame</span>(updateProgress); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(updateProgress);</span><br></pre></td></tr></table></figure></div>
目前为止，requestAnimationFrame()已经解决了浏览器不知道 JavaScript 动画何时开始的问题，以及最佳间隔是多少的问题，但是，不知道自己的代码何时实际执行的问题呢？<br>传给 requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimeStamp 的实例（比如 performance.now()返回的值），表示下次重绘的时间。这一点非常重要：requestAnimationFrame()实际上把重绘任务安排在了未来一个已知的时间点上，而且通过这个参数告诉了开发者。基于这个参数，就可以更好地决定如何调优动画了。</li>
<li>cancelAnimationFrame: 与 setTimeout()类似，requestAnimationFrame()也返回一个请求 ID，可以用于通过另一个方法 cancelAnimationFrame()来取消重绘任务。下面的例子展示了刚把一个任务加入队列又立即将其取消：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> requestID = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Repaint!&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">cancelAnimationFrame</span>(requestID);</span><br></pre></td></tr></table></figure></div></li>
<li>通过requestAnimationFrame节流: 支持这个方法的浏览器实际上会暴露出作为钩子的回调队列。所谓钩子（hook），就是浏览器在执行下一次重绘之前的一个点。这个回调队列是一个可修改的函数列表，包含应该在重绘之前调用的函数。每次调用requestAnimationFrame()都会在队列上推入一个回调函数，队列的长度没有限制。<br>这个回调队列的行为不一定跟动画有关。不过，通过 requestAnimationFrame()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。这是一个非常好的节流工具。在频繁执行影响页面外观的代码时（比如滚动事件监听器），可以利用这个回调队列进行节流。<br>先来看一个原生实现，其中的滚动事件监听器每次触发都会调用名为 expensiveOperation()（耗时操作）的函数。当向下滚动网页时，这个事件很快就会被触发并执行成百上千次：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="title function_">expensiveOperation</span>(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
如果想把事件处理程序的调用限制在每次重绘前发生，那么可以像这样下面把它封装到 requestAnimationFrame()调用中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
这样会把所有回调的执行集中在重绘钩子，但不会过滤掉每次重绘的多余调用。此时，定义一个标志变量，由回调设置其开关状态，就可以将多余的调用屏蔽：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> enqueued = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line"> enqueued = <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (!enqueued) &#123; </span><br><span class="line"> enqueued = <span class="literal">true</span>; </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
因为重绘是非常频繁的操作，所以这还算不上真正的节流。更好的办法是配合使用一个计时器来限制操作执行的频率。这样，计时器可以限制实际的操作执行间隔，而 requestAnimationFrame 控制在浏览器的哪个渲染周期中执行。下面的例子可以将回调限制为不超过 50 毫秒执行一次：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> enabled = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expensiveOperation</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked at&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (enabled) &#123; </span><br><span class="line"> enabled = <span class="literal">false</span>; </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(expensiveOperation); </span><br><span class="line"> <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> enabled = <span class="literal">true</span>, <span class="number">50</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>3、基本的画布功能: 创建<canvas>元素时至少要设置其 width 和 height 属性，这样才能告诉浏览器在多大面积上绘图。出现在开始和结束标签之间的内容是后备数据，会在浏览器不支持<canvas>元素时显示。比如：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span>A drawing of something.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>要在画布上绘制图形，首先要取得绘图上下文。使用 getContext()方法可以获取对绘图上下文的引用。对于平面图形，需要给这个方法传入参数”2d”，表示要获取 2D 上下文对象：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以使用 toDataURL()方法导出<canvas>元素上的图像。这个方法接收一个参数：要生成图像的 MIME 类型（与用来创建图形的上下文无关）。例如，要从画布上导出一张 PNG 格式的图片，可以这样做：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="comment">// 取得图像的数据 URI </span></span><br><span class="line"> <span class="keyword">let</span> imgURI = drawing.<span class="title function_">toDataURL</span>(<span class="string">&quot;image/png&quot;</span>); </span><br><span class="line"> <span class="comment">// 显示图片</span></span><br><span class="line"> <span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>); </span><br><span class="line"> image.<span class="property">src</span> = imgURI; </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(image); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>浏览器默认将图像编码为 PNG 格式，除非另行指定。<br>注意 如果画布中的图像是其他域绘制过来的，toDataURL()方法就会抛出错误。相关内容本章后面会讨论。<br>4、2D绘图上下文: 2D 绘图上下文提供了绘制 2D 图形的方法，包括矩形、弧形和路径。2D 上下文的坐标原点(0, 0)在<canvas>元素的左上角。所有坐标值都相对于该点计算，因此 x 坐标向右增长，y 坐标向下增长。默认情况下，width 和 height 表示两个方向上像素的最大值。</p>
<ul>
<li>填充和描边: 2D 上下文有两个基本绘制操作：填充和描边。填充以指定样式（颜色、渐变或图像）自动填充形状，而描边只为图形边界着色。大多数 2D 上下文操作有填充和描边的变体，显示效果取决于两个属性：fillStyle 和 strokeStyle。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> context.<span class="property">strokeStyle</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"> context.<span class="property">fillStyle</span> = <span class="string">&quot;#0000ff&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>绘制矩形: 矩形是唯一一个可以直接在 2D 绘图上下文中绘制的形状。与绘制矩形相关的方法有 3 个：fillRect()、strokeRect()和 clearRect()。这些方法都接收 4 个参数：矩形 x 坐标、矩形 y 坐标、矩形宽度和矩形高度。这几个参数的单位都是像素。<br>fillRect()方法用于以指定颜色在画布上绘制并填充矩形。填充的颜色使用 fillStyle 属性指定。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 引自 MDN 文档</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="comment">// 绘制红色矩形</span></span><br><span class="line"> context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line"> context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"> <span class="comment">// 绘制半透明蓝色矩形</span></span><br><span class="line"> context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>; </span><br><span class="line"> context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
strokeRect()方法使用通过 strokeStyle 属性指定的颜色绘制矩形轮廓。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 引自 MDN 文档</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> <span class="comment">// 绘制红色轮廓的矩形</span></span><br><span class="line"> context.<span class="property">strokeStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line"> context.<span class="title function_">strokeRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"> <span class="comment">// 绘制半透明蓝色轮廓的矩形</span></span><br><span class="line"> context.<span class="property">strokeStyle</span> = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>; </span><br><span class="line"> context.<span class="title function_">strokeRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
注意 描边宽度由 lineWidth 属性控制，它可以是任意整数值。类似地，lineCap 属性控制线条端点的形状［”butt”（平头）、”round”（出圆头）或”square”（出方头）］，而 lineJoin属性控制线条交点的形状［”round”（圆转）、”bevel”（取平）或”miter”（出尖）］<br>使用 clearRect()方法可以擦除画布中某个区域。该方法用于把绘图上下文中的某个区域变透明。通过先绘制形状再擦除指定区域，可以创建出有趣的效果，比如从已有矩形中开个孔。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 引自 MDN 文档</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 绘制红色矩形</span></span><br><span class="line"> context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line"> context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"> <span class="comment">// 绘制半透明蓝色矩形</span></span><br><span class="line"> context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>; </span><br><span class="line"> context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"> <span class="comment">// 在前两个矩形重叠的区域擦除一个矩形区域</span></span><br><span class="line"> context.<span class="title function_">clearRect</span>(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>绘制路径: 2D 绘图上下文支持很多在画布上绘制路径的方法。通过路径可以创建复杂的形状和线条。要绘制路径，必须首先调用 beginPath()方法以表示要开始绘制新路径。然后，再调用下列方法来绘制路径。<br> arc(x, y, radius, startAngle, endAngle, counterclockwise)：以坐标(x, y)为圆心，以 radius 为半径绘制一条弧线，起始角度为 startAngle，结束角度为 endAngle（都是弧度）。最后一个参数 counterclockwise 表示是否逆时针计算起始角度和结束角度（默认为顺时针）。<br> arcTo(x1, y1, x2, y2, radius)：以给定半径 radius，经由(x1, y1)绘制一条从上一点到(x2, y2)的弧线。<br> bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：以(c1x, c1y)和(c2x, c2y)为控制点，绘制一条从上一点到(x, y)的弧线（三次贝塞尔曲线）。<br> lineTo(x, y)：绘制一条从上一点到(x, y)的直线。<br> moveTo(x, y)：不绘制线条，只把绘制光标移动到(x, y)。<br> quadraticCurveTo(cx, cy, x, y)：以(cx, cy)为控制点，绘制一条从上一点到(x, y)的弧线（二次贝塞尔曲线）。<br> rect(x, y, width, height)：以给定宽度和高度在坐标点(x, y)绘制一个矩形。这个方法与 strokeRect()和 fillRect()的区别在于，它创建的是一条路径，而不是独立的图形。<br>创建路径之后，可以使用 closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可以指定 fillStyle 属性并调用 fill()方法来填充路径，也可以指定 strokeStyle 属性并调用stroke()方法来描画路径，还可以调用 clip()方法基于已有路径创建一个新剪切区域。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">// 创建路径</span></span><br><span class="line"> context.<span class="title function_">beginPath</span>(); </span><br><span class="line"> <span class="comment">// 绘制外圆</span></span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 绘制内圆</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">194</span>, <span class="number">100</span>); </span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 绘制分针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">15</span>); </span><br><span class="line"> <span class="comment">// 绘制时针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">35</span>, <span class="number">100</span>); </span><br><span class="line"> <span class="comment">// 描画路径</span></span><br><span class="line"> context.<span class="title function_">stroke</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
路径是 2D 上下文的主要绘制机制，为绘制结果提供了很多控制。因为路径经常被使用，所以也有一个 isPointInPath()方法，接收 x 轴和 y 轴坐标作为参数。这个方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (context.<span class="title function_">isPointInPath</span>(<span class="number">100</span>, <span class="number">100</span>)) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Point (100, 100) is in the path.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>绘制文本: 文本和图像混合也是常见的绘制需求，因此2D绘图上下文还提供了绘制文本的方法，即fillText()和 strokeText()。这两个方法都接收 4 个参数：要绘制的字符串、x 坐标、y 坐标和可选的最大像素宽度。而且，这两个方法最终绘制的结果都取决于以下 3 个属性。<br> font：以 CSS 语法指定的字体样式、大小、字体族等，比如”10px Arial”。<br> textAlign：指定文本的对齐方式，可能的值包括”start”、”end”、”left”、”right”和”center”。推荐使用”start”和”end”，不使用”left”和”right”，因为前者无论在从左到右书写的语言还是从右到左书写的语言中含义都更明确。<br> textBaseLine ：指定文本的基线，可能的值包括 “top” 、 “hanging” 、 “middle” 、”alphabetic”、”ideographic”和”bottom”。<br>fillText()方法使用fillStyle 属性绘制文本，而 strokeText()方法使用 strokeStyle 属性。通常，fillText()方法是使用最多的，因为它模拟了在网页中渲染文本。例如，下面的例子会在前一节示例的表盘顶部绘制数字“12”：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">context.<span class="property">font</span> = <span class="string">&quot;bold 14px Arial&quot;</span>; </span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;center&quot;</span>; </span><br><span class="line">context.<span class="property">textBaseline</span> = <span class="string">&quot;middle&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></div>
因为把 textAlign 设置为了”center”，把 textBaseline 设置为了”middle”，所以(100, 20)表示文本水平和垂直中心点的坐标。如果 textAlign 是”start”，那么 x 坐标在从左到右书写的语言中表示文本的左侧坐标，而”end”会让 x 坐标在从左到右书写的语言中表示文本的右侧坐标。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常</span></span><br><span class="line">context.<span class="property">font</span> = <span class="string">&quot;bold 14px Arial&quot;</span>; </span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;center&quot;</span>; </span><br><span class="line">context.<span class="property">textBaseline</span> = <span class="string">&quot;middle&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>); </span><br><span class="line"><span class="comment">// 与开头对齐</span></span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;start&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">40</span>); </span><br><span class="line"><span class="comment">// 与末尾对齐</span></span><br><span class="line">context.<span class="property">textAlign</span> = <span class="string">&quot;end&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure></div>
由于绘制文本很复杂，特别是想把文本绘制到特定区域的时候，因此 2D 上下文提供了用于辅助确定文本大小的 measureText()方法。这个方法接收一个参数，即要绘制的文本，然后返回一个TextMetrics 对象。这个返回的对象目前只有一个属性 width，不过将来应该会增加更多度量指标。<br>measureText()方法使用 font、textAlign 和 textBaseline 属性当前的值计算绘制指定文本后的大小。例如，假设要把文本”Hello world!”放到一个 140 像素宽的矩形中，可以使用以下代码，从 100 像素的字体大小开始计算，不断递减，直到文本大小合适：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fontSize = <span class="number">100</span>; </span><br><span class="line">context.<span class="property">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>; </span><br><span class="line"><span class="keyword">while</span>(context.<span class="title function_">measureText</span>(<span class="string">&quot;Hello world!&quot;</span>).<span class="property">width</span> &gt; <span class="number">140</span>) &#123; </span><br><span class="line"> fontSize--; </span><br><span class="line"> context.<span class="property">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;Hello world!&quot;</span>, <span class="number">10</span>, <span class="number">10</span>); </span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;Font size is &quot;</span> + fontSize + <span class="string">&quot;px&quot;</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></div>
fillText()和 strokeText()方法还有第四个参数，即文本的最大宽度。这个参数是可选的（Firefox 4 是第一个实现它的浏览器），如果调用 fillText()和 strokeText()时提供了此参数，但要绘制的字符串超出了最大宽度限制，则文本会以正确的字符高度绘制，这时字符会被水平压缩，以达到限定宽度。</li>
<li>变换: 上下文变换可以操作绘制在画布上的图像。2D 绘图上下文支持所有常见的绘制变换。在创建绘制上下文时，会以默认值初始化变换矩阵，从而让绘制操作如实应用到绘制结果上。对绘制上下文应用变换，可以导致以不同的变换矩阵应用绘制操作，从而产生不同的结果。<br>以下方法可用于改变绘制上下文的变换矩阵。<br> rotate(angle)：围绕原点把图像旋转 angle 弧度。<br> scale(scaleX, scaleY)：通过在 x 轴乘以 scaleX、在 y 轴乘以 scaleY 来缩放图像。scaleX和 scaleY 的默认值都是 1.0。<br> translate(x, y)：把原点移动到(x, y)。执行这个操作后，坐标(0, 0)就会变成(x, y)。<br> transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：像下面这样通过矩阵乘法直接修改矩阵。<br>m1_1 m1_2 dx<br>m2_1 m2_2 dy<br>0 0 1<br> setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：把矩阵重置为默认值，再以传入的参数调用 transform()。<br>变换可以简单，也可以复杂。例如，在前面绘制表盘的例子中，如果把坐标原点移动到表盘中心，那再绘制表针就非常简单了：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">// 创建路径</span></span><br><span class="line"> context.<span class="title function_">beginPath</span>(); </span><br><span class="line"> <span class="comment">// 绘制外圆</span></span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 绘制内圆</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">194</span>, <span class="number">100</span>); </span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 移动原点到表盘中心</span></span><br><span class="line"> context.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"> <span class="comment">// 绘制分针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">0</span>, -<span class="number">85</span>); </span><br><span class="line"> <span class="comment">// 绘制时针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(-<span class="number">65</span>, <span class="number">0</span>); </span><br><span class="line"> <span class="comment">// 描画路径</span></span><br><span class="line"> context.<span class="title function_">stroke</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
把原点移动到(100, 100)，也就是表盘的中心后，要绘制表针只需简单的数学计算即可。这是因为所有计算都是基于(0, 0)，而不是(100, 100)了。当然，也可以使用 rotate()方法来转动表针：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"> <span class="comment">// 创建路径</span></span><br><span class="line"> context.<span class="title function_">beginPath</span>(); </span><br><span class="line"> <span class="comment">// 绘制外圆</span></span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 绘制内圆</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">194</span>, <span class="number">100</span>); </span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>); </span><br><span class="line"> <span class="comment">// 移动原点到表盘中心</span></span><br><span class="line"> context.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line"> <span class="comment">// 旋转表针</span></span><br><span class="line"> context.<span class="title function_">rotate</span>(<span class="number">1</span>); </span><br><span class="line"> <span class="comment">// 绘制分针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">0</span>, -<span class="number">85</span>); </span><br><span class="line"> <span class="comment">// 绘制时针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"> context.<span class="title function_">lineTo</span>(-<span class="number">65</span>, <span class="number">0</span>); </span><br><span class="line"> <span class="comment">// 描画路径</span></span><br><span class="line"> context.<span class="title function_">stroke</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
所有这些变换，包括 fillStyle 和 strokeStyle 属性，会一直保留在上下文中，直到再次修改它们。虽然没有办法明确地将所有值都重置为默认值，但有两个方法可以帮我们跟踪变化。如果想着什么时候再回到当前的属性和变换状态，可以调用 save()方法。调用这个方法后，所有这一时刻的设置会被放到一个暂存栈中。保存之后，可以继续修改上下文。而在需要恢复之前的上下文时，可以调用restore()方法。这个方法会从暂存栈中取出并恢复之前保存的设置。多次调用 save()方法可以在暂存栈中存储多套设置，然后通过 restore()可以系统地恢复。下面来看一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">save</span>(); </span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#00ff00&quot;</span>; </span><br><span class="line">context.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>); </span><br><span class="line">context.<span class="title function_">save</span>(); </span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#0000ff&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(100, 100)绘制蓝色矩形</span></span><br><span class="line">context.<span class="title function_">restore</span>(); </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(100, 100)绘制绿色矩形</span></span><br><span class="line">context.<span class="title function_">restore</span>(); </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(0, 0)绘制红色矩形</span></span><br></pre></td></tr></table></figure></div>
以上代码先将 fillStyle 设置为红色，然后调用 save()。接着，将 fillStyle 修改为绿色，坐标移动到(100, 100)，并再次调用 save()，保存设置。随后，将 fillStyle 属性设置为蓝色并绘制一个矩形。因为此时坐标被移动了，所以绘制矩形的坐标实际上是(100, 100)。在调用 restore()之后，fillStyle 恢复为绿色，因此这一次绘制的矩形是绿色的。而绘制矩形的坐标是(110, 110)，因为变换仍在起作用。再次调用 restore()之后，变换被移除，fillStyle 也恢复为红色。绘制最后一个矩形的坐标变成了(0, 0)。<br>注意，save()方法只保存应用到绘图上下文的设置和变换，不保存绘图上下文的内容。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-08 日报 Day119</title>
    <url>/undefined/2025-03-08/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>所有难过，难是难，但总会过。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 子串之和为K的子数组、滑动窗口最大值</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-09 日报 Day120</title>
    <url>/undefined/2025-03-09/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>蹉跎只能感动自己，行动才能打动别人。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 子串之最小覆盖子串</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-10 日报 Day121</title>
    <url>/undefined/2025-03-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有输得起的勇气，才会有赢得到的底气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之最大子数组和合并区间</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-06 日报 Day117</title>
    <url>/undefined/2025-03-06/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>真正的力量，往往并非来源于成绩的辉煌，而是来自于内心的平静与坚持，是在面对风雨时依然能够保持的一份从容与勇气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>LeetCode 双指针之移动零、盛最多水的容器、三数之和、接雨水</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-07 日报 Day118</title>
    <url>/undefined/2025-03-07/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>我将玫瑰藏于身后，风起花落，从此鲜花赠自己，纵马踏花向自由。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 滑动窗口之无重复字符的最长子串、找到字符串中所有字母异位词</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-04 日报 Day115</title>
    <url>/undefined/2025-03-04/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>前期回顾</p>

    </div>
    <div class="notel-content">
      <p>人生的魅力就在于未知。最近发生了许多的事情，但anyway，打不死我的只会让我更强大，重整旗鼓，继续前行。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>LeetCode 哈希表HOT100之两数之和、字母异位词分组、最长连续序列</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-12 日报 Day123</title>
    <url>/undefined/2025-03-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你做三四月的事，在八九月自有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之轮转数组、除自身以外数组的乘积</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-13 日报 Day124</title>
    <url>/undefined/2025-03-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你做三四月的事，在八九月自有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之缺失的第一个正数</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-16 日报 Day127</title>
    <url>/undefined/2025-03-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>那些难走的路，往往都是向上的路。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之螺旋矩阵</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-14 日报 Day125</title>
    <url>/undefined/2025-03-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你做三四月的事，在八九月自有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之缺失的第一个正数</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-17 日报 Day128</title>
    <url>/undefined/2025-03-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>想要成为什么人，就努力靠近什么样的人。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之旋转图像</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-11 日报 Day122</title>
    <url>/undefined/2025-03-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>如果你热爱生活，生活一定比谁都清楚。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之轮转数组、除自身以外数组的乘积</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-18 日报 Day129</title>
    <url>/undefined/2025-03-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>勇敢地迈出第一步，是治愈焦虑的良药。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之搜索二维矩阵 II</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-21 日报 Day132</title>
    <url>/undefined/2025-03-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你的迷茫，大多都是因为想得太多、做得太少。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之回文链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-22 日报 Day133</title>
    <url>/undefined/2025-03-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>假如生活抛来一颗柠檬，你大可以选择把它榨成鲜美的柠檬汁。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之合并两个有序链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-23 日报 Day134</title>
    <url>/undefined/2025-03-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>如果真的有谁能改变命运，推翻自己身上的偏见，那一定是你自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之两数相加</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-19 日报 Day130</title>
    <url>/undefined/2025-03-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有风有雨是人生的常态，迎难而上才能逆风翻盘。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之相交链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-15 日报 Day126</title>
    <url>/undefined/2025-03-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>多一分坚持，就会少一分遗憾。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之矩阵置零</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-20 日报 Day131</title>
    <url>/undefined/2025-03-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>读书就是用最低廉的成本走最高级的成长路。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之反转链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-24 日报 Day135</title>
    <url>/undefined/2025-03-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>把心放宽，该看开的看开，该放下的放下，才能看到不同的风景。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之删除链表的倒数第N个结点</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-27 日报 Day138</title>
    <url>/undefined/2025-03-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>那些失意和受挫不过是人生的插曲，十年后回头再看，或许已成为财富。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之随机链表的复制</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-26 日报 Day137</title>
    <url>/undefined/2025-03-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>远离不必要的计较和纠缠，把每一个平凡的日子都活出热气腾腾的样子。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之k个一组翻转链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-28 日报 Day139</title>
    <url>/undefined/2025-03-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>不要害怕一次的选择会改变自己的一生，要有一切推倒重来的勇气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之排序链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-25 日报 Day136</title>
    <url>/undefined/2025-03-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>自律和不自律，都会吃苦。不同的是，自律的苦会让人生越来越甜</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之两两交换链表中的节点</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-30 日报 Day141</title>
    <url>/undefined/2025-03-30/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有梦想的人，总是知道自己要什么，一步一个脚印地让梦想离自己更近。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之LRU缓存</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-29 日报 Day140</title>
    <url>/undefined/2025-03-29/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>没有完美的人生，但成熟的人，会懂得如何让自己变得更好。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之合并k个升序链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-31 日报 Day142</title>
    <url>/undefined/2025-03-31/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>一次又一次的努力，会不断激发你的潜力，促使你成长为自己期待的样子。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 二叉树之二叉树的中序遍历</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-01 日报 Day143</title>
    <url>/undefined/2025-04-01/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>无论何时，无论遇到何事，都要保持年轻的心态。放下过往陈旧的观念，打破固有的认知经验，去探索新鲜的事物，把更多时间放在修炼自我上。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P563-568 第十八章：动画与 Canvas 图形</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、绘制图像: 2D 绘图上下文内置支持操作图像。如果想把现有图像绘制到画布上，可以使用 drawImage()方法。这个方法可以接收 3 组不同的参数，并产生不同的结果。最简单的调用是传入一个 HTML 的<img>元素，以及表示绘制目标的 x 和 y 坐标，结果是把图像绘制到指定位置。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>]; </span><br><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></div>
<p>以上代码获取了文本中的第一个图像，然后在画布上的坐标(10, 10)处将它绘制了出来。绘制出来的图像与原来的图像一样大。如果想改变所绘制图像的大小，可以再传入另外两个参数：目标宽度和目标高度。这里的缩放只影响绘制的图像，不影响上下文的变换矩阵。比如下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>
<p>执行之后，图像会缩放到 20 像素宽、30 像素高。还可以只把图像绘制到上下文中的一个区域。此时，需要给 drawImage()提供 9 个参数：要绘制的图像、源图像 x 坐标、源图像 y 坐标、源图像宽度、源图像高度、目标区域 x 坐标、目标区域 y 坐标、目标区域宽度和目标区域高度。这个重载后的 drawImage()方法可以实现最大限度的控制，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">40</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure></div>
<p>最终，原始图像中只有一部分会绘制到画布上。这一部分从(0, 10)开始，50 像素宽、50 像素高。而绘制到画布上时，会从(0, 100)开始，变成 40 像素宽、60 像素高。<br>第一个参数除了可以是 HTML 的<img>元素，还可以是另一个<canvas>元素，这样就会把另一个画布的内容绘制到当前画布上。<br>结合其他一些方法，drawImage()方法可以方便地实现常见的图像操作。操作的结果可以使用toDataURL()方法获取。不过有一种情况例外：如果绘制的图像来自其他域而非当前页面，则不能获取其数据。此时，调用 toDataURL()将抛出错误。<br>2、阴影: 2D 上下文可以根据以下属性的值自动为已有形状或路径生成阴影。<br> shadowColor：CSS 颜色值，表示要绘制的阴影颜色，默认为黑色。<br> shadowOffsetX：阴影相对于形状或路径的 x 坐标的偏移量，默认为 0。<br> shadowOffsetY：阴影相对于形状或路径的 y 坐标的偏移量，默认为 0。<br> shadowBlur：像素，表示阴影的模糊量。默认值为 0，表示不模糊。<br>这些属性都可以通过 context 对象读写。只要在绘制图形或路径前给这些属性设置好适当的值，阴影就会自动生成。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>); </span><br><span class="line"><span class="comment">// 设置阴影</span></span><br><span class="line">context.<span class="property">shadowOffsetX</span> = <span class="number">5</span>; </span><br><span class="line">context.<span class="property">shadowOffsetY</span> = <span class="number">5</span>; </span><br><span class="line">context.<span class="property">shadowBlur</span> = <span class="number">4</span>; </span><br><span class="line">context.<span class="property">shadowColor</span> = <span class="string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>; </span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制蓝色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,1)&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></div>
<p>3、渐变: 渐变通过 CanvasGradient 的实例表示，在 2D 上下文中创建和修改都非常简单。要创建一个新的线性渐变，可以调用上下文的 createLinearGradient()方法。这个方法接收 4 个参数：起点 x 坐标、起点 y 坐标、终点 x 坐标和终点 y 坐标。调用之后，该方法会以指定大小创建一个新的 CanvasGradient对象并返回实例。<br>有了 gradient 对象后，接下来要使用 addColorStop()方法为渐变指定色标。这个方法接收两个参数：色标位置和 CSS 颜色字符串。色标位置通过 0～1 范围内的值表示，0 是第一种颜色，1 是最后一种颜色。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = context.<span class="title function_">createLinearGradient</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>); </span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>这个 gradient 对象现在表示的就是在画布上从(30, 30)到(70, 70)绘制一个渐变。渐变的起点颜色为白色，终点颜色为黑色。可以把这个对象赋给 fillStyle 或 strokeStyle 属性，从而以渐变填充或描画绘制的图形：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>); </span><br><span class="line"><span class="comment">// 绘制渐变矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = gradient; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></div>
<p>3、图案: 图案是用于填充和描画图形的重复图像。要创建新图案，可以调用 createPattern()方法并传入两个参数：一个 HTML <img>元素和一个表示该如何重复图像的字符串。第二个参数的值与 CSS 的background-repeat 属性是一样的，包括”repeat”、”repeat-x”、”repeat-y”和”no-repeat”。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>], </span><br><span class="line"> pattern = context.<span class="title function_">createPattern</span>(image, <span class="string">&quot;repeat&quot;</span>); </span><br><span class="line"><span class="comment">// 绘制矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = pattern; </span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure></div>
<p>传给 createPattern()方法的第一个参数也可以是<video>元素或者另一个<canvas>元素。<br>4、图像数据: 2D 上下文中比较强大的一种能力是可以使用 getImageData()方法获取原始图像数据。这个方法接收 4 个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度。例如，要从(10, 5)开始取得 50 像素宽、50 像素高的区域对应的数据，可以这样写：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageData = context.<span class="title function_">getImageData</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></div>
<p>返回的对象是一个 ImageData 的实例。每个 ImageData 对象都包含 3 个属性：width、height和 data，其中，data 属性是包含图像的原始像素信息的数组。每个像素在 data 数组中都由 4 个值表示，分别代表红、绿、蓝和透明度值。换句话说，第一个像素的信息包含在第 0 到第 3 个值中，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = imageData.<span class="property">data</span>, </span><br><span class="line"> red = data[<span class="number">0</span>], </span><br><span class="line"> green = data[<span class="number">1</span>], </span><br><span class="line"> blue = data[<span class="number">2</span>], </span><br><span class="line"> alpha = data[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></div>
<p>注意 只有在画布没有加载跨域内容时才可以获取图像数据。如果画布上绘制的是跨域内容，则尝试获取图像数据会导致 JavaScript 报错。<br>5、合成: 2D上下文中绘制的所有内容都会应用两个属性：globalAlpha 和 globalComposition Operation，其中，globalAlpha 属性是一个范围在 0~1 的值（包括 0 和 1），用于指定所有绘制内容的透明度，默认值为 0。<br>globalCompositionOperation 属性表示新绘制的形状如何与上下文中已有的形状融合。这个属性是一个字符串，可以取下列值。<br> source-over：默认值，新图形绘制在原有图形上面。<br> source-in：新图形只绘制出与原有图形重叠的部分，画布上其余部分全部透明。<br> source-out：新图形只绘制出不与原有图形重叠的部分，画布上其余部分全部透明。<br> source-atop：新图形只绘制出与原有图形重叠的部分，原有图形不受影响。<br> destination-over：新图形绘制在原有图形下面，重叠部分只有原图形透明像素下的部分可见。<br> destination-in：新图形绘制在原有图形下面，画布上只剩下二者重叠的部分，其余部分完全透明。<br> destination-out：新图形与原有图形重叠的部分完全透明，原图形其余部分不受影响。<br> destination-atop：新图形绘制在原有图形下面，原有图形与新图形不重叠的部分完全透明。<br> lighter：新图形与原有图形重叠部分的像素值相加，使该部分变亮。<br> copy：新图形将擦除并完全取代原有图形。<br> xor：新图形与原有图形重叠部分的像素执行“异或”计算。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-02 日报 Day144</title>
    <url>/undefined/2025-04-02/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>无论何时，无论遇到何事，都要保持年轻的心态。放下过往陈旧的观念，打破固有的认知经验，去探索新鲜的事物，把更多时间放在修炼自我上。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P569-580 第十八章：动画与 Canvas 图形</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、WebGL: WebGL 是画布的 3D 上下文。推荐一个 WebGL 教程网站：Learn WebGL。<br>注意 定型数组是在 WebGL 中执行操作的重要数据结构。<br>2、WebGL上下文: 在完全支持的浏览器中，WebGL 2.0 上下文的名字叫”webgl2”，WebGL 1.0 上下文的名字叫”webgl1”。如果浏览器不支持 WebGL，则尝试访问 WebGL 上下文会返回 null。在使用上下文之前，应该先检测返回值是否存在：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>); </span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt; </span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> gl = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;webgl&quot;</span>); </span><br><span class="line"> <span class="keyword">if</span> (gl)&#123; </span><br><span class="line"> <span class="comment">// 使用 WebGL </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3、WebGL基础: 取得 WebGL 上下文后，就可以开始 3D 绘图了。可以在调用 getContext()取得 WebGL 上下文时指定一些选项。这些选项通过一个参数对象传入，选项就是参数对象的一个或多个属性。<br> alpha：布尔值，表示是否为上下文创建透明通道缓冲区，默认为 true。<br> depth：布尔值，表示是否使用 16 位深缓冲区，默认为 true。<br> stencil：布尔值，表示是否使用 8 位模板缓冲区，默认为 false。<br> antialias：布尔值，表示是否使用默认机制执行抗锯齿操作，默认为 true。<br> premultipliedAlpha：布尔值，表示绘图缓冲区是否预乘透明度值，默认为 true。<br> preserveDrawingBuffer：布尔值，表示绘图完成后是否保留绘图缓冲区，默认为 false。</p>
<ul>
<li>常量: 如果你熟悉 OpenGL，那么可能知道用于操作的各种常量。这些常量在 OpenGL 中的名字以 GL_开头。在 WebGL 中，context 对象上的常量则不包含 GL_前缀。例如，GL_COLOR_BUFFER_BIT 常量在WebGL 中要这样访问 gl.COLOR_BUFFER_BIT。WebGL 以这种方式支持大部分 OpenGL 常量。</li>
<li>方法命名: OpenGL（同时也是 WebGL）中的很多方法会包含相关的数据类型信息。接收不同类型和不同数量参数的方法，会通过方法名的后缀体现这些信息。表示参数数量的数字（1~4）在先，表示数据类型的字符串（“f”表示浮点数，“i”表示整数）在后。比如，gl.uniform4f()的意思是需要 4 个浮点数值参数，而 gl.uniform3i()表示需要 3 个整数值参数。<br>还有很多方法接收数组，这类方法用字母“v”（vector）来表示。因此，gl.uniform3iv()就是要接收一个包含 3 个值的数组参数。在编写 WebGL 代码时，要记住这些约定。</li>
<li>准备绘图: 准备使用 WebGL 上下文之前，通常需要先指定一种实心颜色清除<canvas>。为此，要调用clearColor()方法并传入 4 个参数，分别表示红、绿、蓝和透明度值。每个参数必须是 0~1 范围内的值，表示各个组件在最终颜色的强度。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">gl.<span class="title function_">clearColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 黑色</span></span><br><span class="line">gl.<span class="title function_">clear</span>(gl.<span class="property">COLOR_BUFFER_BIT</span>);</span><br></pre></td></tr></table></figure></div>
以上代码把清理颜色缓冲区的值设置为黑色，然后调用 clear()方法，这个方法相当于 OpenGL中的 glClear()方法。参数 gl.COLOR_BUFFER_BIT 告诉 WebGL 使用之前定义的颜色填充画布。通常，所有绘图操作之前都需要先清除绘制区域。</li>
<li>视口与坐标: 绘图前还要定义 WebGL 视口。默认情况下，视口使用整个<canvas>区域。要改变视口，可以调用viewport()方法并传入视口相对于<canvas>元素的 x、y 坐标及宽度和高度。例如，以下代码表示要使用整个<canvas>元素：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">gl.<span class="title function_">viewport</span>(<span class="number">0</span>, <span class="number">0</span>, drawing.<span class="property">width</span>, </span><br><span class="line">drawing.<span class="property">height</span>);</span><br></pre></td></tr></table></figure></div>
这个视口的坐标系统与网页中通常的坐标系统不一样。视口的 x 和 y 坐标起点(0, 0)表示<canvas>元素的左下角，向上、向右增长可以用点(width–1, height–1)定义</li>
<li>缓冲区: 在 JavaScript 中，顶点信息保存在定型数组中。要使用这些信息，必须先把它们转换为 WebGL 缓冲区。创建缓冲区要调用 gl.createBuffer()方法，并使用 gl.bindBuffer()方法将缓冲区绑定到WebGL 上下文。绑定之后，就可以用数据填充缓冲区了。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = gl.<span class="title function_">createBuffer</span>(); </span><br><span class="line">gl.<span class="title function_">bindBuffer</span>(gl.<span class="property">ARRAY_BUFFER</span>, buffer); </span><br><span class="line">gl.<span class="title function_">bufferData</span>(gl.<span class="property">ARRAY_BUFFER</span>, <span class="keyword">new</span> <span class="title class_">Float32Array</span>([<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]), gl.<span class="property">STATIC_DRAW</span>);</span><br></pre></td></tr></table></figure></div>
调用 gl.bindBuffer()将 buffer 设置为上下文的当前缓冲区。然后，所有缓冲区操作都在buffer 上直接执行。因此，调用 gl.bufferData()虽然没有包含对 buffer 的直接引用，但仍然是在它上面执行的。上面最后一行代码使用一个 Float32Array（通常把所有顶点信息保存在Float32Array 中）初始化了 buffer。如果想输出缓冲区内容，那么可以调用 drawElements()方法并传入 gl.ELEMENT_ARRAY_BUFFER。<br>gl.bufferData()方法的最后一个参数表示如何使用缓冲区。这个参数可以是以下常量值。<br> gl.STATIC_DRAW：数据加载一次，可以在多次绘制中使用。<br> gl.STREAM_DRAW：数据加载一次，只能在几次绘制中使用。<br> gl.DYNAMIC_DRAW：数据可以重复修改，在多次绘制中使用。<br>缓冲区会一直驻留在内存中，直到页面卸载。如果不再需要缓冲区，那么最好调用 gl.deleteBuffer()方法释放其占用的内存：<br>gl.deleteBuffer(buffer);</li>
<li>错误: 与 JavaScript 多数情况下不同的是，在 WebGL 操作中通常不会抛出错误。必须在调用可能失败的方法后，调用 gl.getError()方法。这个方法返回一个常量，表示发生的错误类型。下面列出了这些常量。<br> gl.NO_ERROR：上一次操作没有发生错误（0 值）。<br> gl.INVALID_ENUM：上一次操作没有传入 WebGL 预定义的常量。<br> gl.INVALID_VALUE：上一次操作需要无符号数值，但是传入了负数。<br> gl.INVALID_OPERATION：上一次操作在当前状态下无法完成。<br> gl.OUT_OF_MEMORY：上一次操作因内存不足而无法完成。<br> gl.CONTEXT_LOST_WEBGL：上一次操作因外部事件（如设备掉电）而丢失了 WebGL 上下文。</li>
<li>着色器: WebGL 中有两种着色器：顶点着色器和片段（或像素）着色器。顶点着色器用于把 3D 顶点转换为可以渲染的 2D 点。片段着色器用于计算绘制一个像素的正确颜色。WebGL 着色器的独特之处在于，它们不是 JavaScript 实现的，而是使用一种与 C 或 JavaScript 完全不同的语言 GLSL（OpenGL Shading Language）写的。<br>编写着色器: GLSL 是一种类似于 C 的语言，专门用于编写 OpenGL 着色器。因为 WebGL 是 OpenGL ES 2 的实现，所以 OpenGL 中的着色器可以直接在 WebGL 中使用。这样也可以让桌面应用更方便地移植到 Web 上。<br>每个着色器都有一个 main()方法，在绘制期间会重复执行。给着色器传递数据的方式有两种：attribute 和 uniform。attribute 用于将顶点传入顶点着色器，而 uniform 用于将常量值传入任何着色器。attribute 和 uniform 是在 main()函数外部定义的。在值类型关键字之后是数据类型，然后是变量名。下面是一个简单的顶点着色器的例子：<div class="highlight-container" data-rel="Glsl"><figure class="iseeu highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenGL 着色器语言</span></span><br><span class="line"><span class="comment">// 着色器，摘自 Bartek Drozdz 的文章“Get started with WebGL—draw a square”</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> aVertexPosition; </span><br><span class="line"><span class="type">void</span> main() &#123; </span><br><span class="line"> <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aVertexPosition, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
创建着色器程序: 浏览器并不理解原生 GLSL 代码，因此 GLSL 代码的字符串必须经过编译并链接到一个着色器程序中。为便于使用，通常可以使用带有自定义 type 属性的<script>元素把着色器代码包含在网页中。如果 type 属性无效，则浏览器不会解析<script>的内容，但这并不妨碍读写其中的内容：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;x-webgl/x-vertex-shader&quot;</span> <span class="attr">id</span>=<span class="string">&quot;vertexShader&quot;</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">attribute vec2 aVertexPosition; </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript"> gl_Position = <span class="title function_">vec4</span>(aVertexPosition, <span class="number">0.0</span>, <span class="number">1.0</span>); </span></span><br><span class="line"><span class="language-javascript">&#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;x-webgl/x-fragment-shader&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fragmentShader&quot;</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">uniform vec4 uColor; </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript"> gl_FragColor = uColor; </span></span><br><span class="line"><span class="language-javascript">&#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
然后可以使用 text 属性提取<script>元素的内容：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vertexGlsl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;vertexShader&quot;</span>).<span class="property">text</span>, </span><br><span class="line"> fragmentGlsl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fragmentShader&quot;</span>).<span class="property">text</span>;</span><br></pre></td></tr></table></figure></div></li>
<li>给着色器传值: 前面定义的每个着色器都需要传入一个值，才能完成工作。要给着色器传值，必须先找到要接收值的变量。对于 uniform 变量，可以调用 gl.getUniformLocation()方法。</li>
<li>调试着色器和程序: 与 WebGL 中的其他操作类似，着色器操作也可能失败，而且是静默失败。如果想知道发生了什么错误，则必须手工通过 WebGL 上下文获取关于着色器或程序的信息。</li>
<li>绘图: WebGL 只能绘制三种形状：点、线和三角形。其他形状必须通过这三种基本形状在 3D 空间的组合来绘制。WebGL 绘图要使用 drawArrays()和 drawElements()方法，前者使用数组缓冲区，后者则操作元素数组缓冲区。<br>drawArrays()和 drawElements()的第一个参数都表示要绘制形状的常量。下面列出了这些常量。<br> gl.POINTS：将每个顶点当成一个点来绘制。<br> gl.LINES：将数组作为一系列顶点，在这些顶点间绘制直线。每个顶点既是起点也是终点，因此数组中的顶点必须是偶数个才能开始绘制。<br> gl.LINE_LOOP：将数组作为一系列顶点，在这些顶点间绘制直线。从第一个顶点到第二个顶点绘制一条直线，再从第二个顶点到第三个顶点绘制一条直线，以此类推，直到绘制到最后一个顶点。此时再从最后一个顶点到第一个顶点绘制一条直线。这样就可以绘制出形状的轮廓。<br> gl.LINE_STRIP：类似于 gl.LINE_LOOP，区别在于不会从最后一个顶点到第一个顶点绘制直线。<br> gl.TRIANGLES：将数组作为一系列顶点，在这些顶点间绘制三角形。如不特殊指定，每个三角形都分开绘制，不共享顶点。<br> gl.TRIANGLES_STRIP：类似于 gl.TRIANGLES，区别在于前 3 个顶点之后的顶点会作为第三个顶点与其前面的两个顶点构成三角形。例如，如果数组中包含顶点 A、B、C、D，那么第一个三角形使用 ABC，第二个三角形使用 BCD。<br> gl.TRIANGLES_FAN：类似于 gl.TRIANGLES，区别在于前 3 个顶点之后的顶点会作为第三个顶点与其前面的顶点和第一个顶点构成三角形。例如，如果数组中包含顶点 A、B、C、D，那么第一个三角形使用 ABC，第二个三角形使用 ACD。<br>以上常量可以作为 gl.drawArrays()方法的第一个参数，第二个参数是数组缓冲区的起点索引，第三个参数是数组缓冲区包含的顶点集合的数量。以下代码使用 gl.drawArrays()在画布上绘制了一个三角形：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设已经使用本节前面的着色器清除了视口</span></span><br><span class="line"><span class="comment">// 定义 3 个顶点的 x 坐标和 y 坐标</span></span><br><span class="line"><span class="keyword">let</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([ <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span> ]), </span><br><span class="line"> buffer = gl.<span class="title function_">createBuffer</span>(), </span><br><span class="line"> vertexSetSize = <span class="number">2</span>, </span><br><span class="line"> vertexSetCount = vertices.<span class="property">length</span>/vertexSetSize, </span><br><span class="line"> uColor, </span><br><span class="line"> aVertexPosition; </span><br><span class="line"><span class="comment">// 将数据放入缓冲区</span></span><br><span class="line">gl.<span class="title function_">bindBuffer</span>(gl.<span class="property">ARRAY_BUFFER</span>, buffer); </span><br><span class="line">gl.<span class="title function_">bufferData</span>(gl.<span class="property">ARRAY_BUFFER</span>, vertices, gl.<span class="property">STATIC_DRAW</span>); </span><br><span class="line"><span class="comment">// 给片段着色器传入颜色</span></span><br><span class="line">uColor = gl.<span class="title function_">getUniformLocation</span>(program, <span class="string">&quot;uColor&quot;</span>); </span><br><span class="line">gl.<span class="title function_">uniform4fv</span>(uColor, [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> ]); </span><br><span class="line"><span class="comment">// 把顶点信息传给着色器</span></span><br><span class="line">aVertexPosition = gl.<span class="title function_">getAttribLocation</span>(program, <span class="string">&quot;aVertexPosition&quot;</span>); </span><br><span class="line">gl.<span class="title function_">enableVertexAttribArray</span>(aVertexPosition);</span><br><span class="line">gl.<span class="title function_">vertexAttribPointer</span>(aVertexPosition, vertexSetSize, gl.<span class="property">FLOAT</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// 绘制三角形</span></span><br><span class="line">gl.<span class="title function_">drawArrays</span>(gl.<span class="property">TRIANGLES</span>, <span class="number">0</span>, vertexSetCount);</span><br></pre></td></tr></table></figure></div></li>
<li>纹理: WebGL 纹理可以使用 DOM 中的图片。可以使用 gl.createTexture()方法创建新的纹理，然后再将图片绑定到这个纹理。如果图片还没有加载，则可以创建一个 Image 对象来动态加载。图片加载完成后才能初始化纹理，因此在图片的 load 事件之后才能使用纹理。比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>(), </span><br><span class="line"> texture; </span><br><span class="line">image.<span class="property">src</span> = <span class="string">&quot;smile.gif&quot;</span>;</span><br><span class="line">image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> texture = gl.<span class="title function_">createTexture</span>(); </span><br><span class="line"> gl.<span class="title function_">bindTexture</span>(gl.<span class="property">TEXTURE_2D</span>, texture); </span><br><span class="line"> gl.<span class="title function_">pixelStorei</span>(gl.<span class="property">UNPACK_FLIP_Y_WEBGL</span>, <span class="literal">true</span>); </span><br><span class="line"> gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_2D</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, image); </span><br><span class="line"> gl.<span class="title function_">texParameteri</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_MAG_FILTER</span>, gl.<span class="property">NEAREST</span>); </span><br><span class="line"> gl.<span class="title function_">texParameteri</span>(gl.<span class="property">TEXTURE_2D</span>, gl.<span class="property">TEXTURE_MIN_FILTER</span>, gl.<span class="property">NEAREST</span>); </span><br><span class="line"> <span class="comment">// 除当前纹理</span></span><br><span class="line"> gl.<span class="title function_">bindTexture</span>(gl.<span class="property">TEXTURE_2D</span>, <span class="literal">null</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>读取像素: 与 2D 上下文一样，可以从 WebGL 上下文中读取像素数据。读取像素的 readPixels()方法与OpenGL 中的方法有同样的参数，只不过最后一个参数必须是定型数组。像素信息是从帧缓冲区读出来并放到这个定型数组中的。readPixels()方法的参数包括 x 和 y 坐标、宽度、高度、图像格式、类型和定型数组。前 4 个参数用于指定要读取像素的位置。<br>4、WebGL1与WebGL2: WebGL1 代码几乎完全与 WebGL2 兼容。在使用 WebGL2 上下文时，唯一可能涉及修改代码以保证兼容性的就是扩展。在 WebGL2 中，很多扩展都变成了默认功能。<br>5、小结: requestAnimationFrame 是简单但实用的工具，可以让 JavaScript F<br>HTML5 的<canvas>元素为 JavaScript 提供了动态创建图形的 API。这些图形需要使用特定上下文绘制，主要有两种。第一种是支持基本绘图操作的 2D 上下文：<br> 填充和描绘颜色及图案<br> 绘制矩形<br> 绘制路径<br> 绘制文本<br> 创建渐变和图案<br>第二种是 3D 上下文，也就是 WebGL。WebGL 是浏览器对 OpenGL ES 2.0 的实现。OpenGL ES 2.0是游戏图形开发常用的一个标准。WebGL 支持比 2D 上下文更强大的绘图能力，包括：<br> 用 OpenGL 着色器语言（GLSL）编写顶点和片段着色器；<br> 支持定型数组，限定数组中包含数值的类型；<br> 创建和操作纹理。<br>目前所有主流浏览器的较新版本都已经支持<canvas>标签。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-04 日报 Day146</title>
    <url>/undefined/2025-04-04/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>与大雁齐飞，目之所及皆是广袤天空；与苍蝇为伍，所到之处皆是污秽狼藉。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P597-609 第十九章：表单脚本</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、选择框编程: 选择框是使用<select>和<option>元素创建的。</p>
<ul>
<li>选项处理: 对于只允许选择一项的选择框，获取选项最简单的方式是使用选择框的 selectedIndex 属性，如下面的例子所示：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectedOption = selectbox.<span class="property">options</span>[selectbox.<span class="property">selectedIndex</span>];</span><br><span class="line"><span class="keyword">let</span> selectedIndex = selectbox.<span class="property">selectedIndex</span>;</span><br><span class="line"><span class="keyword">let</span> selectedOption = selectbox.<span class="property">options</span>[selectedIndex];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="string">`Selected index: <span class="subst">$&#123;selectedIndex&#125;</span>\n`</span> +</span><br><span class="line">    <span class="string">`Selected text: <span class="subst">$&#123;selectedOption.text&#125;</span>\n`</span> +</span><br><span class="line">    <span class="string">`Selected value: <span class="subst">$&#123;selectedOption.value&#125;</span>`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>添加选项: 可以使用 JavaScript 动态创建选项并将它们添加到选择框。首先，可以使用 DOM 方法，如下所示：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newOption = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">newOption.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Option text&quot;</span>));</span><br><span class="line">newOption.<span class="title function_">setAttribute</span>(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;Option value&quot;</span>);</span><br><span class="line">selectbox.<span class="title function_">appendChild</span>(newOption);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>移除选项: 与添加选项类似，移除选项的方法也不止一种。第一种方式是使用 DOM 的 removeChild()方法并传入要移除的选项，比如：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">selectbox.<span class="title function_">removeChild</span>(selectbox.<span class="property">options</span>[<span class="number">0</span>]); <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure></div>

<p>第二种方式是使用选择框的 remove()方法。这个方法接收一个参数，即要移除选项的索引，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">selectbox.<span class="title function_">remove</span>(<span class="number">0</span>); <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure></div>

<p>最后一种方式是直接将选项设置为等于 null。这同样也是 DOM 之前浏览器实现的方式。下面是一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">selectbox.<span class="property">options</span>[<span class="number">0</span>] = <span class="literal">null</span>; <span class="comment">// 移除第一项</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>移动和重排选项: 在 DOM 之前，从一个选择框向另一个选择框移动选项是非常麻烦的，要先从第一个选择框移除选项，然后以相同文本和值创建新选项，再将新选项添加到第二个选择框。DOM 方法则可以直接将某个选项从第一个选择框移动到第二个选择框，只要对相应选项使用 appendChild()方法即可。如果给这个方法传入文档中已有的元素，则该元素会先从其父元素中移除，然后再插入指定位置。例如，下面的代码会从选择框中移除第一项并插入另一个选择框：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectbox1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selLocations1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> selectbox2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;selLocations2&quot;</span>);</span><br><span class="line">selectbox2.<span class="title function_">appendChild</span>(selectbox1.<span class="property">options</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></div>

<p>移动选项和移除选项都会导致每个选项的 index 属性重置。<br>2、表单序列化: 表单序列化（form serialization）已经成为一个常见需求。表单在 JavaScript 中可以使用表单字段的 type 属性连同其 name 属性和 value 属性来进行序列化。在写代码之前，我们需要理解浏览器如何确定在提交表单时要把什么发送到服务器。<br> 字段名和值是 URL 编码的并以和号（&amp;）分隔。<br> 禁用字段不会发送。<br> 复选框或单选按钮只在被选中时才发送。<br> 类型为”reset”或”button”的按钮不会发送。<br> 多选字段的每个选中项都有一个值。<br> 通过点击提交按钮提交表单时，会发送该提交按钮；否则，不会发送提交按钮。类型为”image”的<input>元素视同提交按钮。<br> <select>元素的值是被选中<option>元素的 value 属性。如果<option>元素没有 value 属性，则该值是它的文本。<br>表单序列化通常不包含任何按钮，因为序列化得到的字符串很可能以其他方式提交。除此之外其他规则都应该遵循。最终完成表单序列化的代码如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">serialize</span>(<span class="params">form</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> parts = [];</span><br><span class="line"> <span class="keyword">let</span> optValue;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> field <span class="keyword">of</span> form.<span class="property">elements</span>) &#123;</span><br><span class="line"> <span class="keyword">switch</span>(field.<span class="property">type</span>) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;select-one&quot;</span>:</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;select-multiple&quot;</span>:</span><br><span class="line"> <span class="keyword">if</span> (field.<span class="property">name</span>.<span class="property">length</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> option <span class="keyword">of</span> field.<span class="property">options</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (option.<span class="property">selected</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (option.<span class="property">hasAttribute</span>)&#123;</span><br><span class="line"> optValue = (option.<span class="title function_">hasAttribute</span>(<span class="string">&quot;value&quot;</span>) ?</span><br><span class="line"> option.<span class="property">value</span> : option.<span class="property">text</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> optValue = (option.<span class="property">attributes</span>[<span class="string">&quot;value&quot;</span>].<span class="property">specified</span> ?</span><br><span class="line"> option.<span class="property">value</span> : option.<span class="property">text</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> parts.<span class="title function_">push</span>(<span class="built_in">encodeURIComponent</span>(field.<span class="property">name</span>)&#125; + <span class="string">&quot;=&quot;</span> +</span><br><span class="line"> <span class="built_in">encodeURIComponent</span>(optValue));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="attr">undefined</span>: <span class="comment">// 字段集</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;file&quot;</span>: <span class="comment">// 文件输入</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;submit&quot;</span>: <span class="comment">// 提交按钮</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;reset&quot;</span>: <span class="comment">// 重置按钮</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;button&quot;</span>: <span class="comment">// 自定义按钮</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;radio&quot;</span>: <span class="comment">// 单选按钮</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;checkbox&quot;</span>: <span class="comment">// 复选框</span></span><br><span class="line"> <span class="keyword">if</span> (!field.<span class="property">checked</span>) &#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="attr">default</span>:</span><br><span class="line"> <span class="comment">// 不包含没有名字的表单字段</span></span><br><span class="line"> <span class="keyword">if</span> (field.<span class="property">name</span>.<span class="property">length</span>) &#123;</span><br><span class="line"> parts.<span class="title function_">push</span>(<span class="string">&#x27;$&#123;encodeURIComponent(field.name)&#125;=&#x27;</span> +</span><br><span class="line"> <span class="string">&#x27;$&#123;encodeURIComponent(field.value)&#125;&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> parts.<span class="title function_">join</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3、富文本编辑: 在网页上编写富文本内容是 Web 应用开发中很常见的需求。</p>
<ul>
<li>使用contenteditable: 给页面中的任何元素指定 contenteditable 属性，然后该元素会立即被用户编辑。这种方式更受欢迎，因为不需要额外的 iframe、空页面和 JavaScript，只给元素添加一个 contenteditable 属性即可，比如：<div class="editable" id="richedit" contenteditable></div></li>
<li>与富文本交互: 与富文本编辑器交互的主要方法是使用 document.execCommand()。这个方法在文档上执行既定的命令，可以实现大多数格式化任务。document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值（如果不需要则为 null）。为跨浏览器兼容，第二个参数应该始终为 false，因为 Firefox 会在其为 true 时抛出错误。不同浏览器支持的命令也不一样。下表列出了最常用的命令。<table>
<thead>
<tr>
<th>命令</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bold</td>
<td>null</td>
<td>设置选中文本为粗体</td>
</tr>
<tr>
<td>italic</td>
<td>null</td>
<td>设置选中文本为斜体</td>
</tr>
<tr>
<td>underline</td>
<td>null</td>
<td>设置选中文本为下划线</td>
</tr>
<tr>
<td>strikethrough</td>
<td>null</td>
<td>设置选中文本为删除线</td>
</tr>
<tr>
<td>subscript</td>
<td>null</td>
<td>设置选中文本为下标</td>
</tr>
<tr>
<td>superscript</td>
<td>null</td>
<td>设置选中文本为上标</td>
</tr>
<tr>
<td>justifyLeft</td>
<td>null</td>
<td>设置选中文本左对齐</td>
</tr>
<tr>
<td>justifyCenter</td>
<td>null</td>
<td>设置选中文本居中对齐</td>
</tr>
<tr>
<td>justifyRight</td>
<td>null</td>
<td>设置选中文本右对齐</td>
</tr>
<tr>
<td>justifyFull</td>
<td>null</td>
<td>设置选中文本两端对齐</td>
</tr>
<tr>
<td>indent</td>
<td>null</td>
<td>向右缩进选中文本</td>
</tr>
<tr>
<td>outdent</td>
<td>null</td>
<td>向左缩进选中文本</td>
</tr>
<tr>
<td>insertOrderedList</td>
<td>null</td>
<td>插入有序列表</td>
</tr>
<tr>
<td>insertUnorderedList</td>
<td>null</td>
<td>插入无序列表</td>
</tr>
<tr>
<td>insertHorizontalRule</td>
<td>null</td>
<td>插入水平线</td>
</tr>
<tr>
<td>createLink</td>
<td>URL</td>
<td>创建超链接</td>
</tr>
<tr>
<td>unlink</td>
<td>null</td>
<td>删除超链接</td>
</tr>
<tr>
<td>insertImage</td>
<td>URL</td>
<td>插入图像</td>
</tr>
<tr>
<td>insertText</td>
<td>文本</td>
<td>插入文本</td>
</tr>
<tr>
<td>insertHTML</td>
<td>HTML</td>
<td>插入 HTML 代码</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>简易富文本编辑器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#editor</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">90%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.toolbar</span> <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>富文本编辑器（基于 designMode）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toolbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;execCmd(&#x27;bold&#x27;)&quot;</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;execCmd(&#x27;italic&#x27;)&quot;</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;execCmd(&#x27;underline&#x27;)&quot;</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;execCmd(&#x27;insertUnorderedList&#x27;)&quot;</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;execCmd(&#x27;createLink&#x27;, prompt(&#x27;请输入链接地址&#x27;))&quot;</span>&gt;</span>插入链接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(getEditorContent())&quot;</span>&gt;</span>获取内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;editor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 激活 designMode</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> editor = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;editor&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    editor.<span class="property">contentDocument</span>.<span class="property">designMode</span> = <span class="string">&quot;on&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 执行命令</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">execCmd</span>(<span class="params">command, value = <span class="literal">null</span></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      editor.<span class="property">contentDocument</span>.<span class="title function_">execCommand</span>(command, <span class="literal">false</span>, value);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取当前编辑器内容</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getEditorContent</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> editor.<span class="property">contentDocument</span>.<span class="property">body</span>.<span class="property">innerHTML</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
还有与命令相关的其他一些方法。第一个方法是 queryCommandEnabled()，此方法用于确定对当前选中文本或光标所在位置是否可以执行相关命令。它只接收一个参数，即要检查的命令名。如果可编辑区可以执行该命令就返回 true，否则返回 false。来看下面的例子：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = frames[<span class="string">&quot;richedit&quot;</span>].<span class="property">document</span>.<span class="title function_">queryCommandEnabled</span>(<span class="string">&quot;bold&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>另一个方法 queryCommandState()用于确定相关命令是否应用到了当前文本选区。例如，要确定当前选区的文本是否为粗体，可以这样：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isBold = frames[<span class="string">&quot;richedit&quot;</span>].<span class="property">document</span>.<span class="title function_">queryCommandState</span>(<span class="string">&quot;bold&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>最后一个方法是 queryCommandValue()，此方法可以返回执行命令时使用的值</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fontSize = frames[<span class="string">&quot;richedit&quot;</span>].<span class="property">document</span>.<span class="title function_">queryCommandValue</span>(<span class="string">&quot;fontsize&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>4、富文件选择: 在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。这个方法暴露在document 和 window 对象上，返回表示当前选中文本的 Selection 对象。每个 Selection 对象都拥有以下属性</p>
<ul>
<li>anchorNode: 选区的起始节点。</li>
<li>anchorOffset: 选区的起始偏移量。</li>
<li>focusNode: 选区的结束节点。</li>
<li>focusOffset: 选区的结束偏移量。</li>
<li>isCollapsed: 如果选区没有选中任何内容，则为 true。</li>
<li>rangeCount: 选区包含的 Range 对象数量。</li>
<li>type: 选区的类型，可能的值有”None”、”Caret”和”Range”。</li>
<li>toString(): 返回选区的文本内容。</li>
<li>getRangeAt(index): 返回选区中指定索引的 Range 对象。</li>
<li>removeAllRanges(): 清除选区中的所有 Range 对象。</li>
<li>addRange(range): 将指定的 Range 对象添加到选区中。</li>
<li>collapse(node, offset): 将选区折叠到指定的节点和偏移量。</li>
<li>extend(node, offset): 扩展选区到指定的节点和偏移量。</li>
<li>selectAllChildren(node): 选中指定节点的所有子节点。</li>
<li>deleteFromDocument(): 从文档中删除选区的内容。</li>
<li>containsNode(node, allowPartial): 检查选区是否包含指定的节点。</li>
<li>getClientRects(): 返回选区的所有矩形区域。</li>
<li>getRangeAt(index): 返回选区中指定索引的 Range 对象。</li>
<li>isCollapsed: 如果选区没有选中任何内容，则为 true。</li>
<li>rangeCount: 选区包含的 Range 对象数量。</li>
<li>type: 选区的类型，可能的值有”None”、”Caret”和”Range”。</li>
<li>toString(): 返回选区的文本内容。<br>Selection 对象的这个方法极其强大，充分利用了 DOM 范围来管理选区。操纵 DOM 范围可以实现比 execCommand()更细粒度的控制，因为可以直接对选中文本的 DOM 内容进行操作。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selection = frames[<span class="string">&quot;richedit&quot;</span>].<span class="title function_">getSelection</span>(); </span><br><span class="line"><span class="comment">// 取得选中的文本</span></span><br><span class="line"><span class="keyword">let</span> selectedText = selection.<span class="title function_">toString</span>(); </span><br><span class="line"><span class="comment">// 取得表示选区的范围</span></span><br><span class="line"><span class="keyword">let</span> range = selection.<span class="title function_">getRangeAt</span>(<span class="number">0</span>); </span><br><span class="line"><span class="comment">// 高亮选中的文本</span></span><br><span class="line"><span class="keyword">let</span> span = frames[<span class="string">&quot;richedit&quot;</span>].<span class="property">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>); </span><br><span class="line">span.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;yellow&quot;</span>; </span><br><span class="line">range.<span class="title function_">surroundContents</span>(span);</span><br></pre></td></tr></table></figure></div>
5、通过表单提交富文本: 因为富文本编辑是在内嵌窗格中或通过为元素指定 contenteditable 属性实现的，而不是在表单控件中实现，所以富文本编辑器技术上与表单没有关系。这意味着要把富文本编辑的结果提交给服务器，必须手工提取 HTML 并自己提交。通常的解决方案是在表单中添加一个隐藏字段，使用内嵌窗格或contenteditable 元素的 HTML 更新它的值。在表单提交之前，从内嵌窗格或 contenteditable 元素中提取出 HTML 并插入隐藏字段中。例如，以下代码在使用内嵌窗格实现富文本编辑时，可以用在表单的 onsubmit 事件处理程序中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> target = event.<span class="property">target</span>; </span><br><span class="line"> target.<span class="property">elements</span>[<span class="string">&quot;comments&quot;</span>].<span class="property">value</span> = </span><br><span class="line"> frames[<span class="string">&quot;richedit&quot;</span>].<span class="property">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-03 日报 Day145</title>
    <url>/undefined/2025-04-03/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>往后岁月，愿你摆正自己，见天地之大、众生之广，行稳致远，活出精彩人生。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P591-596 第十九章：表单脚本</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、表单基础: Web 表单在 HTML 中以<form>元素表示，在 JavaScript 中则以 HTMLFormElement 类型表示。HTMLFormElement 类型继承自 HTMLElement 类型，因此拥有与其他 HTML 元素一样的默认属性。不过，HTMLFormElement 也有自己的属性和方法。<br> acceptCharset：服务器可以接收的字符集，等价于 HTML 的 accept-charset 属性。<br> action：请求的 URL，等价于 HTML 的 action 属性。<br> elements：表单中所有控件的 HTMLCollection。<br> enctype：请求的编码类型，等价于 HTML 的 enctype 属性。<br> length：表单中控件的数量。<br> method：HTTP 请求的方法类型，通常是”get”或”post”，等价于 HTML 的 method 属性。<br> name：表单的名字，等价于 HTML 的 name 属性。<br> reset()：把表单字段重置为各自的默认值。<br> submit()：提交表单。<br> target：用于发送请求和接收响应的窗口的名字，等价于 HTML 的 target 属性。</p>
<ul>
<li>提交表单: 表单是通过用户点击提交按钮或图片按钮的方式提交的。提交按钮可以使用 type 属性为”submit”的<input>或<button>元素来定义，图片按钮可以使用 type 属性为”image”的<input>元素来定义。点击下面例子中定义的所有按钮都可以提交它们所在的表单：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit Form&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 图片按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;graphic.gif&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>以这种方式提交表单会在向服务器发送请求之前触发 submit 事件。这样就提供了一个验证表单数据的机会，可以根据验证结果决定是否真的要提交。阻止这个事件的默认行为可以取消提交表单。例如，下面的代码会阻止表单提交：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 阻止表单提交</span></span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>调用 preventDefault()方法可以阻止表单提交。通常，在表单数据无效以及不应该发送到服务器时可以这样处理。<br>当然，也可以通过编程方式在 JavaScript 中调用 submit()方法来提交表单。可以在任何时候调用这个方法来提交表单，而且表单中不存在提交按钮也不影响表单提交。下面是一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="comment">// 提交表单</span></span><br><span class="line">form.<span class="title function_">submit</span>();</span><br></pre></td></tr></table></figure></div>

<p>通过 submit()提交表单时，submit 事件不会触发。因此在调用这个方法前要先做数据验证。<br>表单提交的一个最大的问题是可能会提交两次表单。如果提交表单之后没有什么反应，那么没有耐心的用户可能会多次点击提交按钮。结果是很烦人的（因为服务器要处理重复的请求），甚至可能造成损失（如果用户正在购物，则可能会多次下单）。解决这个问题主要有两种方式：在表单提交后禁用提交按钮，或者通过 onsubmit 事件处理程序取消之后的表单提交。</p>
<ul>
<li>重置表单: 用户单击重置按钮可以重置表单。重置按钮可以使用 type 属性为”reset”的<input>或<button>元素来创建，比如：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用重置按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Reset Form&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自定义重置按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>Reset Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这两种按钮都可以重置表单。表单重置后，所有表单字段都会重置回页面第一次渲染时各自拥有的值。如果字段原来是空的，就会变成空的；如果字段有默认值，则恢复为默认值。<br>用户单击重置按钮重置表单会触发 reset 事件。这个事件为取消重置提供了机会。例如，以下代码演示了如何阻止重置表单：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;reset&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>与表单提交一样，重置表单也可以通过 JavaScript 调用 reset()方法来完成，如下面的例子所示</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="comment">// 重置表单</span></span><br><span class="line">form.<span class="title function_">reset</span>();</span><br></pre></td></tr></table></figure></div>

<p>与 submit()方法的功能不同，调用 reset()方法会像单击了重置按钮一样触发 reset 事件。</p>
<ul>
<li>表单字段: 表单元素可以像页面中的其他元素一样使用原生 DOM 方法来访问。此外，所有表单元素都是表单 elements 属性（元素集合）中包含的一个值。这个 elements 集合是一个有序列表，包含对表单中所有字段的引用，包括所有<input>、<textarea>、<button>、<select>和<fieldset>元素。elements 集合中的每个字段都以它们在 HTML 标记中出现的次序保存，可以通过索引位置和 name 属性来访问。以下是几个例子：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;form1&quot;</span>);</span><br><span class="line"><span class="comment">// 取得表单中的第一个字段</span></span><br><span class="line"><span class="keyword">let</span> field1 = form.<span class="property">elements</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 取得表单中名为&quot;textbox1&quot;的字段</span></span><br><span class="line"><span class="keyword">let</span> field2 = form.<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line"><span class="comment">// 取得字段的数量</span></span><br><span class="line"><span class="keyword">let</span> fieldCount = form.<span class="property">elements</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果多个表单控件使用了同一个 name，比如像单选按钮那样，则会返回包含所有同名元素的 HTMLCollection。比如，来看下面的 HTML 代码片段：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span> /&gt;</span>Red<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span> /&gt;</span>Green<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span>Blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这个 HTML 中的表单有 3 个单选按钮的 name 是”color”，这个名字把它们联系在了一起。在访问 elements[“color”]时，返回的 NodeList 就包含这 3 个元素。而在访问 elements[0]时，只会返回第一个元素。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> colorFields = form.<span class="property">elements</span>[<span class="string">&quot;color&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorFields.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> firstColorField = colorFields[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> firstFormField = form.<span class="property">elements</span>[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColorField === firstFormField); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>表单字段的公共属性: 除<fieldset>元素以外，所有表单字段都有一组同样的属性。由于<input>类型可以表示多种表单字段，因此某些属性只适用于特定类型的字段。除此之外的属性可以在任何表单字段上使用。以下列出了这些表单字段的公共属性和方法。<br> disabled：布尔值，表示表单字段是否禁用。<br> form：指针，指向表单字段所属的表单。这个属性是只读的。<br> name：字符串，这个字段的名字。<br> readOnly：布尔值，表示这个字段是否只读。<br> tabIndex：数值，表示这个字段在按 Tab 键时的切换顺序。<br> type：字符串，表示字段类型，如”checkbox”、”radio”等。<br> value：要提交给服务器的字段值。对文件输入字段来说，这个属性是只读的，仅包含计算机上某个文件的路径。<br>2、文本框编程: HTML 中有两种表示文本框的方式：单行使用<input>元素，多行使用<textarea>元素。<br>默认情况下，<input>元素显示为文本框，省略 type 属性会以”text”作为默认值。然后可以通过 size 属性指定文本框的宽度，这个宽度是以字符数来计量的。而 value 属性用于指定文本框的初始值，maxLength 属性用于指定文本框允许的最多字符数。因此要创建一个一次可显示 25 个字符，但最多允许显示 50 个字符的文本框，可以这样写：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">size</span>=<span class="string">&quot;25&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;50&quot;</span> <span class="attr">value</span>=<span class="string">&quot;initial value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<textarea>元素总是会创建多行文本框。可以使用 rows 属性指定这个文本框的高度，以字符数计量；以 cols 属性指定以字符数计量的文本框宽度，类似于<input>元素的 size 属性。与<input>不同的是，<textarea>的初始值必须包含在<textarea>和</textarea>之间，如下所示：

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;25&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;5&quot;</span>&gt;</span>initial value<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>选择文本: 两种文本框都支持一个名为 select()的方法，此方法用于全部选中文本框中的文本。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line">textbox.<span class="title function_">select</span>();</span><br><span class="line"></span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;focus&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="property">target</span>.<span class="title function_">select</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>1、Select 事件: 当选中文本框中的文本时，会触发 select 事件。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="property">elements</span>[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line">textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;select&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Text selected: &quot;</span> + event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>2、取得选中文本: 虽然 select 事件能够表明有文本被选中，但不能提供选中了哪些文本的信息。HTML5 对此进行了扩展，以方便更好地获取选中的文本。扩展为文本框添加了两个属性：selectionStart 和 selectionEnd。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSelectedText</span>(<span class="params">textbox</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> textbox.<span class="property">value</span>.<span class="title function_">substring</span>(textbox.<span class="property">selectionStart</span>, textbox.<span class="property">selectionEnd</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>3、部分选中文本: setSelectionRange()方法也可以在所有文本框中使用。这个方法接收两个参数：要选择的第一个字符的索引和停止选择的字符的索引（与字符串的 substring()方法一样）。下面是几个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">textbox.<span class="property">value</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="comment">// 选择所有文本</span></span><br><span class="line">textbox.<span class="title function_">setSelectionRange</span>(<span class="number">0</span>, textbox.<span class="property">value</span>.<span class="property">length</span>); <span class="comment">// &quot;Hello world!&quot;</span></span><br><span class="line"><span class="comment">// 选择前 3 个字符</span></span><br><span class="line">textbox.<span class="title function_">setSelectionRange</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// &quot;Hel&quot;</span></span><br><span class="line"><span class="comment">// 选择第 4~6 个字符</span></span><br><span class="line">textbox.<span class="title function_">setSelectionRange</span>(<span class="number">4</span>, <span class="number">7</span>); <span class="comment">// &quot;o w&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>4、自动切换: JavaScript 可以通过很多方式来增强表单字段的易用性。最常用的是在当前字段完成时自动切换到下一个字段。对于要收集数据的长度已知（比如电话号码）的字段是可以这样处理的。在美国，电话号码通常分为 3 个部分：区号、交换局号，外加 4 位数字。在网页中，可以通过 3 个文本框来表示这几个部分，比如：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtTel1&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtTel2&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel3&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtTel3&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>为增加这个表单的易用性并加速数据输入，可以在每个文本框输入到最大允许字符数时自动把焦点切换到下一个文本框。因此，当用户在第一个文本框中输入 3 个字符后，就把焦点移到第二个文本框，当用户在第二个文本框中输入 3 个字符后，把焦点再移到第三个文本框。这种自动切换文本框的行为可以通过如下代码实现：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">tabForward</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> target = event.<span class="property">target</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (target.<span class="property">value</span>.<span class="property">length</span> == target.<span class="property">maxLength</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> form = target.<span class="property">form</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = form.<span class="property">elements</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (form.<span class="property">elements</span>[i] == target) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (form.<span class="property">elements</span>[i + <span class="number">1</span>]) &#123;</span></span><br><span class="line"><span class="language-javascript">            form.<span class="property">elements</span>[i + <span class="number">1</span>].<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> inputIds = [<span class="string">&quot;txtTel1&quot;</span>, <span class="string">&quot;txtTel2&quot;</span>, <span class="string">&quot;txtTel3&quot;</span>];</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">of</span> inputIds) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span></span><br><span class="line"><span class="language-javascript">    textbox.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, tabForward);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> textbox1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txtTel1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> textbox2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txtTel2&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> textbox3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txtTel3&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>5、HTML5为浏览器新增了在提交表单前验证数据的能力。这些能力实现了基本的验证，即使JavaScript不可用或加载失败也没关系。</p>
<ul>
<li>必填字段: 第一个条件是给表单字段添加 required 属性，如下所示：<input type="text" name="username" required> 
任何带有 required 属性的字段都必须有值，否则无法提交表单。</li>
<li>更多输入类型: HTML5 为<input>元素增加了几个新的 type 值。这些类型属性不仅表明了字段期待的数据类型，而且也提供了一些默认验证，其中两个新的输入类型是已经得到广泛支持的”email”和”url”，二者都有浏览器提供的自定义验证。比如：<input type="email" name="email"> 
<input type="url" name="homepage">
"email"类型确保输入的文本匹配电子邮件地址，而"url"类型确保输入的文本匹配 URL。</li>
<li>数值范围: 除了”email”和”url”，HTML5 还定义了其他几种新的输入元素类型，它们都是期待某种数值输入的，包括：”number”、”range”、”datetime”、”datetime-local”、”date”、”month”、”week”和”time”。<br>对上述每种数值类型，都可以指定 min 属性（最小可能值）、max 属性（最大可能值），以及 step属性（从 min 到 max 的步长值）。例如，如果只允许输入 0 到 100 中 5 的倍数，那么可以这样写：<input type="number" min="0" max="100" step="5" name="count"></li>
<li>输入模式: HTML5 为文本字段新增了 pattern 属性。这个属性用于指定一个正则表达式，用户输入的文本必须与之匹配。例如，要限制只能在文本字段中输入数字，可以这样添加模式：<input type="text" pattern="\d+" name="count">
注意模式的开头和末尾分别假设有^和$。这意味着输入内容必须从头到尾都严格与模式匹配。</li>
<li>检测有效性: 使用 checkValidity()方法可以检测表单中任意给定字段是否有效。这个方法在所有表单元素上都可以使用，如果字段值有效就会返回 true，否则返回 false。</li>
<li>禁用验证: 通过指定 novalidate 属性可以禁止对表单进行任何验证：<form method="post" action="/signup" novalidate> 
 <!-- 表单元素 --> 
</form>
这个值也可以通过 JavaScript 属性 noValidate 检索或设置，设置为 true 表示属性存在，设置为false 表示属性不存在：
document.forms[0].noValidate = true; // 关闭验证</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-06 日报 Day148</title>
    <url>/undefined/2025-04-06/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>少欲则心静，心静则事简，只有这样方能够挣脱繁华虚妄的羁绊，拥抱明确而简单的生活。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P616-626 第二十章：JavaScript API</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、 跨上下文消息: 跨文档消息，有时候也简称为 XDM（cross-document messaging），是一种在不同执行上下文（如不同工作线程或不同源的页面）间传递信息的能力。<br>注意 跨上下文消息用于窗口之间通信或工作线程之间通信。本节主要介绍使用postMessage()与其他窗口通信 。关于工作线程之间通信、MessageChannel 和BroadcastChannel，可以参考第 27 章。<br>postMessage()方法接收 3 个参数：消息、表示目标接收源的字符串和可选的可传输对象的数组（只与工作线程相关）。第二个参数对于安全非常重要，其可以限制浏览器交付数据的目标。下面来看一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iframeWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myframe&quot;</span>).<span class="property">contentWindow</span>; </span><br><span class="line">iframeWindow.<span class="title function_">postMessage</span>(<span class="string">&quot;A secret&quot;</span>, <span class="string">&quot;http://www.wrox.com&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>接收到 XDM 消息后，window 对象上会触发 message 事件。这个事件是异步触发的，因此从消息发出到接收到消息（接收窗口触发 message 事件）可能有延迟。传给 onmessage 事件处理程序的 event对象包含以下 3 方面重要信息。<br> data：作为第一个参数传递给 postMessage()的字符串数据。<br> origin：发送消息的文档源，例如”<a class="link"   href="http://www.wrox.com" ./">http://www.wrox.com&quot;。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br> source：发送消息的文档中 window 对象的代理。这个代理对象主要用于在发送上一条消息的窗口中执行 postMessage()方法。如果发送窗口有相同的源，那么这个对象应该就是 window对象。<br>接收消息之后验证发送窗口的源是非常重要的。与 postMessage()的第二个参数可以保证数据不会意外传给未知页面一样，在 onmessage 事件处理程序中检查发送窗口的源可以保证数据来自正确的地方。基本的使用方式如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// 确保来自预期发送者</span></span><br><span class="line"> <span class="keyword">if</span> (event.<span class="property">origin</span> == <span class="string">&quot;http://www.wrox.com&quot;</span>) &#123; </span><br><span class="line"> <span class="comment">// 对数据进行一些处理</span></span><br><span class="line"> <span class="title function_">processMessage</span>(event.<span class="property">data</span>); </span><br><span class="line"> <span class="comment">// 可选：向来源窗口发送一条消息</span></span><br><span class="line"> event.<span class="property">source</span>.<span class="title function_">postMessage</span>(<span class="string">&quot;Received!&quot;</span>, <span class="string">&quot;http://p2p.wrox.com&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>大多数情况下，event.source 是某个 window 对象的代理，而非实际的 window 对象。因此不能通过它访问所有窗口下的信息。最好只使用 postMessage()，这个方法永远存在而且可以调用。<br>XDM 有一些怪异之处。首先，postMessage()的第一个参数的最初实现始终是一个字符串。后来，第一个参数改为允许任何结构的数据传入，不过并非所有浏览器都实现了这个改变。为此，最好就是只通 过 postMessage() 发送字符串。如果需要传递结构化数据，那么最好先对该数据调用JSON.stringify()，通过 postMessage()传过去之后，再在 onmessage 事件处理程序中调用JSON.parse()。<br>在通过内嵌窗格加载不同域时，使用 XDM 是非常方便的。这种方法在混搭（mashup）和社交应用中非常常用。通过使用 XDM 与内嵌窗格中的网页通信，可以保证包含页面的安全。XDM 也可以用于同源页面之间通信。<br>2、Encoding API: Encoding API 主要用于实现字符串与定型数组之间的转换。规范新增了 4 个用于执行转换的全局类：TextEncoder、TextEncoderStream、TextDecoder 和 TextDecoderStream。<br>注意 相比于批量（bulk）的编解码，对流（stream）编解码的支持很有限。<br>3、文本编码: Encoding API 提供了两种将字符串转换为定型数组二进制格式的方法：批量编码和流编码。把字符串转换为定型数组时，编码器始终使用 UTF-8。</p>
<ul>
<li>批量编码: 所谓批量，指的是 JavaScript 引擎会同步编码整个字符串。对于非常长的字符串，可能会花较长时间。批量编码是通过 TextEncoder 的实例完成的：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br></pre></td></tr></table></figure></div>
这个实例上有一个 encode()方法，该方法接收一个字符串参数，并以 Uint8Array 格式返回每个字符的 UTF-8 编码：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>(); </span><br><span class="line"><span class="keyword">const</span> decodedText = <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> encodedText = textEncoder.<span class="title function_">encode</span>(decodedText);</span><br><span class="line"><span class="comment">// f 的 UTF-8 编码是 0x66（即十进制 102）</span></span><br><span class="line"><span class="comment">// o 的 UTF-8 编码是 0x6F（即二进制 111）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedText); <span class="comment">// Uint8Array(3) [102, 111, 111]</span></span><br></pre></td></tr></table></figure></div>
编码器是用于处理字符的，有些字符（如表情符号）在最终返回的数组中可能会占多个索引：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>(); </span><br><span class="line"><span class="keyword">const</span> decodedText = <span class="string">&#x27;☺&#x27;</span>; </span><br><span class="line"><span class="keyword">const</span> encodedText = textEncoder.<span class="title function_">encode</span>(decodedText); </span><br><span class="line"><span class="comment">// ☺的 UTF-8 编码是 0xF0 0x9F 0x98 0x8A（即十进制 240、159、152、138）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encodedText); <span class="comment">// Uint8Array(4) [240, 159, 152, 138]</span></span><br></pre></td></tr></table></figure></div></li>
<li>流编码: TextEncoderStream 其实就是 TransformStream 形式的 TextEncoder。将解码后的文本流通过管道输入流编码器会得到编码后文本块的流：<br>4、文本解码: Encoding API 提供了两种将定型数组转换为字符串的方式：批量解码和流解码。与编码器类不同，在将定型数组转换为字符串时，解码器支持非常多的字符串编码，可以参考 Encoding Standard 规范的“Names and labels”一节。<br>默认字符编码格式是 UTF-8。</li>
<li>批量解码: 批量，指的是 JavaScript 引擎会同步解码整个字符串。对于非常长的字符串，可能会花较长时间。批量解码是通过 TextDecoder 的实例完成的：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textDecoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>();</span><br></pre></td></tr></table></figure></div>
这个实例上有一个 decode()方法，该方法接收一个定型数组参数，返回解码后的字符串：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textDecoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>(); </span><br><span class="line"><span class="comment">// f 的 UTF-8 编码是 0x66（即十进制 102）</span></span><br><span class="line"><span class="comment">// o 的 UTF-8 编码是 0x6F（即二进制 111）</span></span><br><span class="line"><span class="keyword">const</span> encodedText = <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">102</span>, <span class="number">111</span>, <span class="number">111</span>); </span><br><span class="line"><span class="keyword">const</span> decodedText = textDecoder.<span class="title function_">decode</span>(encodedText);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(decodedText); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure></div></li>
<li>流解码: TextDecoderStream 其实就是 TransformStream 形式的 TextDecoder。将编码后的文本流通过管道输入流解码器会得到解码后文本块的流<br>5、File API与Blob API: Web 应用程序的一个主要的痛点是无法操作用户计算机上的文件。File API 与 Blob API 是为了让 Web 开发者能以安全的方式访问客户端机器上的文件，从而更好地与这些文件交互而设计的。</li>
<li>File 类型: File API 仍然以表单中的文件输入字段为基础，但是增加了直接访问文件信息的能力。HTML5 在DOM 上为文件输入元素添加了 files 集合。当用户在文件字段中选择一个或多个文件时，这个 files集合中会包含一组 File 对象，表示被选中的文件。每个 File 对象都有一些只读属性。<br> name：本地系统中的文件名。<br> size：以字节计的文件大小。<br> type：包含文件 MIME 类型的字符串。<br> lastModifiedDate：表示文件最后修改时间的字符串。这个属性只有 Chome 实现了。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;files-list&quot;</span>); </span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> files = event.<span class="property">target</span>.<span class="property">files</span>, </span><br><span class="line"> i = <span class="number">0</span>, </span><br><span class="line"> len = files.<span class="property">length</span>; </span><br><span class="line"> <span class="keyword">while</span> (i &lt; len) &#123; </span><br><span class="line"> <span class="keyword">const</span> f = files[i]; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;f.name&#125;</span> (<span class="subst">$&#123;f.type&#125;</span>, <span class="subst">$&#123;f.size&#125;</span> bytes)`</span>); </span><br><span class="line"> i++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></li>
<li>FileReader类型: FileReader类型表示一种异步文件读取机制。可以把FileReader 想象成类似于XMLHttpRequest，只不过是用于从文件系统读取文件，而不是从服务器读取数据。FileReader 类型提供了几个读取文件数据的方法。<br> readAsText(file, encoding)：从文件中读取纯文本内容并保存在 result 属性中。第二个参数表示编码，是可选的。<br> readAsDataURL(file)：读取文件并将内容的数据 URI 保存在 result 属性中。<br> readAsBinaryString(file)：读取文件并将每个字符的二进制数据保存在 result 属性中。<br> readAsArrayBuffer(file)：读取文件并将文件内容以 ArrayBuffer 形式保存在 result 属性。</li>
<li>FileReaderSync类型: FileReaderSync 类型就是 FileReader 的同步版本。这个类型拥有与 FileReader相同的方法，只有在整个文件都加载到内存之后才会继续执行。FileReaderSync 只在工作线程中可用，因为如果读取整个文件耗时太长则会影响全局。<br>假设通过 postMessage()向工作线程发送了一个 File 对象。以下代码会让工作线程同步将文件读取到内存中，然后将文件的数据 URL 发回来：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// worker.js </span></span><br><span class="line">self.<span class="property">omessage</span> = <span class="function">(<span class="params">messageEvent</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">const</span> syncReader = <span class="keyword">new</span> <span class="title class_">FileReaderSync</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(syncReader); <span class="comment">// FileReaderSync &#123;&#125; </span></span><br><span class="line"> <span class="comment">// 读取文件时阻塞工作线程</span></span><br><span class="line"> <span class="keyword">const</span> result = syncReader.<span class="title function_">readAsDataUrl</span>(messageEvent.<span class="property">data</span>);</span><br><span class="line"> <span class="comment">// PDF 文件的示例响应</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// data:application/pdf;base64,JVBERi0xLjQK... </span></span><br><span class="line"> <span class="comment">// 把 URL 发回去</span></span><br><span class="line"> self.<span class="title function_">postMessage</span>(result); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>Blob与部分读取: File 对象提供了一个名为 slice()的方法。slice()方法接收两个参数：起始字节和要读取的字节数。这个方法返回一个 Blob 的实例，而 Blob 实际上是 File 的超类。blob 表示二进制大对象（binary larget object），是 JavaScript 对不可修改二进制数据的封装类型。包含字符串的数组、ArrayBuffers、ArrayBufferViews，甚至其他 Blob 都可以用来创建 blob。Blob构造函数可以接收一个 options 参数，并在其中指定 MIME 类型：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;foo&#x27;</span>])); </span><br><span class="line"><span class="comment">// Blob &#123;size: 3, type: &quot;&quot;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;&#123;&quot;a&quot;: &quot;b&quot;&#125;&#x27;</span>], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;)); </span><br><span class="line"><span class="comment">// &#123;size: 10, type: &quot;application/json&quot;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;&lt;p&gt;Foo&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;&lt;p&gt;Bar&lt;/p&gt;&#x27;</span>], &#123; <span class="attr">type</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;)); </span><br><span class="line"><span class="comment">// &#123;size: 20, type: &quot;text/html&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>Blob 对象有一个 size 属性和一个 type 属性，还有一个 slice()方法用于进一步切分数据。另外也可以使用 FileReader 从 Blob 中读取数据。下面的例子只会读取文件的前 32 字节：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;files-list&quot;</span>); </span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> info = <span class="string">&quot;&quot;</span>, </span><br><span class="line"> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>), </span><br><span class="line"> progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;progress&quot;</span>), </span><br><span class="line"> files = event.<span class="property">target</span>.<span class="property">files</span>, </span><br><span class="line"> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(), </span><br><span class="line"> blob = <span class="title function_">blobSlice</span>(files[<span class="number">0</span>], <span class="number">0</span>, <span class="number">32</span>); </span><br><span class="line"> <span class="keyword">if</span> (blob) &#123; </span><br><span class="line"> reader.<span class="title function_">readAsText</span>(blob); </span><br><span class="line"> reader.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">&quot;Could not read file, error code is &quot;</span> + </span><br><span class="line"> reader.<span class="property">error</span>.<span class="property">code</span>; </span><br><span class="line"> &#125;; </span><br><span class="line"> reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> output.<span class="property">innerHTML</span> = reader.<span class="property">result</span>; </span><br><span class="line"> &#125;; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Your browser doesn&#x27;t support slice().&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<ul>
<li>对象URL与Blob: 对象 URL 有时候也称作 Blob URL，是指引用存储在 File 或 Blob 中数据的 URL。对象 URL 的优点是不用把文件内容读取到 JavaScript 也可以使用文件。只要在适当位置提供对象 URL 即可。要创建对象 URL，可以使用 window.URL.createObjectURL()方法并传入 File 或 Blob 对象。这个函数返回的值是一个指向内存中地址的字符串。因为这个字符串是 URL，所以可以在 DOM 中直接使用。例如，以下代码使用对象 URL 在页面中显示了一张图片：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filesList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;files-list&quot;</span>); </span><br><span class="line">filesList.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">let</span> info = <span class="string">&quot;&quot;</span>, </span><br><span class="line"> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>), </span><br><span class="line"> progress = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;progress&quot;</span>), </span><br><span class="line"> files = event.<span class="property">target</span>.<span class="property">files</span>, </span><br><span class="line"> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(), </span><br><span class="line"> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(files[<span class="number">0</span>]); </span><br><span class="line"> <span class="keyword">if</span> (url) &#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="regexp">/image/</span>.<span class="title function_">test</span>(files[<span class="number">0</span>].<span class="property">type</span>)) &#123; </span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;url&#125;</span>&quot;&gt;`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">&quot;Not an image.&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> output.<span class="property">innerHTML</span> = <span class="string">&quot;Your browser doesn&#x27;t support object URLs.&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
使用完数据之后，最好能释放与之关联的内存。只要对象 URL 在使用中，就不能释放内存。如果想表明不再使用某个对象 URL，则可以把它传给 window.URL.revokeObjectURL()。页面卸载时，所有对象 URL 占用的内存都会被释放。不过，最好在不使用时就立即释放内存，以便尽可能保持页面占用最少资源。</li>
<li>读取拖放文件: 组合使用 HTML5 拖放 API 与 File API 可以创建读取文件信息的有趣功能。在页面上创建放置目标后，可以从桌面上把文件拖动并放到放置目标。这样会像拖放图片或链接一样触发 drop 事件。被放置的文件可以通过事件的 event.dataTransfer.files 属性读到，这个属性保存着一组 File 对象，就像文本输入字段一样。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-08 日报 Day150</title>
    <url>/undefined/2025-04-08/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>现在的你，是十年前你的决定，十年后的你，是现在的你的决定。种一棵树，最好是十年前，其次是现在。想要改变，从此刻开始，一切还不晚。星光不问赶路人，时光不负有心人，愿十年后的今天不为虚度年华而悔恨，所得皆所愿。我们各自努力，顶峰相见。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P636-650 第二十章：JavaScript API</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、 Page Visibility API: Web 开发中一个常见的问题是开发者不知道用户什么时候真正在使用页面。如果页面被最小化或隐藏在其他标签页后面，那么轮询服务器或更新动画等功能可能就没有必要了。Page Visibility API 旨在为开发者提供页面对用户是否可见的信息。<br>这个 API 本身非常简单，由 3 部分构成。<br> document.visibilityState 值，表示下面 4 种状态之一。<br> 页面在后台标签页或浏览器中最小化了。<br> 页面在前台标签页中。<br> 实际页面隐藏了，但对页面的预览是可见的（例如在 Windows 7 上，用户鼠标移到任务栏图标上会显示网页预览）。<br> 页面在屏外预渲染。<br> visibilitychange 事件，该事件会在文档从隐藏变可见（或反之）时触发。<br> document.hidden 布尔值，表示页面是否隐藏。这可能意味着页面在后台标签页或浏览器中被最小化了。这个值是为了向后兼容才继续被浏览器支持的，应该优先使用 document.visibilityState检测页面可见性。<br>要想在页面从可见变为隐藏或从隐藏变为可见时得到通知，需要监听 visibilitychange 事件。<br>document.visibilityState 的值是以下三个字符串之一：<br> “hidden”<br> “visible”<br> “prerender”<br>2、Streams API: Streams API 是为了解决一个简单但又基础的问题而生的：Web 应用如何消费有序的小信息块而不是大块信息？这种能力主要有两种应用场景。<br> 大块数据可能不会一次性都可用。网络请求的响应就是一个典型的例子。网络负载是以连续信息包形式交付的，而流式处理可以让应用在数据一到达就能使用，而不必等到所有数据都加载完毕。<br> 大块数据可能需要分小部分处理。视频处理、数据压缩、图像编码和 JSON 解析都是可以分成小部分进行处理，而不必等到所有数据都在内存中时再处理的例子。</p>
<ul>
<li>理解流: 提到流，可以把数据想像成某种通过管道输送的液体。JavaScript 中的流借用了管道相关的概念，因为原理是相通的。根据规范，“这些 API 实际是为映射低级 I&#x2F;O 原语而设计，包括适当时候对字节流的规范化”。Stream API 直接解决的问题是处理网络请求和读写磁盘。<br>Stream API 定义了三种流。<br> 可读流：可以通过某个公共接口读取数据块的流。数据在内部从底层源进入流，然后由消费者（consumer）进行处理。<br> 可写流：可以通过某个公共接口写入数据块的流。生产者（producer）将数据写入流，数据在内部传入底层数据槽（sink）。<br> 转换流：由两种流组成，可写流用于接收数据（可写端），可读流用于输出数据（可读端）。这两个流之间是转换程序（transformer），可以根据需要检查和修改流内容。<br>块、内部队列和反压:<br>流的基本单位是块（chunk）。块可是任意数据类型，但通常是定型数组。<br>前面提到的各种类型的流都有入口和出口的概念。有时候，由于数据进出速率不同，可能会出现不匹配的情况。为此流平衡可能出现如下三种情形。<br> 流出口处理数据的速度比入口提供数据的速度快。流出口经常空闲（可能意味着流入口效率较低），但只会浪费一点内存或计算资源，因此这种流的不平衡是可以接受的。<br> 流入和流出均衡。这是理想状态。<br> 流入口提供数据的速度比出口处理数据的速度快。这种流不平衡是固有的问题。此时一定会在某个地方出现数据积压，流必须相应做出处理。<br>流不平衡是常见问题，但流也提供了解决这个问题的工具。所有流都会为已进入流但尚未离开流的块提供一个内部队列。对于均衡流，这个内部队列中会有零个或少量排队的块，因为流出口块出列的速度与流入口块入列的速度近似相等。这种流的内部队列所占用的内存相对比较小。<br>如果块入列速度快于出列速度，则内部队列会不断增大。流不能允许其内部队列无限增大，因此它使用反压（backpressure）通知流入口停止发送数据，直到队列大小降到某个既定的阈值之下。这个阈值由排列策略决定，这个策略定义了内部队列可以占用的最大内存，即高水位线（high water mark）。</li>
<li>可读流: 可读流是对底层数据源的封装。底层数据源可以将数据填充到流中，允许消费者通过流的公共接口读取数据。</li>
</ul>
<ol>
<li>ReadableStreamDefaultController<br>来看下面的生成器，它每 1000 毫秒就会生成一个递增的整数：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="comment">// 每 1000 毫秒生成一个递增的整数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
这个生成器的值可以通过可读流的控制器传入可读流。访问这个控制器最简单的方式就是创建ReadableStream 的一个实例，并在这个构造函数的 underlyingSource 参数（第一个参数）中定义start()方法，然后在这个方法中使用作为参数传入的 controller。默认情况下，这个控制器参数是ReadableStreamDefaultController 的一个实例：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readableStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line"> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(controller); <span class="comment">// ReadableStreamDefaultController &#123;&#125; </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></div>
调用控制器的 enqueue()方法可以把值传入控制器。所有值都传完之后，调用 close()关闭流：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="comment">// 每 1000 毫秒生成一个递增的整数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> readableStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line"> controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line"> &#125; </span><br><span class="line"> controller.<span class="title function_">close</span>(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
2、ReadableStreamDefaultReader: 前面的例子把 5 个值加入了流的队列，但没有把它们从队列中读出来。为此，需要一个ReadableStreamDefaultReader 的实例，该实例可以通过流的 getReader()方法获取。调用这个方法会获得流的锁，保证只有这个读取器可以从流中读取值：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="comment">// 每 1000 毫秒生成一个递增的整数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">const</span> readableStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line"> controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line"> &#125; </span><br><span class="line"> controller.<span class="title function_">close</span>(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readableStream.<span class="property">locked</span>); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">const</span> readableStreamDefaultReader = readableStream.<span class="title function_">getReader</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readableStream.<span class="property">locked</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
消费者使用这个读取器实例的 read()方法可以读出值：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">ints</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="comment">// 每 1000 毫秒生成一个递增的整数</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, i)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> readableStream = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>(&#123; </span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">start</span>(<span class="params">controller</span>) &#123; </span><br><span class="line"> <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> <span class="title function_">ints</span>()) &#123; </span><br><span class="line"> controller.<span class="title function_">enqueue</span>(chunk); </span><br><span class="line"> &#125; </span><br><span class="line"> controller.<span class="title function_">close</span>(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readableStream.<span class="property">locked</span>); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">const</span> readableStreamDefaultReader = readableStream.<span class="title function_">getReader</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readableStream.<span class="property">locked</span>); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> &#123; done, value &#125; = <span class="keyword">await</span> readableStreamDefaultReader.<span class="title function_">read</span>(); </span><br><span class="line"> <span class="keyword">if</span> (done) &#123; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(value); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<ul>
<li>可写流: 可写流是对底层数据槽的封装。生产者可以通过可写流的公共接口向底层数据槽写入数据。</li>
<li>转换流: 转换流用于组合可读流和可写流。数据块在两个流之间的转换是通过 transform()方法完成的。<br>3、通过管道连接流: 流可以通过管道连接成一串。最常见的用例是使用 pipeThrough()方法把 ReadableStream 接入TransformStream。从内部看，ReadableStream 先把自己的值传给 TransformStream 内部的WritableStream，然后执行转换，接着转换后的值又在新的 ReadableStream 上出现。<br>4、记时API: 页面性能始终是 Web 开发者关心的话题。Performance 接口通过 JavaScript API 暴露了浏览器内部的度量指标，允许开发者直接访问这些信息并基于这些信息实现自己想要的功能。这个接口暴露在window.performance 对象上。所有与页面相关的指标，包括已经定义和将来会定义的，都会存在于这个对象上。<br>Performance 接口由多个 API 构成：<br> High Resolution Time API<br> Performance Timeline API<br> Navigation Timing API<br> User Timing API<br> Resource Timing API<br> Paint Timing API</li>
<li>High Resolution Time API:<br>Date.now()方法只适用于日期时间相关操作，而且是不要求计时精度的操作。在下面的例子中，函数 foo()调用前后分别记录了一个时间戳：<br>const t0 &#x3D; Date.now();<br>foo();<br>const t1 &#x3D; Date.now();<br>const duration &#x3D; t1 – t0;<br>console.log(duration);<br>考虑如下 duration 会包含意外值的情况。<br> duration 是 0。Date.now()只有毫秒级精度，如果 foo()执行足够快，则两个时间戳的值会相等。<br> duration 是负值或极大值。如果在 foo()执行时，系统时钟被向后或向前调整了（如切换到夏令时），则捕获的时间戳不会考虑这种情况，因此时间差中会包含这些调整。<br>High Resolution Time API 定义了window.performance.now()，这个方法返回一个微秒精度的浮点值。因此，使用这个方法先后捕获的时间戳更不可能出现相等的情况。而且这个方法可以保证时间戳单调增长。<br>const t0 &#x3D; performance.now();<br>const t1 &#x3D; performance.now();<br>console.log(t0); &#x2F;&#x2F; 1768.625000026077<br>console.log(t1); &#x2F;&#x2F; 1768.6300000059418<br>const duration &#x3D; t1 – t0;<br>console.log(duration); &#x2F;&#x2F; 0.004999979864805937<br>performance.now()计时器采用相对度量。这个计时器在执行上下文创建时从 0 开始计时。例如，打开页面或创建工作线程时，performance.now()就会从 0 开始计时。由于这个计时器在不同上下文中初始化时可能存在时间差，因此不同上下文之间如果没有共享参照点则不可能直接比较 performance.now()。performance.timeOrigin 属性返回计时器初始化时全局系统时钟的值。<br>const relativeTimestamp &#x3D; performance.now();<br>const absoluteTimestamp &#x3D; performance.timeOrigin + relativeTimestamp;<br>console.log(relativeTimestamp); &#x2F;&#x2F; 244.43500000052154<br>console.log(absoluteTimestamp); &#x2F;&#x2F; 1561926208892.4001</li>
<li>Performance Timeline API: Performance Timeline API 使用一套用于度量客户端延迟的工具扩展了 Performance 接口。性能度量将会采用计算结束与开始时间差的形式。这些开始和结束时间会被记录为 DOMHighResTimeStamp值，而封装这个时间戳的对象是 PerformanceEntry 的实例。<br>浏览器会自动记录各种 PerformanceEntry 对象，而使用 performance.mark()也可以记录自定义的 PerformanceEntry 对象。在一个执行上下文中被记录的所有性能条目可以通过 performance. getEntries()获取：<br>console.log(performance.getEntries());<br>&#x2F;&#x2F; [PerformanceNavigationTiming, PerformanceResourceTiming, … ]<br>这个返回的集合代表浏览器的性能时间线（performance timeline）。每个 PerformanceEntry 对象都有 name、entryType、startTime 和 duration 属性：<br>const entry &#x3D; performance.getEntries()[0];<br>console.log(entry.name); &#x2F;&#x2F; “<a class="link"   href="https://foo.com/" >https://foo.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“<br>console.log(entry.entryType); &#x2F;&#x2F; navigation<br>console.log(entry.startTime); &#x2F;&#x2F; 0<br>console.log(entry.duration); &#x2F;&#x2F; 182.36500001512468<br>不过，PerformanceEntry 实际上是一个抽象基类。所有记录条目虽然都继承 PerformanceEntry，但最终还是如下某个具体类的实例：<br> PerformanceMark<br> PerformanceMeasure<br> PerformanceFrameTiming<br> PerformanceNavigationTiming<br> PerformanceResourceTiming<br> PerformancePaintTiming</li>
<li>Navigation Timing API: Navigation Timing API 提供了高精度时间戳，用于度量当前页面加载速度。浏览器会在导航事件发生时自动记录 PerformanceNavigationTiming 条目。这个对象会捕获大量时间戳，用于描述页面是何时以及如何加载的。<br>下面的例子计算了 loadEventStart 和 loadEventEnd 时间戳之间的差：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [performanceNavigationTimingEntry] = performance.<span class="title function_">getEntriesByType</span>(<span class="string">&#x27;navigation&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(performanceNavigationTimingEntry); </span><br><span class="line"><span class="comment">// PerformanceNavigationTiming &#123; </span></span><br><span class="line"><span class="comment">// connectEnd: 2.259999979287386 </span></span><br><span class="line"><span class="comment">// connectStart: 2.259999979287386 </span></span><br><span class="line"><span class="comment">// decodedBodySize: 122314 </span></span><br><span class="line"><span class="comment">// domComplete: 631.9899999652989 </span></span><br><span class="line"><span class="comment">// domContentLoadedEventEnd: 300.92499998863786 </span></span><br><span class="line"><span class="comment">// domContentLoadedEventStart: 298.8950000144541 </span></span><br><span class="line"><span class="comment">// domInteractive: 298.88499999651685 </span></span><br><span class="line"><span class="comment">// domainLookupEnd: 2.259999979287386 </span></span><br><span class="line"><span class="comment">// domainLookupStart: 2.259999979287386 </span></span><br><span class="line"><span class="comment">// duration: 632.819999998901 </span></span><br><span class="line"><span class="comment">// encodedBodySize: 21107 </span></span><br><span class="line"><span class="comment">// entryType: &quot;navigation&quot; </span></span><br><span class="line"><span class="comment">// fetchStart: 2.259999979287386 </span></span><br><span class="line"><span class="comment">// initiatorType: &quot;navigation&quot; </span></span><br><span class="line"><span class="comment">// loadEventEnd: 632.819999998901 </span></span><br><span class="line"><span class="comment">// loadEventStart: 632.0149999810383 </span></span><br><span class="line"><span class="comment">// name: &quot; https://foo.com &quot; </span></span><br><span class="line"><span class="comment">// nextHopProtocol: &quot;h2&quot; </span></span><br><span class="line"><span class="comment">// redirectCount: 0 </span></span><br><span class="line"><span class="comment">// redirectEnd: 0 </span></span><br><span class="line"><span class="comment">// redirectStart: 0 </span></span><br><span class="line"><span class="comment">// requestStart: 7.7099999762140214 </span></span><br><span class="line"><span class="comment">// responseEnd: 130.50999998813495 </span></span><br><span class="line"><span class="comment">// responseStart: 127.16999999247491 </span></span><br><span class="line"><span class="comment">// secureConnectionStart: 0 </span></span><br><span class="line"><span class="comment">// serverTiming: [] </span></span><br><span class="line"><span class="comment">// startTime: 0 </span></span><br><span class="line"><span class="comment">// transferSize: 21806 </span></span><br><span class="line"><span class="comment">// type: &quot;navigate&quot; </span></span><br><span class="line"><span class="comment">// unloadEventEnd: 132.73999997181818 </span></span><br><span class="line"><span class="comment">// unloadEventStart: 132.41999997990206 </span></span><br><span class="line"><span class="comment">// workerStart: 0 </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(performanceNavigationTimingEntry.<span class="property">loadEventEnd</span> – </span><br><span class="line"> performanceNavigationTimingEntry.<span class="property">loadEventStart</span>); </span><br><span class="line"><span class="comment">// 0.805000017862767</span></span><br></pre></td></tr></table></figure></div></li>
<li>Resource Timing API: Resource Timing API 提供了高精度时间戳，用于度量当前页面加载时请求资源的速度。浏览器会在加载资源时自动记录 PerformanceResourceTiming。这个对象会捕获大量时间戳，用于描述资源加载的速度。<br>下面的例子计算了加载一个特定资源所花的时间：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> performanceResourceTimingEntry = performance.<span class="title function_">getEntriesByType</span>(<span class="string">&#x27;resource&#x27;</span>)[<span class="number">0</span>]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(performanceResourceTimingEntry); </span><br><span class="line"><span class="comment">// PerformanceResourceTiming &#123; </span></span><br><span class="line"><span class="comment">// connectEnd: 138.11499997973442</span></span><br><span class="line"><span class="comment">// connectStart: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// decodedBodySize: 33808 </span></span><br><span class="line"><span class="comment">// domainLookupEnd: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// domainLookupStart: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// duration: 0 </span></span><br><span class="line"><span class="comment">// encodedBodySize: 33808 </span></span><br><span class="line"><span class="comment">// entryType: &quot;resource&quot; </span></span><br><span class="line"><span class="comment">// fetchStart: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// initiatorType: &quot;link&quot; </span></span><br><span class="line"><span class="comment">// name: &quot;https://static.foo.com/bar.png&quot;, </span></span><br><span class="line"><span class="comment">// nextHopProtocol: &quot;h2&quot; </span></span><br><span class="line"><span class="comment">// redirectEnd: 0 </span></span><br><span class="line"><span class="comment">// redirectStart: 0 </span></span><br><span class="line"><span class="comment">// requestStart: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// responseEnd: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// responseStart: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// secureConnectionStart: 0 </span></span><br><span class="line"><span class="comment">// serverTiming: [] </span></span><br><span class="line"><span class="comment">// startTime: 138.11499997973442 </span></span><br><span class="line"><span class="comment">// transferSize: 0 </span></span><br><span class="line"><span class="comment">// workerStart: 0 </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(performanceResourceTimingEntry.<span class="property">responseEnd</span> – </span><br><span class="line"> performanceResourceTimingEntry.<span class="property">requestStart</span>); </span><br><span class="line"><span class="comment">// 493.9600000507198</span></span><br></pre></td></tr></table></figure></div>
通过计算并分析不同时间的差，可以更全面地审视浏览器加载页面的过程，发现可能存在的性能瓶颈。<br>5、Web组件: 这里所说的 Web 组件指的是一套用于增强 DOM 行为的工具，包括影子 DOM、自定义元素和 HTML 模板。这一套浏览器 API 特别混乱。</li>
<li>HTML模版: 在 Web 组件之前，一直缺少基于 HTML 解析构建 DOM 子树，然后在需要时再把这个子树渲染出来的机制。一种间接方案是使用 innerHTML 把标记字符串转换为 DOM 元素，但这种方式存在严重的安全隐患。另一种间接方案是使用 document.createElement()构建每个元素，然后逐个把它们添加到孤儿根节点（不是添加到 DOM），但这样做特别麻烦，完全与标记无关。<br>相反，更好的方式是提前在页面中写出特殊标记，让浏览器自动将其解析为 DOM 子树，但跳过渲染。这正是 HTML 模板的核心思想，而<template>标签正是为这个目的而生的。下面是一个简单的HTML 模板的例子：<template id="foo"> 
 <p>I'm inside a template!</p> 
</template>
使用DocumentFragment: DocumentFragment 也是批量向 HTML 中添加元素的高效工具。比如，我们想以最快的方式给某个 HTML 元素添加多个子元素。如果连续调用 document.appendChild()，则不仅费事，还会导致多次布局重排。而使用 DocumentFragment 可以一次性添加所有子节点，最多只会有一次布局重排：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始状态：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 期待的最终状态：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/div&gt; </span></span><br><span class="line"><span class="comment">// 也可以使用 document.createDocumentFragment() </span></span><br><span class="line"><span class="keyword">const</span> fragment = <span class="keyword">new</span> <span class="title class_">DocumentFragment</span>(); </span><br><span class="line"><span class="keyword">const</span> foo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 为 DocumentFragment 添加子元素不会导致布局重排</span></span><br><span class="line">fragment.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)); </span><br><span class="line">fragment.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)); </span><br><span class="line">fragment.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fragment.<span class="property">children</span>.<span class="property">length</span>); <span class="comment">// 3 </span></span><br><span class="line">foo.<span class="title function_">appendChild</span>(fragment);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fragment.<span class="property">children</span>.<span class="property">length</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>使用<template>标签: 注意，在前面的例子中，DocumentFragment 的所有子节点都高效地转移到了 foo 元素上，转移之后 DocumentFragment 变空了。同样的过程也可以使用<template>标签重现：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fooElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barTemplate = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#bar&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barFragment = barTemplate.<span class="property">content</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;/div&gt; </span></span><br><span class="line"><span class="comment">// &lt;template id=&quot;bar&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/template&gt; </span></span><br><span class="line">fooElement.<span class="title function_">appendChild</span>(barFragment); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/div&gt; </span></span><br><span class="line"><span class="comment">// &lt;tempate id=&quot;bar&quot;&gt;&lt;/template&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>如果想要复制模板，可以使用 importNode()方法克隆 DocumentFragment：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fooElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barTemplate = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#bar&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barFragment = barTemplate.<span class="property">content</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;/div&gt; </span></span><br><span class="line"><span class="comment">// &lt;template id=&quot;bar&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/template&gt; </span></span><br><span class="line">fooElement.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.importNode(barFragment, <span class="literal">true</span>)); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt; </span></span><br><span class="line"><span class="comment">// &lt;template id=&quot;bar&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;/template&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>模版脚本: 脚本执行可以推迟到将 DocumentFragment 的内容实际添加到 DOM 树。下面的例子演示了这个过程：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面 HTML：</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="comment">// &lt;template id=&quot;bar&quot;&gt; </span></span><br><span class="line"><span class="comment">// &lt;script&gt;console.log(&#x27;Template script executed&#x27;);&lt;/script&gt; </span></span><br><span class="line"><span class="comment">// &lt;/template&gt; </span></span><br><span class="line"><span class="keyword">const</span> fooElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barTemplate = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#bar&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> barFragment = barTemplate.<span class="property">content</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;About to add template&#x27;</span>); </span><br><span class="line">fooElement.<span class="title function_">appendChild</span>(barFragment); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Added template&#x27;</span>); </span><br><span class="line"><span class="comment">// About to add template </span></span><br><span class="line"><span class="comment">// Template script executed </span></span><br><span class="line"><span class="comment">// Added template</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-07 日报 Day149</title>
    <url>/undefined/2025-04-07/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>“等闲识得东风面，万紫千红总是春”，这是生命繁衍的律动。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P627-635 第二十章：JavaScript API</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、 媒体元素: HTML5 引入了 <audio> 和 <video> 元素，用于在网页中嵌入音频和视频内容。JavaScript 可以通过这些元素的 API 控制媒体播放。<br>这两个元素既支持 Web 开发者在页面中嵌入媒体文件，也支持 JavaScript 实现对媒体的自定义控制。<br>以下是它们的用法：</p>
<!-- 嵌入视频 --> 
<p><video src="conference.mpg" id="myVideo">Video player not available.</video> </p>
<!-- 嵌入音频 --> 
<p><audio src="song.mp3" id="myAudio">Audio player not available.</audio><br>每个元素至少要求有一个 src 属性，以表示要加载的媒体文件。我们也可以指定表示视频播放器大小的 width 和 height 属性，以及在视频加载期间显示图片 URI 的 poster 属性。另外，controls属性如果存在，则表示浏览器应该显示播放界面，让用户可以直接控制媒体。开始和结束标签之间的内容是在媒体播放器不可用时显示的替代内容。<br>由于浏览器支持的媒体格式不同，因此可以指定多个不同的媒体源。为此，需要从元素中删除 src属性，使用一个或多个<source>元素代替，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌入视频 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;myVideo&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;conference.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm; codecs=&#x27;vp8, vorbis&#x27;&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;conference.ogv&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg; codecs=&#x27;theora, vorbis&#x27;&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;conference.mpg&quot;</span>&gt;</span> </span><br><span class="line"> Video player not available. </span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 嵌入音频 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">&quot;myAudio&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;song.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;song.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span> </span><br><span class="line"> Audio player not available. </span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>属性: <video>和<audio>元素提供了稳健的 JavaScript 接口。这两个元素有很多共有属性，可以用于确定媒体的当前状态，如下表所示。<table>
<thead>
<tr>
<th>属性</th>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>boolean</td>
<td>如果存在，则表示媒体应该在加载后自动播放。</td>
</tr>
<tr>
<td>buffered</td>
<td>TimeRanges</td>
<td>返回一个表示已缓冲媒体的 TimeRanges 对象。</td>
</tr>
<tr>
<td>controls</td>
<td>boolean</td>
<td>如果存在，则表示浏览器应该显示媒体播放器的控制界面。</td>
</tr>
<tr>
<td>currentSrc</td>
<td>string</td>
<td>返回当前媒体源的 URL。</td>
</tr>
<tr>
<td>currentTime</td>
<td>double</td>
<td>返回或设置当前媒体的播放位置（以秒为单位）。</td>
</tr>
<tr>
<td>defaultMuted</td>
<td>boolean</td>
<td>如果存在，则表示媒体应该在加载后静音。</td>
</tr>
<tr>
<td>defaultPlaybackRate</td>
<td>double</td>
<td>返回或设置媒体的默认播放速率。</td>
</tr>
<tr>
<td>duration</td>
<td>double</td>
<td>返回媒体的总时长（以秒为单位）。</td>
</tr>
<tr>
<td>ended</td>
<td>boolean</td>
<td>返回 true，如果媒体已播放到结尾。</td>
</tr>
<tr>
<td>loop</td>
<td>boolean</td>
<td>如果存在，则表示媒体应该在播放结束后重新开始。</td>
</tr>
<tr>
<td>muted</td>
<td>boolean</td>
<td>返回或设置媒体是否静音。</td>
</tr>
<tr>
<td>paused</td>
<td>boolean</td>
<td>返回 true，如果媒体当前处于暂停状态。</td>
</tr>
<tr>
<td>playbackRate</td>
<td>double</td>
<td>返回或设置媒体的当前播放速率。</td>
</tr>
<tr>
<td>played</td>
<td>TimeRanges</td>
<td>返回一个表示已播放媒体的 TimeRanges 对象。</td>
</tr>
<tr>
<td>preload</td>
<td>string</td>
<td>返回或设置媒体的预加载策略。可能的值包括 “none”、”metadata” 和 “auto”。</td>
</tr>
<tr>
<td>readyState</td>
<td>unsigned short</td>
<td>返回媒体的就绪状态。可能的值包括 HAVE_NOTHING、HAVE_METADATA、HAVE_CURRENT_DATA、HAVE_FUTURE_DATA 和 HAVE_ENOUGH_DATA。</td>
</tr>
<tr>
<td>src</td>
<td>string</td>
<td>返回或设置媒体的源 URL。</td>
</tr>
<tr>
<td>textTracks</td>
<td>TextTrackList</td>
<td>返回一个表示媒体文本轨道的 TextTrackList 对象。</td>
</tr>
<tr>
<td>volume</td>
<td>double</td>
<td>返回或设置媒体的音量（0.0 到 1.0）。</td>
</tr>
</tbody></table>
</li>
<li>事件: 除了有很多属性，媒体元素还有很多事件。这些事件会监控由于媒体回放或用户交互导致的不同属性的变化。下表列出了这些事件。<table>
<thead>
<tr>
<th>事件</th>
<th>何时触发</th>
</tr>
</thead>
<tbody><tr>
<td>abort</td>
<td>当媒体加载被中止时触发。</td>
</tr>
<tr>
<td>canplay</td>
<td>回放可以开始，readyState 为 2</td>
</tr>
<tr>
<td>canplaythrough</td>
<td>回放可以继续，不应该中断，readState 为 3</td>
</tr>
<tr>
<td>canshowcurrentframe</td>
<td>已经下载当前帧，readyState 为 1</td>
</tr>
<tr>
<td>dataunavailable</td>
<td>不能回放，因为没有数据，readyState 为 0</td>
</tr>
<tr>
<td>ended</td>
<td>当媒体播放到结尾时触发。</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>2、自定义媒体播放器: 使用<audio>和<video>的 play()和 pause()方法，可以手动控制媒体文件的播放。综合使用属性、事件和这些方法，可以方便地创建自定义的媒体播放器，如下面的例子所示：</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mediaplayer&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;player&quot;</span> <span class="attr">src</span>=<span class="string">&quot;movie.mov&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;mymovie.jpg&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span> </span><br><span class="line"> Video player not available. </span><br><span class="line"> <span class="tag">&lt;/<span class="name">video</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;controls&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Play&quot;</span> <span class="attr">id</span>=<span class="string">&quot;video-btn&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;curtime&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>/<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;duration&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>3、检测编解码器: 如前所述，并不是所有浏览器都支持<video>和<audio>的所有编解码器，这通常意味着必须提供多个媒体源。为此，也有 JavaScript API 可以用来检测浏览器是否支持给定格式和编解码器。这两个媒体元素都有一个名为 canPlayType()的方法，该方法接收一个格式&#x2F;编解码器字符串，返回一个字符串值：”probably”、”maybe”或””（空字符串），其中空字符串就是假值，意味着可以在 if 语句中像这样使用 canPlayType()：<br>if (audio.canPlayType(“audio&#x2F;mpeg”)) {<br> &#x2F;&#x2F; 执行某些操作<br>}<br>“probably”和”maybe”都是真值，在 if 语句的上下文中可以转型为 true。<br>4、音频类型: <audio>元素还有一个名为 Audio 的原生 JavaScript 构造函数，支持在任何时候播放音频。Audio类型与 Image 类似，都是 DOM 元素的对等体，只是不需插入文档即可工作。要通过 Audio 播放音频，只需创建一个新实例并传入音频源文件：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> audio = <span class="keyword">new</span> <span class="title class_">Audio</span>(<span class="string">&quot;sound.mp3&quot;</span>); </span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">addHandler</span>(audio, <span class="string">&quot;canplaythrough&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> audio.<span class="title function_">play</span>(); </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure></div>
<p>创建 Audio 的新实例就会开始下载指定的文件。下载完毕后，可以调用 play()来播放音频。<br>在 iOS 中调用 play()方法会弹出一个对话框，请求用户授权播放声音。为了连续播放，必须在onfinish 事件处理程序中立即调用 play()。<br>5、原生拖放: 关于拖放最有意思的可能就是可以跨窗格、跨浏览器容器，有时候甚至可以跨应用程序拖动元素。浏览器对拖放的支持可以让我们实现这些功能。</p>
<ul>
<li>拖放事件: 拖放事件几乎可以让开发者控制拖放操作的方方面面。关键的部分是确定每个事件是在哪里触发的。有的事件在被拖放元素上触发，有的事件则在放置目标上触发。在某个元素被拖动时，会（按顺序）触发以下事件：<br>(1) dragstart<br>(2) drag<br>(3) dragend<br>dragstart 事件触发后，只要目标还被拖动就会持续触发 drag 事件。这个事件类似于 mousemove，即随着鼠标移动而不断触发。当拖动停止时（把元素放到有效或无效的放置目标上），会触发 dragend事件。<br>在把元素拖动到一个有效的放置目标上时，会依次触发以下事件：<br>(1) dragenter<br>(2) dragover<br>(3) dragleave 或 drop</li>
<li>自定义放置目标: 在把某个元素拖动到无效放置目标上时，会看到一个特殊光标（圆环中间一条斜杠）表示不能放下。即使所有元素都支持放置目标事件，这些元素默认也是不允许放置的。如果把元素拖动到不允许放置的目标上，无论用户动作是什么都不会触发 drop 事件。不过，通过覆盖 dragenter 和 dragover 事件的默认行为，可以把任何元素转换为有效的放置目标。例如，如果有一个 ID 为”droptarget”的<div>元素，那么可以使用以下代码把它转换成一个放置目标：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> droptarget = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;droptarget&quot;</span>); </span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragover&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">&#125;); </span><br><span class="line">droptarget.<span class="title function_">addEventListener</span>(<span class="string">&quot;dragenter&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123; </span><br><span class="line"> event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
6、dataTransfer对象: dataTransfer 对象有两个主要方法：getData()和 setData()。顾名思义，getData()用于获取 setData()存储的值。setData()的第一个参数以及 getData()的唯一参数是一个字符串，表示要设置的数据类型：”text”或”URL”，如下所示：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传递文本</span></span><br><span class="line">event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;some text&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> text = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&quot;text&quot;</span>); </span><br><span class="line"><span class="comment">// 传递 URL </span></span><br><span class="line">event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&quot;URL&quot;</span>, <span class="string">&quot;http://www.wrox.com/&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> url = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&quot;URL&quot;</span>);</span><br></pre></td></tr></table></figure></div>
7、dropEffect与effectAllowed: dataTransfer 对象不仅可以用于实现简单的数据传输，还可以用于确定能够对被拖动元素和放置目标执行什么操作。为此，可以使用两个属性：dropEffect 与 effectAllowed。<br>8、可拖动能力: 默认情况下，图片、链接和文本是可拖动的，这意味着无须额外代码用户便可以拖动它们。文本只有在被选中后才可以拖动，而图片和链接在任意时候都是可以拖动的。<br>我们也可以让其他元素变得可以拖动。HTML5 在所有 HTML 元素上规定了一个 draggable 属性，表示元素是否可以拖动。图片和链接的 draggable 属性自动被设置为 true，而其他所有元素此属性的默认值为 false。如果想让其他元素可拖动，或者不允许图片和链接被拖动，都可以设置这个属性。例如：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 禁止拖动图片 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;smile.gif&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Smiley face&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 让元素可以拖动 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
9、Notifications API: Notifications API 用于向用户显示通知。无论从哪个角度看，这里的通知都很类似 alert()对话框：都使用 JavaScript API 触发页面外部的浏览器行为，而且都允许页面处理用户与对话框或通知弹层的交互。不过，通知提供更灵活的自定义能力。<br>Notifications API 在 Service Worker 中非常有用。渐进 Web 应用（PWA，Progressive Web Application）通过触发通知可以在页面不活跃时向用户显示消息，看起来就像原生应用。</li>
<li>通知权限: Notifications API 有被滥用的可能，因此默认会开启两项安全措施：<br> 通知只能在运行在安全上下文的代码中被触发；<br> 通知必须按照每个源的原则明确得到用户允许。<br>用户授权显示通知是通过浏览器内部的一个对话框完成的。除非用户没有明确给出允许或拒绝的答复，否则这个权限请求对每个域只会出现一次。浏览器会记住用户的选择，如果被拒绝则无法重来。<br>页面可以使用全局对象 Notification 向用户请求通知权限。这个对象有一个 requestPemission()方法，该方法返回一个期约，用户在授权对话框上执行操作后这个期约会解决。<br>Notification.requestPermission()<br> .then((permission) &#x3D;&gt; {<br> console.log(‘User responded to permission request:’, permission);<br> });<br>“granted”值意味着用户明确授权了显示通知的权限。除此之外的其他值意味着显示通知会静默失败。如果用户拒绝授权，这个值就是”denied”。一旦拒绝，就无法通过编程方式挽回，因为不可能再触发授权提示。</li>
<li>显示和隐藏通知: Notification 构造函数用于创建和显示通知。最简单的通知形式是只显示一个标题，这个标题内容可以作为第一个参数传给 Notification 构造函数。以下面这种方式调用 Notification，应该会立即显示通知：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&#x27;Title text!&#x27;</span>); </span><br></pre></td></tr></table></figure></div>
可以通过 options 参数对通知进行自定义，包括设置通知的主体、图片和振动等：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&#x27;Title text!&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">body</span>: <span class="string">&#x27;Body text!&#x27;</span>, </span><br><span class="line"> <span class="attr">image</span>: <span class="string">&#x27;path/to/image.png&#x27;</span>, </span><br><span class="line"> <span class="attr">vibrate</span>: <span class="literal">true</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
调用这个构造函数返回的 Notification 对象的 close()方法可以关闭显示的通知。下面的例子展示了显示通知后 1000 毫秒再关闭它：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&#x27;I will close in 1000ms&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> n.<span class="title function_">close</span>(), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>通知生命周期回调: 通知并非只用于显示文本字符串，也可用于实现交互。Notifications API 提供了 4 个用于添加回调的生命周期方法：<br> onshow 在通知显示时触发；<br> onclick 在通知被点击时触发；<br> onclose 在通知消失或通过 close()关闭时触发；<br> onerror 在发生错误阻止通知显示时触发。<br>下面的代码将每个生命周期事件都通过日志打印了出来：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">n.<span class="property">onshow</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Notification was shown!&#x27;</span>); </span><br><span class="line">n.<span class="property">onclick</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Notification was clicked!&#x27;</span>); </span><br><span class="line">n.<span class="property">onclose</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Notification was closed!&#x27;</span>); </span><br><span class="line">n.<span class="property">onerror</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Notification experienced an error!&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-05 日报 Day147</title>
    <url>/undefined/2025-04-05/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>跳出原有的格局，用积极的心态，去学习新的思维方式，许多困难都能迎刃而解。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P610-615 第二十章：JavaScript API</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Atomics与sharedArrayBuffer: 多个上下文访问 SharedArrayBuffer 时，如果同时对缓冲区执行操作，就可能出现资源争用问题。Atomics API 通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个SharedArrayBuffer。<br>仔细研究会发现 Atomics API 非常像一个简化版的指令集架构（ISA），这并非意外。原子操作的本质会排斥操作系统或计算机硬件通常会自动执行的优化（比如指令重新排序）。原子操作也让并发访问内存变得不可能，如果应用不当就可能导致程序执行变慢。为此，Atomics API 的设计初衷是在最少但很稳定的原子行为基础之上，构建复杂的多线程 JavaScript 程序。</p>
<ul>
<li>SharedArrayBuffer: SharedArrayBuffer 与 ArrayBuffer 具有同样的 API。二者的主要区别是 ArrayBuffer 必须在不同执行上下文间切换，SharedArrayBuffer 则可以被任意多个执行上下文同时使用。<br>在多个执行上下文间共享内存意味着并发线程操作成为了可能。传统 JavaScript 操作对于并发内存访问导致的资源争用没有提供保护。下面的例子演示了 4 个专用工作线程访问同一个SharedArrayBuffer 导致的资源争用问题：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string">self.onmessage = (&#123;data&#125;) =&gt; &#123; </span></span><br><span class="line"><span class="string"> const view = new Uint32Array(data); </span></span><br><span class="line"><span class="string"> // 执行 1 000 000 次加操作</span></span><br><span class="line"><span class="string"> for (let i = 0; i &lt; 1E6; ++i) &#123; </span></span><br><span class="line"><span class="string"> // 线程不安全加操作会导致资源争用</span></span><br><span class="line"><span class="string"> view[0] += 1; </span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string"> self.postMessage(null); </span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="keyword">const</span> workerScriptBlobUrl = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript])); </span><br><span class="line"><span class="comment">// 创建容量为 4 的工作线程池</span></span><br><span class="line"><span class="keyword">const</span> workers = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; </span><br><span class="line"> workers.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(workerScriptBlobUrl)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 在最后一个工作线程完成后打印出最终值</span></span><br><span class="line"><span class="keyword">let</span> responseCount = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line"> worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (++responseCount == workers.<span class="property">length</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final buffer value: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 初始化 SharedArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 把 SharedArrayBuffer 发送到每个工作线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line"> worker.<span class="title function_">postMessage</span>(sharedArrayBuffer); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//（期待结果为 4000001。实际输出可能类似这样：）</span></span><br><span class="line"><span class="comment">// Final buffer value: 2145106</span></span><br></pre></td></tr></table></figure></div></li>
<li>原子操作基础: 任何全局上下文中都有 Atomics 对象，这个对象上暴露了用于执行线程安全操作的一套静态方法，其中多数方法以一个 TypedArray 实例（一个 SharedArrayBuffer 的引用）作为第一个参数，以相关操作数作为后续参数。<br> 1、算术及位操作方法: Atomics API 提供了一套简单的方法用以执行就地修改操作。在 ECMA 规范中，这些方法被定义为AtomicReadModifyWrite 操作。在底层，这些方法都会从 SharedArrayBuffer 中某个位置读取值，然后执行算术或位操作，最后再把计算结果写回相同的位置。这些操作的原子本质意味着上述读取、修改、写回操作会按照顺序执行，不会被其他线程中断。以下代码演示了所有算术方法：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建大小为 1 的缓冲区</span></span><br><span class="line"><span class="keyword">let</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 基于缓冲创建 Uint8Array </span></span><br><span class="line"><span class="keyword">let</span> typedArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(sharedArrayBuffer); </span><br><span class="line"><span class="comment">// 所有 ArrayBuffer 全部初始化为 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[0]</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">const</span> increment = <span class="number">5</span>; </span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子加 5 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">add</span>(typedArray, index, increment); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[5]</span></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子减 5 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">sub</span>(typedArray, index, increment); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码演示了所有位方法：</span></span><br><span class="line"><span class="comment">// 创建大小为 1 的缓冲区</span></span><br><span class="line"><span class="keyword">let</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// 基于缓冲创建 Uint8Array </span></span><br><span class="line"><span class="keyword">let</span> typedArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(sharedArrayBuffer); </span><br><span class="line"><span class="comment">// 所有 ArrayBuffer 全部初始化为 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[0]</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子或 0b1111 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">or</span>(typedArray, index, <span class="number">0b1111</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[15] </span></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子与 0b1111 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">and</span>(typedArray, index, <span class="number">0b1100</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[12]</span></span><br><span class="line"><span class="comment">// 对索引 0 处的值执行原子异或 0b1111 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">xor</span>(typedArray, index, <span class="number">0b1111</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(typedArray); <span class="comment">// Uint8Array[3]</span></span><br></pre></td></tr></table></figure></div>
前面线程不安全的例子可以改写为下面这样：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string"> self.onmessage = (&#123;data&#125;) =&gt; &#123; </span></span><br><span class="line"><span class="string"> const view = new Uint32Array(data); </span></span><br><span class="line"><span class="string"> // 执行 1 000 000 次加操作</span></span><br><span class="line"><span class="string"> for (let i = 0; i &lt; 1E6; ++i) &#123; </span></span><br><span class="line"><span class="string"> // 线程安全的加操作</span></span><br><span class="line"><span class="string"> Atomics.add(view, 0, 1); </span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string"> self.postMessage(null); </span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="keyword">const</span> workerScriptBlobUrl = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript])); </span><br><span class="line"><span class="comment">// 创建容量为 4 的工作线程池</span></span><br><span class="line"><span class="keyword">const</span> workers = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; </span><br><span class="line"> workers.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(workerScriptBlobUrl)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 在最后一个工作线程完成后打印出最终值</span></span><br><span class="line"><span class="keyword">let</span> responseCount = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line"> worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (++responseCount == workers.<span class="property">length</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final buffer value: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 初始化 SharedArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 把 SharedArrayBuffer 发送到每个工作线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123;</span><br><span class="line">    worker.<span class="title function_">postMessage</span>(sharedArrayBuffer); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//（期待结果为 4000001）</span></span><br><span class="line"><span class="comment">// Final buffer value: 4000001</span></span><br></pre></td></tr></table></figure></div></li>
<li>原子读和写: 浏览器的 JavaScript 编译器和 CPU 架构本身都有权限重排指令以提升程序执行效率。正常情况下，JavaScript 的单线程环境是可以随时进行这种优化的。但多线程下的指令重排可能导致资源争用，而且极难排错。<br>Atomics API 通过两种主要方式解决了这个问题。<br> 所有原子指令相互之间的顺序永远不会重排。<br> 使用原子读或原子写保证所有指令（包括原子和非原子指令）都不会相对原子读&#x2F;写重新排序。这意味着位于原子读&#x2F;写之前的所有指令会在原子读&#x2F;写发生前完成，而位于原子读&#x2F;写之后的所有指令会在原子读&#x2F;写完成后才会开始。<br>除了读写缓冲区的值，Atomics.load()和 Atomics.store()还可以构建“代码围栏”。JavaScript引擎保证非原子指令可以相对于 load()或 store()本地重排，但这个重排不会侵犯原子读&#x2F;写的边界。以下代码演示了这种行为：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line"><span class="comment">// 执行非原子写</span></span><br><span class="line">view[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 非原子写可以保证在这个读操作之前完成，因此这里一定会读到 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 执行原子写</span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">store</span>(view, <span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line"><span class="comment">// 非原子读可以保证在原子写完成后发生，因此这里一定会读到 2 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(view[<span class="number">0</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div></li>
<li>原子交换: 为了保证连续、不间断的先读后写， Atomics API 提供了两种方法： exchange() 和 compareExchange()。Atomics.exchange()执行简单的交换，以保证其他线程不会中断值的交换：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line"><span class="comment">// 在索引 0 处写入 3 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">store</span>(view, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// 从索引 0 处读取值，然后在索引 0 处写入 4 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">exchange</span>(view, <span class="number">0</span>, <span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 从索引 0 处读取值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
在多线程程序中，一个线程可能只希望在上次读取某个值之后没有其他线程修改该值的情况下才对共享缓冲区执行写操作。如果这个值没有被修改，这个线程就可以安全地写入更新后的值；如果这个值被修改了，那么执行写操作将会破坏其他线程计算的值。对于这种任务，Atomics API 提供了 compareExchange()方法。这个方法只在目标索引处的值与预期值匹配时才会执行写操作。来看下面这个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line"><span class="comment">// 在索引 0 处写入 5 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">store</span>(view, <span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 从缓冲区读取值</span></span><br><span class="line"><span class="keyword">let</span> initial = <span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// 对这个值执行非原子操作</span></span><br><span class="line"><span class="keyword">let</span> result = initial ** <span class="number">2</span>; </span><br><span class="line"><span class="comment">// 只在缓冲区未被修改的情况下才会向缓冲区写入新值</span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">compareExchange</span>(view, <span class="number">0</span>, initial, result); </span><br><span class="line"><span class="comment">// 检查写入成功</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>)); <span class="comment">// 25</span></span><br><span class="line">如果值不匹配，<span class="title function_">compareExchange</span>()调用则什么也不做：</span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(sharedArrayBuffer); </span><br><span class="line"><span class="comment">// 在索引 0 处写入 5 </span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">store</span>(view, <span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 从缓冲区读取值</span></span><br><span class="line"><span class="keyword">let</span> initial = <span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// 对这个值执行非原子操作</span></span><br><span class="line"><span class="keyword">let</span> result = initial ** <span class="number">2</span>; </span><br><span class="line"><span class="comment">// 只在缓冲区未被修改的情况下才会向缓冲区写入新值</span></span><br><span class="line"><span class="title class_">Atomics</span>.<span class="title function_">compareExchange</span>(view, <span class="number">0</span>, -<span class="number">1</span>, result); </span><br><span class="line"><span class="comment">// 检查写入失败</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Atomics</span>.<span class="title function_">load</span>(view, <span class="number">0</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></div></li>
<li>原子Futex操作与加锁: 如果没有某种锁机制，多线程程序就无法支持复杂需求。为此，Atomics API 提供了模仿 Linux Futex（快速用户空间互斥量，fast user-space mutex）的方法。这些方法本身虽然非常简单，但可以作为更复杂锁机制的基本组件。<br>注意 所有原子 Futex 操作只能用于 Int32Array 视图。而且，也只能用在工作线程内部。<br>Atomics.wait()和 Atomics.notify()通过示例很容易理解。下面这个简单的例子创建了 4 个工作线程，用于对长度为 1 的 Int32Array 进行操作。这些工作线程会依次取得锁并执行自己的加操作：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string">self.onmessage = (&#123;data&#125;) =&gt; &#123; </span></span><br><span class="line"><span class="string"> const view = new Int32Array(data); </span></span><br><span class="line"><span class="string"> console.log(&#x27;Waiting to obtain lock&#x27;); </span></span><br><span class="line"><span class="string"> // 遇到初始值则停止，10 000 毫秒超时</span></span><br><span class="line"><span class="string">  Atomics.wait(view, 0, 0, 1E5); </span></span><br><span class="line"><span class="string"> console.log(&#x27;Obtained lock&#x27;); </span></span><br><span class="line"><span class="string"> // 在索引 0 处加 1 </span></span><br><span class="line"><span class="string"> Atomics.add(view, 0, 1); </span></span><br><span class="line"><span class="string"> console.log(&#x27;Releasing lock&#x27;); </span></span><br><span class="line"><span class="string"> // 只允许 1 个工作线程继续执行</span></span><br><span class="line"><span class="string"> Atomics.notify(view, 0, 1); </span></span><br><span class="line"><span class="string"> self.postMessage(null); </span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="keyword">const</span> workerScriptBlobUrl = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript])); </span><br><span class="line"><span class="keyword">const</span> workers = []; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; </span><br><span class="line"> workers.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(workerScriptBlobUrl)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 在最后一个工作线程完成后打印出最终值</span></span><br><span class="line"><span class="keyword">let</span> responseCount = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line"> worker.<span class="property">onmessage</span> = <span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">if</span> (++responseCount == workers.<span class="property">length</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Final buffer value: <span class="subst">$&#123;view[<span class="number">0</span>]&#125;</span>`</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 初始化 SharedArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> sharedArrayBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">8</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(sharedArrayBuffer); </span><br><span class="line"><span class="comment">// 把 SharedArrayBuffer 发送到每个工作线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> worker <span class="keyword">of</span> workers) &#123; </span><br><span class="line"> worker.<span class="title function_">postMessage</span>(sharedArrayBuffer); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1000 毫秒后释放第一个锁</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title class_">Atomics</span>.<span class="title function_">notify</span>(view, <span class="number">0</span>, <span class="number">1</span>), <span class="number">1000</span>); </span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Waiting to obtain lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Obtained lock </span></span><br><span class="line"><span class="comment">// Releasing lock </span></span><br><span class="line"><span class="comment">// Final buffer value: 4</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-09 日报 Day151</title>
    <url>/undefined/2025-04-09/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>一寸光阴一寸金，寸金难买寸光阴，时间买不到也租不来，惜时如金就是增进财富储量，因时制宜就是掌控发展变量，分秒必争就是创造价值增量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P651-662 第二十章：JavaScript API</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、 影子DOM: 概念上讲，影子 DOM（shadow DOM） Web 组件相当直观，通过它可以将一个完整的 DOM 树作为节点添加到父 DOM 树。这样可以实现 DOM 封装，意味着 CSS 样式和 CSS 选择符可以限制在影子 DOM子树而不是整个顶级 DOM 树中。<br>影子 DOM 与 HTML 模板很相似，因为它们都是类似 document 的结构，并允许与顶级 DOM 有一定程度的分离。不过，影子 DOM 与 HTML 模板还是有区别的，主要表现在影子 DOM 的内容会实际渲染到页面上，而 HTML 模板的内容不会。</p>
<ul>
<li>理解影子DOM: 假设有以下 HTML 标记，其中包含多个类似的 DOM 子树：<div> 
 <p>Make me red!</p> 
</div> 
<div> 
 <p>Make me blue!</p> 
</div> 
<div> 
 <p>Make me green!</p> 
</div>
从其中的文本节点可以推断出，这 3 个 DOM 子树会分别渲染为不同的颜色。
理想情况下，应该能够把 CSS 限制在使用它们的 DOM 上：这正是影子 DOM 最初的使用场景。</li>
<li>创建影子DOM: 考虑到安全及避免影子 DOM 冲突，并非所有元素都可以包含影子 DOM。尝试给无效元素或者已经有了影子 DOM 的元素添加影子 DOM 会导致抛出错误。<br>影子 DOM 是通过 attachShadow()方法创建并添加给有效 HTML 元素的。容纳影子 DOM 的元素被称为影子宿主（shadow host）。影子 DOM 的根节点被称为影子根（shadow root）。<br>attachShadow()方法需要一个shadowRootInit 对象，返回影子DOM的实例。shadowRootInit对象必须包含一个 mode 属性，值为”open”或”closed”。对”open”影子 DOM的引用可以通过 shadowRoot属性在 HTML 元素上获得，而对”closed”影子 DOM 的引用无法这样获取。<br>下面的代码演示了不同 mode 的区别：</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string"> &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string"> &lt;div id=&quot;bar&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="keyword">const</span> foo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#foo&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> bar = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#bar&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> openShadowDOM = foo.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;); </span><br><span class="line"><span class="keyword">const</span> closedShadowDOM = bar.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;closed&#x27;</span> &#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(openShadowDOM); <span class="comment">// #shadow-root (open)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(closedShadowDOM); <span class="comment">// #shadow-root (closed)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">shadowRoot</span>); <span class="comment">// #shadow-root (open) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">shadowRoot</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用影子DOM: 把影子 DOM 添加到元素之后，可以像使用常规 DOM 一样使用影子 DOM。来看下面的例子，这里重新创建了前面红&#x2F;绿&#x2F;蓝子树的示例：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]) &#123; </span><br><span class="line"> <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"> <span class="keyword">const</span> shadowDOM = div.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;); </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div); </span><br><span class="line"> shadowDOM.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string"> &lt;p&gt;Make me <span class="subst">$&#123;color&#125;</span>&lt;/p&gt; </span></span><br><span class="line"><span class="string"> &lt;style&gt; </span></span><br><span class="line"><span class="string"> p &#123; </span></span><br><span class="line"><span class="string"> color: <span class="subst">$&#123;color&#125;</span>; </span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string"> &lt;/style&gt; </span></span><br><span class="line"><span class="string"> `</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
虽然这里使用相同的选择符应用了 3 种不同的颜色，但每个选择符只会把样式应用到它们所在的影子 DOM 上。为此，3 个<p>元素会出现 3 种不同的颜色。<br>可以这样验证这些元素分别位于它们自己的影子 DOM 中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]) &#123; </span><br><span class="line"> <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"> <span class="keyword">const</span> shadowDOM = div.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;); </span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div); </span><br><span class="line"> shadowDOM.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string"> &lt;p&gt;Make me <span class="subst">$&#123;color&#125;</span>&lt;/p&gt; </span></span><br><span class="line"><span class="string"> &lt;style&gt; </span></span><br><span class="line"><span class="string"> p &#123; </span></span><br><span class="line"><span class="string"> color: <span class="subst">$&#123;color&#125;</span>; </span></span><br><span class="line"><span class="string"> &#125; </span></span><br><span class="line"><span class="string"> &lt;/style&gt; </span></span><br><span class="line"><span class="string"> `</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countP</span>(<span class="params">node</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">length</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">countP</span>(<span class="variable language_">document</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)) &#123; </span><br><span class="line"> <span class="title function_">countP</span>(element.<span class="property">shadowRoot</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>
在浏览器开发者工具中可以更清楚地看到影子 DOM。例如，前面的例子在浏览器检查窗口中会显示成这样：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line"> #shadow-root (open) </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Make me red!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css"> <span class="selector-tag">p</span> &#123; </span></span><br><span class="line"><span class="language-css"> <span class="attribute">color</span>: red; </span></span><br><span class="line"><span class="language-css"> &#125; </span></span><br><span class="line"><span class="language-css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line"> #shadow-root (open) </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Make me green!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css"> <span class="selector-tag">p</span> &#123; </span></span><br><span class="line"><span class="language-css"> <span class="attribute">color</span>: green; </span></span><br><span class="line"><span class="language-css"> &#125; </span></span><br><span class="line"><span class="language-css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line"> #shadow-root (open) </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Make me blue!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"> </span></span><br><span class="line"><span class="language-css"> <span class="selector-tag">p</span> &#123; </span></span><br><span class="line"><span class="language-css"> <span class="attribute">color</span>: blue; </span></span><br><span class="line"><span class="language-css"> &#125; </span></span><br><span class="line"><span class="language-css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
影子 DOM 并非铁板一块。HTML 元素可以在 DOM 树间无限制移动：</li>
<li>合成与影子DOM槽位: 影子 DOM 是为自定义 Web 组件设计的，为此需要支持嵌套 DOM 片段。从概念上讲，可以这么说：位于影子宿主中的 HTML需要一种机制以渲染到影子 DOM中去，但这些 HTML又不必属于影子 DOM树。<br>默认情况下，嵌套内容会隐藏。来看下面的例子，其中的文本在 1000 毫秒后会被隐藏：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;div&gt; </span></span><br><span class="line"><span class="string"> &lt;p&gt;Foo&lt;/p&gt; </span></span><br><span class="line"><span class="string">&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div>
为了显示文本内容，需要使用<slot>标签指示浏览器在哪里放置原来的 HTML。下面的代码修改了前面的例子，让影子宿主中的文本出现在了影子 DOM 中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="string"> &lt;p&gt;Foo&lt;/p&gt; </span></span><br><span class="line"><span class="string">&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>) </span><br><span class="line"> .<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;) </span><br><span class="line"> .<span class="property">innerHTML</span> = <span class="string">`&lt;div id=&quot;bar&quot;&gt; </span></span><br><span class="line"><span class="string"> &lt;slot&gt;&lt;/slot&gt; </span></span><br><span class="line"><span class="string"> &lt;div&gt;`</span></span><br></pre></td></tr></table></figure></div>
现在，投射进去的内容就像自己存在于影子 DOM 中一样。检查页面会发现原来的内容实际上替代了<slot>：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span> </span><br><span class="line"> #shadow-root (open) </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Foo<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
注意，虽然在页面检查窗口中看到内容在影子 DOM中，但这实际上只是 DOM内容的投射（projection）。实际的元素仍然处于外部 DOM 中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;div id=&quot;foo&quot;&gt; </span></span><br><span class="line"><span class="string"> &lt;p&gt;Foo&lt;/p&gt; </span></span><br><span class="line"><span class="string">&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>) </span><br><span class="line"> .<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;) </span><br><span class="line"> .<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string"> &lt;div id=&quot;bar&quot;&gt; </span></span><br><span class="line"><span class="string"> &lt;slot&gt;&lt;/slot&gt; </span></span><br><span class="line"><span class="string"> &lt;/div&gt;`</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">parentElement</span>); </span><br><span class="line"><span class="comment">// &lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>事件重定向: 如果影子 DOM 中发生了浏览器事件（如 click），那么浏览器需要一种方式以让父 DOM 处理事件。不过，实现也必须考虑影子 DOM 的边界。为此，事件会逃出影子 DOM 并经过事件重定向（event retarget）在外部被处理。逃出后，事件就好像是由影子宿主本身而非真正的包装元素触发的一样。下面的代码演示了这个过程：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个元素作为影子宿主</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;div onclick=&quot;console.log(&#x27;Handled outside:&#x27;, event.target)&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="comment">// 添加影子 DOM 并向其中插入 HTML </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>) </span><br><span class="line"> .<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;) </span><br><span class="line"> .<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;button onclick=&quot;console.log(&#x27;Handled inside:&#x27;, event.target)&quot;&gt;Foo&lt;/button&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="comment">// 点击按钮时：</span></span><br><span class="line"><span class="comment">// Handled inside: &lt;button onclick=&quot;...&quot;&gt;&lt;/button&gt; </span></span><br><span class="line"><span class="comment">// Handled outside: &lt;div onclick=&quot;...&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></div>
2、自定义元素: 自定义元素为 HTML 元素引入了面向对象编程的风格。基于这种风格，可以创建自定义的、复杂的和可重用的元素，而且只要使用简单的 HTML 标签或属性就可以创建相应的实例。</li>
<li>创建自定义元素: 浏览器会尝试将无法识别的元素作为通用元素整合进 DOM。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;x-foo &gt;I&#x27;m inside a nonsense element.&lt;/x-foo &gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;x-foo&#x27;</span>) <span class="keyword">instanceof</span> <span class="title class_">HTMLElement</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
调用 customElements.define()方法可以创建自定义元素。下面的代码创建了一个简单的自定义元素，这个元素继承 HTMLElement：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;x-foo &gt;I&#x27;m inside a nonsense element.&lt;/x-foo &gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;x-foo&#x27;</span>) <span class="keyword">instanceof</span> <span class="title class_">FooElement</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
自定义元素的威力源自类定义。例如，可以通过调用自定义元素的构造函数来控制这个类在 DOM中每个实例的行为：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x-foo&#x27;</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;x-foo&gt;&lt;/x-foo&gt; </span></span><br><span class="line"><span class="string">&lt;x-foo&gt;&lt;/x-foo&gt; </span></span><br><span class="line"><span class="string">&lt;x-foo&gt;&lt;/x-foo&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo</span></span><br></pre></td></tr></table></figure></div>
注意 在自定义元素的构造函数中必须始终先调用 super()。如果元素继承了 HTMLElement或相似类型而不会覆盖构造函数，则没有必要调用 super()，因为原型构造函数默认会做这件事。很少有创建自定义元素而不继承 HTMLElement 的。<br>如果自定义元素继承了一个元素类，那么可以使用 is 属性和 extends 选项将标签指定为该自定义元素的实例：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLDivElement</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x-foo&#x27;</span>) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>, &#123; <span class="attr">extends</span>: <span class="string">&#x27;div&#x27;</span> &#125;); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string">&lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">&lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">&lt;div is=&quot;x-foo&quot;&gt;&lt;/div&gt; </span></span><br><span class="line"><span class="string">`</span>; </span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo </span></span><br><span class="line"><span class="comment">// x-foo</span></span><br></pre></td></tr></table></figure></div></li>
<li>添加Web组件内容: 因为每次将自定义元素添加到 DOM 中都会调用其类构造函数，所以很容易自动给自定义元素添加子 DOM 内容。虽然不能在构造函数中添加子 DOM（会抛出 DOMException），但可以为自定义元素添加影子 DOM 并将内容添加到这个影子 DOM 中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(); </span><br><span class="line"> <span class="comment">// this 引用 Web 组件节点</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;); </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="property">innerHTML</span> = <span class="string">` </span></span><br><span class="line"><span class="string"> &lt;p&gt;I&#x27;m inside a custom element!&lt;/p&gt; </span></span><br><span class="line"><span class="string"> `</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> += <span class="string">`&lt;x-foo&gt;&lt;/x-foo`</span>; </span><br><span class="line"><span class="comment">// 结果 DOM：</span></span><br><span class="line"><span class="comment">// &lt;body&gt; </span></span><br><span class="line"><span class="comment">// &lt;x-foo&gt; </span></span><br><span class="line"><span class="comment">// #shadow-root (open) </span></span><br><span class="line"><span class="comment">// &lt;p&gt;I&#x27;m inside a custom element!&lt;/p&gt; </span></span><br><span class="line"><span class="comment">// &lt;x-foo&gt; </span></span><br><span class="line"><span class="comment">// &lt;/body&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>使用自定义元素生命周期方法: 可以在自定义元素的不同生命周期执行代码。带有相应名称的自定义元素类的实例方法会在不同生命周期阶段被调用。自定义元素有以下 5 个生命周期方法。<br> constructor()：在创建元素实例或将已有 DOM 元素升级为自定义元素时调用。<br> connectedCallback()：在每次将这个自定义元素实例添加到 DOM 中时调用。<br> disconnectedCallback()：在每次将这个自定义元素实例从 DOM 中移除时调用。<br> attributeChangedCallback()：在每次可观察属性的值发生变化时调用。在元素实例初始化时，初始值的定义也算一次变化。<br> adoptedCallback()：在通过 document.adoptNode()将这个自定义元素实例移动到新文档对象时调用。<br>下面的例子演示了这些构建、连接和断开连接的回调：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ctor&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;connected&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">disconnectedCallback</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;disconnected&#x27;</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"><span class="keyword">const</span> fooElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;x-foo&#x27;</span>); </span><br><span class="line"><span class="comment">// ctor </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(fooElement); </span><br><span class="line"><span class="comment">// connected </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(fooElement); </span><br><span class="line"><span class="comment">// disconnected</span></span><br></pre></td></tr></table></figure></div></li>
<li>反射自定义元素属性: 自定义元素既是 DOM 实体又是 JavaScript 对象，因此两者之间应该同步变化。换句话说，对 DOM的修改应该反映到 JavaScript 对象，反之亦然。要从 JavaScript 对象反射到 DOM，常见的方式是使用获取函数和设置函数。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;x-foo&gt;&lt;/x-foo&gt;`</span>; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">super</span>(); </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="literal">true</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;bar&#x27;</span>, value) </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-foo&#x27;</span>, <span class="title class_">FooElement</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); </span><br><span class="line"><span class="comment">// &lt;x-foo bar=&quot;true&quot;&gt;&lt;/x-foo&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>升级自定义元素: 并非始终可以先定义自定义元素，然后再在 DOM 中使用相应的元素标签。为解决这个先后次序问题，Web 组件在 CustomElementRegistry 上额外暴露了一些方法。这些方法可以用来检测自定义元素是否定义完成，然后可以用它来升级已有元素。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-10 日报 Day152</title>
    <url>/undefined/2025-04-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>一寸光阴一寸金，寸金难买寸光阴，时间买不到也租不来，惜时如金就是增进财富储量，因时制宜就是掌控发展变量，分秒必争就是创造价值增量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P663-674 第二十章：JavaScript API</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、 Web Cryptography API: Web Cryptography API 描述了一套密码学工具，规范了 JavaScript 如何以安全和符合惯例的方式实现加密。这些工具包括生成、使用和应用加密密钥对，加密和解密消息，以及可靠地生成随机数。<br>2、生成随机数: 在需要生成随机值时，很多人会使用 Math.random()。这个方法在浏览器中是以伪随机数生成器（PRNG，PseudoRandom Number Generator）方式实现的。所谓“伪”指的是生成值的过程不是真的随机。PRNG 生成的值只是模拟了随机的特性。<br>由于算法本身是固定的，其输入只是之前的状态，因此随机数顺序也是确定的。xorshift128+使用 128 位内部状态，而算法的设计让任何初始状态在重复自身之前都会产生 2128–1 个伪随机值。这种循环被称为置换循环（permutation cycle），而这个循环的长度被称为一个周期（period）。很明显，如果攻击者知道 PRNG 的内部状态，就可以预测后续生成的伪随机值。如果开发者无意中使用 PRNG 生成了私有密钥用于加密，则攻击者就可以利用 PRNG 的这个特性算出私有密钥。<br>伪随机数生成器主要用于快速计算出看起来随机的值。不过并不适合用于加密计算。为解决这个问题，密码学安全伪随机数生成器（CSPRNG，Cryptographically Secure PseudoRandom Number Generator）额外增加了一个熵作为输入，例如测试硬件时间或其他无法预计行为的系统特性。这样一来，计算速度明显比常规 PRNG 慢很多，但 CSPRNG 生成的值就很难预测，可以用于加密了。<br>Web Cryptography API 引入了 CSPRNG，这个 CSPRNG 可以通过 crypto.getRandomValues()在全局 Crypto 对象上访问。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(crypto.<span class="title function_">getRandomValues</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uint8Array [41]</span></span><br><span class="line"><span class="comment">// Uint8Array [250]</span></span><br><span class="line"><span class="comment">// Uint8Array [51]</span></span><br><span class="line"><span class="comment">// Uint8Array [129]</span></span><br><span class="line"><span class="comment">// Uint8Array [35]</span></span><br></pre></td></tr></table></figure></div>

<p>要使用 CSPRNG 重新实现 Math.random()，可以通过生成一个随机的 32 位数值，然后用它去除最大的可能值 0xFFFFFFFF。这样就会得到一个介于 0 和 1 之间的值</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomFloat</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 生成 32 位随机值</span></span><br><span class="line">  <span class="keyword">const</span> fooArray = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 最大值是 2^32 –1</span></span><br><span class="line">  <span class="keyword">const</span> maxUint32 = <span class="number">0xffffffff</span>;</span><br><span class="line">  <span class="comment">// 用最大可能的值来除</span></span><br><span class="line">  <span class="keyword">return</span> crypto.<span class="title function_">getRandomValues</span>(fooArray)[<span class="number">0</span>] / maxUint32;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomFloat</span>()); <span class="comment">// 0.5033651619458955</span></span><br></pre></td></tr></table></figure></div>

<p>3、使用 SubtleCrypto 对象: Web Cryptography API 重头特性都暴露在了 SubtleCrypto 对象上，可以通过 window.crypto.subtle 访问：<br>console.log(crypto.subtle); &#x2F;&#x2F; SubtleCrypto {}<br>这个对象包含一组方法，用于执行常见的密码学功能，如加密、散列、签名和生成密钥。</p>
<ul>
<li>生成密码学摘要: 计算数据的密码学摘要是非常常用的密码学操作。这个规范支持 4 种摘要算法：SHA-1 和 3 种 SHA-2。<br> SHA-1（Secure Hash Algorithm 1）：架构类似 MD5 的散列函数。接收任意大小的输入，生成 160 位消息散列。由于容易受到碰撞攻击，这个算法已经不再安全。<br> SHA-2（Secure Hash Algorithm 2）：构建于相同耐碰撞单向压缩函数之上的一套散列函数。规范支持其中 3 种：SHA-256、SHA-384 和 SHA-512。生成的消息摘要可以是 256 位（SHA-256）、384 位（SHA-384）或 512 位（SHA-512）。这个算法被认为是安全的，广泛应用于很多领域和协议，包括 TLS、PGP 和加密货币（如比特币）。<br>SubtleCrypto.digest()方法用于生成消息摘要。要使用的散列算法通过字符串”SHA-1”、”SHA-256”、”SHA-384”或”SHA-512”指定。下面的代码展示了一个使用 SHA-256 为字符串”foo”生成消息摘要的例子：</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line">  <span class="keyword">const</span> message = textEncoder.<span class="title function_">encode</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> messageDigest = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">digest</span>(<span class="string">&quot;SHA-256&quot;</span>, message);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Uint32Array</span>(messageDigest));</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// Uint32Array(8) [1806968364, 2412183400, 1011194873, 876687389,</span></span><br><span class="line"><span class="comment">// 1882014227, 2696905572, 2287897337, 2934400610]</span></span><br></pre></td></tr></table></figure></div>

<p>通常，在使用时，二进制的消息摘要会转换为十六进制字符串格式。通过将二进制数据按 8 位进行分割，然后再调用 toString(16)就可以把任何数组缓冲区转换为十六进制字符串：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> textEncoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>();</span><br><span class="line">  <span class="keyword">const</span> message = textEncoder.<span class="title function_">encode</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> messageDigest = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">digest</span>(<span class="string">&quot;SHA-256&quot;</span>, message);</span><br><span class="line">  <span class="keyword">const</span> hexDigest = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(messageDigest))</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>))</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(hexDigest);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae</span></span><br></pre></td></tr></table></figure></div>

<p>软件公司通常会公开自己软件二进制安装包的摘要，以便用户验证自己下载到的确实是该公司发布的版本（而不是被恶意软件篡改过的版本）。下面的例子演示了下载 Firefox v67.0，通过 SHA-512 计算其散列，再下载其 SHA-512 二进制验证摘要，最后检查两个十六进制字符串匹配：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mozillaCdnUrl =</span><br><span class="line">    <span class="string">&quot;// downloadorigin.cdn.mozilla.net/pub/firefox/releases/67.0 /&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> firefoxBinaryFilename = <span class="string">&quot;linux-x86_64/en-US/firefox-67.0.tar.bz2&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> firefoxShaFilename = <span class="string">&quot;SHA512SUMS&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fetching Firefox binary...&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> fileArrayBuffer = <span class="keyword">await</span> (</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fetch</span>(mozillaCdnUrl + firefoxBinaryFilename)</span><br><span class="line">  ).<span class="title function_">arrayBuffer</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Calculating Firefox digest...&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> firefoxBinaryDigest = <span class="keyword">await</span> crypto.<span class="property">subtle</span>.<span class="title function_">digest</span>(</span><br><span class="line">    <span class="string">&quot;SHA-512&quot;</span>,</span><br><span class="line">    fileArrayBuffer</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> firefoxHexDigest = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(firefoxBinaryDigest))</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>))</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fetching published binary digests...&quot;</span>);</span><br><span class="line">  <span class="comment">// SHA 文件包含此次发布的所有 Firefox 二进制文件的摘要，</span></span><br><span class="line">  <span class="comment">// 因此要根据其格式进制拆分</span></span><br><span class="line">  <span class="keyword">const</span> shaPairs = (</span><br><span class="line">    <span class="keyword">await</span> (<span class="keyword">await</span> <span class="title function_">fetch</span>(mozillaCdnUrl + firefoxShaFilename)).<span class="title function_">text</span>()</span><br><span class="line">  )</span><br><span class="line">    .<span class="title function_">split</span>(<span class="regexp">/\n/</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x.<span class="title function_">split</span>(<span class="regexp">/\s+/</span>));</span><br><span class="line">  <span class="keyword">let</span> verified = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Checking calculated digest against published digests...&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [sha, filename] <span class="keyword">of</span> shaPairs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filename === firefoxBinaryFilename) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sha === firefoxHexDigest) &#123;</span><br><span class="line">        verified = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Verified:&quot;</span>, verified);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// Fetching Firefox binary...</span></span><br><span class="line"><span class="comment">// Calculating Firefox digest...</span></span><br><span class="line"><span class="comment">// Fetching published binary digests...</span></span><br><span class="line"><span class="comment">// Checking calculated digest against published digests...</span></span><br><span class="line"><span class="comment">// Verified: true</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>CryptoKey与算法: 如果没了密钥，那密码学也就没什么意义了。SubtleCrypto 对象使用 CryptoKey 类的实例来生成密钥。CryptoKey 类支持多种加密算法，允许控制密钥抽取和使用。<br>CryptoKey 类支持以下算法，按各自的父密码系统归类。<br> RSA（Rivest-Shamir-Adleman）：公钥密码系统，使用两个大素数获得一对公钥和私钥，可用于签名&#x2F;验证或加密&#x2F;解密消息。RSA 的陷门函数被称为分解难题（factoring problem）。<br> RSASSA-PKCS1-v1_5：RSA 的一个应用，用于使用私钥给消息签名，允许使用公钥验证签名。<br> SSA（Signature Schemes with Appendix），表示算法支持签名生成和验证操作。<br> PKCS1（Public-Key Cryptography Standards #1），表示算法展示出的 RSA 密钥必需的数学特性。<br> RSASSA-PKCS1-v1_5 是确定性的，意味着同样的消息和密钥每次都会生成相同的签名。<br> RSA-PSS：RSA 的另一个应用，用于签名和验证消息。<br> PSS（Probabilistic Signature Scheme），表示生成签名时会加盐以得到随机签名。<br> 与 RSASSA-PKCS1-v1_5 不同，同样的消息和密钥每次都会生成不同的签名。<br> 与 RSASSA-PKCS1-v1_5 不同，RSA-PSS 有可能约简到 RSA 分解难题的难度。<br> 通常，虽然 RSASSA-PKCS1-v1_5 仍被认为是安全的，但 RSA-PSS 应该用于代替RSASSA-PKCS1-v1_5。<br> RSA-OAEP：RSA 的一个应用，用于使用公钥加密消息，用私钥来解密。<br> OAEP（Optimal Asymmetric Encryption Padding），表示算法利用了 Feistel 网络在加密前处理未加密的消息。<br> OAEP 主要将确定性 RSA 加密模式转换为概率性加密模式。<br> ECC（Elliptic-Curve Cryptography）：公钥密码系统，使用一个素数和一个椭圆曲线获得一对公钥和私钥，可用于签名&#x2F;验证消息。ECC 的陷门函数被称为椭圆曲线离散对数问题（elliptic curve discrete logarithm problem）。ECC 被认为优于 RSA。虽然 RSA 和 ECC 在密码学意义上都很强，但 ECC 密钥比 RSA 密钥短，而且 ECC 密码学操作比 RSA 操作快。<br> ECDSA（Elliptic Curve Digital Signature Algorithm）：ECC 的一个应用，用于签名和验证消息。这个算法是数字签名算法（DSA，Digital Signature Algorithm）的一个椭圆曲线风格的变体。<br> ECDH（Elliptic Curve Diffie-Hellman）：ECC 的密钥生成和密钥协商应用，允许两方通过公开通信渠道建立共享的机密。这个算法是 Diffie-Hellman 密钥交换（DH，Diffie-Hellman key exchange）协议的一个椭圆曲线风格的变体。<br> AES（Advanced Encryption Standard）：对称密钥密码系统，使用派生自置换组合网络的分组密码加密和解密数据。AES 在不同模式下使用，不同模式算法的特性也不同。<br> AES-CTR：AES 的计数器模式（counter mode）。这个模式使用递增计数器生成其密钥流，其行为类似密文流。使用时必须为其提供一个随机数，用作初始化向量。AES-CTR 加密&#x2F;解密可以并行。<br> AES-CBC：AES 的密码分组链模式（cipher block chaining mode）。在加密纯文本的每个分组之前，先使用之前密文分组求 XOR，也就是名字中的“链”。使用一个初始化向量作为第一个分组的 XOR 输入。<br> AES-GCM：AES 的伽罗瓦&#x2F;计数器模式（Galois&#x2F;Counter mode）。这个模式使用计数器和初始化向量生成一个值，这个值会与每个分组的纯文本计算 XOR。与 CBC 不同，这个模式的 XOR 输入不依赖之前分组密文。因此 GCM 模式可以并行。由于其卓越的性能，AES-GCM 在很多网络安全协议中得到了应用。<br> AES-KW：AES 的密钥包装模式（key wrapping mode）。这个算法将加密密钥包装为一个可移植且加密的格式，可以在不信任的渠道中传输。传输之后，接收方可以解包密钥。与其他 AES 模式不同，AES-KW 不需要初始化向量。<br> HMAC（Hash-Based Message Authentication Code）：用于生成消息认证码的算法，用于验证通过不可信网络接收的消息没有被修改过。两方使用散列函数和共享私钥来签名和验证消息。<br> KDF（Key Derivation Functions）：可以使用散列函数从主密钥获得一个或多个密钥的算法。KDF能够生成不同长度的密钥，也能把密钥转换为不同格式。<br> HKDF（HMAC-Based Key Derivation Function）：密钥推导函数，与高熵输入（如已有密钥）一起使用。<br> PBKDF2（Password-Based Key Derivation Function 2）：密钥推导函数，与低熵输入（如密钥字符串）一起使用。</li>
<li>生成CryptoKey: 使用 SubtleCrypto.generateKey()方法可以生成随机 CryptoKey，这个方法返回一个期约，解决为一个或多个 CryptoKey 实例。使用时需要给这个方法传入一个指定目标算法的参数对象、一个表示密钥是否可以从 CryptoKey 对象中提取出来的布尔值，以及一个表示这个密钥可以与哪个SubtleCrypto 方法一起使用的字符串数组（keyUsages）。<br>-生成CryptoKey: 使用 SubtleCrypto.generateKey()方法可以生成随机 CryptoKey，这个方法返回一个期约，解决为一个或多个 CryptoKey 实例。使用时需要给这个方法传入一个指定目标算法的参数对象、一个表示密钥是否可以从 CryptoKey 对象中提取出来的布尔值，以及一个表示这个密钥可以与哪个SubtleCrypto 方法一起使用的字符串数组（keyUsages）。<br>由于不同的密码系统需要不同的输入来生成密钥，上述参数对象为每种密码系统都规定了必需的输入：<br> RSA 密码系统使用 RsaHashedKeyGenParams 对象；<br> ECC 密码系统使用 EcKeyGenParams 对象；<br> HMAC 密码系统使用 HmacKeyGenParams 对象；<br> AES 密码系统使用 AesKeyGenParams 对象。<br>keyUsages 对象用于说明密钥可以与哪个算法一起使用。至少要包含下列中的一个字符串：<br> encrypt<br> decrypt<br> sign<br> verify<br> deriveKey<br> deriveBits<br> wrapKey<br> unwrapKey<br>keyUsages 对象用于说明密钥可以与哪个算法一起使用。至少要包含下列中的一个字符串：<br> encrypt<br> decrypt<br> sign<br> verify<br> deriveKey<br> deriveBits<br> wrapKey<br> unwrapKey<br>假设要生成一个满足如下条件的对称密钥：<br> 支持 AES-CTR 算法；<br> 密钥长度 128 位；<br> 不能从 CryptoKey 对象中提取；<br> 可以跟 encrypt()和 decrypt()方法一起使用。<br>那么可以参考如下代码：<br>(async function() {<br> const params &#x3D; {<br> name: ‘AES-CTR’,<br> length: 128<br> };<br> const keyUsages &#x3D; [‘encrypt’, ‘decrypt’];<br> const key &#x3D; await crypto.subtle.generateKey(params, false, keyUsages);<br> console.log(key);<br> &#x2F;&#x2F; CryptoKey {type: “secret”, extractable: true, algorithm: {…}, usages: Array(2)}<br>})();</li>
<li>导出和导入密钥: 如果密钥是可提取的，那么就可以在 CryptoKey 对象内部暴露密钥原始的二进制内容。使用exportKey()方法并指定目标格式（”raw”、”pkcs8”、”spki”或”jwk”）就可以取得密钥。这个方法返回一个期约，解决后的 ArrayBuffer 中包含密钥：<br>(async function() {<br> const params &#x3D; {<br> name: ‘AES-CTR’,<br> length: 128<br> };<br> const keyUsages &#x3D; [‘encrypt’, ‘decrypt’];<br> const key &#x3D; await crypto.subtle.generateKey(params, true, keyUsages);<br> const rawKey &#x3D; await crypto.subtle.exportKey(‘raw’, key);<br> console.log(new Uint8Array(rawKey));<br> &#x2F;&#x2F; Uint8Array[93, 122, 66, 135, 144, 182, 119, 196, 234, 73, 84, 7, 139, 43, 238,<br> &#x2F;&#x2F; 110]<br>})();<br>exportKey()相反的操作要使用 importKey()方法实现。importKey()方法的签名实际上是generateKey()和 exportKey()的组合。下面的方法会生成密钥、导出密钥，然后再导入密钥：</li>
<li>从主密钥派生密钥: 使用 SubtleCrypto 对象可以通过可配置的属性从已有密钥获得新密钥。</li>
<li>使用非对称密钥签名和验证消息: 通过 SubtleCrypto 对象可以使用公钥算法用私钥生成签名，或者用公钥验证签名。这两种操作分别通过 SubtleCrypto.sign()和 SubtleCrypto.verify()方法完成。</li>
<li>使用对称密钥加密和解密: SubtleCrypto 对象支持使用公钥和对称算法加密和解密消息。这两种操作分别通过 SubtleCrypto.encrypt()和 SubtleCrypto.decrypt()方法完成。加密消息需要传入参数对象以指定算法和必要的值、加密密钥和要加密的数据。</li>
<li>包装和解包密钥: SubtleCrypto 对象支持包装和解包密钥，以便在非信任渠道传输。这两种操作分别通过 SubtleCrypto.wrapKey()和 SubtleCrypto.unwrapKey()方法完成。<br>4、小结: 除了定义新标签，HTML5 还定义了一些 JavaScript API。这些 API 可以为开发者提供更便捷的 Web接口，暴露堪比桌面应用的能力。本章主要介绍了以下 API。<br> Atomics API 用于保护代码在多线程内存访问模式下不发生资源争用。<br> postMessage() API 支持从不同源跨文档发送消息，同时保证安全和遵循同源策略。<br> Encoding API 用于实现字符串与缓冲区之间的无缝转换（越来越常见的操作）。<br> File API 提供了发送、接收和读取大型二进制对象的可靠工具。<br> 媒体元素<audio>和<video>拥有自己的 API，用于操作音频和视频。并不是每个浏览器都会支持所有媒体格式，使用 canPlayType()方法可以检测浏览器支持情况。<br> 拖放 API 支持方便地将元素标识为可拖动，并在操作系统完成放置时给出回应。可以利用它创建自定义可拖动元素和放置目标。<br> Notifications API 提供了一种浏览器中立的方式，以此向用户展示消通知弹层。<br> Streams API 支持以全新的方式读取、写入和处理数据。<br> Timing API 提供了一组度量数据进出浏览器时间的可靠工具。<br> Web Components API 为元素重用和封装技术向前迈进提供了有力支撑。<br> Web Cryptography API 让生成随机数、加密和签名消息成为一类特性。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-13 日报 Day155</title>
    <url>/undefined/2025-04-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>我们常说，生活没有标准答案，每个人都有自己的注脚。面对困境，我们也各有各的选择。“行到水穷处，坐观云起时”是选择，“卧薪尝胆，三千越甲可吞吴”是选择，当然，你也可以选择带上拳套，奋力搏击。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P703-710 第二十三章：JSON</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、JSON 是 JavaScript 的严格子集，利用 JavaScript 中的几种模式来表示结构化数据。Crockford 将 JSON 作为替代 XML 的一个方案提出，因为 JSON 可以直接传给 eval()而不需要创建 DOM。<br>JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语<br>言都有解析和序列化 JSON 的内置能力。<br>2、JSON的语法: JSON 语法支持表示 3 种类型的值。<br> 简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。<br> 对象：第一种复杂数据类型，对象表示有序键&#x2F;值对。每个值可以是简单值，也可以是复杂类型。<br> 数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以是任意类型，包括简单值、对象，甚至其他数组。<br>JSON 没有变量、函数或对象实例的概念。JSON 的所有记号都只为表示结构化数据，虽然它借用了JavaScript 的语法，但是千万不要把它跟 JavaScript 语言混淆。</p>
<ul>
<li>简单值: 最简单的 JSON 可以是一个数值。例如，下面这个数值是有效的 JSON：<br>5<br>这个 JSON 表示数值 5。类似地，下面这个字符串也是有效的 JSON：<br>“Hello world!”<br>JavaScript 字符串与 JSON 字符串的主要区别是，JSON 字符串必须使用双引号（单引号会导致语法错误）。<br>布尔值和 null 本身也是有效的 JSON 值。不过，实践中更多使用 JSON 表示比较复杂的数据结构，其中会包含简单值。</li>
<li>对象: 对象使用与 JavaScript 对象字面量略为不同的方式表示。以下是 JavaScript 中的对象字面量：<br>let person &#x3D; {<br> name: “Nicholas”,<br> age: 29<br>};<br>虽然这对 JavaScript 开发者来说是标准的对象字面量，但 JSON 中的对象必须使用双引号把属性名包围起来。下面的代码与前面的代码是一样的：<br>let object &#x3D; {<br> “name”: “Nicholas”,<br> “age” : 29<br>};</li>
<li>数组: JSON 的第二种复杂数据类型是数组。数组在 JSON 中使用 JavaScript 的数组字面量形式表示。例如，以下是一个 JavaScript 数组：<br>let values &#x3D; [25, “hi”, true];<br>在 JSON 中可以使用类似语法表示相同的数组：<br>[25, “hi”, true]<br>3、解析与序列化: JSON 的迅速流行并不仅仅因为其语法与 JavaScript 类似，很大程度上还因为 JSON 可以直接被解析成可用的 JavaScript 对象。JSON 出现之后就迅速成为了 Web 服务的事实序列化标准。</li>
<li>JSON对象: 早期的 JSON 解析器基本上就相当于 JavaScript 的 eval()函数。因为 JSON 是 JavaScript 语法的子集，所以 eval()可以解析、解释，并将其作为 JavaScript 对象和数组返回。ECMAScript 5 增加了 JSON全局对象，正式引入解析 JSON 的能力。这个对象在所有主流浏览器中都得到了支持。旧版本的浏览器可以使用垫片脚本（参见 GitHub 上 douglascrockford&#x2F;JSON-js 中的 JSON in JavaScript）。考虑到直接执行代码的风险，最好不要在旧版本浏览器中只使用 eval()求值 JSON。这个 JSON 垫片脚本最好只在浏览器原生不支持 JSON 解析时使用。<br>JSON对象有两个方法: stringify()和 parse()。这两个方法分别用于序列化和解析 JSON。<br>在序列化 JavaScript 对象时，所有函数和原型成员都会有意地在结果中省略。此外，值为 undefined<br>的任何属性也会被跳过。最终得到的就是所有实例属性均为有效 JSON 数据类型的表示。<br>如果给 JSON.parse()传入的 JSON 字符串无效，则会导致抛出错误。</li>
<li>序列化选项: ，JSON.stringify()方法除了要序列化的对象，还可以接收两个参数。这两个参数可以用于指定其他序列化 JavaScript 对象的方式。第一个参数是过滤器，可以是数组或函数；第二个参数是用于缩进结果 JSON 字符串的选项。单独或组合使用这些参数可以更好地控制 JSON 序列化。<br>过滤结果: 如果第二个参数是一个数组，那么 JSON.stringify()返回的结果只会包含该数组中列出的对象属性。比如下面的例子：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line"> <span class="attr">authors</span>: [ </span><br><span class="line"> <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line"> <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line"> ], </span><br><span class="line"> <span class="attr">edition</span>: <span class="number">4</span>, </span><br><span class="line"> <span class="attr">year</span>: <span class="number">2017</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(book, [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;edition&quot;</span>]);</span><br></pre></td></tr></table></figure></div>
在这个例子中，JSON.stringify()方法的第二个参数是一个包含两个字符串的数组：”title”和”edition”。它们对应着要序列化的对象中的属性，因此结果 JSON 字符串中只会包含这两个属性：<br>{“title”:”Professional JavaScript”,”edition”:4}<br>如果第二个参数是一个函数，则行为又有不同。提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作。这个 key 始终是字符串，只是在值不属于某个键&#x2F;值对时会是空字符串。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123; </span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Professional JavaScript&quot;</span>, </span><br><span class="line"> <span class="attr">authors</span>: [ </span><br><span class="line"> <span class="string">&quot;Nicholas C. Zakas&quot;</span>, </span><br><span class="line"> <span class="string">&quot;Matt Frisbie&quot;</span> </span><br><span class="line"> ], </span><br><span class="line"> <span class="attr">edition</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">year</span>: <span class="number">2017</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(book, <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">switch</span>(key) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;authors&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> value.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>) </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;year&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="number">5000</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;edition&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">undefined</span>; </span><br><span class="line"> <span class="attr">default</span>: </span><br><span class="line"> <span class="keyword">return</span> value; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
最终得到的 JSON 字符串是这样的：<br>{“title”:”Professional JavaScript”,”authors”:”Nicholas C. Zakas,Matt<br>Frisbie”,”year”:5000}</li>
<li>字符串缩进: JSON.stringify()方法的第三个参数控制缩进和空格。在这个参数是数值时，表示每一级缩进的空格数。例如，每级缩进 4 个空格，可以这样：<br>let book &#x3D; {<br> title: “Professional JavaScript”,<br> authors: [<br> “Nicholas C. Zakas”,<br> “Matt Frisbie”<br> ],<br> edition: 4,<br> year: 2017<br>};<br>let jsonText &#x3D; JSON.stringify(book, null, 4);<br>这样得到的 jsonText 格式如下：<br>{<br> “title”: “Professional JavaScript”,<br> “authors”: [<br> “Nicholas C. Zakas”,<br> “Matt Frisbie”<br> ],<br> “edition”: 4,<br> “year”: 2017<br>}<br>如果缩进参数是一个字符串而非数值，那么 JSON 字符串中就会使用这个字符串而不是空格来缩进。使用字符串，也可以将缩进字符设置为 Tab 或任意字符，如两个连字符：<br>用字符串，也可以将缩进字符设置为 Tab 或任意字符，如两个连字符：<br>let jsonText &#x3D; JSON.stringify(book, null, “–” );<br>这样，jsonText 的值会变成如下格式：<br>{<br>–”title”: “Professional JavaScript”,<br>–”authors”: [<br>—-“Nicholas C. Zakas”,<br>—-“Matt Frisbie”<br>–],<br>–”edition”: 4,<br>–”year”: 2017<br>}</li>
<li>toJSON()方法: 对象需要在 JSON.stringify()之上自定义 JSON 序列化。此时，可以在要序列化的对象中添加 toJSON()方法，序列化时会基于这个方法返回适当的 JSON 表示。事实上，原生 Date 对象就有一个 toJSON()方法，能够自动将 JavaScript 的 Date 对象转换为 ISO 8601 日期字符串（本质上与在Date 对象上调用 toISOString()方法一样）。<br>下面的对象为自定义序列化而添加了一个 toJSON()方法：<br>let book &#x3D; {<br> title: “Professional JavaScript”,<br> authors: [<br> “Nicholas C. Zakas”,<br> “Matt Frisbie”<br> ],<br> edition: 4,<br> year: 2017,<br> toJSON: function() {<br>  return this.title;<br> }<br>};<br>let jsonText &#x3D; JSON.stringify(book);<br>这里 book 对象中定义的 toJSON()方法简单地返回了图书的书名（this.title）。<br>4、解析选项: JSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键&#x2F;值对都调用一次。为区别于传给 JSON.stringify()的起过滤作用的替代函数（replacer），这个函数被称为还原函数（reviver）。实际上它们的格式完全一样，即还原函数也接收两个参数，属性名（key）和属性值（value），另外也需要返回值。<br>如果还原函数返回 undefined，则结果中就会删除相应的键。如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。还原函数经常被用于把日期字符串转换为 Date 对象。例如：<br>let book &#x3D; {<br> title: “Professional JavaScript”,<br> authors: [<br> “Nicholas C. Zakas”,<br> “Matt Frisbie”<br> ],<br> edition: 4,<br> year: 2017,<br> releaseDate: new Date(2017, 11, 1)<br>};<br>let jsonText &#x3D; JSON.stringify(book);<br>let bookCopy &#x3D; JSON.parse(jsonText,<br> (key, value) &#x3D;&gt; key &#x3D;&#x3D; “releaseDate” ? new Date(value) : value);<br>alert(bookCopy.releaseDate.getFullYear());<br>5、小结: JSON 是一种轻量级数据格式，可以方便地表示复杂数据结构。这个格式使用 JavaScript 语法的一个子集表示对象、数组、字符串、数值、布尔值和 null。虽然 XML 也能胜任同样的角色，但 JSON 更简洁，JavaScript 支持也更好。更重要的是，所有浏览器都已经原生支持全局 JSON 对象。<br>ECMAScript 5 定义了原生 JSON 对象，用于将 JavaScript 对象序列化为 JSON 字符串，以及将 JSON数组解析为 JavaScript 对象。JSON.stringify()和 JSON.parse()方法分别用于实现这两种操作。这两个方法都有一些选项可以用来改变默认的行为，以实现过滤或修改流程。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-11 日报 Day153</title>
    <url>/undefined/2025-04-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>珍惜、善用时间资源，才能浇灌梦想花开，眺望硕果累累。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P675-693 第二十一章：错误处理与调试</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、 浏览器错误报告: </p>
<ul>
<li>桌面控制台: 所有现代桌面浏览器都会通过控制台暴露错误。这些错误可以显示在开发者工具内嵌的控制台中。在前面提到的所有浏览器中，访问开发者工具的路径是相似的。可能最简单的查看错误的方式就是在页面上单击鼠标右键，然后在上下文菜单中选择 Inspect（检查）或 Inspect Element（检查元素），然后再单击 Console（控制台）选项卡。</li>
<li>移动控制台: 移动浏览器不会直接在设备上提供控制台界面。不过，还是有一些途径可以在移动设备中检查错误。Chrome 移动版和 Safari 的 iOS 版内置了实用工具，支持将设备连接到宿主操作系统中相同的浏览器。然后，就可以在对应的桌面浏览器中查看错误了。这涉及设备之间的硬件连接，且要遵循不同的操作步骤。<br>2、错误处理: 错误处理在编程中的重要性毋庸置疑。所有主流 Web 应用程序都需要定义完善的错误处理协议，大多数优秀的应用程序有自己的错误处理策略，尽管主要逻辑是放在服务器端的。事实上，服务器端团队通常会花很多精力根据错误类型、频率和其他重要指标来定义规范的错误日志机制。最终实现通过简单的数据库查询或报告生成脚本就可以了解应用程序的运行状态。</li>
<li>try&#x2F;catch语句: ECMA-262 第 3 版新增了 try&#x2F;catch 语句，作为在 JavaScript 中处理异常的一种方式。基本的语法如下所示，跟 Java 中的 try&#x2F;catch 语句一样：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="comment">// 可能出错的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line"> <span class="comment">// 出错时要做什么</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任何可能出错的代码都应该放到 try 块中，而处理错误的代码则放在 catch 块中，如下所示：</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">someNonexistentFunction</span>(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error)&#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;An error happened!&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
如果 try 块中有代码发生错误，代码会立即退出执行，并跳到 catch 块中。catch 块此时接收到一个对象，该对象包含发生错误的相关信息。<br>finnally子句: try&#x2F;catch 语句中可选的 finally 子句始终运行。如果 try 块中的代码运行完，则接着执行finally 块中的代码。如果出错并执行 catch 块中的代码，则 finally 块中的代码仍执行。try 或catch 块无法阻止 finally 块执行，包括 return 语句。比如：<br>function testFinally(){<br> try {<br> return 2;<br> } catch (error){<br> return 1;<br> } finally {<br> return 0;<br> }<br>}<br>这个函数在 try&#x2F;catch 语句的各个部分都只放了一个 return 语句。看起来该函数应该返回 2，因为它在 try 块中，不会导致错误。但是，finally 块的存在导致 try 块中的 return 语句被忽略。因此，无论什么情况下调用该函数都会返回 0。如果去掉 finally 子句，该函数会返回 2。如果写出finally 子句，catch 块就成了可选的（它们两者中只有一个是必需的）。<br>错误类型: 代码执行过程中会发生各种类型的错误。每种类型都会对应一个错误发生时抛出的错误对象。ECMA-262 定义了以下 8 种错误类型：<br> Error<br> InternalError<br> EvalError<br> RangeError<br> ReferenceError<br> SyntaxError<br> TypeError<br> URIError<br>Error 是基类型，其他错误类型继承该类型。<br>InternalError 类型的错误会在底层 JavaScript 引擎抛出异常时由浏览器抛出。例如，递归过多导致了栈溢出。这个类型并不是代码中通常要处理的错误，如果真发生了这种错误，很可能代码哪里弄错了或者有危险了。<br>EvalError 类型的错误会在使用 eval()函数发生异常时抛出。<br>RangeError 错误会在数值越界时抛出。例如，定义数组时如果设置了并不支持的长度，如-20 或Number.MAX_VALUE，就会报告该错误。<br>ReferenceError 会在找不到对象时发生。<br>SyntaxError 经常在给 eval()传入的字符串包含 JavaScript 语法错误时发生。<br>TypeError 在 JavaScript 中很常见，主要发生在变量不是预期类型，或者访问不存在的方法时。很多原因可能导致这种错误，尤其是在使用类型特定的操作而变量类型不对时。</li>
<li>抛出错误: 与 try&#x2F;catch 语句对应的一个机制是 throw 操作符，用于在任何时候抛出自定义错误。throw 操作符必须有一个值，但值的类型不限。下面这些代码都是有效的：<br>throw 12345;<br>throw “Hello world!”;<br>throw true;<br>throw { name: “JavaScript” };<br>使用 throw 操作符时，代码立即停止执行，除非 try&#x2F;catch 语句捕获了抛出的值。<br>可以通过内置的错误类型来模拟浏览器错误。每种错误类型的构造函数都只接收一个参数，就是错误消息。下面看一个例子：<br>throw new Error(“Something bad happened.”);<br>以上代码使用一个自定义的错误消息生成了一个通用错误。浏览器会像处理自己生成的错误一样来处理这个自定义错误。换句话说，浏览器会像通常一样报告这个错误，最终显示这个自定义错误。当然，使用特定的错误类型也是一样的，如以下代码所示：<br>throw new SyntaxError(“I don’t like your syntax.”);<br>throw new InternalError(“I can’t do that, Dave.”);<br>throw new TypeError(“What type of variable do you take me for?”);<br>throw new RangeError(“Sorry, you just don’t have the range.”);<br>throw new EvalError(“That doesn’t evaluate.”);<br>throw new URIError(“Uri, is that you?”);<br>throw new ReferenceError(“You didn’t cite your references properly.”);<br>自定义错误常用的错误类型是 Error、RangeError、ReferenceError 和 TypeError。<br>此外，通过继承 Error（第 6 章介绍过继承）也可以创建自定义的错误类型。创建自定义错误类型时，需要提供 name 属性和 message 属性，比如：<br>class CustomError extends Error {<br> constructor(message) {<br> super(message);<br> this.name &#x3D; “CustomError”;<br> this.message &#x3D; message;<br> }<br>}<br>throw new CustomError(“My message”);</li>
<li>error事件: 任何没有被 try&#x2F;catch 语句处理的错误都会在 window 对象上触发 error 事件。<br>在 onerror 事件处理程序中，任何浏览器都不会传入 event 对象。相反，会传入 3 个参数：错误消息、发生错误的 URL 和行号。<br>window.onerror &#x3D; (message, url, line) &#x3D;&gt; {<br> console.log(message);<br>};<br>在任何错误发生时，无论是否是浏览器生成的，都会触发 error 事件并执行这个事件处理程序。然后，浏览器的默认行为就会生效，像往常一样显示这条错误消息。可以返回 false 来阻止浏览器默认报告错误的行为，如下所示：<br>window.onerror &#x3D; (message, url, line) &#x3D;&gt; {<br> console.log(message);<br> return false;<br>};</li>
<li>错误处理策略: 过去，Web 应用程序的错误处理策略基本上是在服务器上落地。错误处理策略涉及很多错误和错误处理考量，包括日志记录和监控系统。这些主要是为了分析模式，以期找到问题的根源并了解有多少用户会受错误影响。<br>在 Web 应用程序的 JavaScipt 层面落地错误处理策略同样重要。因为任何 JavaScript 错误都可能导致网页无法使用，所以理解这些错误会在什么情况下发生以及为什么会发生非常重要。绝大多数 Web 应用程序的用户不懂技术，在碰到页面出问题时通常会迷惑。为解决问题，他们可能会尝试刷新页面，也可能会直接放弃。作为开发者，应该非常清楚自己的代码在什么情况下会失败，以及失败会导致什么结果。另外，还要有一个系统跟踪这些问题。</li>
<li>识别错误: 错误处理非常重要的部分是首先识别错误可能会在代码中的什么地方发生。因为 JavaScript 是松散类型的，不会验证函数参数，所以很多错误只有在代码真正运行起来时才会出现。通常，需要注意 3 类错误：<br> 类型转换错误<br> 数据类型错误<br> 通信错误<br>静态代码分析器: 不得不说的是，通过在代码构建流程中添加静态代码分析或代码检查器（linter），可以预先发现非常多的错误。常用的静态分析工具是 JSHint、JSLint、Google Closure 和 TypeScript。<br>静态代码分析器要求使用类型、函数签名及其他指令来注解 JavaScript，以此描述程序如何在基本可执行代码之外运行。分析器会比较注解和 JavaScript 代码的各个部分，对在实际运行时可能出现的潜在不兼容问题给出提醒。<br>类型转换错误: 类型转换错误的主要原因是使用了会自动改变某个值的数据类型的操作符或语言构造。<br>数据类型错误: 因为 JavaScript 是松散类型的，所以变量和函数参数都不能保证会使用正确的数据类型。开发者需要自己检查数据类型，确保不会发生错误。数据类型错误常发生在将意外值传给函数的时候。<br>通信错误: 随着 Ajax 编程的出现，Web 应用程序在运行期间动态加载数据和功能成为常见的情形。JavaScript和服务器之间的通信也会出现错误。</li>
<li>区分重大与非重大错误: 任何错误处理策略中一个非常重要的方面就是确定某个错误是否为重大错误。具有以下一个或多个特性的错误属于非重大错误：<br> 不会影响用户的主要任务；<br> 只会影响页面中某个部分；<br> 可以恢复；<br> 重复操作可能成功。<br>另一方面，重大错误具备如下特性：<br> 应用程序绝对无法继续运行；<br> 错误严重影响了用户的主要目标；<br> 会导致其他错误发生。</li>
<li>把错误记录到服务器中: Web 应用程序开发中的一个常见做法是建立中心化的错误日志存储和跟踪系统。数据库和服务器错误正常写到日志中并按照常用 API 加以分类。对复杂的 Web 应用程序而言，最好也把 JavaScript 错误发送回服务器记录下来。这样做可以把错误记录到与服务器相同的系统，只要把它们归类到前端错误即可。使用相同的系统可以进行相同的分析，而不用考虑错误来源。<br>要建立 JavaScript 错误日志系统，首先需要在服务器上有页面或入口可以处理错误数据。该页面只要从查询字符串中取得错误数据，然后把它们保存到错误日志中即可。比如，该页面可以使用如下代码：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logError</span>(<span class="params">sev, msg</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>(), </span><br><span class="line"> encodedSev = <span class="built_in">encodeURIComponent</span>(sev), </span><br><span class="line"> encodedMsg = <span class="built_in">encodeURIComponent</span>(msg); </span><br><span class="line"> img.<span class="property">src</span> = <span class="string">&#x27;log.php?sev=$&#123;encodedSev&#125;&amp;msg=$&#123;encodedMsg&#125;&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
logError()函数接收两个参数：严重程度和错误消息。严重程度可以是数值或字符串，具体取决于使用的日志系统。这里使用 Image 对象发送请求主要是从灵活性方面考虑的。<br> 所有浏览器都支持 Image 对象，即使不支持 XMLHttpRequest 对象也一样。<br> 不受跨域规则限制。通常，接收错误消息的应该是多个服务器中的一个，而 XMLHttpRequest此时就比较麻烦。<br> 记录错误的过程很少出错。大多数 Ajax 通信借助 JavaScript 库的包装来处理。如果这个库本身出错，而你又要利用它记录错误，那么显然错误消息永远不会发给服务器。只要是使用 try&#x2F;catch 语句的地方，都可以把相关错误记录下来。下面是一个例子：<br>for (let mod of mods){<br> try {<br> mod.init();<br> } catch (ex){<br> logError(“nonfatal”, ‘Module init failed: ${ex.message}’);<br> }<br>}<br>在这个例子中，模块初始化失败就会调用 logError()函数。第一个参数是表示错误严重程度的”nonfatal”，第二个参数在上下文信息后面追加了 JavaScript 错误消息。记录到服务器的错误消息应该包含尽量多的上下文信息，以便找出错误的确切原因。<br>3、调试技术: 在 JavaScript 调试器出现以前，开发者必须使用创造性的方法调试代码。结果就出现了各种各样专门为输出调试信息而设计的代码。其中最为常用的调试技术是在相关代码中插入 alert()，这种方式既费事（调试完之后还得清理）又麻烦（如果有漏洞的警告框出现在产品环境中，会给用户造成不便）。已不再推荐将警告框用于调试，因为有其他更好的解决方案。</li>
<li>把消息记录到控制台: 所有主流浏览器都有 JavaScript 控制台，该控制台可用于查询 JavaScript 错误。另外，这些浏览器都支持通过 console 对象直接把 JavaScript 消息写入控制台，这个对象包含如下方法。<br> error(message)：在控制台中记录错误消息。<br> info(message)：在控制台中记录信息性内容。<br> log(message)：在控制台记录常规消息。<br> warn(message)：在控制台中记录警告消息。<br>注意 相比于使用警告框，打印日志消息是更好的调试方法。这是因为警告框会阻塞代码执行，从而影响对异步操作的计时，进而影响代码的结果。打印日志也可以随意输出任意多个参数并检查对象实例（警告框只能将对象序列化为一个字符串再展示出来，因此经常会看到 Object[Object]。</li>
<li>理解控制台运行时: 浏览器控制台是个读取-求值-打印-循环（REPL，read-eval-print-loop），与页面的 JavaScript 运行时并发。</li>
<li>使用js调试器: 在所有主流浏览器中都可以使用的还有 JavaScript 调试器。ECMAScript 5.1 规范定义了 debugger关键字，用于调用可能存在的调试功能。如果没有相关的功能，这条语句会被简单地跳过。可以像下面这样使用 debugger 关键字：<br>function pauseExecution(){<br> console.log(“Will print before breakpoint”);<br> debugger;<br> console.log(“Will not print until breakpoint continues”);<br>}</li>
<li>在页面中打印消息: 另一种常见的打印调试消息的方式是把消息写到页面中指定的区域。这个区域可以是所有页面中都包含的元素，但仅用于调试目的；也可以是在需要时临时创建的元素。</li>
<li>补充控制台方法: 记住使用哪个日志方法（原生的 console.log()和自定义的 log()方法），对开发者来说是一种负担。因为 console 是一个全局对象，所以可以为这个对象添加方法，也可以用自定义的函数重写已有的方法，这样无论在哪里用到的日志打印方法，都会按照自定义的方式行事。</li>
<li>抛出错误: 如前所述，抛出错误是调试代码的很好方式。如果错误消息足够具体，只要看一眼错误就可以确定原因。好的错误消息包含关于错误原因的确切信息，因此可以减少额外调试的工作量。比如下面的函数：<br>4、旧版IE的常见错误: </li>
<li>无效字符</li>
<li>未找到成员</li>
<li>未知运行时错误</li>
<li>语法错误</li>
<li>系统找不到指定资源<br>5、小结: 对于今天复杂的 Web 应用程序而言，JavaScript 中的错误处理十分重要。未能预测什么时候会发生错误以及如何从错误中恢复，会导致糟糕的用户体验，甚至造成用户流失。大多数浏览器默认不向用户报告 JavaScript 错误，因此在开发和调试时需要自己实现错误报告。不过在生产环境中，不应该以这种方式报告错误。<br>下列方法可用于阻止浏览器对 JavaScript 错误作出反应。<br> 使用 try&#x2F;catch 语句，可以通过更合适的方式对错误做出处理，避免浏览器处理。<br> 定义 window.onerror 事件处理程序，所有没有通过 try&#x2F;catch 处理的错误都会被该事件处理程序接收到（仅限 IE、Firefox 和 Chrome）。<br>开发 Web 应用程序时，应该认真考虑可能发生的错误，以及如何处理这些错误。<br> 首先，应该分清哪些算重大错误，哪些不算重大错误。<br> 然后，要通过分析代码预测很可能发生哪些错误。由于以下因素，JavaScript 中经常出现错误：<br> 类型转换；<br> 数据类型检测不足；<br> 向服务器发送错误数据或从服务器接收到错误数据。<br>IE、Firefox、Chrome、Opera 和 Safari 都有 JavaScript 调试器，有的内置在浏览器中，有的是作为扩展，需另行下载。所有调试器都能够设置断点、控制代码执行和在运行时检查变量值。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-12 日报 Day154</title>
    <url>/undefined/2025-04-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>选择所爱，爱所选择。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P694-702 第二十二章：处理 XML</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、浏览器对XML DOM的支持: XML 曾一度是在互联网上存储和传输结构化数据的标准。自从有了 DOM 标准，所有浏览器都开始原生支持 XML、XML DOM 及很多其他相关技术。</p>
<ul>
<li>DOM Level2 Core: DOM Level2 Core 定义了对 XML 文档的支持。它定义了一个通用的 API，允许脚本访问和操作 XML 文档。所有现代浏览器都支持 DOM Level2 Core。</li>
<li>DOMParser类型: 为把 XML 解析为 DOM 文档新增了 DOMParser 类型，后来所有其他浏览器也实现了该类型。要使用 DOMParser，需要先创建它的一个实例，然后再调用 parseFromString()方法。这个方法接收两个参数：要解析的 XML 字符串和内容类型（始终应该是”text&#x2F;html”）。返回值是 Document的实例。来看下面的例子：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parser = <span class="keyword">new</span> <span class="title class_">DOMParser</span>(); </span><br><span class="line"><span class="keyword">let</span> xmldom = parser.<span class="title function_">parseFromString</span>(<span class="string">&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;</span>, <span class="string">&quot;text/xml&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xmldom.<span class="property">documentElement</span>.<span class="property">tagName</span>); <span class="comment">// &quot;root&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xmldom.<span class="property">documentElement</span>.<span class="property">firstChild</span>.<span class="property">tagName</span>); <span class="comment">// &quot;child&quot; </span></span><br><span class="line"><span class="keyword">let</span> anotherChild = xmldom.<span class="title function_">createElement</span>(<span class="string">&quot;child&quot;</span>); </span><br><span class="line">xmldom.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(anotherChild); </span><br><span class="line"><span class="keyword">let</span> children = xmldom.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;child&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
DOMParser 只能解析格式良好的 XML，因此不能把 HTML 解析为 HTML 文档。在发生解析错误时，不同浏览器的行为也不一样。</li>
<li>XMLSerializer类型: XMLSerializer 类型提供了一个将 DOM 文档序列化为 XML 字符串的方法。该方法是 serializeToString()，接收一个 Document 或 Element 实例作为参数。要序列化DOM文档，必须创建XMLSerializer 的新实例，然后把文档传给serializeToString()方法，如下所示：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serializer = <span class="keyword">new</span> <span class="title class_">XMLSerializer</span>(); </span><br><span class="line"><span class="keyword">let</span> xml = serializer.<span class="title function_">serializeToString</span>(xmldom); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xml);</span><br></pre></td></tr></table></figure></div>
2、浏览器对XPath的支持: XPath 是为了在 DOM 文档中定位特定节点而创建的，因此它对 XML 处理很重要。</li>
<li>DOM Level 3 XPath: DOM Level 3 XPath 规范定义了接口，用于在 DOM 中求值 XPath 表达式。要确定浏览器是否支持DOM Level 3 XPath，可以使用以下代码：<br>let supportsXPath &#x3D; document.implementation.hasFeature(“XPath”, “3.0”);</li>
<li>单个节点结果: XPathResult.FIRST_ORDERED_NODE_TYPE 结果类型返回匹配的第一个节点，可以通过结果的singleNodeValue 属性获取。</li>
<li>简单类型结果: 使用布尔值、数值和字符串 XPathResult 类型，可以根据 XPath 获取简单、非节点数据类型。这些结果类型返回的值需要分别使用 booleanValue、numberValue 和 stringValue 属性获取。对于布尔值类型，如果至少有一个节点匹配 XPath 表达式，booleanValue 就是 true；否则，booleanValue为 false。</li>
<li>默认类型结果: 所有 XPath 表达式都会自动映射到特定类型的结果。设置特定结果类型会限制表达式的输出。</li>
<li>命名空间支持: 对于使用命名空间的 XML 文档，必须告诉 XPathEvaluator 命名空间信息，才能进行正确求值。<br>3、浏览器对XSLT的支持: 可扩展样式表语言转换（XSLT，Extensible Stylesheet Language Transformations）是与 XML 相伴的一种技术，可以利用 XPath 将一种文档表示转换为另一种文档表示。与 XML 和 XPath 不同，XSLT 没有与之相关的正式 API，正式的 DOM 中也没有涵盖它。因此浏览器都以自己的方式实现 XSLT。</li>
<li>XSLTProcessor类型: Mozilla 通过增加了一个新类型 XSLTProcessor，在 JavaScript 中实现了对 XSLT 的支持。通过使用 XSLTProcessor 类型，开发者可以使用 XSLT 转换 XML 文档，其方式类似于在 IE 中使用 XSL 处理器。自从 XSLTProcessor 首次实现以来，所有浏览器都照抄了其实现，从而使 XSLTProcessor 成了通过 JavaScript 完成 XSLT 转换的事实标准。</li>
<li>使用参数: XSLTProcessor 还允许使用 setParameter()方法设置 XSLT 参数。该方法接收三个参数：命名空间 URI、参数本地名称和要设置的值。</li>
<li>重置处理器: 每个 XSLTProcessor 实例都可以重用于多个转换，只是要使用不同的 XSLT 样式表。处理器的reset()方法可以删除所有参数和样式表。<br>4、小结: 浏览器对使用 JavaScript 处理 XML 实现及相关技术相当支持。然而，由于早期缺少规范，常用的功能出现了不同实现。DOM Level 2 提供了创建空 XML 文档的 API，但不能解析和序列化。浏览器为解析和序列化 XML 实现了两个新类型。<br> DOMParser 类型是简单的对象，可以将 XML 字符串解析为 DOM 文档。<br> XMLSerializer 类型执行相反操作，将 DOM 文档序列化为 XML 字符串。<br>基于所有主流浏览器的实现，DOM Level 3 新增了针对 XPath API 的规范。该 API 可以让 JavaScript针对 DOM 文档执行任何 XPath 查询并得到不同数据类型的结果。<br>最后一个与 XML相关的技术是 XSLT，目前并没有规范定义其 API。Firefox最早增加了 XSLTProcessor类型用于通过 JavaScript 处理转换。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-14 日报 Day156</title>
    <url>/undefined/2025-04-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有人说，世界上最美好的事情就是：我已经长大，你还未老，我有能力报答，你仍然健康。当父母不在年轻，他们最需要的是陪伴。记得常回家看看，忙碌的日程里也要给家留好位置，记得多陪父母聊聊天，简短的日子也能温暖他们许多日子。来日并不方长，请紧紧握住他们变老的手，余生陪他们慢慢走。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P711-717 第二十四章：网络请求与远程资源</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、把 Ajax 推到历史舞台上的关键技术是 XMLHttpRequest（XHR）对象。Fetch API 支持期约（promise）和服务线程（service worker），已经成为极其强大的 Web 开发工具。<br>2、XMLHttpRequest 对象: XMLHttpRequest 对象是浏览器提供的一个 API，用于在后台与服务器交换数据。所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象：<br>let xhr &#x3D; new XMLHttpRequest();</p>
<ul>
<li>使用XHR: 使用XHR对象首先先要调用 open()方法，这个方法接收 3 个参数：请求类型（”get”、”post”等）、请求 URL，以及表示请求是否异步的布尔值。下面是一个例子：<br>xhr.open(“get”, “example.php”, false);<br>这行代码就可以向 example.php 发送一个同步的 GET 请求。关于这行代码需要说明几点。首先，这里的 URL 是相对于代码所在页面的，当然也可以使用绝对 URL。其次，调用 open()不会实际发送请求，只是为发送请求做好准备。<br>注意 只能访问同源 URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与发送请求的页面在任何方面有所不同，则会抛出安全错误。<br>要发送定义好的请求，必须像下面这样调用 send()方法：<br>xhr.open(“get”, “example.txt”, false);<br>xhr.send(null);<br>send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传 null，因为这个参数在某些浏览器中是必需的。调用 send()之后，请求就会发送到服务器。<br>因为这个请求是同步的，所以 JavaScript 代码会等待服务器响应之后再继续执行。收到响应后，XHR对象的以下属性会被填充上数据。<br> responseText：作为响应体返回的文本。<br> responseXML：如果响应的内容类型是”text&#x2F;xml”或”application&#x2F;xml”，那就是包含响应数据的 XML DOM 文档。<br> status：响应的 HTTP 状态。<br> statusText：响应的 HTTP 状态描述。<br>收到响应后，第一步要检查 status 属性以确保响应成功返回。一般来说，HTTP 状态码为 2xx 表示成功。此时，responseText 或 responseXML（如果内容类型正确）属性中会有内容。如果 HTTP状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。为确保收到正确的响应，应该检查这些状态，如下所示：<br>xhr.open(“get”, “example.txt”, false);<br>xhr.send(null);<br>if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304) {<br> alert(xhr.responseText);<br>} else {<br> alert(“Request was unsuccessful: “ + xhr.status);<br>}<br>虽然可以像前面的例子一样发送同步请求，但多数情况下最好使用异步请求，这样可以不阻塞JavaScript 代码继续执行。XHR 对象有一个 readyState 属性，表示当前处在请求&#x2F;响应过程的哪个阶段。这个属性有如下可能的值。<br> 0：未初始化（Uninitialized）。尚未调用 open()方法。<br> 1：已打开（Open）。已调用 open()方法，尚未调用 send()方法。<br> 2：已发送（Sent）。已调用 send()方法，尚未收到响应。<br> 3：接收中（Receiving）。已经收到部分响应。<br> 4：完成（Complete）。已经收到所有响应，可以使用了。<br>每次 readyState 从一个值变成另一个值，都会触发 readystatechange 事件。可以借此机会检查 readyState 的值。一般来说，我们唯一关心的 readyState 值是 4，表示数据已就绪。为保证跨浏览器兼容，onreadystatechange 事件处理程序应该在调用 open()之前赋值。来看下面的例子：<br>let xhr &#x3D; new XMLHttpRequest();<br>xhr.onreadystatechange &#x3D; function() {<br> if (xhr.readyState &#x3D;&#x3D; 4) {<br> if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304) {<br> alert(xhr.responseText);<br> } else {<br> alert(“Request was unsuccessful: “ + xhr.status);<br> }<br> }<br>};<br>xhr.open(“get”, “example.txt”, true);<br>xhr.send(null);<br>在收到响应之前如果想取消异步请求，可以调用 abort()方法：<br>xhr.abort();<br>调用这个方法后，XHR 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中断请求后，应该取消对 XHR 对象的引用。由于内存问题，不推荐重用 XHR 对象</li>
<li>HTTP头部: 每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一些方法暴露与请求和响应相关的头部字段。默认情况下，XHR 请求会发送以下头部字段。<br> Accept：浏览器可以处理的内容类型。<br> Accept-Charset：浏览器可以显示的字符集。<br> Accept-Encoding：浏览器可以处理的压缩编码类型。<br> Accept-Language：浏览器使用的语言。<br> Connection：浏览器与服务器的连接类型。<br> Cookie：页面中设置的 Cookie。<br> Host：发送请求的页面所在的域。<br> Referer：发送请求的页面的 URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容性也必须将错就错。（正确的拼写应该是 Referrer。）<br> User-Agent：浏览器的用户代理字符串。<br>虽然不同浏览器发送的确切头部字段可能各不相同，但这些通常都是会发送的。如果需要发送额外的请求头部，可以使用 setRequestHeader()方法。这个方法接收两个参数：头部字段的名称和值。为保证请求头部被发送，必须在 open()之后、send()之前调用 setRequestHeader()，如下面的例<br>子所示：<br>let xhr &#x3D; new XMLHttpRequest();<br>xhr.onreadystatechange &#x3D; function() {<br> if (xhr.readyState &#x3D;&#x3D; 4) {<br> if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304) {<br> alert(xhr.responseText);<br> } else {<br> alert(“Request was unsuccessful: “ + xhr.status);<br> }<br> }<br>};<br>xhr.open(“get”, “example.php”, true);<br>xhr.setRequestHeader(“MyHeader”, “MyValue”);<br>xhr.send(null);</li>
<li>GET请求: 最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时，需要在 GET 请求的 URL后面添加查询字符串参数。对 XHR 而言，查询字符串必须正确编码后添加到 URL 后面，然后再传给open()方法。<br>发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用encodeURIComponent()编码，所有名&#x2F;值对必须以和号（&amp;）分隔，如下面的例子所示：<br>xhr.open(“get”, “example.php?name1&#x3D;value1&amp;name2&#x3D;value2”, true);<br>可以使用以下函数将查询字符串参数添加到现有的 URL 末尾：<br>function addURLParam(url, name, value) {<br> url +&#x3D; (url.indexOf(“?”) &#x3D;&#x3D; -1 ? “?” : “&amp;”);<br> url +&#x3D; encodeURIComponent(name) + “&#x3D;” + encodeURIComponent(value);<br> return url;<br>}</li>
<li>POST请求: 第二个最常用的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据可以是任意格式。要初始化 POST 请求，open()方法的第一个参数要传”post”，比如：<br>xhr.open(“post”, “example.php”, true);<br>默认情况下，对服务器而言，POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST数据才能取得浏览器发送的数据。不过，可以使用 XHR 模拟表单提交。为此，第一步需要把 ContentType 头部设置为”application&#x2F;x-www-formurlencoded”，这是提交表单时使用的内容类型。第二步是创建对应格式的字符串。POST 数据此时使用与查询字符串相同的格式。如果网页中确实有一个表单需要序列化并通过 XHR 发送到服务器，则可以使用第 14 章的 serialize()函数来创建相应的字符串，如下所示：<br>function submitData() {<br> let xhr &#x3D; new XMLHttpRequest();<br> xhr.onreadystatechange &#x3D; function() {<br> if (xhr.readyState &#x3D;&#x3D; 4) {<br> if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304) {<br> alert(xhr.responseText);<br> } else {<br> alert(“Request was unsuccessful: “ + xhr.status);<br> }<br> }<br> };<br> xhr.open(“post”, “postexample.php”, true);<br> xhr.setRequestHeader(“Content-Type”, “application&#x2F;x-www-form-urlencoded”);<br> let form &#x3D; document.getElementById(“user-info”);<br> xhr.send(serialize(form));<br>}<br>注意 POST 请求相比 GET 请求要占用更多资源。从性能方面说，发送相同数量的数据，GET 请求比 POST 请求要快两倍。</li>
<li>XMLHttpRequest Level2: 现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了FormData 类型。FormData 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR发送。下面的代码创建了一个 FormData 对象，并填充了一些数据：<br>let data &#x3D; new FormData();<br>data.append(“name”, “Nicholas”);<br>append()方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意多个键&#x2F;值对数据。此外，通过直接给 FormData 构造函数传入一个表单元素，也可以将表单中的数据作为键&#x2F;值对填充进去：<br>let data &#x3D; new FormData(document.forms[0]);<br>有了 FormData 实例，可以像下面这样直接传给 XHR 对象的 send()方法：<br>let xhr &#x3D; new XMLHttpRequest();<br>xhr.onreadystatechange &#x3D; function() {<br> if (xhr.readyState &#x3D;&#x3D; 4) {<br> if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304) {<br> alert(xhr.responseText);<br> } else {<br> alert(“Request was unsuccessful: “ + xhr.status);<br> }<br> }<br>};<br>xhr.open(“post”, “postexample.php”, true);<br>let form &#x3D; document.getElementById(“user-info”);<br>xhr.send(new FormData(form));<br>使用 FormData 的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能够识别作为 FormData 实例传入的数据类型并自动配置相应的头部。<br>IE8 给 XHR 对象增加了一个 timeout 属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有浏览器都在自己的 XHR 实现中增加了这个属性。在给 timeout 属性设置了一个时间且在该时间过后没有收到响应时，XHR 对象就会触发 timeout 事件，调用 ontimeout 事件处理程序。这个特性后来也被添加到了 XMLHttpRequest Level 2 规范。下面看一个例子：<br>let xhr &#x3D; new XMLHttpRequest();<br>xhr.onreadystatechange &#x3D; function() {<br> if (xhr.readyState &#x3D;&#x3D; 4) {<br> try {<br> if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304) {<br> alert(xhr.responseText);<br> } else {<br> alert(“Request was unsuccessful: “ + xhr.status);<br> }<br> } catch (ex) {<br> &#x2F;&#x2F; 假设由 ontimeout 处理<br> }<br> }<br>};<br>xhr.open(“get”, “timeout.php”, true);<br>xhr.timeout &#x3D; 1000; &#x2F;&#x2F; 设置 1 秒超时<br>xhr.ontimeout &#x3D; function() {<br> alert(“Request did not return in a second.”);<br>};<br>xhr.send(null);<br>Firefox 首先引入了 overrideMimeType()方法用于重写 XHR 响应的 MIME 类型。这个特性后来也被添加到了 XMLHttpRequest Level 2。因为响应返回的 MIME 类型决定了 XHR 对象如何处理响应，所以如果有办法覆盖服务器返回的类型，那么是有帮助的<br>假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 text&#x2F;plain。结果就会导致虽然数据是 XML，但 responseXML 属性值是 null。此时调用 overrideMimeType()可以保证将响应当成 XML 而不是纯文本来处理：<br>let xhr &#x3D; new XMLHttpRequest();<br>xhr.open(“get”, “text.php”, true);<br>xhr.overrideMimeType(“text&#x2F;xml”);<br>xhr.send(null);</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-15 日报 Day157</title>
    <url>/undefined/2025-04-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>将生活嚼得有滋有味，把日子过得活色生香，往往靠的不只是嘴，还要有一颗浸透人间烟火的心。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P718-734 第二十四章：网络请求与远程资源</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、进度事件: Progress Events 是 W3C 的工作草案，定义了客户端服务器端通信。这些事件最初只针对 XHR，现在也推广到了其他类似的 API。有以下 6 个进度相关的事件。<br> loadstart：在接收到响应的第一个字节时触发。<br> progress：在接收响应期间反复触发。<br> error：在请求出错时触发。<br> abort：在调用 abort()终止连接时触发。<br> load：在成功接收完响应时触发。<br> loadend：在通信完成时，且在 error、abort 或 load 之后触发。<br>每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort或 load 中的一个，最后以 loadend 事件结束。这些事件大部分都很好理解，但其中有两个需要说明一下。</p>
<ul>
<li>load事件: 最终，增加了一个 load 事件用于替代readystatechange 事件。load 事件在响应接收完成后立即触发，这样就不用检查 readyState 属性了。onload 事件处理程序会收到一个 event 对象，其 target 属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法。不过，并不是所有浏览器都实现了这个事件的 event 对象。考虑到跨浏览器兼容，还是需要像下面这样使用 XHR 对象变量：</li>
<li>progress 事件: Mozilla 在 XHR 对象上另一个创新是 progress 事件，在浏览器接收数据期间，这个事件会反复触发。每次触发时，onprogress 事件处理程序都会收到 event 对象，其 target 属性是 XHR 对象，且包含 3 个额外属性：lengthComputable、position 和 totalSize。其中，lengthComputable 是一个布尔值，表示进度信息是否可用；position 是接收到的字节数；totalSize 是响应的 ContentLength 头部定义的总字节数。有了这些信息，就可以给用户提供进度条了。以下代码演示了如何向用户展示进度：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || </span><br><span class="line"> xhr.<span class="property">status</span> == <span class="number">304</span>) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> divStatus = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>); </span><br><span class="line"> <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123; </span><br><span class="line"> divStatus.<span class="property">innerHTML</span> = <span class="string">&quot;Received &quot;</span> + event.<span class="property">position</span> + <span class="string">&quot; of &quot;</span> + </span><br><span class="line"> event.<span class="property">totalSize</span> + </span><br><span class="line"><span class="string">&quot; bytes&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;altevents.php&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>
为了保证正确执行，必须在调用 open()之前添加 onprogress 事件处理程序。在前面的例子中，每次触发 progress 事件都会更新 HTML 元素中的信息。假设响应有 Content-Length 头部，就可以利用这些信息计算出已经收到响应的百分比。<br>2、跨源资源共享: 通过 XHR 进行 Ajax 通信的一个主要限制是跨源安全策略。默认情况下，XHR 只能访问与发起请求的页面在同一个域内的资源。这个安全限制可以防止某些恶意行为。不过，浏览器也需要支持合法跨源访问的能力。<br>跨源资源共享（CORS，Cross-Origin Resource Sharing）定义了浏览器与服务器如何实现跨源通信。CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。<br>对于简单的请求，比如 GET 或 POST 请求，没有自定义头部，而且请求体是 text&#x2F;plain 类型，这样的请求在发送时会有一个额外的头部叫 Origin。Origin 头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。下面是 Origin 头部的一个示例：<br>Origin: <a class="link"   href="http://www.nczonline.net/" >http://www.nczonline.net <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；<br>或者如果资源是公开的，那么就包含”*”。比如：<br>Access-Control-Allow-Origin: <a class="link"   href="http://www.nczonline.net/" >http://www.nczonline.net <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。<br>现代浏览器通过 XMLHttpRequest 对象原生支持 CORS。在尝试访问不同源的资源时，这个行为会被自动触发。要向不同域的源发送请求，可以使用标准 XHR对象并给 open()方法传入一个绝对 URL，比如：<br>let xhr &#x3D; new XMLHttpRequest();<br>xhr.onreadystatechange &#x3D; function() {<br> if (xhr.readyState &#x3D;&#x3D; 4) {<br> if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status &#x3D;&#x3D; 304) {<br> alert(xhr.responseText);<br> } else {<br> alert(“Request was unsuccessful: “ + xhr.status);<br> }<br> }<br>};<br>xhr.open(“get”, “<a class="link"   href="http://www.somewhere-else.com/page/" >http://www.somewhere-else.com/page/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“, true);<br>xhr.send(null);<br>跨域 XHR 对象允许访问 status 和 statusText 属性，也允许同步请求。出于安全考虑，跨域 XHR对象也施加了一些额外限制。<br> 不能使用 setRequestHeader()设置自定义头部。<br> 不能发送和接收 cookie。<br> getAllResponseHeaders()方法始终返回空字符串。<br>因为无论同域还是跨域请求都使用同一个接口，所以最好在访问本地资源时使用相对 URL，在访问远程资源时使用绝对 URL。这样可以更明确地区分使用场景，同时避免出现访问本地资源时出现头部或cookie 信息访问受限的问题。</li>
<li>预检请求: CORS 通过一种叫预检请求（preflighted request）的服务器验证机制，允许使用自定义头部、除 GET和 POST 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个“预检”请求。这个请求使用 OPTIONS 方法发送并包含以下头部。<br> Origin：与简单请求相同。<br> Access-Control-Request-Method：请求希望使用的方法。<br> Access-Control-Request-Headers：（可选）要使用的逗号分隔的自定义头部列表。<br>下面是一个假设的 POST 请求，包含自定义的 NCZ 头部：<br>Origin: <a class="link"   href="http://www.nczonline.net/" >http://www.nczonline.net <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Access-Control-Request-Method: POST<br>Access-Control-Request-Headers: NCZ<br>在这个请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送如下头部与浏览器沟通这些信息。<br> Access-Control-Allow-Origin：与简单请求相同。<br> Access-Control-Allow-Methods：允许的方法（逗号分隔的列表）。<br> Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）。<br> Access-Control-Max-Age：缓存预检请求的秒数。<br>例如：<br>Access-Control-Allow-Origin: <a class="link"   href="http://www.nczonline.net/" >http://www.nczonline.net <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Access-Control-Allow-Methods: POST, GET<br>Access-Control-Allow-Headers: NCZ<br>Access-Control-Max-Age: 1728000<br>预检请求返回后，结果会按响应指定的时间缓存一段时间。换句话说，只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求。</li>
<li>凭据请求: 默认情况下，跨源请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书）。可以通过将withCredentials 属性设置为 true 来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下 HTTP 头部：<br>Access-Control-Allow-Credentials: true<br>如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给 JavaScript（responseText 是空字符串，status 是 0，onerror()被调用）。注意，服务器也可以在预检请求的响应中发送这个 HTTP 头部，以表明这个源允许发送凭据请求。<br>3、替代性跨域技术: CORS 出现之前，实现跨源 Ajax 通信是有点麻烦的。开发者需要依赖能够执行跨源请求的 DOM 特性，在不使用 XHR 对象情况下发送某种类型的请求。虽然 CORS 目前已经得到广泛支持，但这些技术仍然没有过时，因为它们不需要修改服务器。</li>
<li>图片探测: 图片探测是利用<img>标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告跟踪的主要方式。可以动态创建图片，然后通过它们的 onload 和onerror 事件处理程序得知何时收到响应。<br>这种动态创建图片的技术经常用于图片探测（image pings）。图片探测是与服务器之间简单、跨域、单向的通信。数据通过查询字符串发送，响应可以随意设置，不过一般是位图图片或值为 204 的状态码。浏览器通过图片探测拿不到任何数据，但可以通过监听 onload 和 onerror 事件知道什么时候能接收到响应。下面看一个例子：<br>let img &#x3D; new Image();<br>img.onload &#x3D; img.onerror &#x3D; function() {<br> alert(“Done!”);<br>};<br>img.src &#x3D; “<a class="link"   href="http://www.example.com/test?name=Nicholas" >http://www.example.com/test?name=Nicholas <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“;<br>这个例子创建了一个新的 Image 实例，然后为它的 onload 和 onerror 事件处理程序添加了同一个函数。这样可以确保请求完成时无论什么响应都会收到通知。设置完 src 属性之后请求就开始了，这个例子向服务器发送了一个 name 值。<br>图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。当然，图片探测的缺点是只能发送 GET 请求和无法获取服务器响应的内容。这也是只能利用图片探测实现浏览器与服务器单向通信的原因。</li>
<li>JSONP: JSONP 是“JSON with padding”的简写，是在 Web 服务上流行的一种 JSON 变体。JSONP 看起来跟 JSON 一样，只是会被包在一个函数调用里，比如：<br>callback({ “name”: “Nicholas” });<br>JSONP 格式包含两个部分：回调和数据。回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。而数据就是作为参数传给回调函数的 JSON 数据。下面是一个典型的 JSONP 请求：<br><a class="link"   href="http://freegeoip.net/json/?callback=handleResponse" >http://freegeoip.net/json/?callback=handleResponse <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>这个 JSONP 请求的 URL 是一个地理位置服务。JSONP 服务通常支持以查询字符串形式指定回调函数的名称。比如这个例子就把回调函数的名字指定为 handleResponse()。<br>JSONP 调用是通过动态创建<script>元素并为 src 属性指定跨域 URL 实现的。此时的<script>与<img>元素类似，能够不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript，所以 JSONP响应在被加载完成之后会立即执行。比如下面这个例子：<br>function handleResponse(response) {<br> console.log(<code>   You&#39;re at IP address $&#123;response.ip&#125;, which is in   $&#123;response.city&#125;, $&#123;response.region_name&#125;</code>);<br>}<br>let script = document.createElement("script");<br>script.src = "<a class="link"   href="http://freegeoip.net/json/?callback=handleResponse" >http://freegeoip.net/json/?callback=handleResponse <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>";<br>document.body.insertBefore(script, document.body.firstChild);<br>JSONP 由于其简单易用，在开发者中非常流行。相比于图片探测，使用 JSONP 可以直接访问响应，实现浏览器与服务器的双向通信。不过 JSONP 也有一些缺点。<br>首先，JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时，一定要保证是可以信任的。<br>第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了<script>元素的 onerror 事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的。<br>4、Fetch API: Fetch API 能够执行 XMLHttpRequest 对象的所有任务，但更容易使用，接口也更现代化，能够在Web 工作线程等现代 Web 工具中使用。XMLHttpRequest 可以选择异步，而 Fetch API 则必须是异步。<br>Fetch API 本身是使用 JavaScript 请求资源的优秀工具，同时这个 API 也能够应用在服务线程（service worker）中，提供拦截、重定向和修改通过 fetch()生成的请求接口</li>
<li>基本用法: fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法，浏览器就会向给定 URL 发送请求。<br>分派请求: fetch()只有一个必需的参数 input。多数情况下，这个参数是要获取资源的 URL。这个方法返回一个期约：<br>let r = fetch('/bar');<br>console.log(r); // Promise <pending><br>URL 的格式（相对路径、绝对路径等）的解释与 XHR 对象一样。请求完成、资源可用时，期约会解决为一个 Response 对象。这个对象是 API 的封装，可以通过它取得相应资源。<br>读取响应: 读取响应内容的最简单方式是取得纯文本格式的内容，这要用到 text()方法。这个方法返回一个期约，会解决为取得资源的完整内容：<br>处理状态吗和请求失败: Fetch API 支持通过 Response 的 status（状态码）和 statusText（状态文本）属性检查响应状态。成功获取响应的请求通常会产生值为 200 的状态码，请求不存在的资源通常会产生值为 404 的状态码，请求的 URL 如果抛出服务器错误会产生值为 500 的状态码。违反 CORS、无网络连接、HTTPS 错配及其他浏览器/网络策略问题都会导致期约被拒绝。<br>自定义选项: 只使用 URL 时，fetch()会发送 GET 请求，只包含最低限度的请求头。要进一步配置如何发送请求，需要传入可选的第二个参数 init 对象。</li>
<li>常见Fetch请求模式: 与 XMLHttpRequest 一样，fetch()既可以发送数据也可以接收数据。使用 init 对象参数，可以配置 fetch()在请求体中发送各种序列化的数据。<br>发送JSON数据: 可以像下面这样发送简单 JSON 字符串：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; </span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">let</span> jsonHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123; </span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-json&#x27;</span>, &#123; </span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line"> <span class="attr">body</span>: payload, </span><br><span class="line"> <span class="attr">headers</span>: jsonHeaders </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
在请求体中发送参数: 因为请求体支持任意字符串值，所以可以通过它发送请求参数：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> paramHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123; </span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span> </span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-params&#x27;</span>, &#123; </span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line"> <span class="attr">body</span>: payload, </span><br><span class="line"> <span class="attr">headers</span>: paramHeaders </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
发送文件: 因为请求体支持 FormData 实现，所以 fetch()也可以序列化并发送文件字段中的文件：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>(); </span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>); </span><br><span class="line">imageFormData.<span class="title function_">append</span>(<span class="string">&#x27;image&#x27;</span>, imageInput.<span class="property">files</span>[<span class="number">0</span>]); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/img-upload&#x27;</span>, &#123; </span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line"> <span class="attr">body</span>: imageFormData </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这个 fetch()实现可以支持多个文件：</span></span><br><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>(); </span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;][multiple]&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageInput.<span class="property">files</span>.<span class="property">length</span>; ++i) &#123; </span><br><span class="line"> imageFormData.<span class="title function_">append</span>(<span class="string">&#x27;image&#x27;</span>, imageInput.<span class="property">files</span>[i]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/img-upload&#x27;</span>, &#123; </span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line"> <span class="attr">body</span>: imageFormData </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
加载Blob文件: Fetch API也能提供 Blob 类型的响应，而 Blob 又可以兼容多种浏览器 API。一种常见的做法是明确将图片文件加载到内存，然后将其添加到 HTML图片元素。为此，可以使用响应对象上暴露的 blob()方法。这个方法返回一个期约，解决为一个 Blob 的实例。然后，可以将这个实例传给 URL.createObjectUrl()以生成可以添加给图片元素 src 属性的值：<br>const imageElement = document.querySelector('img');<br>fetch('my-image.png')<br> .then((response) => response.blob())<br> .then((blob) => {<br> imageElement.src = URL.createObjectURL(blob);<br> });<br>发送跨域请求: 从不同的源请求资源，响应要包含 CORS 头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误。<br>fetch('//cross-origin.com');<br>// TypeError: Failed to fetch<br>// No 'Access-Control-Allow-Origin' header is present on the requested resource.<br>中断请求: Fetch API 支持通过 AbortController/AbortSignal 对中断请求。调用 AbortController. abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的 fetch()请求会导致包含错误的拒绝。<br>let abortController = new AbortController();<br>fetch('wikipedia.zip', { signal: abortController.signal })<br> .catch(() => console.log('aborted!');<br>// 10 毫秒后中断请求<br>setTimeout(() => abortController.abort(), 10);<br>// 已经中断</li>
<li>Headers对象: Headers 对象是所有外发请求和入站响应头部的容器。每个外发的 Request 实例都包含一个空的Headers 实例，可以通过 Request.prototype.headers 访问，每个入站 Response 实例也可以通过Response.prototype.headers 访问包含着响应头部的 Headers 对象。这两个属性都是可修改属性。另外，使用 new Headers()也可以创建一个新实例。<br>Headers与Map的相似之处: HTTP 头部本质上是序列化后的键/值对，它们的 JavaScript 表示则是中间接口。Headers 与 Map 类型都有 get()、set()、has()和 delete()等实例方法，如下面的代码所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(); </span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="comment">// 设置键</span></span><br><span class="line">h.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="comment">// 检查键</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">has</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar </span></span><br><span class="line"><span class="comment">// 更新值</span></span><br><span class="line">h.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="comment">// 取得更新的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// baz </span></span><br><span class="line"><span class="comment">// 删除值</span></span><br><span class="line">h.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="comment">// 确定值已经删除</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Headers 和 Map 都可以使用一个可迭代对象来初始化，比如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seed = [[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]]; </span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(seed); </span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(seed); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而且，它们也都有相同的 keys()、values()和 entries()迭代器接口：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seed = [[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], [<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>]]; </span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Headers</span>(seed); </span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(seed); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...h.<span class="title function_">keys</span>()); <span class="comment">// foo, baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...m.<span class="title function_">keys</span>()); <span class="comment">// foo, baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...h.<span class="title function_">values</span>()); <span class="comment">// bar, qux </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...m.<span class="title function_">values</span>()); <span class="comment">// bar, qux </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...h.<span class="title function_">entries</span>()); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, &#x27;qux&#x27;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...m.<span class="title function_">entries</span>()); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, &#x27;qux&#x27;]</span></span><br></pre></td></tr></table></figure></div>
Headers独有的特性: Headers 并不是与 Map 处处都一样。在初始化 Headers 对象时，也可以使用键/值对形式的对象，而 Map 则不可以：<br>let seed = {foo: 'bar'};<br>let h = new Headers(seed);<br>console.log(h.get('foo')); // bar<br>let m = new Map(seed);<br>// TypeError: object is not iterable<br>一个 HTTP 头部字段可以有多个值，而 Headers 对象通过 append()方法支持添加多个值。在Headers 实例中还不存在的头部上调用 append()方法相当于调用 set()。后续调用会以逗号为分隔符拼接多个值：<br>let h = new Headers();<br>h.append('foo', 'bar');<br>console.log(h.get('foo')); // "bar"<br>h.append('foo', 'baz');<br>console.log(h.get('foo')); // "bar, baz"<br>头部护卫: 某些情况下，并非所有 HTTP 头部都可以被客户端修改，而 Headers 对象使用护卫来防止不被允许的修改。不同的护卫设置会改变 set()、append()和 delete()的行为。违反护卫限制会抛出TypeError。</li>
<li>Request对象: 顾名思义，Request 对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求体的不同方式。<br>创建Request对象: 可以通过构造函数初始化 Request 对象。为此需要传入一个 input 参数，一般是 URL：<br>let r = new Request('<a class="link"   href="https://foo.com/" >https://foo.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>');<br>console.log(r);<br>// Request {...}<br>Request 构造函数也接收第二个参数——一个 init 对象。这个 init 对象与前面介绍的 fetch()的 init 对象一样。没有在 init 对象中涉及的值则会使用默认值：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用所有默认值创建 Request 对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;&#x27;</span>)); </span><br><span class="line"><span class="comment">// Request &#123; </span></span><br><span class="line"><span class="comment">// bodyUsed: false </span></span><br><span class="line"><span class="comment">// cache: &quot;default&quot; </span></span><br><span class="line"><span class="comment">// credentials: &quot;same-origin&quot; </span></span><br><span class="line"><span class="comment">// destination: &quot;&quot; </span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125;</span></span><br><span class="line"><span class="comment">// integrity: &quot;&quot; </span></span><br><span class="line"><span class="comment">// keepalive: false </span></span><br><span class="line"><span class="comment">// method: &quot;GET&quot; </span></span><br><span class="line"><span class="comment">// mode: &quot;cors&quot; </span></span><br><span class="line"><span class="comment">// redirect: &quot;follow&quot; </span></span><br><span class="line"><span class="comment">// referrer: &quot;about:client&quot; </span></span><br><span class="line"><span class="comment">// referrerPolicy: &quot;&quot; </span></span><br><span class="line"><span class="comment">// signal: AbortSignal &#123;aborted: false, onabort: null&#125; </span></span><br><span class="line"><span class="comment">// url: &quot;&lt;current URL&gt;&quot; </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// 用指定的初始值创建 Request 对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&#x27;https://foo.com&#x27;</span>, </span><br><span class="line"> &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span> &#125;)); </span><br><span class="line"><span class="comment">// Request &#123; </span></span><br><span class="line"><span class="comment">// bodyUsed: false </span></span><br><span class="line"><span class="comment">// cache: &quot;default&quot; </span></span><br><span class="line"><span class="comment">// credentials: &quot;same-origin&quot; </span></span><br><span class="line"><span class="comment">// destination: &quot;&quot; </span></span><br><span class="line"><span class="comment">// headers: Headers &#123;&#125; </span></span><br><span class="line"><span class="comment">// integrity: &quot;&quot; </span></span><br><span class="line"><span class="comment">// keepalive: false </span></span><br><span class="line"><span class="comment">// method: &quot;POST&quot;</span></span><br><span class="line"><span class="comment">// mode: &quot;cors&quot; </span></span><br><span class="line"><span class="comment">// redirect: &quot;follow&quot; </span></span><br><span class="line"><span class="comment">// referrer: &quot;about:client&quot; </span></span><br><span class="line"><span class="comment">// referrerPolicy: &quot;&quot; </span></span><br><span class="line"><span class="comment">// signal: AbortSignal &#123;aborted: false, onabort: null&#125; </span></span><br><span class="line"><span class="comment">// url: &quot;https://foo.com/&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></div>
克隆Request对象: Fetch API 提供了两种不太一样的方式用于创建 Request 对象的副本：使用 Request 构造函数和使用 clone()方法。<br>在fetch()中使用Request对象: fetch()和 Request 构造函数拥有相同的函数签名并不是巧合。在调用 fetch()时，可以传入已经创建好的 Request 实例而不是 URL。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-16 日报 Day158</title>
    <url>/undefined/2025-04-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>一旦时机到来，我们要能迅速地发现时机、把握时机，不犹豫，不踌躇，乘风而起，破万里浪。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P735-750 第二十四章：网络请求与远程资源</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Response 对象: Response 对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。</p>
<ul>
<li>创建Response对象: 可以通过构造函数初始化 Response 对象且不需要参数。此时响应实例的属性均为默认值，因为它并不代表实际的 HTTP 响应：<br>let r &#x3D; new Response();<br>console.log(r);<br>&#x2F;&#x2F; Response {<br>&#x2F;&#x2F; body: (…)<br>&#x2F;&#x2F; bodyUsed: false<br>&#x2F;&#x2F; headers: Headers {}<br>&#x2F;&#x2F; ok: true<br>&#x2F;&#x2F; redirected: false<br>&#x2F;&#x2F; status: 200<br>&#x2F;&#x2F; statusText: “OK”<br>&#x2F;&#x2F; type: “default”<br>&#x2F;&#x2F; url: “”<br>&#x2F;&#x2F; }<br>Response 构造函数接收一个可选的 body 参数。这个 body 可以是 null，等同于 fetch()参数init 中的 body。还可以接收一个可选的 init 对象，这个对象可以包含下表所列的键和值。<br>可以像下面这样使用 body 和 init 来构建 Response 对象：<br>let r &#x3D; new Response(‘foobar’, {<br> status: 418,<br> statusText: ‘I&#39;m a teapot’<br>});<br>console.log(r);<br>&#x2F;&#x2F; Response {<br>&#x2F;&#x2F; body: (…)<br>&#x2F;&#x2F; bodyUsed: false<br>&#x2F;&#x2F; headers: Headers {}<br>&#x2F;&#x2F; ok: false<br>&#x2F;&#x2F; redirected: false<br>&#x2F;&#x2F; status: 418<br>&#x2F;&#x2F; statusText: “I’m a teapot”<br>&#x2F;&#x2F; type: “default”<br>&#x2F;&#x2F; url: “”<br>&#x2F;&#x2F; }<br>Response 类还有两个用于生成 Response 对象的静态方法：Response.redirect()和 Response.error()。前者接收一个 URL 和一个重定向状态码（301、302、303、307 或 308），返回重定向的 Response对象：<br>console.log(Response.redirect(‘<a class="link"   href="https://foo.com/" >https://foo.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘, 301));<br>&#x2F;&#x2F; Response {<br>&#x2F;&#x2F; body: (…)<br>&#x2F;&#x2F; bodyUsed: false<br>&#x2F;&#x2F; headers: Headers {}<br>&#x2F;&#x2F; ok: false<br>&#x2F;&#x2F; redirected: false<br>&#x2F;&#x2F; status: 301<br>&#x2F;&#x2F; statusText: “”<br>&#x2F;&#x2F; type: “default”<br>&#x2F;&#x2F; url: “”<br>&#x2F;&#x2F; }<br>提供的状态码必须对应重定向，否则会抛出错误：<br>Response.redirect(‘<a class="link"   href="https://foo.com/" >https://foo.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘, 200);<br>&#x2F;&#x2F; RangeError: Failed to execute ‘redirect’ on ‘Response’: Invalid status code<br>另一个静态方法 Response.error()用于产生表示网络错误的 Response 对象（网络错误会导致fetch()期约被拒绝）。<br>console.log(Response.error());<br>&#x2F;&#x2F; Response {<br>&#x2F;&#x2F; body: (…)<br>&#x2F;&#x2F; bodyUsed: false<br>&#x2F;&#x2F; headers: Headers {}<br>&#x2F;&#x2F; ok: false<br>&#x2F;&#x2F; redirected: false<br>&#x2F;&#x2F; status: 0<br>&#x2F;&#x2F; statusText: “”<br>&#x2F;&#x2F; type: “error”<br>&#x2F;&#x2F; url: “”<br>&#x2F;&#x2F; }</li>
<li>读取响应状态信息: Response 对象包含一组只读属性，描述了请求完成后的状态，如下表所示。</li>
<li>克隆Response对象: 克隆 Response 对象的主要方式是使用 clone()方法，这个方法会创建一个一模一样的副本，不会覆盖任何值。<br>2、Request、Response及Body混入: Request 和 Response 都使用了 Fetch API 的 Body 混入，以实现两者承担有效载荷的能力。这个混入为两个类型提供了只读的 body 属性（实现为 ReadableStream）、只读的 bodyUsed 布尔值（表示 body 流是否已读）和一组方法，用于从流中读取内容并将结果转换为某种 JavaScript 对象类型。<br>通常，将 Request 和 Response 主体作为流来使用主要有两个原因。一个原因是有效载荷的大小可能会导致网络延迟，另一个原因是流 API 本身在处理有效载荷方面是有优势的。除此之外，最好是一次性获取资源主体。<br>3、Beacon API: 为了把尽量多的页面信息传到服务器，很多分析工具需要在页面生命周期中尽量晚的时候向服务器发送遥测或分析数据。因此，理想的情况下是通过浏览器的 unload 事件发送网络请求。这个事件表示用户要离开当前页面，不会再生成别的有用信息了。<br>在 unload 事件触发时，分析工具要停止收集信息并把收集到的数据发给服务器。这时候有一个问题，因为 unload 事件对浏览器意味着没有理由再发送任何结果未知的网络请求（因为页面都要被销毁了）。例如，在 unload 事件处理程序中创建的任何异步请求都会被浏览器取消。为此，异步 XMLHttpRequest或 fetch()不适合这个任务。分析工具可以使用同步 XMLHttpRequest 强制发送请求，但这样做会导致用户体验问题。浏览器会因为要等待 unload 事件处理程序完成而延迟导航到下一个页面。<br>为解决这个问题，W3C 引入了补充性的 Beacon API。这个 API 给 navigator 对象增加了一个sendBeacon()方法。这个简单的方法接收一个 URL 和一个数据有效载荷参数，并会发送一个 POST请求。可选的数据有效载荷参数有 ArrayBufferView、Blob、DOMString、FormData 实例。如果请求成功进入了最终要发送的任务队列，则这个方法返回 true，否则返回 false。<br>可以像下面这样使用这个方法：<br>&#x2F;&#x2F; 发送 POST 请求<br>&#x2F;&#x2F; URL: ‘<a class="link"   href="https://example.com/analytics-reporting-url" >https://example.com/analytics-reporting-url <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘<br>&#x2F;&#x2F; 请求负载：’{foo: “bar”}’<br>navigator.sendBeacon(‘<a class="link"   href="https://example.com/analytics-reporting-url" >https://example.com/analytics-reporting-url <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘, ‘{foo: “bar”}’);<br>这个方法虽然看起来只不过是 POST 请求的一个语法糖，但它有几个重要的特性。<br> sendBeacon()并不是只能在页面生命周期末尾使用，而是任何时候都可以使用。<br> 调用 sendBeacon()后，浏览器会把请求添加到一个内部的请求队列。浏览器会主动地发送队列中的请求。<br> 浏览器保证在原始页面已经关闭的情况下也会发送请求。<br> 状态码、超时和其他网络原因造成的失败完全是不透明的，不能通过编程方式处理。<br> 信标（beacon）请求会携带调用 sendBeacon()时所有相关的 cookie。<br>4、WebSocket: Web Socket（套接字）的目标是通过一个长时连接实现与服务器全双工、双向的通信。在 JavaScript中创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接。服务器响应后，连接使用 HTTP的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议。这意味着 Web Socket 不能通过标准 HTTP 服务器实现，而必须使用支持该协议的专有服务器。<br>因为 Web Socket使用了自定义协议，所以 URL方案（scheme）稍有变化：不能再使用 http:&#x2F;&#x2F;或 https:&#x2F;&#x2F;，而要使用 ws:&#x2F;&#x2F;和 wss:&#x2F;&#x2F;。前者是不安全的连接，后者是安全连接。在指定 Web Socket URL 时，必须包含 URL 方案，因为将来有可能再支持其他方案。</li>
<li>API: 要创建一个新的 Web Socket，就要实例化一个 WebSocket 对象并传入提供连接的 URL：<br>let socket &#x3D; new WebSocket(“ws:&#x2F;&#x2F;<a class="link"   href="http://www.example.com/server.php" >www.example.com/server.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“);<br>注意，必须给 WebSocket 构造函数传入一个绝对 URL。同源策略不适用于 Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（在握手阶段就可以确定请求来自哪里。）<br>浏览器会在初始化 WebSocket 对象之后立即创建连接。与 XHR 类似，WebSocket 也有一个readyState 属性表示当前状态。不过，这个值与 XHR 中相应的值不一样。<br> WebSocket.OPENING（0）：连接正在建立。<br> WebSocket.OPEN（1）：连接已经建立。<br> WebSocket.CLOSING（2）：连接正在关闭。<br> WebSocket.CLOSE（3）：连接已经关闭。<br>WebSocket 对象没有 readystatechange 事件，而是有与上述不同状态对应的其他事件。readyState 值从 0 开始。任何时候都可以调用 close()方法关闭 Web Socket 连接：<br>socket.close();<br>调用 close()之后，readyState 立即变为 2（连接正在关闭），并会在关闭后变为 3（连接已经关闭）。</li>
<li>发送和接收数据: 打开 Web Socket 之后，可以通过连接发送和接收数据。要向服务器发送数据，使用 send()方法并传入一个字符串、ArrayBuffer 或 Blob，如下所示：<br>let socket &#x3D; new WebSocket(“ws:&#x2F;&#x2F;<a class="link"   href="http://www.example.com/server.php" >www.example.com/server.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“);<br>let stringData &#x3D; “Hello world!”;<br>let arrayBufferData &#x3D; Uint8Array.from([‘f’, ‘o’, ‘o’]);<br>let blobData &#x3D; new Blob([‘f’, ‘o’, ‘o’]);<br>socket.send(stringData);<br>socket.send(arrayBufferData.buffer);<br>socket.send(blobData);<br>服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件。这个 message 事件与其他消息协议类似，可以通过 event.data 属性访问到有效载荷：<br>socket.onmessage &#x3D; function(event) {<br> let data &#x3D; event.data;<br> &#x2F;&#x2F; 对数据执行某些操作<br>};<br>与通过 send()方法发送的数据类似，event.data 返回的数据也可能是 ArrayBuffer 或 Blob。这由 WebSocket 对象的 binaryType 属性决定，该属性可能是”blob”或”arraybuffer”。</li>
<li>其他事件: WebSocket 对象在连接生命周期中有可能触发 3 个其他事件。<br> open：在连接成功建立时触发。<br> error：在发生错误时触发。连接无法存续。<br> close：在连接关闭时触发。<br>WebSocket 对象不支持 DOM Level 2 事件监听器，因此需要使用 DOM Level 0 风格的事件处理程序来监听这些事件：<br>let socket &#x3D; new WebSocket(“ws:&#x2F;&#x2F;<a class="link"   href="http://www.example.com/server.php" >www.example.com/server.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“);<br>socket.onopen &#x3D; function() {<br> alert(“Connection established.”);<br>};<br>socket.onerror &#x3D; function() {<br> alert(“Connection error.”);<br>};<br>socket.onclose &#x3D; function() {<br> alert(“Connection closed.”);<br>};<br>在这些事件中，只有 close 事件的 event 对象上有额外信息。这个对象上有 3 个额外属性：<br>wasClean、code 和 reason。其中，wasClean 是一个布尔值，表示连接是否干净地关闭；code 是一个来自服务器的数值状态码；reason 是一个字符串，包含服务器发来的消息。可以将这些信息显示给用户或记录到日志：<br>socket.onclose &#x3D; function(event) {<br> console.log(<code>as clean? $&#123;event.wasClean&#125; Code=$&#123;event.code&#125; Reason=$&#123;   event.reason&#125;</code>);<br>};<br>5、安全: 探讨 Ajax 安全的文章已经有了很多，事实上也出版了很多专门讨论这个话题的书。大规模 Ajax 应用程序需要考虑的安全问题非常多，但在通用层面上一般需要考虑以下几个问题。<br>首先，任何 Ajax 可以访问的 URL，也可以通过浏览器或服务器访问，例如下面这个 URL：<br>&#x2F;getuserinfo.php?id&#x3D;23 请求这个 URL，可以假定返回 ID 为 23 的用户信息。访问者可以将 23 改为 24 或 56，甚至其他任何值。getuserinfo.php 文件必须知道访问者是否拥有访问相应数据的权限。否则，服务器就会大门敞开，泄露所有用户的信息。在未授权系统可以访问某个资源时，可以将其视为跨站点请求伪造（CSRF，cross-site request forgery）攻击。未授权系统会按照处理请求的服务器的要求伪装自己。Ajax 应用程序，无论大小，都会受到 CSRF攻击的影响，包括无害的漏洞验证攻击和恶意的数据盗窃或数据破坏攻击。<br>关于安全防护 Ajax 相关 URL 的一般理论认为，需要验证请求发送者拥有对资源的访问权限。可以通过如下方式实现。<br> 要求通过 SSL 访问能够被 Ajax 访问的资源。<br> 要求每个请求都发送一个按约定算法计算好的令牌（token）。<br>注意，以下手段对防护 CSRF 攻击是无效的。<br> 要求 POST 而非 GET 请求（很容易修改请求方法）。<br> 使用来源 URL 验证来源（来源 URL 很容易伪造）。<br> 基于 cookie 验证（同样很容易伪造）<br>6、小结: Ajax 是无须刷新当前页面即可从服务器获取数据的一个方法，具有如下特点。<br> 让 Ajax 迅速流行的中心对象是 XMLHttpRequest（XHR）。<br> 这个对象最早由微软发明，并在 IE5 中作为通过 JavaScript 从服务器获取 XML 数据的一种手段。<br> 之后，Firefox、Safari、Chrome 和 Opera 都复刻了相同的实现。W3C 随后将 XHR 行为写入 Web标准。<br> 虽然不同浏览器的实现有些差异，但 XHR 对象的基本使用在所有浏览器中相对是规范的，因此可以放心地在 Web 应用程序中使用。<br>XHR 的一个主要限制是同源策略，即通信只能在相同域名、相同端口和相同协议的前提下完成。访问超出这些限制之外的资源会导致安全错误，除非使用了正式的跨域方案。这个方案叫作跨源资源共享（CORS，Cross-Origin Resource Sharing），XHR 对象原生支持 CORS。图片探测和 JSONP 是另外两种跨域通信技术，但没有 CORS 可靠。<br>Fetch API 是作为对 XHR 对象的一种端到端的替代方案而提出的。这个 API 提供了优秀的基于期约的结构、更直观的接口，以及对 Stream API 的最好支持。<br>Web Socket 是与服务器的全双工、双向通信渠道。与其他方案不同，Web Socket 不使用 HTTP，而使用了自定义协议，目的是更快地发送小数据块。这需要专用的服务器，但速度优势明显。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-18 日报 Day160</title>
    <url>/undefined/2025-04-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>别让人生就停留在当下，从现在开始，改变朋友圈、改变位置、改变心态和思维，去发现更好的生活，塑造更优秀的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P759-771 第二十五章：客户端存储</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Web Storage: Web Storage 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。<br>Web Storage 规范最新的版本是第 2 版，这一版规范主要有两个目标：<br> 提供在 cookie 之外的存储会话数据的途径；<br> 提供跨会话持久化存储大量数据的机制。<br>Web Storage 的第 2 版定义了两个对象：localStorage 和 sessionStorage。localStorage 是永久存储机制，sessionStorage 是跨会话的存储机制。这两种浏览器存储 API 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。</p>
<ul>
<li>storage类型: Storage 类型用于保存名&#x2F;值对数据，直至存储空间上限（由浏览器决定）。Storage 的实例与其他对象一样，但增加了以下方法。<br> clear()：删除所有值；不在 Firefox 中实现。<br> getItem(name)：取得给定 name 的值。<br> key(index)：取得给定数值位置的名称。<br> removeItem(name)：删除给定 name 的名&#x2F;值对。<br> setItem(name, value)：设置给定 name 的值。<br>注意 Storage 类型只能存储字符串。非字符串数据在存储之前会自动转换为字符串。注意，这种转换不能在获取数据时撤销。</li>
<li>sessionStorage对象: sessionStorage 对象只存储会话数据，这意味着数据只会存储到浏览器关闭。这跟浏览器关闭时会消失的会话 cookie 类似。存储在 sessionStorage 中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复。<br>因为 sessionStorage 对象与服务器会话紧密相关，所以在运行本地文件时不能使用。存储在sessionStorage 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限。<br>因为 sessionStorage 对象是 Storage 的实例，所以可以通过使用 setItem()方法或直接给属性赋值给它添加数据。下面是使用这两种方式的例子：<br>&#x2F;&#x2F; 使用方法存储数据<br>sessionStorage.setItem(“name”, “Nicholas”);<br>&#x2F;&#x2F; 使用属性存储数据<br>sessionStorage.book &#x3D; “Professional JavaScript”;<br>所有现代浏览器在实现存储写入时都使用了同步阻塞方式，因此数据会被立即提交到存储。具体API 的实现可能不会立即把数据写入磁盘（而是使用某种不同的物理存储），但这个区别在 JavaScript 层面是不可见的。通过 Web Storage 写入的任何数据都可以立即被读取。<br>老版 IE 以异步方式实现了数据写入，因此给数据赋值的时间和数据写入磁盘的时间可能存在延迟。对于少量数据，这里的差别可以忽略不计，但对于大量数据，就可以注意到 IE 中 JavaScript 恢复执行的速度比其他浏览器更快。这是因为实际写入磁盘的进程被转移了。在 IE8 中可以在数据赋值前调用begin()、之后调用 commit()来强制将数据写入磁盘。比如：<br>&#x2F;&#x2F; 仅适用于 IE8<br>sessionStorage.begin();<br>sessionStorage.name &#x3D; “Nicholas”;<br>sessionStorage.book &#x3D; “Professional JavaScript”;<br>sessionStorage.commit();<br>以上代码确保了”name”和”book”在 commit()调用之后会立即写入磁盘。调用 begin()是为了保证在代码执行期间不会有写入磁盘的操作。对于少量数据，这个过程不是必要的，但对于较大的数据量，如文档，则可以考虑使用这种事务性方法。<br>对存在于 sessionStorage 上的数据，可以使用 getItem()或直接访问属性名来取得。下面是使用这两种方式的例子：<br>&#x2F;&#x2F; 使用方法取得数据<br>let name &#x3D; sessionStorage.getItem(“name”);<br>&#x2F;&#x2F; 使用属性取得数据<br>let book &#x3D; sessionStorage.book;<br>可以结合 sessionStorage 的 length 属性和 key()方法遍历所有的值：<br>for (let i &#x3D; 0, len &#x3D; sessionStorage.length; i &lt; len; i++){<br> let key &#x3D; sessionStorage.key(i);<br> let value &#x3D; sessionStorage.getItem(key);<br> alert(<code>$&#123;key&#125;=</code>${value}&#96;);<br>}<br>要从 sessionStorage 中删除数据，可以使用 delete 操作符直接删除对象属性，也可以使用removeItem()方法。下面是使用这两种方式的例子：<br>&#x2F;&#x2F; 使用 delete 删除值<br>delete sessionStorage.name;<br>&#x2F;&#x2F; 使用方法删除值<br>sessionStorage.removeItem(“book”);<br>sessionStorage 对象应该主要用于存储只在会话期间有效的小块数据。如果需要跨会话持久存储数据，可以使用 globalStorage 或 localStorage。</li>
<li>localStorage对象: 在修订的 HTML5 规范里，localStorage 对象取代了 globalStorage，作为在客户端持久存储数据的机制。要访问同一个 localStorage 对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议。<br>因 为 localStorage 是 Storage 的实例，所以可以像使用 sessionStorage 一样使用localStorage。比如下面这几个例子：<br>&#x2F;&#x2F; 使用方法存储数据<br>localStorage.setItem(“name”, “Nicholas”);<br>&#x2F;&#x2F; 使用属性存储数据<br>localStorage.book &#x3D; “Professional JavaScript”;<br>&#x2F;&#x2F; 使用方法取得数据<br>let name &#x3D; localStorage.getItem(“name”);<br>&#x2F;&#x2F; 使用属性取得数据<br>let book &#x3D; localStorage.book;<br>两种存储方法的区别在于，存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失。</li>
<li>存储事件: 每当 Storage 对象发生变化时，都会在文档上触发 storage 事件。使用属性或 setItem()设置值、使用 delete 或 removeItem()删除值，以及每次调用 clear()时都会触发这个事件。这个事件的事件对象有如下 4 个属性。<br> domain：存储变化对应的域。<br> key：被设置或删除的键。<br> newValue：键被设置的新值，若键被删除则为 null。<br> oldValue：键变化之前的值。<br>可以使用如下代码监听 storage 事件：<br>window.addEventListener(“storage”,<br> (event) &#x3D;&gt; alert(‘Storage changed for ${event.domain}’));<br>对于 sessionStorage 和 localStorage 上的任何更改都会触发 storage 事件，但 storage 事件不会区分这两者。</li>
<li>限制: 与其他客户端数据存储方案一样，Web Storage 也有限制。具体的限制取决于特定的浏览器。一般来说，客户端数据的大小限制是按照每个源（协议、域和端口）来设置的，因此每个源有固定大小的数据存储空间。分析存储数据的页面的源可以加强这一限制。<br>不同浏览器给 localStorage 和 sessionStorage 设置了不同的空间限制，但大多数会限制为每个源 5MB。<br>2、IndexedDB: Indexed Database API 简称 IndexedDB，是浏览器中存储结构化数据的一个方案。IndexedDB 背后的思想是创造一套 API，方便 JavaScript 对象的存储和获取，同时也支持查询和搜索。<br>IndexedDB 的设计几乎完全是异步的。为此，大多数操作以请求的形式执行，这些请求会异步执行，产生成功的结果或错误。绝大多数 IndexedDB 操作要求添加 onerror 和 onsuccess 事件处理程序来确定输出。</li>
<li>数据库: IndexedDB 是类似于 MySQL 或 Web SQL Database 的数据库。与传统数据库最大的区别在于，IndexedDB 使用对象存储而不是表格保存数据。IndexedDB 数据库就是在一个公共命名空间下的一组对象存储，类似于 NoSQL 风格的实现。<br>使用 IndexedDB 数据库的第一步是调用 indexedDB.open()方法，并给它传入一个要打开的数据库名称。如果给定名称的数据库已存在，则会发送一个打开它的请求；如果不存在，则会发送创建并打开这个数据库的请求。这个方法会返回 IDBRequest 的实例，可以在这个实例上添加 onerror 和onsuccess 事件处理程序。举例如下：<br>let db,<br> request,<br> version &#x3D; 1;<br>request &#x3D; indexedDB.open(“admin”, version);<br>request.onerror &#x3D; (event) &#x3D;&gt;<br> alert(<code>Failed to open: $&#123;event.target.errorCode&#125;</code>);<br>request.onsuccess &#x3D; (event) &#x3D;&gt; {<br> db &#x3D; event.target.result;<br>};</li>
<li>对象存储: 建立了数据库连接之后，下一步就是使用对象存储。</li>
<li>事务: 创建了对象存储之后，剩下的所有操作都是通过事务完成的。事务要通过调用数据库对象的transaction()方法创建。</li>
<li>插入对象: 拿到了对象存储的引用后，就可以使用 add()或 put()写入数据了。<br>每次调用 add()或 put()都会创建对象存储的新更新请求。如果想验证请求成功与否，可以把请求对象保存到一个变量，然后为它添加 onerror 和 onsuccess 事件处理程序：<br>&#x2F;&#x2F; users 是一个用户数据的数组<br>let request,<br> requests &#x3D; [];<br>for (let user of users) {<br> request &#x3D; store.add(user);<br> request.onerror &#x3D; () &#x3D;&gt; {<br> &#x2F;&#x2F; 处理错误<br> };<br> request.onsuccess &#x3D; () &#x3D;&gt; {<br> &#x2F;&#x2F; 处理成功<br> };<br> requests.push(request);<br>}<br>创建并填充了数据后，就可以查询对象存储了。</li>
<li>通过游标查询: 使用事务可以通过一个已知键取得一条记录。如果想取得多条数据，则需要在事务中创建一个游标。游标是一个指向结果集的指针。与传统数据库查询不同，游标不会事先收集所有结果。相反，游标指向第一个结果，并在接到指令前不会主动查找下一条数据。</li>
<li>键范围: 使用游标会给人一种不太理想的感觉，因为获取数据的方式受到了限制。使用键范围（key range）可以让游标更容易管理。</li>
<li>设置游标方向: openCursor()方法实际上可以接收两个参数，第一个是 IDBKeyRange 的实例，第二个是表示方向的字符串。</li>
<li>索引: 对某些数据集，可能需要为对象存储指定多个键。例如，如果同时记录了用户 ID 和用户名，那可能需要通过任何一种方式来获取用户数据。为此，可以考虑将用户 ID 作为主键，然后在用户名上创建索引。</li>
<li>并发问题: IndexedDB 虽然是网页中的异步 API，但仍存在并发问题。如果两个不同的浏览器标签页同时打开了同一个网页，则有可能出现一个网页尝试升级数据库而另一个尚未就绪的情形。有问题的操作是设置数据库为新版本，而版本变化只能在浏览器只有一个标签页使用数据库时才能完成。</li>
<li>限制: IndexedDB 的很多限制实际上与 Web Storage 一样。首先，IndexedDB 数据库是与页面源（协议、域和端口）绑定的，因此信息不能跨域共享。这意味着 <a class="link"   href="http://www.wrox.com/" >www.wrox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 p2p.wrox.com 会对应不同的数据存储。<br>其次，每个源都有可以存储的空间限制。当前 Firefox 的限制是每个源 50MB，而 Chrome 是 5MB。移动版 Firefox 有 5MB 限制，如果用度超出配额则会请求用户许可。<br>Firefox 还有一个限制——本地文本不能访问 IndexedDB 数据库。Chrome 没有这个限制。因此在本地运行本书示例时，要使用 Chrome。<br>3、小结: Web Storage 定义了两个对象用于存储数据：sessionStorage 和 localStorage。前者用于严格保存浏览器一次会话期间的数据，因为数据会在浏览器关闭时被删除。后者用于会话之外持久保存数据。<br>IndexedDB 是类似于 SQL 数据库的结构化数据存储机制。不同的是，IndexedDB 存储的是对象，而不是数据表。对象存储是通过定义键然后添加数据来创建的。游标用于查询对象存储中的特定数据，而索引可以针对特定属性实现更快的查询。<br>有了这些存储手段，就可以在客户端通过使用 JavaScript 存储可观的数据。因为这些数据没有加密，所以要注意不能使用它们存储敏感信息</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-17 日报 Day159</title>
    <url>/undefined/2025-04-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>和格局远大的人在一起，你的眼里就不会只有鸡毛蒜皮； 和自律向上的人在一起，你也会不由自主想要改变自己；和乐观豁达的人在一起，平凡的生活也能富有情趣。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P751-758 第二十五章：客户端存储</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、客户端存储: 随着 Web 应用程序的出现，直接在客户端存储用户信息的需求也随之出现。这背后的想法是合理的：与特定用户相关的信息应该保存在用户的机器上。无论是登录信息、个人偏好，还是其他数据，Web 应用程序提供者都需要有办法把它们保存在客户端。对该问题的第一个解决方案就是 cookie，cookie 由古老的网景公司发明，由一份名为 Persistent Client State: HTTP Cookies 的规范定义。今天，cookie 只是在客户端存储数据的一个选项。<br>2、cookie: HTTP cookie 通常也叫作 cookie，最初用于在客户端存储会话信息。这个规范要求服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息。例如，下面是包含这个头部的一个 HTTP 响应：<br>HTTP&#x2F;1.1 200 OK<br>Content-type: text&#x2F;html<br>Set-Cookie: name&#x3D;value<br>Other-header: other-header-value<br>这个 HTTP 响应会设置一个名为”name”，值为”value”的 cookie。名和值在发送时都会经过 URL 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发回服务器，比如：<br>GET &#x2F;index.jsl HTTP&#x2F;1.1<br>Cookie: name&#x3D;value<br>Other-header: other-header-value<br>这些发送回服务器的额外信息可用于唯一标识发送请求的客户端</p>
<ul>
<li>限制: cookie 是与特定域绑定的。设置 cookie 后，它会与请求一起发送到创建它的域。这个限制能保证 cookie 中存储的信息只对被认可的接收者开放，不被其他域访问。<br>因为 cookie 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，cookie 也不会占用太多磁盘空间。</li>
<li>cookie 的构成: cookie 在浏览器中是由以下参数构成的。<br> 名称：唯一标识 cookie 的名称。cookie 名不区分大小写，因此 myCookie 和 MyCookie 是同一个名称。<br> 值：存储在 cookie 里的字符串值。<br> 域：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如<a class="link"   href="http://www.wrox.com),也可以不包含(如.wrox.com/" >www.wrox.com），也可以不包含（如.wrox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 表示对 wrox.com 的所有子域都有效）。如果不明确设置，则默认为设置 cookie 的域。<br> 路径：请求 URL 中包含这个路径才会把 cookie 发送到服务器。例如，可以指定 cookie 只能由<a class="link"   href="http://www.wrox.com/books/%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%AE%BF%E9%97%AE" >http://www.wrox.com/books/访问，因此访问 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link"   href="http://www.wrox.com/%E4%B8%8B%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%8F%91%E9%80%81" >http://www.wrox.com/下的页面就不会发送 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> cookie，即使请求的是同一个域。<br> 过期时间：表示何时删除 cookie 的时间戳（即什么时间之后就不发送到服务器了）。默认情况下，浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间。这个值是 GMT 格式（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定删除 cookie 的具体时间。这样即使关闭浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。<br> 安全标志：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。例如，请求 <a class="link"   href="https://www.wrox.com/" >https://www.wrox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 会发送 cookie，而请求 <a class="link"   href="http://www.wrox.com/" >http://www.wrox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 则不会。<br>这些参数在 Set-Cookie 头部中使用分号加空格隔开，比如：<br>HTTP&#x2F;1.1 200 OK<br>Content-type: text&#x2F;html<br>Set-Cookie: name&#x3D;value; expires&#x3D;Mon, 22-Jan-07 07:10:24 GMT; domain&#x3D;.wrox.com<br>Other-header: other-header-value<br>安全标志 secure 是 cookie 中唯一的非名&#x2F;值对，只需一个 secure 就可以了。比如：<br>HTTP&#x2F;1.1 200 OK<br>Content-type: text&#x2F;html<br>Set-Cookie: name&#x3D;value; domain&#x3D;.wrox.com; path&#x3D;&#x2F;; secure<br>Other-header: other-header-value<br>这里创建的 cookie 对所有 wrox.com 的子域及该域中的所有页面有效（通过 path&#x3D;&#x2F;指定）。不过，这个 cookie 只能在 SSL 连接上发送，因为设置了 secure 标志。</li>
<li>javascript 中的 cookie: 在 JavaScript 中处理 cookie 比较麻烦，因为接口过于简单，只有 BOM 的 document.cookie 属性。根据用法不同，该属性的表现迥异。要使用该属性获取值时，document.cookie 返回包含页面中所有有效 cookie 的字符串（根据域、路径、过期时间和安全设置），以分号分隔，如下面的例子所示：<br>name1&#x3D;value1;name2&#x3D;value2;name3&#x3D;value3<br>所有名和值都是 URL 编码的，因此必须使用 decodeURIComponent()解码。在设置值时，可以通过 document.cookie 属性设置新的 cookie 字符串。这个字符串在被解析后会添加到原有 cookie 中。设置 document.cookie 不会覆盖之前存在的任何 cookie，除非设置了已有的 cookie。设置 cookie 的格式如下，与 Set-Cookie 头部的格式一样：<br>name&#x3D;value; expires&#x3D;expiration_time; path&#x3D;domain_path; domain&#x3D;domain_name; secure<br>在所有这些参数中，只有 cookie 的名称和值是必需的。下面是个简单的例子：<br>document.cookie &#x3D; “name&#x3D;Nicholas”;<br>这行代码会创建一个名为”name”的会话 cookie，其值为”Nicholas”。这个 cookie 在每次客户端向服务器发送请求时都会被带上，在浏览器关闭时就会被删除。虽然这样直接设置也可以，因为不需要在名称或值中编码任何字符，但最好还是使用 encodeURIComponent()对名称和值进行编码，比如：<br>document.cookie &#x3D; encodeURIComponent(“name”) + “&#x3D;” + encodeURIComponent(“Nicholas”);<br>要为创建的 cookie 指定额外的信息，只要像 Set-Cookie 头部一样直接在后面追加相同格式的字符串即可：<br>document.cookie &#x3D; encodeURIComponent(“name”) + “&#x3D;” + encodeURIComponent(“Nicholas”) + “; domain&#x3D;.wrox.com; path&#x3D;&#x2F;“;<br>因为在 JavaScript 中读写 cookie 不是很直观，所以可以通过辅助函数来简化相应的操作。与 cookie 相关的基本操作有读、写和删除。这些在 CookieUtil 对象中表示如下：</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CookieUtil</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">get</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cookieName = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=`</span>,</span><br><span class="line">      cookieStart = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(cookieName),</span><br><span class="line">      cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;;&quot;</span>, cookieStart);</span><br><span class="line">      <span class="keyword">if</span> (cookieEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">        cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="property">length</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cookieValue = <span class="built_in">decodeURIComponent</span>(</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">substring</span>(cookieStart + cookieName.<span class="property">length</span>, cookieEnd)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">set</span>(<span class="params">name, value, expires, path, domain, secure</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cookieText = <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(name)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(value)&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">      cookieText += <span class="string">`; expires=<span class="subst">$&#123;expires.toGMTString()&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">      cookieText += <span class="string">`; path=<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">      cookieText += <span class="string">`; domain=<span class="subst">$&#123;domain&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">      cookieText += <span class="string">&quot;; secure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">cookie</span> = cookieText;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">unset</span>(<span class="params">name, path, domain, secure</span>) &#123;</span><br><span class="line">    <span class="title class_">CookieUtil</span>.<span class="title function_">set</span>(name, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>), path, domain, secure);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>子 cookie:<br>为绕过浏览器对每个域 cookie 数的限制，有些开发者提出了子 cookie 的概念。子 cookie 是在单个<br>cookie 存储的小块数据，本质上是使用 cookie 的值在单个 cookie 中存储多个名&#x2F;值对。最常用的子 cookie<br>模式如下：<br>name1&#x3D;value1&amp;name2&#x3D;value2&amp;name3&#x3D;value3&amp;name4&#x3D;value4&amp;name5&#x3D;value5<br>子 cookie 的格式类似于查询字符串。这些值可以存储为单个 cookie，而不用单独存储为自己的名&#x2F;值对。结果就是网站或 Web 应用程序能够在单域 cookie 数限制下存储更多的结构化数据。<br>要操作子 cookie，就需要再添加一些辅助方法。解析和序列化子 cookie 的方式不一样，且因为对子 cookie 的使用而变得更复杂。比如，要取得某个子 cookie，就需要先取得 cookie，然后在解码值之前需要先像下面这样找到子 cookie：</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubCookieUtil</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">get</span>(<span class="params">name, subName</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subCookies = <span class="title class_">SubCookieUtil</span>.<span class="title function_">getAll</span>(name);</span><br><span class="line">    <span class="keyword">return</span> subCookies ? subCookies[subName] : <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getAll</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span>,</span><br><span class="line">      cookieStart = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(cookieName),</span><br><span class="line">      cookieValue = <span class="literal">null</span>,</span><br><span class="line">      cookieEnd,</span><br><span class="line">      subCookies,</span><br><span class="line">      parts,</span><br><span class="line">      result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;;&quot;</span>, cookieStart);</span><br><span class="line">      <span class="keyword">if</span> (cookieEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">        cookieEnd = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="property">length</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cookieValue = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">substring</span>(</span><br><span class="line">        cookieStart + cookieName.<span class="property">length</span>,</span><br><span class="line">        cookieEnd</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (cookieValue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        subCookies = cookieValue.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = subCookies.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">          parts = subCookies[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">          result[<span class="built_in">decodeURIComponent</span>(parts[<span class="number">0</span>])] = <span class="built_in">decodeURIComponent</span>(parts[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用cookie的注意事项: 还有一种叫作 HTTP-only 的 cookie。HTTP-only 可以在浏览器设置，也可以在服务器设置，但只能在服务器上读取，这是因为 JavaScript 无法取得这种 cookie 的值。<br>因为所有 cookie 都会作为请求头部由浏览器发送给服务器，所以在 cookie 中保存大量信息可能会影响特定域浏览器请求的性能。保存的 cookie 越大，请求完成的时间就越长。即使浏览器对 cookie 大小有限制，最好还是尽可能只通过 cookie 保存必要信息，以避免性能问题。对 cookie 的限制及其特性决定了 cookie 并不是存储大量数据的理想方式。因此，其他客户端存储技术出现了。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-20 日报 Day162</title>
    <url>/undefined/2025-04-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>本应是照亮生活的“灯塔”，却变成时刻检验生活态度的炽光灯。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P782-782 第二十六章：模块</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、通用模块定义: 为了统一 CommonJS 和 AMD 生态系统，通用模块定义（UMD，Universal Module Definition）规范应运而生。UMD 可用于创建这两个系统都可以使用的模块代码。本质上，UMD 定义的模块会在启动时检测要使用哪个模块系统，然后进行适当配置，并把所有逻辑包装在一个立即调用的函数表达式（IIFE）中。虽然这种组合并不完美，但在很多场景下足以实现两个生态的共存。<br>下面是只包含一个依赖的 UMD 模块定义的示例:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> (<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123; </span><br><span class="line"> <span class="comment">// AMD。注册为匿名模块</span></span><br><span class="line"> <span class="title function_">define</span>([<span class="string">&#x27;moduleB&#x27;</span>], factory); </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) &#123; </span><br><span class="line"> <span class="comment">// Node。不支持严格 CommonJS </span></span><br><span class="line"> <span class="comment">// 但可以在 Node 这样支持 module.exports 的</span></span><br><span class="line"> <span class="comment">// 类 CommonJS 环境下使用</span></span><br><span class="line"> <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27; moduleB &#x27;</span>)); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">// 浏览器全局上下文（root 是 window）</span></span><br><span class="line"> root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root. moduleB); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">moduleB</span>) &#123; </span><br><span class="line"> <span class="comment">// 以某种方式使用 moduleB </span></span><br><span class="line"> <span class="comment">// 将返回值作为模块的导出</span></span><br><span class="line"> <span class="comment">// 这个例子返回了一个对象</span></span><br><span class="line"> <span class="comment">// 但是模块也可以返回函数作为导出值</span></span><br><span class="line"> <span class="keyword">return</span> &#123;&#125;; </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></div>
<p>此模式有支持严格 CommonJS 和浏览器全局上下文的变体。不应该期望手写这个包装函数，它应该由构建工具自动生成。开发者只需专注于模块的内由容，而不必关心这些样板代码。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-19 日报 Day161</title>
    <url>/undefined/2025-04-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>我希望在繁华尽处，寻一抹静谧，泛舟湖上，三五好友，一壶老酒，家人作伴，唱歌会友。来吧，于绿野间、阳光下创造美好，治愈青春。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P772-781 第二十六章：模块</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、模块: 现代 JavaScript 开发毋庸置疑会遇到代码量大和广泛使用第三方库的问题。解决这个问题的方案通常需要把代码拆分成很多部分，然后再通过某种方式将它们连接起来。<br>在 ECMAScript 6 模块规范出现之前，虽然浏览器原生不支持模块的行为，但迫切需要这样的行为。ECMAScript 同样不支持模块，因此希望使用模块模式的库或代码库必须基于 JavaScript 的语法和词法特性“伪造”出类似模块的行为。<br>因为 JavaScript 是异步加载的解释型语言，所以得到广泛应用的各种模块实现也表现出不同的形态。这些不同的形态决定了不同的结果，但最终它们都实现了经典的模块模式。<br>2、理解模块模式: 将代码拆分成独立的块，然后再把这些块连接起来可以通过模块模式来实现。这种模式背后的思想很简单：把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。不同的实现和特性让这些基本的概念变得有点复杂，但这个基本的思想是所有 JavaScript模块系统的基础。</p>
<ul>
<li>模块标识符: 模块标识符是所有模块系统通用的概念。模块系统本质上是键&#x2F;值实体，其中每个模块都有个可用于引用它的标识符。这个标识符在模拟模块的系统中可能是字符串，在原生实现的模块系统中可能是模块文件的实际路径。<br>将模块标识符解析为实际模块的过程要根据模块系统对标识符的实现。原生浏览器模块标识符必须提供实际 JavaScript 文件的路径。除了文件路径，Node.js 还会搜索 node_modules 目录，用标识符去匹配包含 index.js 的目录。</li>
<li>模块依赖: 模块系统的核心是管理依赖。指定依赖的模块与周围的环境会达成一种契约。本地模块向模块系统声明一组外部模块（依赖），这些外部模块对于当前模块正常运行是必需的。模块系统检视这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖。<br>每个模块都会与某个唯一的标识符关联，该标识符可用于检索模块。这个标识符通常是 JavaScript文件的路径，但在某些模块系统中，这个标识符也可以是在模块本身内部声明的命名空间路径字符串。</li>
<li>模块加载: 加载模块的概念派生自依赖契约。当一个外部模块被指定为依赖时，本地模块期望在执行它时，依赖已准备好并已初始化。<br>在浏览器中，加载模块涉及几个步骤。加载模块涉及执行其中的代码，但必须是在所有依赖都加载并执行之后。如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回。收到模块代码之后，浏览器必须确定刚收到的模块是否也有依赖。然后递归地评估并加载所有依赖，直到所有依赖模块都加载完成。只有整个依赖图都加载完成，才可以执行入口模块。</li>
<li>入口: 相互依赖的模块必须指定一个模块作为入口（entry point），这也是代码执行的起点。这是理所当然的，因为 JavaScript 是顺序执行的，并且是单线程的，所以代码必须有执行的起点。入口模块也可能依赖其他模块，其他模块同样可能有自己的依赖。于是模块化 JavaScript 应用程序的所有模块会构成依赖图。<br>可以通过有向图来表示应用程序中各模块的依赖关系。<br>在 JavaScript 中，“加载”的概念可以有多种实现方式。因为模块是作为包含将立即执行的 JavaScript代码的文件实现的，所以一种可能是按照依赖图的要求依次请求各个脚本。对于前面的应用程序来说，下面的脚本请求顺序能够满足依赖图的要求：<script src="moduleE.js"></script> 
<script src="moduleD.js"></script> 
<script src="moduleC.js"></script> 
<script src="moduleB.js"></script> 
<script src="moduleA.js"></script>
模块加载是“阻塞的”，这意味着前置操作必须完成才能执行后续操作。</li>
<li>异步依赖: 因为 JavaScript 可以异步执行，所以如果能按需加载就好了。换句话说，可以让 JavaScript 通知模块系统在必要时加载新模块，并在模块加载完成后提供回调。在代码层面，可以通过下面的伪代码来实现：<br>&#x2F;&#x2F; 在模块 A 里面<br>load(‘moduleB’).then(function(moduleB) {<br> moduleB.doStuff();<br>});<br>模块 A 的代码使用了 moduleB 标识符向模块系统请求加载模块 B，并以模块 B 作为参数调用回调。模块 B 可能已加载完成，也可能必须重新请求和初始化，但这里的代码并不关心。这些事情都交给了模块加载器去负责。</li>
<li>动态依赖: 有些模块系统要求开发者在模块开始列出所有依赖，而有些模块系统则允许开发者在程序结构中动态添加依赖。动态添加的依赖有别于模块开头列出的常规依赖，这些依赖必须在模块执行前加载完毕。<br>下面是动态依赖加载的例子：<br>if (loadCondition) {<br> require(‘.&#x2F;moduleA’);<br>}<br>动态依赖可以支持更复杂的依赖关系，但代价是增加了对模块进行静态分析的难度。</li>
<li>静态分析: 模块中包含的发送到浏览器的 JavaScript 代码经常会被静态分析，分析工具会检查代码结构并在不实际执行代码的情况下推断其行为。对静态分析友好的模块系统可以让模块打包系统更容易将代码处理为较少的文件。它还将支持在智能编辑器里智能自动完成。<br>更复杂的模块行为，例如动态依赖，会导致静态分析更困难。不同的模块系统和模块加载器具有不同层次的复杂度。至于模块的依赖，额外的复杂度会导致相关工具更难预测模块在执行时到底需要哪些依赖。</li>
<li>循环依赖: 要构建一个没有循环依赖的 JavaScript 应用程序几乎是不可能的，因此包括 CommonJS、AMD 和ES6 在内的所有模块系统都支持循环依赖。在包含循环依赖的应用程序中，模块加载顺序可能会出人意料。不过，只要恰当地封装模块，使它们没有副作用，加载顺序就应该不会影响应用程序的运行。<br>3、凑合的模块系统: 为按照模块模式提供必要的封装，ES6 之前的模块有时候会使用函数作用域和立即调用函数表达式（IIFE，Immediately Invoked Function Expression）将模块定义封装在匿名闭包中。模块定义是立即执行的，如下：<br>(function() {<br> &#x2F;&#x2F; 私有 Foo 模块的代码<br> console.log(‘bar’);<br>})();<br>&#x2F;&#x2F; bar<br>4、使用ES6之前的模块加载器: 在 ES6 原生支持模块之前，使用模块的 JavaScript 代码本质上是希望使用默认没有的语言特性。因此，必须按照符合某种规范的模块语法来编写代码，另外还需要单独的模块工具把这些模块语法与JavaScript 运行时连接起来。这里的模块语法和连接方式有不同的表现形式，通常需要在浏览器中额外加载库或者在构建时完成预处理。</li>
<li>CommonJS: CommonJS 规范概述了同步声明依赖的模块定义。这个规范主要用于在服务器端实现模块化代码组织，但也可用于定义在浏览器中使用的模块依赖。CommonJS 模块语法不能在浏览器中直接运行。<br>注意 一般认为，Node.js的模块系统使用了CommonJS规范，实际上并不完全正确。Node.js使用了轻微修改版本的 CommonJS，因为 Node.js 主要在服务器环境下使用，所以不需要考虑网络延迟问题。考虑到一致性，本节使用 Node.js 风格的模块定义语法。<br>CommonJS 模块定义需要使用 require()指定依赖，而使用 exports 对象定义自己的公共 API。下面的代码展示了简单的模块定义：<br>var moduleB &#x3D; require(‘.&#x2F;moduleB’);<br>module.exports &#x3D; {<br> stuff: moduleB.doStuff();<br>};<br>无论一个模块在 require()中被引用多少次，模块永远是单例。在下面的例子中，moduleA 只会被打印一次。这是因为无论请求多少次，moduleA 只会被加载一次。<br>console.log(‘moduleA’);<br>var a1 &#x3D; require(‘.&#x2F;moduleA’);<br>var a2 &#x3D; require(‘.&#x2F;moduleA’);<br>console.log(a1 &#x3D;&#x3D;&#x3D; a2); &#x2F;&#x2F; true<br>在 CommonJS 中，模块加载是模块系统执行的同步操作。因此 require()可以像下面这样以编程方式嵌入在模块中：<br>console.log(‘moduleA’);<br>if (loadCondition) {<br> require(‘.&#x2F;moduleA’);<br>}<br>这里，moduleA 只会在 loadCondition 求值为 true 时才会加载。这个加载是同步的，因此 if()块之前的任何代码都会在加载 moduleA 之前执行，而 if()块之后的任何代码都会在加载 moduleA 之后执行。<br>注意，此模块不导出任何内容。即使它没有公共接口，如果应用程序请求了这个模块，那也会在加载时执行这个模块体。<br>module.exports 对象非常灵活，有多种使用方式。如果只想导出一个实体，可以直接给 module.exports 赋值：<br>module.exports &#x3D; ‘foo’;<br>这样，整个模块就导出一个字符串，可以像下面这样使用：<br>var moduleA &#x3D; require(‘.&#x2F;moduleB’);<br>console.log(moduleB); &#x2F;&#x2F; ‘foo’<br>导出多个值也很常见，可以使用对象字面量赋值或每个属性赋一次值来实现：<br>&#x2F;&#x2F; 等价操作：<br>module.exports &#x3D; {<br> a: ‘A’,<br> b: ‘B’<br>};<br>module.exports.a &#x3D; ‘A’;<br>module.exports.b &#x3D; ‘B’;</li>
<li>异步模块定义: CommonJS 以服务器端为目标环境，能够一次性把所有模块都加载到内存，而异步模块定义（AMD，Asynchronous Module Definition）的模块定义系统则以浏览器为目标执行环境，这需要考虑网络延迟的问题。AMD 的一般策略是让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块。<br>AMD 模块实现的核心是用函数包装模块定义。AMD 模块可以使用字符串标识符指定自己的依赖，而 AMD 加载器会在所有依赖模块加载完毕后立即调用模块工厂函数。与 CommonJS 不同，AMD 支持可选地为模块指定字符串标识符。<br>&#x2F;&#x2F; ID 为’moduleA’的模块定义。moduleA 依赖 moduleB，<br>&#x2F;&#x2F; moduleB 会异步加载<br>define(‘moduleA’, [‘moduleB’], function(moduleB) {<br> return {<br> stuff: moduleB.doStuff();<br> };<br>});<br>AMD 也支持 require 和 exports 对象，通过它们可以在 AMD 模块工厂函数内部定义 CommonJS风格的模块。这样可以像请求模块一样请求它们，但 AMD 加载器会将它们识别为原生 AMD 结构，而不是模块定义：<br>define(‘moduleA’, [‘require’, ‘exports’], function(require, exports) {<br> var moduleB &#x3D; require(‘moduleB’);<br> exports.stuff &#x3D; moduleB.doStuff();<br>});<br>动态依赖也是通过这种方式支持的：<br>define(‘moduleA’, [‘require’], function(require) {<br> if (condition) {<br> var moduleB &#x3D; require(‘moduleB’);<br> }<br>});</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-21 日报 Day163</title>
    <url>/undefined/2025-04-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>只争朝夕、不负韶华，是对未来最好的宣示。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P783-790 第二十六章：模块</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、使用ES6模块: ES6 最大的一个改进就是引入了模块规范。这个规范全方位简化了之前出现的模块加载器，原生浏览器支持意味着加载器及其他预处理都不再必要。从很多方面看，ES6 模块系统是集 AMD 和 CommonJS之大成者。</p>
<ul>
<li>模块标签及定义: ECMAScript 6 模块是作为一整块 JavaScript 代码而存在的。带有 type&#x3D;”module”属性的<script> 标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。模块可以嵌入在网页中，也可以作为外部文件引入：<script type="module"> 
 // 模块代码
</script> 
<script type="module" src="path/to/myModule.js"></script>
即使与常规 JavaScript 文件处理方式不同，JavaScript 模块文件也没有专门的内容类型。<br>与传统脚本不同，所有模块都会像<script defer>加载的脚本一样按顺序执行。解析到<script type="module">标签后会立即下载模块文件，但执行会延迟到文档解析完成。无论对嵌入的模块代码，还是引入的外部模块文件，都是这样。<script type="module">在页面中出现的顺序就是它们执行的顺序。与<script defer>一样，修改模块标签的位置，无论是在<head>还是在<body>中，只会影响文件什么时候加载，而不会影响模块什么时候加载。<br>下面演示了嵌入模块代码的执行顺序：<!-- 第二个执行 --> 
<script type="module"></script> 
<!-- 第三个执行 --> 
<script type="module"></script> 
<!-- 第一个执行 --> 
<script></script> 
另外，可以改为加载外部 JS 模块定义：<!-- 第二个执行 --> 
<script type="module" src="module.js"></script> 
<!-- 第三个执行 --> 
<script type="module" src="module.js"></script> 
<!-- 第一个执行 --> 
<script><script>
也可以给模块标签添加 async 属性。
这样影响就是双重的：不仅模块执行顺序不再与<script>标签在页面中的顺序绑定，模块也不会等待文档完成解析才执行。不过，入口模块仍必须等待其依赖加载完成。
与<script type="module">标签关联的 ES6 模块被认为是模块图中的入口模块。一个页面上有多少个入口模块没有限制，重复加载同一个模块也没有限制。同一个模块无论在一个页面中被加载多少次，也不管它是如何加载的，实际上都只会加载一次，如下面的代码所示：
<!-- moduleA 在这个页面上只会被加载一次 --> 
<script type="module"> 
 import './moduleA.js' 
<script> 
<script type="module"> 
 import './moduleA.js' 
<script> 
<script type="module" src="./moduleA.js"></script> 
<script type="module" src="./moduleA.js"></script> 
嵌入的模块定义代码不能使用 import 加载到其他模块。只有通过外部文件加载的模块才可以使用import 加载。因此，嵌入模块只适合作为入口模块。</li>
<li>模块加载: 完全支持 ECMAScript 6 模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。浏览器会解析入口模块，确定依赖，并发送对依赖模块的请求。这些文件通过网络返回后，浏览器就会解析它们的内容，确定它们的依赖，如果这些二级依赖还没有加载，则会发送更多请求。这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。解析完依赖图，应用程序就可以正式加载模块了。</li>
<li>模块行为: ECMAScript 6 模块借用了 CommonJS 和 AMD 的很多优秀特性。下面简单列举一些。<br> 模块代码只在加载后执行。<br> 模块只能加载一次。<br> 模块是单例。<br> 模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。<br> 模块可以请求加载其他模块。<br> 支持循环依赖。<br>ES6 模块系统也增加了一些新行为。<br> ES6 模块默认在严格模式下执行。<br> ES6 模块不共享全局命名空间。<br> 模块顶级 this 的值是 undefined（常规脚本中是 window）。<br> 模块中的 var 声明不会添加到 window 对象。<br> ES6 模块是异步加载和执行的。<br>浏览器运行时在知道应该把某个文件当成模块时，会有条件地按照上述 ECMAScript 6 模块行为来施加限制。与<script type="module">关联或者通过 import 语句加载的 JavaScript 文件会被认定为模块。</li>
<li>模块导出: ES6 模块的公共导出系统与 CommonJS 非常相似。控制模块的哪些部分对外部可见的是 export 关键字。ES6 模块支持两种导出：命名导出和默认导出。不同的导出方式对应不同的导入方式，下一节会介绍导入。<br>export 关键字用于声明一个值为命名导出。导出语句必须在模块顶级，不能嵌套在某个块中：<br>// 允许<br>export ...<br>// 不允许<br>if (condition) {<br> export ...<br>}<br>导出值对模块内部 JavaScript 的执行没有直接影响，因此 export 语句与导出值的相对位置或者export 关键字在模块中出现的顺序没有限制。export 语句甚至可以出现在它要导出的值之前：<br>// 允许<br>const foo = 'foo';<br>export { foo };<br>// 允许<br>export const foo = 'foo';<br>// 允许，但应该避免<br>export { foo };<br>const foo = 'foo';<br>命名导出（named export）就好像模块是被导出值的容器。行内命名导出，顾名思义，可以在同一行执行变量声明。下面展示了一个声明变量同时又导出变量的例子。外部模块可以导入这个模块，而 foo 将成为这个导入模块的一个属性：<br>export const foo = 'foo';<br>导出时也可以提供别名，别名必须在 export 子句的大括号语法中指定。<br>const foo = 'foo';<br>export { foo as myFoo };<br>默认导出（default export）就好像模块与被导出的值是一回事。默认导出使用 default 关键字将一个值声明为默认导出，每个模块只能有一个默认导出。重复的默认导出会导致 SyntaxError。<br>下面的例子定义了一个默认导出，外部模块可以导入这个模块，而这个模块本身就是 foo 的值：<br>const foo = 'foo';<br>export default foo;<br>ES6 规范对不同形式的 export 语句中可以使用什么不可以使用什么规定了限制。某些形式允许声明和赋值，某些形式只允许表达式，而某些形式则只允许简单标识符。注意，有的形式使用了分号，有的则没有：<br>// 命名行内导出<br>export const baz = 'baz';<br>export const foo = 'foo', bar = 'bar';<br>export function foo() {}<br>export function* foo() {}<br>export class Foo {}<br>// 命名子句导出<br>export { foo };<br>export { foo, bar };<br>export { foo as myFoo, bar };<br>// 默认导出<br>export default 'foo';<br>export default 123;<br>export default /[a-z]*/;<br>export default { foo: 'foo' };</li>
<li>模块导入: 模块可以通过使用 import 关键字使用其他模块导出的值。与 export 类似，import 必须出现在模块的顶级：<br>// 允许<br>import ...<br>// 不允许<br>if (condition) {<br> import ...<br>}<br>import 语句被提升到模块顶部。因此，与 export 关键字类似，import 语句与使用导入值的语句的相对位置并不重要。不过，还是推荐把导入语句放在模块顶部。<br>模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径。它必须是纯字符串，不能是动态计算的结果。<br>如果在浏览器中通过标识符原生加载模块，则文件必须带有.js 扩展名，不然可能无法正确解析。不过，如果是通过构建工具或第三方模块加载器打包或解析的 ES6 模块，则可能不需要包含文件扩展名。<br>导入对模块而言是只读的，实际上相当于 const 声明的变量。在使用*执行批量导入时，赋值给别名的命名导出就好像使用 Object.freeze()冻结过一样。直接修改导出的值是不可能的，但可以修改导出对象的属性。同样，也不能给导出的集合添加或删除导出的属性。要修改导出的值，必须使用有内部变量和属性访问权限的导出方法。<br>import foo, * as Foo './foo.js';<br>foo = 'foo'; // 错误<br>Foo.foo = 'foo'; // 错误<br>foo.bar = 'bar'; // 允许</li>
<li>模块转移导出: 模块导入的值可以直接通过管道转移到导出。此时，也可以将默认导出转换为命名导出，或者相反。如果想把一个模块的所有命名导出集中在一块，可以像下面这样在 bar.js 中使用*导出：<br>export * from './foo.js';<br>这样，foo.js 中的所有命名导出都会出现在导入 bar.js 的模块中。如果 foo.js 有默认导出，则该语法会忽略它。使用此语法也要注意导出名称是否冲突。如果 foo.js 导出 baz，bar.js 也导出 baz，则最终导出的是 bar.js 中的值。这个“重写”是静默发生的：</li>
<li>工作者模块: ECMAScript 6 模块与 Worker 实例完全兼容。在实例化时，可以给工作者传入一个指向模块文件的路径，与传入常规脚本文件一样。Worker 构造函数接收第二个参数，用于说明传入的是模块文件。<br>下面是两种类型的 Worker 的实例化行为：<br>// 第二个参数默认为{ type: 'classic' }<br>const scriptWorker = new Worker('scriptWorker.js');<br>const moduleWorker = new Worker('moduleWorker.js', { type: 'module' });<br>在基于模块的工作者内部，self.importScripts()方法通常用于在基于脚本的工作者中加载外部脚本，调用它会抛出错误。这是因为模块的 import 行为包含了 importScripts()。</li>
<li>向后兼容: ECMAScript 模块的兼容是个渐进的过程，能够同时兼容支持和不支持的浏览器对早期采用者是有价值的。对于想要尽可能在浏览器中原生使用 ECMAScript 6 模块的用户，可以提供两个版本的代码：基于模块的版本与基于脚本的版本。<br>第一种方案涉及在服务器上检查浏览器的用户代理，与支持模块的浏览器名单进行匹配，然后基于匹配结果决定提供哪个版本的 JavaScript 文件。这个方法不太可靠，而且比较麻烦，不推荐。更好、更优雅的方案是利用脚本的 type 属性和 nomodule 属性。<br>2、小结: 模块模式是管理复杂性的永恒工具。开发者可以通过它创建逻辑彼此独立的代码段，在这些代码段之间声明依赖，并将它们连接在一起。此外，这种模式也是经证明能够优雅扩展到任意复杂度且跨平台的方案。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-22 日报 Day164</title>
    <url>/undefined/2025-04-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>努力是一件特别需要沉下心来，长久坚持的事。它成长的土壤需要一个人单打独斗，忍受无数个孤独和寂寞的日子，当你真正发自内心想要做成某件事，就不会太在乎要不要晒给别人看。内在驱动力足够支撑你，无论遇到任何困难和挫折都能坚持到底。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P791-795 第二十七章：工作者线程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、前端开发者常说：“JavaScript 是单线程的。”这种说法虽然有些简单，但描述了 JavaScript 在浏览器中的一般行为。因此，作为帮助 Web 开发人员理解 JavaScript 的教学工具，它非常有用。<br>单线程就意味着不能像多线程语言那样把工作委托给独立的线程或进程去做。JavaScript 的单线程可以保证它与不同浏览器 API 兼容。假如 JavaScript 可以多线程执行并发更改，那么像 DOM 这样的 API就会出现问题。因此，POSIX 线程或 Java 的 Thread 类等传统并发结构都不适合 JavaScript。<br>而这也正是工作者线程的价值所在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模型。虽然本章要介绍的各种工作者线程有不同的形式和功能，但它们的共同的特点是都独立于JavaScript 的主执行环境。<br>2、工作者线程简介: JavaScript 环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分配一个它自己的环境。这样，每个页面都有自己的内存、事件循环、DOM，等等。每个页面就相当于一个沙盒，不会干扰其他页面。对于浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境都是并行执行的。<br>使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。这个子环境不能与依赖单线程交互的 API（如 DOM）互操作，但可以与父环境并行执行代码。</p>
<ul>
<li>工作者线程与线程:  工作者线程是以实际线程实现的。例如，Blink 浏览器引擎实现工作者线程的 WorkerThread 就对应着底层的线程。<br> 工作者线程并行执行。虽然页面和工作者线程都是单线程 JavaScript 环境，每个环境中的指令则可以并行执行。<br> 工作者线程可以共享某些内存。工作者线程能够使用 SharedArrayBuffer 在多个环境间共享内容。虽然线程会使用锁实现并发控制，但 JavaScript 使用 Atomics 接口实现并发控制。<br>工作者线程与线程有很多类似之处，但也有重要的区别。<br> 工作者线程不共享全部内存。在传统线程模型中，多线程有能力读写共享内存空间。除了 SharedArrayBuffer 外，从工作者线程进出的数据需要复制或转移。<br> 工作者线程不一定在同一个进程里。通常，一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者线程可能与页面属于同一进程，也可能不属于。例如，Chrome 的 Blink 引擎对共享工作者线程和服务工作者线程使用独立的进程。<br> 创建工作者线程的开销更大。工作者线程有自己独立的事件循环、全局对象、事件处理程序和其他 JavaScript 环境必需的特性。创建这些结构的代价不容忽视</li>
<li>工作者线程的类型: Web 工作者线程规范中定义了三种主要的工作者线程：专用工作者线程、共享工作者线程和服务工作者线程。<br>1-专用工作者线程: 专用工作者线程，通常简称为工作者线程、Web Worker 或 Worker，是一种实用的工具，可以让脚本单独创建一个 JavaScript 线程，以执行委托的任务。专用工作者线程，顾名思义，只能被创建它的页面使用。<br>2-共享工作者线程: 共享工作者线程与专用工作者线程非常相似。主要区别是共享工作者线程可以被多个不同的上下文使用，包括不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。<br>3-服务工作者线程:服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的主要用途是拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者的角色。</li>
<li>WorkerGlobalScope: 在网页上，window 对象可以向运行在其中的脚本暴露各种全局变量。在工作者线程内部，没有 window的概念。这里的全局对象是 WorkerGlobalScope 的实例，通过 self 关键字暴露出来。<br>1-WorkerGlobalScope属性和方法: self 上可用的属性是 window 对象上属性的严格子集。其中有些属性会返回特定于工作者线程的版本。<br> navigator：返回与工作者线程关联的 WorkerNavigator。<br> self：返回 WorkerGlobalScope 对象。<br> location：返回与工作者线程关联的 WorkerLocation。<br> performance：返回（只包含特定属性和方法的）Performance 对象。<br> console：返回与工作者线程关联的 Console 对象；对 API 没有限制。<br> caches：返回与工作者线程关联的 CacheStorage 对象；对 API 没有限制。<br> indexedDB：返回 IDBFactory 对象。<br> isSecureContext：返回布尔值，表示工作者线程上下文是否安全。<br> origin：返回 WorkerGlobalScope 的源。<br>类似地，self 对象上暴露的一些方法也是 window 上方法的子集。这些 self 上的方法也与 window上对应的方法操作一样。<br> atob()<br> btoa()<br> clearInterval()<br> clearTimeout()<br> createImageBitmap()<br> fetch()<br> setInterval()<br> setTimeout()<br>WorkerGlobalScope 还增加了新的全局方法 importScripts()，只在工作者线程内可用。本章稍后会介绍该方法。<br>2-WorkerGlobalScope 的子类<br>实际上并不是所有地方都实现了 WorkerGlobalScope。每种类型的工作者线程都使用了自己特定的全局对象，这继承自 WorkerGlobalScope。<br> 专用工作者线程使用 DedicatedWorkerGlobalScope。<br> 共享工作者线程使用 SharedWorkerGlobalScope。<br> 服务工作者线程使用 ServiceWorkerGlobalScope。<br>本章稍后会在这些全局对象对应的小节中讨论其差异。<br>3、专用工作者线程: 专用工作者线程是最简单的 Web 工作者线程，网页中的脚本可以创建专用工作者线程来执行在页面线程之外的其他任务。这样的线程可以与父页面交换信息、发送网络请求、执行文件输入&#x2F;输出、进行密集计算、处理大量数据，以及实现其他不适合在页面执行线程里做的任务（否则会导致页面响应迟钝）。</li>
<li>专用工作者线程的基本概念: 可以把专用工作者线程称为后台脚本（background script）。JavaScript 线程的各个方面，包括生命周期管理、代码路径和输入&#x2F;输出，都由初始化线程时提供的脚本来控制。该脚本也可以再请求其他脚本，但一个线程总是从一个脚本源开始。<br>1-创建专用工作者线程: 创建专用工作者线程最常见的方式是加载 JavaScript 文件。把文件路径提供给 Worker 构造函数，然后构造函数再在后台异步加载脚本并实例化工作者线程。传给构造函数的文件路径可以是多种形式。<br>下面的代码演示了如何创建空的专用工作者线程：<br>emptyWorker.js<br>&#x2F;&#x2F; 空的 JS 工作者线程文件<br>main.js<br>console.log(location.href); &#x2F;&#x2F; “<a class="link"   href="https://example.com/" >https://example.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“<br>const worker &#x3D; new Worker(location.href + ‘emptyWorker.js’);<br>console.log(worker); &#x2F;&#x2F; Worker {}<br>这个例子非常简单，但涉及几个基本概念。<br> emptyWorker.js 文件是从绝对路径加载的。根据应用程序的结构，使用绝对 URL 经常是多余的。<br> 这个文件是在后台加载的，工作者线程的初始化完全独立于 main.js。<br> 工作者线程本身存在于一个独立的 JavaScript 环境中，因此 main.js 必须以 Worker 对象为代理实现与工作者线程通信。在上面的例子中，该对象被赋值给了 worker 变量。<br> 虽然相应的工作者线程可能还不存在，但该 Worker 对象已在原始环境中可用了。<br>前面的例子可修改为使用相对路径。不过，这要求 main.js 必须与 emptyWorker.js 在同一个路径下：<br>const worker &#x3D; new Worker(‘.&#x2F;emptyWorker.js’);<br>console.log(worker); &#x2F;&#x2F; Worker {}<br>2-工作者线程安全限制: 工作者线程的脚本文件只能从与父页面相同的源加载。从其他源加载工作者线程的脚本文件会导致错误，如下所示：<br>&#x2F;&#x2F; 尝试基于 <a class="link"   href="https://example.com/worker.js" >https://example.com/worker.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 创建工作者线程<br>const sameOriginWorker &#x3D; new Worker(‘.&#x2F;worker.js’);<br>&#x2F;&#x2F; 尝试基于 <a class="link"   href="https://untrusted.com/worker.js" >https://untrusted.com/worker.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 创建工作者线程<br>const remoteOriginWorker &#x3D; new Worker(‘<a class="link"   href="https://untrusted.com/worker.js" >https://untrusted.com/worker.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘);<br>&#x2F;&#x2F; Error: Uncaught DOMException: Failed to construct ‘Worker’:<br>&#x2F;&#x2F; Script at <a class="link"   href="https://untrusted.com/main.js" >https://untrusted.com/main.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> cannot be accessed<br>&#x2F;&#x2F; from origin <a class="link"   href="https://example.com/" >https://example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>注意 不能使用非同源脚本创建工作者线程，并不影响执行其他源的脚本。在工作者线程内部，使用 importScripts()可以加载其他源的脚本。<br>基于加载脚本创建的工作者线程不受文档的内容安全策略限制，因为工作者线程在与父文档不同的上下文中运行。不过，如果工作者线程加载的脚本带有全局唯一标识符（与加载自一个二进制大文件一样），就会受父文档内容安全策略的限制。<br>3-使用worker对象: Worker()构造函数返回的 Worker 对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文间传输信息，以及捕获专用工作者线程发出的事件。<br>注意 要管理好使用 Worker()创建的每个 Worker 对象。在终止工作者线程之前，它不会被垃圾回收，也不能通过编程方式恢复对之前 Worker 对象的引用。<br>Worker 对象支持下列事件处理程序属性。<br> onerror：在工作者线程中发生 ErrorEvent 类型的错误事件时会调用指定给该属性的处理程序。<br> 该事件会在工作者线程中抛出错误时发生。<br> 该事件也可以通过 worker.addEventListener(‘error’, handler)的形式处理。<br> onmessage：在工作者线程中发生 MessageEvent 类型的消息事件时会调用指定给该属性的处理程序。<br> 该事件会在工作者线程向父上下文发送消息时发生。<br> 该事件也可以通过使用 worker.addEventListener(‘message’, handler)处理。<br> onmessageerror：在工作者线程中发生 MessageEvent 类型的错误事件时会调用指定给该属性的处理程序。<br> 该事件会在工作者线程收到无法反序列化的消息时发生。<br> 该事件也可以通过使用 worker.addEventListener(‘messageerror’, handler)处理。<br>Worker 对象还支持下列方法。<br> postMessage()：用于通过异步消息事件向工作者线程发送信息。<br> terminate()：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。<br>4-DedicatedWorkerGlobalScope: 在专用工作者线程内部，全局作用域是 DedicatedWorkerGlobalScope 的实例。因为这继承自WorkerGlobalScope，所以包含它的所有属性和方法。工作者线程可以通过 self 关键字访问该全局作用域。<br>globalScopeWorker.js<br>console.log(‘inside worker:’, self);<br>main.js<br>const worker &#x3D; new Worker(‘.&#x2F;globalScopeWorker.js’);<br>console.log(‘created worker:’, worker);<br>&#x2F;&#x2F; created worker: Worker {}<br>&#x2F;&#x2F; inside worker: DedicatedWorkerGlobalScope {}<br>如此例所示，顶级脚本和工作者线程中的 console 对象都将写入浏览器控制台，这对于调试非常有用。因为工作者线程具有不可忽略的启动延迟，所以即使 Worker 对象存在，工作者线程的日志也会在主线程的日志之后打印出来。<br>注意 这里两个独立的 JavaScript 线程都在向一个 console 对象发消息，该对象随后将消息序列化并在浏览器控制台打印出来。浏览器从两个不同的 JavaScript 线程收到消息，并按照自己认为合适的顺序输出这些消息。为此，在多线程应用程序中使用日志确定操作顺序时必须要当心。<br>DedicatedWorkerGlobalScope 在 WorkerGlobalScope 基础上增加了以下属性和方法。<br> name：可以提供给 Worker 构造函数的一个可选的字符串标识符。<br> postMessage()：与 worker.postMessage()对应的方法，用于从工作者线程内部向父上下文发送消息。<br> close()：与 worker.terminate()对应的方法，用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。<br> importScripts()：用于向工作者线程中导入任意数量的脚本。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-24 日报 Day166</title>
    <url>/undefined/2025-04-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>当你能量越来越高的时候，你开始真正理解每一个人，没有好坏，没有对错，只是他处在不同的能量频率，呈现出了不同的状态，做了不同的选择。言慢者贵，性柔者富，德厚者旺。请允许自己做自己，也允许别人做别人，你会活得更洒脱。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P801- 第二十七章：工作者线程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、委托任务到子工作者线程: 有时候可能需要在工作者线程中再创建子工作者线程。在有多个 CPU 核心的时候，使用多个子工作者线程可以实现并行计算。使用多个子工作者线程前要考虑周全，确保并行计算的投入确实能够得到收益，毕竟同时运行多个子线程会有很大计算成本。<br>除了路径解析不同，创建子工作者线程与创建普通工作者线程是一样的。子工作者线程的脚本路径根据父工作者线程而不是相对于网页来解析。来看下面的例子（注意额外的 js 目录）：<br>main.js<br>const worker &#x3D; new Worker(‘.&#x2F;js&#x2F;worker.js’);<br>&#x2F;&#x2F; worker<br>&#x2F;&#x2F; subworker<br>js&#x2F;worker.js<br>console.log(‘worker’);<br>const worker &#x3D; new Worker(‘.&#x2F;subworker.js’);<br>js&#x2F;subworker.js<br>console.log(‘subworker’);<br>注意 顶级工作者线程的脚本和子工作者线程的脚本都必须从与主页相同的源加载。<br>2、处理工作者线程错误: 如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。如下例所示，其中的 try&#x2F;catch 块不会捕获到错误：<br>main.js<br>try {<br> const worker &#x3D; new Worker(‘.&#x2F;worker.js’);<br> console.log(‘no error’);<br>} catch(e) {<br> console.log(‘caught error’);<br>}<br>&#x2F;&#x2F; no error<br>worker.js<br>throw Error(‘foo’);<br>不过，相应的错误事件仍然会冒泡到工作者线程的全局上下文，因此可以通过在 Worker 对象上设置错误事件侦听器访问到。下面看这个例子：<br>main.js<br>const worker &#x3D; new Worker(‘.&#x2F;worker.js’);<br>worker.onerror &#x3D; console.log;<br>&#x2F;&#x2F; ErrorEvent {message: “Uncaught Error: foo”}<br>worker.js<br>throw Error(‘foo’);<br>3、与专用工作者线程通信: 与工作者线程的通信都是通过异步消息完成的，但这些消息可以有多种形式。</p>
<ul>
<li>使用postMessage(): 最简单也最常用的形式是使用 postMessage()传递序列化的消息。下面来看一个计算阶乘的例子：<br>factorialWorker.js<br>function factorial(n) {<br> let result &#x3D; 1;<br> while(n) { result *&#x3D; n–; }<br> return result;<br>}<br>self.onmessage &#x3D; ({data}) &#x3D;&gt; {<br> self.postMessage(<code>$&#123;data&#125;! = $&#123;factorial(data)&#125;</code>);<br>};<br>main.js<br>const factorialWorker &#x3D; new Worker(‘.&#x2F;factorialWorker.js’);<br>factorialWorker.onmessage &#x3D; ({data}) &#x3D;&gt; console.log(data);<br>factorialWorker.postMessage(5);<br>factorialWorker.postMessage(7);<br>factorialWorker.postMessage(10);<br>&#x2F;&#x2F; 5! &#x3D; 120<br>&#x2F;&#x2F; 7! &#x3D; 5040<br>&#x2F;&#x2F; 10! &#x3D; 3628800<br>对于传递简单的消息，使用 postMessage()在主线程和工作者线程之间传递消息，与在两个窗口间传递消息非常像。主要区别是没有 targetOrigin 的限制，该限制是针对 Window.prototype.postMessage 的，对 WorkerGlobalScope.prototype.postMessage 或 Worker.prototype. postMessage 没有影响。这样约定的原因很简单：工作者线程脚本的源被限制为主页的源，因此没有必要再去过滤了。</li>
<li>使用MessageChannel: 无论主线程还是工作者线程，通过 postMessage()进行通信涉及调用全局对象上的方法，并定义一个临时的传输协议。这个过程可以被 Channel Messaging API 取代，基于该 API 可以在两个上下文间明确建立通信渠道。<br>MessageChannel 实例有两个端口，分别代表两个通信端点。要让父页面和工作线程通过MessageChannel 通信，需要把一个端口传到工作者线程中，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">worker.<span class="property">js</span></span><br><span class="line"><span class="comment">// 在监听器中存储全局 messagePort </span></span><br><span class="line"><span class="keyword">let</span> messagePort = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> result = <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">while</span>(n) &#123; result *= n--; &#125; </span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 在全局对象上添加消息处理程序</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;ports&#125;</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// 只设置一次端口</span></span><br><span class="line"> <span class="keyword">if</span> (!messagePort) &#123; </span><br><span class="line"> <span class="comment">// 初始化消息发送端口，</span></span><br><span class="line"> <span class="comment">// 给变量赋值并重置监听器</span></span><br><span class="line">  messagePort = ports[<span class="number">0</span>]; </span><br><span class="line"> self.<span class="property">onmessage</span> = <span class="literal">null</span>; </span><br><span class="line"> <span class="comment">// 在全局对象上设置消息处理程序</span></span><br><span class="line"> messagePort.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123; </span><br><span class="line"> <span class="comment">// 收到消息后发送数据</span></span><br><span class="line"> messagePort.<span class="title function_">postMessage</span>(<span class="string">`<span class="subst">$&#123;data&#125;</span>! = <span class="subst">$&#123;factorial(data)&#125;</span>`</span>); </span><br><span class="line"> &#125;; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">main.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>(); </span><br><span class="line"><span class="keyword">const</span> factorialWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>); </span><br><span class="line"><span class="comment">// 把`MessagePort`对象发送到工作者线程</span></span><br><span class="line"><span class="comment">// 工作者线程负责处理初始化信道</span></span><br><span class="line">factorialWorker.<span class="title function_">postMessage</span>(<span class="literal">null</span>, [channel.<span class="property">port1</span>]); </span><br><span class="line"><span class="comment">// 通过信道实际发送数据</span></span><br><span class="line">channel.<span class="property">port2</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line"><span class="comment">// 工作者线程通过信道响应</span></span><br><span class="line">channel.<span class="property">port2</span>.<span class="title function_">postMessage</span>(<span class="number">5</span>); </span><br><span class="line"><span class="comment">// 5! = 120</span></span><br></pre></td></tr></table></figure></div>
…to be continued</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-23 日报 Day165</title>
    <url>/undefined/2025-04-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有风有雨是常态，风雨无阻是心态，风雨兼程是状态。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P796-800 第二十七章：工作者线程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、专用工作者线程与隐式 MessagePorts: 专用工作者线程的 Worker 对象和 DedicatedWorkerGlobalScope 与 MessagePorts 有一些相同接口处理程序和方法：onmessage、onmessageerror、close()和 postMessage()。这不是偶然的，因为专用工作者线程隐式使用了 MessagePorts 在两个上下文之间通信。<br>父上下文中的 Worker 对象和 DedicatedWorkerGlobalScope 实际上融合了 MessagePort，并在自己的接口中分别暴露了相应的处理程序和方法。换句话说，消息还是通过 MessagePort 发送，只是没有直接使用 MessagePort 而已。<br>也有不一致的地方，比如 start()和 close()约定。专用工作者线程会自动发送排队的消息，因此 start()也就没有必要了。另外，close()在专用工作者线程的上下文中没有意义，因为这样关闭MessagePort 会使工作者线程孤立。因此，在工作者线程内部调用 close()（或在外部调用terminate()）不仅会关闭 MessagePort，也会终止线程。<br>2、专用工作者线程的生命周期: 调用 Worker()构造函数是一个专用工作者线程生命的起点。调用之后，它会初始化对工作者线程脚本的请求，并把 Worker 对象返回给父上下文。虽然父上下文中可以立即使用这个 Worker 对象，但与之关联的工作者线程可能还没有创建，因为存在请求脚本的网格延迟和初始化延迟。<br>一般来说，专用工作者线程可以非正式区分为处于下列三个状态：初始化（initializing）、活动（active）和终止（terminated）。这几个状态对其他上下文是不可见的。虽然 Worker 对象可能会存在于父上下文中，但也无法通过它确定工作者线程当前是处理初始化、活动还是终止状态。换句话说，与活动的专用工作者线程关联的 Worker 对象和与终止的专用工作者线程关联的 Worker 对象无法分别。<br>初始化时，虽然工作者线程脚本尚未执行，但可以先把要发送给工作者线程的消息加入队列。这些消息会等待工作者线程的状态变为活动，再把消息添加到它的消息队列。下面的代码演示了这个过程。<br>initializingWorker.js<br>self.addEventListener(‘message’, ({data}) &#x3D;&gt; console.log(data));<br>main.js<br>const worker &#x3D; new Worker(‘.&#x2F;initializingWorker.js’);<br>&#x2F;&#x2F; Worker 可能仍处于初始化状态<br>&#x2F;&#x2F; 但 postMessage()数据可以正常处理<br>worker.postMessage(‘foo’);<br>worker.postMessage(‘bar’);<br>worker.postMessage(‘baz’);<br>&#x2F;&#x2F; foo<br>&#x2F;&#x2F; bar<br>&#x2F;&#x2F; baz<br>创建之后，专用工作者线程就会伴随页面的整个生命期而存在，除非自我终止（self.close()）或通过外部终止（worker.terminate()）。即使线程脚本已运行完成，线程的环境仍会存在。只要工作者线程仍存在，与之关联的 Worker 对象就不会被当成垃圾收集掉。<br>自我终止和外部终止最终都会执行相同的工作者线程终止例程。来看下面的例子，其中工作者线程在发送两条消息中间执行了自我终止：<br>closeWorker.js<br>self.postMessage(‘foo’);<br>self.close();<br>self.postMessage(‘bar’);<br>setTimeout(() &#x3D;&gt; self.postMessage(‘baz’), 0);<br>main.js<br>const worker &#x3D; new Worker(‘.&#x2F;closeWorker.js’);<br>worker.onmessage &#x3D; ({data}) &#x3D;&gt; console.log(data);<br>&#x2F;&#x2F; foo<br>&#x2F;&#x2F; bar<br>虽然调用了 close()，但显然工作者线程的执行并没有立即终止。close()在这里会通知工作者线程取消事件循环中的所有任务，并阻止继续添加新任务。这也是为什么”baz”没有打印出来的原因。工作者线程不需要执行同步停止，因此在父上下文的事件循环中处理的”bar”仍会打印出来。<br>下面来看外部终止的例子。<br>terminateWorker.js<br>self.onmessage &#x3D; ({data}) &#x3D;&gt; console.log(data);<br>main.js<br>const worker &#x3D; new Worker(‘.&#x2F;terminateWorker.js’);<br>&#x2F;&#x2F; 给 1000 毫秒让工作者线程初始化<br>setTimeout(() &#x3D;&gt; {<br> worker.postMessage(‘foo’);<br> worker.terminate();<br> worker.postMessage(‘bar’);<br> setTimeout(() &#x3D;&gt; worker.postMessage(‘baz’), 0);<br>}, 1000);<br>&#x2F;&#x2F; foo<br>这里，外部先给工作者线程发送了带”foo”的 postMessage，这条消息可以在外部终止之前处理。一旦调用了 terminate()，工作者线程的消息队列就会被清理并锁住，这也是只是打印”foo”的原因。<br>注意 close()和 terminate()是幂等操作，多次调用没有问题。这两个方法仅仅是将Worker 标记为 teardown，因此多次调用不会有不好的影响。<br>在整个生命周期中，一个专用工作者线程只会关联一个网页（Web 工作者线程规范称其为一个文档）。除非明确终止，否则只要关联文档存在，专用工作者线程就会存在。如果浏览器离开网页（通过导航或关闭标签页或关闭窗口），它会将与其关联的工作者线程标记为终止，它们的执行也会立即停止。<br>3、配置Worker选项: Worker()构造函数允许将可选的配置对象作为第二个参数。该配置对象支持下列属性。<br> name：可以在工作者线程中通过 self.name 读取到的字符串标识符。<br> type：表示加载脚本的运行方式，可以是”classic”或”module”。”classic”将脚本作为常规脚本来执行，”module”将脚本作为模块来执行。<br> credentials：在 type 为”module”时，指定如何获取与传输凭证数据相关的工作者线程模块脚本。值可以是”omit”、”same-orign”或”include”。这些选项与 fetch()的凭证选项相同。在 type 为”classic”时，默认为”omit”。<br>4、在javaScript行内创建工作者线程: 工作者线程需要基于脚本文件来创建，但这并不意味着该脚本必须是远程资源。专用工作者线程也可以通过 Blob 对象 URL 在行内脚本创建。这样可以更快速地初始化工作者线程，因为没有网络延迟。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建要执行的 JavaScript 代码字符串</span></span><br><span class="line"><span class="keyword">const</span> workerScript = <span class="string">` </span></span><br><span class="line"><span class="string"> self.onmessage = (&#123;data&#125;) =&gt; console.log(data); </span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="comment">// 基于脚本字符串生成 Blob 对象</span></span><br><span class="line"><span class="keyword">const</span> workerScriptBlob = <span class="keyword">new</span> <span class="title class_">Blob</span>([workerScript]); </span><br><span class="line"><span class="comment">// 基于 Blob 实例创建对象 URL </span></span><br><span class="line"><span class="keyword">const</span> workerScriptBlobUrl = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(workerScriptBlob); </span><br><span class="line"><span class="comment">// 基于对象 URL 创建专用工作者线程</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(workerScriptBlobUrl); </span><br><span class="line">worker.<span class="title function_">postMessage</span>(<span class="string">&#x27;blob worker script&#x27;</span>); </span><br><span class="line"><span class="comment">// blob worker script</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，通过脚本字符串创建了 Blob，然后又通过 Blob 创建了对象 URL，最后把对象 URL传给了 Worker()构造函数。该构造函数同样创建了专用工作者线程。<br>这里有意使用了斐波那契数列的实现，将其序列化之后传给了工作者线程。该函数作为 IIFE 调用并传递参数，结果则被发送回主线程。虽然计算斐波那契数列比较耗时，但所有计算都会委托到工作者线程，因此并不会影响父上下文的性能。<br>注意 像这样序列化函数有个前提，就是函数体内不能使用通过闭包获得的引用，也包括全局变量，比如 window，因为这些引用在工作者线程中执行时会出错。<br>5、在工作者线程中动态执行脚本: 工作者线程中的脚本并非铁板一块，而是可以使用 importScripts()方法通过编程方式加载和执行任意脚本。该方法可用于全局 Worker 对象。这个方法会加载脚本并按照加载顺序同步执行。比如，下面的例子加载并执行了两个脚本：<br>main.js<br>const worker &#x3D; new Worker(‘.&#x2F;worker.js’);<br>&#x2F;&#x2F; importing scripts<br>&#x2F;&#x2F; scriptA executes<br>&#x2F;&#x2F; scriptB executes<br>&#x2F;&#x2F; scripts imported<br>scriptA.js<br>console.log(‘scriptA executes’);<br>scriptB.js<br>console.log(‘scriptB executes’);<br>worker.js<br>console.log(‘importing scripts’);<br>importScripts(‘.&#x2F;scriptA.js’);<br>importScripts(‘.&#x2F;scriptB.js’);<br>console.log(‘scripts imported’);<br>importScripts()方法可以接收任意数量的脚本作为参数。浏览器下载它们的顺序没有限制，但执行则会严格按照它们在参数列表的顺序进行。因此，下面的代码与前面的效果一样：<br>console.log(‘importing scripts’);<br>importScripts(‘.&#x2F;scriptA.js’, ‘.&#x2F;scriptB.js’);<br>console.log(‘scripts imported’);<br>脚本加载受到常规 CORS 的限制，但在工作者线程内部可以请求来自任何源的脚本。这里的脚本导入策略类似于使用生成的<script>标签动态加载脚本。在这种情况下，所有导入的脚本也会共享作用域。下面的代码演示了这个事实：<br>main.js<br>const worker = new Worker('./worker.js', {name: 'foo'});<br>// importing scripts in foo with bar<br>// scriptA executes in foo with bar<br>// scriptB executes in foo with bar<br>// scripts imported<br>scriptA.js<br>console.log(<code>scriptA executes in $&#123;self.name&#125; with $&#123;globalToken&#125;</code>);<br>scriptB.js<br>console.log(<code>scriptB executes in $&#123;self.name&#125; with $&#123;globalToken&#125;</code>);<br>worker.js<br>const globalToken = 'bar';<br>console.log(<code>importing scripts in $&#123;self.name&#125; with $&#123;globalToken&#125;</code>);<br>importScripts('./scriptA.js', './scriptB.js');<br>console.log('scripts imported');</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-25 日报 Day167</title>
    <url>/undefined/2025-04-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>当你能量越来越高的时候，你开始真正理解每一个人，没有好坏，没有对错，只是他处在不同的能量频率，呈现出了不同的状态，做了不同的选择。言慢者贵，性柔者富，德厚者旺。请允许自己做自己，也允许别人做别人，你会活得更洒脱。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P843- 第二十七章：工作者线程</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、最佳实践之可维护性:<br>编写可维护的代码十分重要，因为大多数开发者会花大量时间去维护别人写的代码。实际开发中，从第一行代码开始写起的情况非常少，通常是要在别人的代码之上构建自己的工作。让自己的代码容易维护，可以保证其他开发者更好地完成自己的工作。</p>
<ul>
<li>什么是可维护的代码:<br>通常，说代码“可维护”就意味着它具备如下特点。<br> 容易理解：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它是怎么实现的。<br> 符合常识：代码中的一切都显得顺理成章，无论操作有多么复杂。<br> 容易适配：即使数据发生变化也不用完全重写。<br> 容易扩展：代码架构经过认真设计，支持未来扩展核心功能。<br> 容易调试：出问题时，代码可以给出明确的信息，通过它能直接定位问题。</li>
<li>编码规范:编码规范对 JavaScript 而言非常重要，因为这门语言实在太灵活了。<br>可读性、变量和函数命名、变量类型透明化</li>
<li>松散耦合: 只要应用程序的某个部分对另一个部分依赖得过于紧密，代码就会变成紧密耦合，因而难以维护。典型的问题是在一个对象中直接引用另一个对象，这样，修改其中一个，可能必须还得修改另一个。紧密耦合的软件难于维护，肯定需要频繁地重写。<br>2、部署: 任何 JavaScript 解决方案最重要的部分可能就是把网站或 Web 应用程序部署到线上环境了。</li>
<li>构建流程: 准备发布 JavaScript 代码时最重要一环是准备构建流程。开发软件的典型模式是编码、编译和测试。换句话说，首先要写代码，然后编译，之后运行并确保它能够正常工作。但因为 JavaScript 不是编译型语言，所以这个流程经常会变成编码、测试。<br>摇树优化（tree shaking）是非常常见且极为有效的减少冗余代码的策略。</li>
<li>压缩: 谈到 JavaScript 文件压缩，实际上主要是两件事：代码大小（code size）和传输负载（wire weight）</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-04-27 日报 Day169</title>
    <url>/undefined/2025-04-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>铭记誓词、以行践诺。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、<a class="link"   href="https://www.youtube.com/watch?v=EVFZazcxAbo" >https://www.youtube.com/watch?v=EVFZazcxAbo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、JSX的本质: </p>
<ul>
<li>JSX是JavaScript的语法扩展，允许在JavaScript代码中直接编写类似HTML的标签。</li>
<li>在编译(Babel)时，JSX会被转换为React.createElement()调用，这些调用创建了React元素。</li>
<li>JSX使得组件的结构更直观，易于理解和维护。<br>JSX语法躺允许前端开发者使用最为熟悉的类HTML标签语法来创建虚拟DOM，在降低学习成本的同时，也提升了研发效率和体验。<br>USING React Without JSX:<br>For example, this code written with JSX:<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.toWhat&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">toWhat</span>=<span class="string">&quot;World&quot;</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></div>
can be rewritten without JSX like this:<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">`Hello <span class="subst">$&#123;<span class="variable language_">this</span>.props.toWhat&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Hello</span>, &#123;<span class="attr">toWhat</span>: <span class="string">&#x27;World&#x27;</span>&#125;, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>2、createELement源码解析:<br><a class="link"   href="https://legacy.reactjs.org/docs/react-api.html#createelement" >https://legacy.reactjs.org/docs/react-api.html#createelement <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://react.dev/reference/react/createElement" >https://react.dev/reference/react/createElement <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, children</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// We don&#x27;t warn for invalid element type here because with owner stacks,</span></span><br><span class="line">    <span class="comment">// we error in the renderer. The renderer is the only one that knows what</span></span><br><span class="line">    <span class="comment">// types are valid for this particular renderer so we let it error there.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip key warning if the type isn&#x27;t valid since our key validation logic</span></span><br><span class="line">    <span class="comment">// doesn&#x27;t expect a non-string/function type and can throw confusing</span></span><br><span class="line">    <span class="comment">// errors. We don&#x27;t want exception behavior to differ between dev and</span></span><br><span class="line">    <span class="comment">// prod. (Rendering will throw with a helpful message and as soon as the</span></span><br><span class="line">    <span class="comment">// type is fixed, the key warnings will appear.)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">validateChildKeys</span>(<span class="variable language_">arguments</span>[i], type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unlike the jsx() runtime, createElement() doesn&#x27;t warn about key spread.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reserved names are extracted</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !didWarnAboutOldJSXRuntime &amp;&amp;</span><br><span class="line">        <span class="string">&#x27;__self&#x27;</span> <span class="keyword">in</span> config &amp;&amp;</span><br><span class="line">        <span class="comment">// Do not assume this is the result of an oudated JSX transform if key</span></span><br><span class="line">        <span class="comment">// is present, because the modern JSX transform sometimes outputs</span></span><br><span class="line">        <span class="comment">// createElement to preserve precedence between a static key and a</span></span><br><span class="line">        <span class="comment">// spread key. To avoid false positive warnings, we never warn if</span></span><br><span class="line">        <span class="comment">// there&#x27;s a key.</span></span><br><span class="line">        !(<span class="string">&#x27;key&#x27;</span> <span class="keyword">in</span> config)</span><br><span class="line">      ) &#123;</span><br><span class="line">        didWarnAboutOldJSXRuntime = <span class="literal">true</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Your app (or one of its dependencies) is using an outdated JSX &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;transform. Update to the modern JSX transform for &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;faster performance: https://react.dev/link/new-jsx-transform&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasValidKey</span>(config)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="title function_">checkKeyStringCoercion</span>(config.<span class="property">key</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      key = <span class="string">&#x27;&#x27;</span> + config.<span class="property">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        hasOwnProperty.<span class="title function_">call</span>(config, propName) &amp;&amp;</span><br><span class="line">        <span class="comment">// Skip over reserved prop names</span></span><br><span class="line">        propName !== <span class="string">&#x27;key&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// Even though we don&#x27;t use these anymore in the runtime, we don&#x27;t want</span></span><br><span class="line">        <span class="comment">// them to appear as props, so in createElement we filter them out.</span></span><br><span class="line">        <span class="comment">// We don&#x27;t have to do this in the jsx() runtime because the jsx()</span></span><br><span class="line">        <span class="comment">// transform never passed these as props; it used separate arguments.</span></span><br><span class="line">        propName !== <span class="string">&#x27;__self&#x27;</span> &amp;&amp;</span><br><span class="line">        propName !== <span class="string">&#x27;__source&#x27;</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Children can be more than one argument, and those are transferred onto</span></span><br><span class="line">  <span class="comment">// the newly allocated props object.</span></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.<span class="property">children</span> = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="title class_">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="variable language_">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">freeze</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">freeze</span>(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.<span class="property">children</span> = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resolve default props</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.<span class="property">defaultProps</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultProps = type.<span class="property">defaultProps</span>;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      <span class="keyword">const</span> displayName =</span><br><span class="line">        <span class="keyword">typeof</span> type === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">          ? type.<span class="property">displayName</span> || type.<span class="property">name</span> || <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line">          : type;</span><br><span class="line">      <span class="title function_">defineKeyPropWarningGetter</span>(props, displayName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> trackActualOwner =</span><br><span class="line">    __DEV__ &amp;&amp;</span><br><span class="line">    <span class="title class_">ReactSharedInternals</span>.<span class="property">recentlyCreatedOwnerStacks</span>++ &lt; ownerStackLimit;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactElement</span>(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="title function_">getOwner</span>(),</span><br><span class="line">    props,</span><br><span class="line">    __DEV__ &amp;&amp;</span><br><span class="line">      (trackActualOwner</span><br><span class="line">        ? <span class="title class_">Error</span>(<span class="string">&#x27;react-stack-top-frame&#x27;</span>)</span><br><span class="line">        : unknownOwnerDebugStack),</span><br><span class="line">    __DEV__ &amp;&amp;</span><br><span class="line">      (trackActualOwner</span><br><span class="line">        ? <span class="title function_">createTask</span>(<span class="title function_">getTaskName</span>(type))</span><br><span class="line">        : unknownOwnerDebugTask),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>CreateElement只是ReactElement的一个包装函数，主要用于处理JSX语法的转换和一些额外的属性处理。<br>3、ReactElement源码解析:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ReactElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  type,</span></span><br><span class="line"><span class="params">  key,</span></span><br><span class="line"><span class="params">  self,</span></span><br><span class="line"><span class="params">  source,</span></span><br><span class="line"><span class="params">  owner,</span></span><br><span class="line"><span class="params">  props,</span></span><br><span class="line"><span class="params">  debugStack,</span></span><br><span class="line"><span class="params">  debugTask,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Ignore whatever was passed as the ref argument and treat `props.ref` as</span></span><br><span class="line">  <span class="comment">// the source of truth. The only thing we use this for is `element.ref`,</span></span><br><span class="line">  <span class="comment">// which will log a deprecation warning on access. In the next release, we</span></span><br><span class="line">  <span class="comment">// can remove `element.ref` as well as the `ref` argument.</span></span><br><span class="line">  <span class="keyword">const</span> refProp = props.<span class="property">ref</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An undefined `element.ref` is coerced to `null` for</span></span><br><span class="line">  <span class="comment">// backwards compatibility.</span></span><br><span class="line">  <span class="keyword">const</span> ref = refProp !== <span class="literal">undefined</span> ? refProp : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> element;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// In dev, make `ref` a non-enumerable property with a warning. It&#x27;s non-</span></span><br><span class="line">    <span class="comment">// enumerable so that test matchers and serializers don&#x27;t access it and</span></span><br><span class="line">    <span class="comment">// trigger the warning.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// `ref` will be removed from the element completely in a future release.</span></span><br><span class="line">    element = &#123;</span><br><span class="line">      <span class="comment">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class="line">      <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">      type,</span><br><span class="line">      key,</span><br><span class="line"></span><br><span class="line">      props,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">      <span class="attr">_owner</span>: owner,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(element, <span class="string">&#x27;ref&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">get</span>: elementRefGetterWithDeprecationWarning,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Don&#x27;t warn on access if a ref is not given. This reduces false</span></span><br><span class="line">      <span class="comment">// positives in cases where a test serializer uses</span></span><br><span class="line">      <span class="comment">// getOwnPropertyDescriptors to compare objects, like Jest does, which is</span></span><br><span class="line">      <span class="comment">// a problem because it bypasses non-enumerability.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// So unfortunately this will trigger a false positive warning in Jest</span></span><br><span class="line">      <span class="comment">// when the diff is printed:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//   expect(&lt;div ref=&#123;ref&#125; /&gt;).toEqual(&lt;span ref=&#123;ref&#125; /&gt;);</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// A bit sketchy, but this is what we&#x27;ve done for the `props.key` and</span></span><br><span class="line">      <span class="comment">// `props.ref` accessors for years, which implies it will be good enough</span></span><br><span class="line">      <span class="comment">// for `element.ref`, too. Let&#x27;s see if anyone complains.</span></span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(element, <span class="string">&#x27;ref&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// In prod, `ref` is a regular property and _owner doesn&#x27;t exist.</span></span><br><span class="line">    element = &#123;</span><br><span class="line">      <span class="comment">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class="line">      <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">      type,</span><br><span class="line">      key,</span><br><span class="line">      ref,</span><br><span class="line"></span><br><span class="line">      props,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// The validation flag is currently mutative. We put it on</span></span><br><span class="line">    <span class="comment">// an external backing store so that we can freeze the whole object.</span></span><br><span class="line">    <span class="comment">// This can be replaced with a WeakMap once they are implemented in</span></span><br><span class="line">    <span class="comment">// commonly used development environments.</span></span><br><span class="line">    element.<span class="property">_store</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To make comparing ReactElements easier for testing purposes, we make</span></span><br><span class="line">    <span class="comment">// the validation flag non-enumerable (where possible, which should</span></span><br><span class="line">    <span class="comment">// include every environment we run tests in), so the test framework</span></span><br><span class="line">    <span class="comment">// ignores it.</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(element.<span class="property">_store</span>, <span class="string">&#x27;validated&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// debugInfo contains Server Component debug information.</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(element, <span class="string">&#x27;_debugInfo&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(element, <span class="string">&#x27;_debugStack&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: debugStack,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(element, <span class="string">&#x27;_debugTask&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: debugTask,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">freeze</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">freeze</span>(element.<span class="property">props</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">freeze</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202506140735782.png"
                      alt="image-20250614073503671"
                ><br>4、虚拟DOM: </p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AppJSX</span> = (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;App&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span>I am the title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&#x27;description&#x27;</span>&gt;</span>I am the description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ App ~ AppJSX:&quot;</span>, <span class="title class_">AppJSX</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202506140744748.png"
                      alt="image-20250614074400799"
                ></p>
<p>虚拟DOM &#x3D;&gt; 真实DOM 由ReactDOM.render()方法完成<br>5、ReactDOM.render()源码解析:<br><a href="https://github.com/facebook/react/blob/v18.2.0/packages/react-dom/src/client/ReactDOMLegacy.js">https://github.com/facebook/react/blob/v18.2.0/packages/react-dom/src/client/ReactDOMLegacy.js</a></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span></span><br><span class="line"><span class="params">  element: React$Element&lt;any&gt;,</span></span><br><span class="line"><span class="params">  container: Container,</span></span><br><span class="line"><span class="params">  callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">      <span class="string">&#x27;ReactDOM.render is no longer supported in React 18. Use createRoot &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;instead. Until you switch to the new API, your app will behave as &#x27;</span> +</span><br><span class="line">        <span class="string">&quot;if it&#x27;s running React 17. Learn &quot;</span> +</span><br><span class="line">        <span class="string">&#x27;more: https://reactjs.org/link/switch-to-createroot&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isValidContainerLegacy</span>(container)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Target container is not a DOM element.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">const</span> isModernRoot =</span><br><span class="line">      <span class="title function_">isContainerMarkedAsRoot</span>(container) &amp;&amp;</span><br><span class="line">      container.<span class="property">_reactRootContainer</span> === <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (isModernRoot) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">        <span class="string">&#x27;You are calling ReactDOM.render() on a container that was previously &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;passed to ReactDOMClient.createRoot(). This is not supported. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;Did you mean to call root.render(element)?&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202506140755079.png"
                      alt="image-20250614075552820"
                ></p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC</title>
    <url>/Yuyang/BFC/</url>
    <content><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC(Block Formatting Context) 是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level box 如何布局，并且与这个区域外部毫不相干。</p>
<h2 id="BFC-的布局规则"><a href="#BFC-的布局规则" class="headerlink" title="BFC 的布局规则"></a>BFC 的布局规则</h2><ul>
<li>内部的 Box 会在垂直方向，一个接一个地放置。</li>
<li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li>
<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反），即使存在浮动也是如此。</li>
<li>BFC 的区域不会与 float box 重叠。</li>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。</li>
<li>计算 BFC 的高度时，浮动元素也参与计算。</li>
</ul>
<h2 id="BFC的触发条件"><a href="#BFC的触发条件" class="headerlink" title="BFC的触发条件"></a>BFC的触发条件</h2><ul>
<li>根元素，即 HTML 元素</li>
<li>float 的值不为 none</li>
<li>overflow 的值不为 visible</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>position 的值为 absolute 或 fixed</li>
<li>flex 元素的子元素，且父元素的 display 值为 flex 或 inline-flex</li>
</ul>
<h2 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h2><ul>
<li>阻止 margin 重叠<br>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠,以最大的为准。<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>避免重叠可以在box外面包裹一层容器，并触发这个容器生成一个BFC，此时不会出现margin重叠</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>这时候box1和box2的margin不会重叠</p>
<ul>
<li>清除浮动<br>有浮动样式</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410201531989.png"
                      alt="image-20241020153054705"
                ></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix-example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落，如果不清除浮动，它会和上面的浮动框重叠。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#eaf2f8</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.float-box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#3498db</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.clearfix-example</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#f9e79f</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>清除浮动后</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410201534497.png"
                      alt="image-20241020153407574"
                ></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix-example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落，如果不清除浮动，它会和上面的浮动框重叠。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#eaf2f8</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.float-box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#3498db</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.clearfix-example</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#f9e79f</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>自适应两栏布局<br>这里以两栏布局为例</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410201541730.png"
                      alt="image-20241020154148226"
                ></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.aside</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此。而BFC的区域不会与浮动盒子重叠，所以可以通过触发main生成一个BFC来实现两栏布局</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.aside</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202036606.png"
                      alt="image-20241020203632868"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>Blockchain and Money Session1</title>
    <url>/Yuyang/MIT15-S12-session1/</url>
    <content><![CDATA[<p>最近在学习这个区块链课程，单纯记录一下学习笔记。</p>
<p>The Internet: Layers of open protocols</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408060025360.png"
                      alt="image-20240806002506930"
                ></p>
<h2 id="what-is-a-blockchain？"><a href="#what-is-a-blockchain？" class="headerlink" title="what is a blockchain？"></a>what is a blockchain？</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408060032056.png"
                      alt="image-20240806003227672"
                ></p>
<p>区块链技术</p>
<ul>
<li>Verifiably moves ‘data’ on a decentralized network </li>
<li>The ‘data’ can represent value or computer code </li>
<li>Thus it goes directly to the plumbing of the financial sector and money </li>
<li>Broad adoption rests on addressing technical, commercial and public policy hurdles </li>
<li>It can be a catalyst for change in the world of finance and money</li>
</ul>
<h2 id="What-is-the-Role-of-Money"><a href="#What-is-the-Role-of-Money" class="headerlink" title="What is the Role of Money?"></a>What is the Role of Money?</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408060118524.png"
                      alt="image-20240806011757446"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>2025-04-26 日报 Day168</title>
    <url>/undefined/2025-04-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>树木在森林中相依偎而生长，星辰在银河中因辉映而璀璨。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、RN</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、移动APP的开发模式: 原生开发和混合开发<br>原生开发: 原生app android | ios | windows<br>混合开发: 混合app react native | Weex | Flutter<br>h5开发: h5 app<br>2、RN的优势:</p>
<ul>
<li>开发体验好: 统一的代码规范开发移动端程序，不用关注移动端的差异</li>
<li>开发成本低: Learn once, write anywhere，开发一次，可以生成Android和iOS的app</li>
<li>学习成本低: 只要掌握js和react就可以上手RN的开发</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202506132354752.png"
                      alt="image-20250613235430232"
                ></p>
<p>3、RN的不足</p>
<ul>
<li>不成熟: 学习成本高</li>
<li>性能差: 整体性能不如原生</li>
<li>兼容性差: 设计底层的功能 需要针对Android和ios双端单独开发</li>
</ul>
<p>4、基础环境搭建: </p>
<ul>
<li>安装Node.js: Node.js是RN的核心依赖</li>
<li>安装Yarn: Yarn是一个包管理工具，可以更快地安装依赖</li>
<li>安装RN脚手架: npm install -g react-native-cli</li>
<li>安装Watchman: Watchman是一个文件监视工具，可以提高RN的开发效率 brew install watchman</li>
<li>安装CocoaPods: CocoaPods是iOS的包管理工具，可以更方便地管理iOS的依赖 brew install cocoapods</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 盒模型</title>
    <url>/Yuyang/CSS_BOX_MODEL/</url>
    <content><![CDATA[<h2 id="CSS-盒模型介绍"><a href="#CSS-盒模型介绍" class="headerlink" title="CSS 盒模型介绍"></a>CSS 盒模型介绍</h2><p>CSS中的盒模型用来描述一个元素在页面汇总的布局方式，每个HTML元素都被视为是一个矩形的盒子，这个盒子由实际内容（content）、外边距（margin）、边框（border）和内边距（padding）组成。<br>CSS盒模型主要包含两种：W3C标准盒子模型和IE怪异盒子模型。</p>
<p>CSS的box-sizing属性定义了引擎如何计算一个元素的总宽度和总高度</p>
<p>box-sizing: content-box ｜ border-box ｜inherit</p>
<ul>
<li>content-box 默认值，元素的 width&#x2F;height 不包含 padding，border 与标准盒子模型表现一致</li>
<li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li>
<li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li>
</ul>
<h3 id="标准盒子模型："><a href="#标准盒子模型：" class="headerlink" title="标准盒子模型："></a>标准盒子模型：</h3><ul>
<li>盒子总宽度 &#x3D; width + padding + border + margin</li>
<li>盒子总高度 &#x3D; height + padding + border + margin</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410200006845.png"
                      alt="image-20241020000606496"
                ></p>
<h3 id="IE怪异盒子模型："><a href="#IE怪异盒子模型：" class="headerlink" title="IE怪异盒子模型："></a>IE怪异盒子模型：</h3><ul>
<li>盒子总宽度 &#x3D; width + margin</li>
<li>盒子总高度 &#x3D; height + margin</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410200018782.png"
                      alt="image-20241020001810933"
                ></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS 盒模型示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>W3C 标准盒子模型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>IE 怪异盒子模型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#3498db</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#3498db</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>响应式设计</title>
    <url>/Yuyang/RWD/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的需求包含平台的H5和PC端，为了适应不同的屏幕尺寸，我们需要做响应式设计。<br>响应式网站设计（Responsive Web Design）是一种网络页面设计布局，页面的设计与开发应该根据用户行为以及设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相应的响应和调整。响应式设计是一种优化设计，不同于传统的网站设计，它可以使网站在不同的设备上显示效果更加友好，提高用户体验。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>响应式设计的基本原理可以根据不同的设备设置不同的样式，为了处理移动端，页面头部必须有meta标签，设置viewport。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>属性对应如下:</p>
<ul>
<li>width&#x3D;device-width: 宽度等于设备宽度</li>
<li>maximum-scale: 是缩放比例的最大值</li>
<li>initial-scale: 是初始缩放比例</li>
<li>user-scalable: 是否允许用户缩放页面</li>
</ul>
<p>实现响应式的方式有如下：</p>
<ul>
<li>媒体查询</li>
<li>百分比</li>
<li>vw&#x2F;vh</li>
<li>rem</li>
</ul>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是CSS3的一个模块，它允许你查询设备的特性，比如视口的宽度、高度、设备的宽度、高度等等。通过媒体查询，可以为不同的设备设置不同的样式。</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen (<span class="attribute">min-width</span>: <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面的代码表示，当屏幕宽度大于375px和小于600px时，body的背景颜色为lightblue。</p>
<ul>
<li><p>demo:</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>响应式设计示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">header</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#3498db</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.navbar</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">gap</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">article</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">3</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#eaf2f8</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">aside</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#f9e79f</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">footer</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">article</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">header</span> <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.navbar</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的响应式网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>服务<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些内容。这段内容会根据屏幕的大小自动调整布局。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是侧边栏的内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>版权所有 © 2024 Yuyang<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>手机版</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202350100.png"
                      alt="image-20241020234953469"
                ></p>
<ul>
<li><p>平板</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202350281.png"
                      alt="image-20241020235037286"
                ></p>
</li>
<li><p>PC网页</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202351402.png"
                      alt="image-20241020235116130"
                ></p>
<h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h3><p>百分比是相对于父元素的百分比，可以根据父元素的大小来设置子元素的大小。</p>
<h3 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw&#x2F;vh"></a>vw&#x2F;vh</h3><p>vw和vh是相对于视口的宽度和高度的百分比，1vw等于视口宽度的1%，1vh等于视口高度的1%。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem是相对于根元素的字体大小的单位，1rem等于根元素的字体大小。rem的好处是可以根据根元素的字体大小来设置子元素的大小，方便调整。默认情况下浏览器字体大小为16px, 此时1rem &#x3D; 16px。</p>
<p>为了更准确监听监听设备可视窗口变化，我们可以在css之前插入script标签，代码实现如下：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">init</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> width = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = width / <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">init</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听手机旋转事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;orientationchange&#x27;</span>, init);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听手机窗口大小变化事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, init);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="rem和em的区别"><a href="#rem和em的区别" class="headerlink" title="rem和em的区别"></a>rem和em的区别</h4><ul>
<li>rem是相对于根元素的字体大小的单位，1rem等于根元素的字体大小。</li>
<li>em是相对于父元素的字体大小的单位，1em等于父元素的字体大小。</li>
</ul>
<table>
<thead>
<tr>
<th>特点</th>
<th>em</th>
<th>rem</th>
</tr>
</thead>
<tbody><tr>
<td><strong>相对基准</strong></td>
<td>相对于<strong>父元素的字体大小</strong></td>
<td><strong>相对于</strong>根元素<html> <strong>的字体大小</strong></td>
</tr>
<tr>
<td><strong>嵌套影响</strong></td>
<td>受父级元素的字体大小影响，可能层层放大</td>
<td>不受嵌套结构影响，保持一致的参考大小</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>适用于局部样式调整，比如按钮、标题等</td>
<td>适用于全局布局，确保页面一致性和可控性</td>
</tr>
<tr>
<td><strong>优缺点</strong></td>
<td>灵活但复杂，容易因嵌套变动导致不可预期的结果</td>
<td>简单且稳定，方便全局控制字体和布局</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>自动化构建</title>
    <url>/Yuyang/autoBuild/</url>
    <content><![CDATA[<h2 id="自动化构建方案"><a href="#自动化构建方案" class="headerlink" title="自动化构建方案"></a>自动化构建方案</h2><p>通过自动化手段 提高效率 可靠性</p>
<p>构建工具： grunt webpack gulp vite rollup esbuild swc turbopack</p>
<p>编译 测试 部署 区分环境</p>
<h2 id="构建的整体设计思路"><a href="#构建的整体设计思路" class="headerlink" title="构建的整体设计思路"></a>构建的整体设计思路</h2><ul>
<li><p>构建工具的选择</p>
<p>实际业务触发</p>
<ul>
<li>UI rollup</li>
<li>小型项目 vite</li>
<li>大型项目 vite webpack</li>
<li>swc swc-loader 对标 babel-loader &#x3D;&gt; ast</li>
</ul>
</li>
<li><p>确定构建流程</p>
<ul>
<li>loader（解析 编译 文件处理）webpack 需要了解 基础</li>
<li>plugin  增强 最后阶段进行输出 webpack</li>
</ul>
</li>
<li><p>确定构建产物的输出</p>
<ul>
<li>分chunk输出 可以对内容进行按需加载</li>
</ul>
</li>
<li><p>优化打包构建流程</p>
<ul>
<li>review构建过程 优化部分阶段</li>
<li>怎么让打出来的包体积更小？</li>
<li>tree shaking webpack 静态编译的时候<ul>
<li>尽量减少commonjs库的使用，尽量使用esm的库？</li>
</ul>
</li>
<li>按需加载（异步组件）把非首屏的组件异步出来</li>
<li>配合缓存 splitChunks<ul>
<li>不怎么变动的包打包到一起 vue pinia vue-router vrender.js<ul>
<li>优势 减小入口js体积</li>
<li>vender 利用缓存 无需跟新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>….</p>
<ul>
<li><p>externals 通过这种方式导入第三方资源</p>
<ul>
<li>微前端 引用公共资源</li>
</ul>
</li>
<li><p>提升构建速度</p>
<ul>
<li>空间 时间<ul>
<li>缓存 cache</li>
<li>利用好计算机算力</li>
<li>多线程打包 happy-pack thread-loader</li>
</ul>
</li>
</ul>
</li>
<li><p>构建的技术选型和方案</p>
</li>
<li><p>初始化工程</p>
</li>
<li><p>依赖盘点与安装</p>
</li>
<li><p>确定一些工程化脚本</p>
</li>
<li><p>start build</p>
</li>
<li><p>test lint type-check</p>
</li>
<li><p>基于git钩子 commit pre-commit</p>
</li>
<li><p>前端代码规范 确定代码规范 ts eslint spellcheck git flow 规范</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>tapbale 组织这条复杂的生产线</p>
</li>
<li><p>事件发布订阅机制</p>
</li>
<li><p>广播事件</p>
<h3 id="tapbale"><a href="#tapbale" class="headerlink" title="tapbale"></a>tapbale</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化钩子</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&#x27;compilation&#x27;</span>])</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>事件注册</p>
</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&quot;flag1&quot;</span>,<span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(compilation)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>事件执行</li>
</ul>
<p>call()</p>
<h3 id="compilation"><a href="#compilation" class="headerlink" title="compilation"></a>compilation</h3><p>compilation 对象包含当前的模块资源 编译生成的资源 变化的文件</p>
<p>compiler 包含 webpack所有配置信息 options loaders plugins全局唯一的</p>
<p>compiler &#x3D;&gt; compilation</p>
]]></content>
  </entry>
  <entry>
    <title>AST-抽象语法树</title>
    <url>/Yuyang/ast/</url>
    <content><![CDATA[<h2 id="编译器的底层原理-AST"><a href="#编译器的底层原理-AST" class="headerlink" title="编译器的底层原理 AST"></a>编译器的底层原理 AST</h2><p>编译器介绍：它会将用某种编程语言写成的源代码，转换成另一种编程语言。编译器（compiler）是一种用于将源代码（通常是高级编程语言编写的代码）翻译成目标代码（如机器语言或中间代码）的软件工具。目标代码通常可以直接在计算机上执行，或者在特定的运行环境中执行。编译器的主要目的是使程序员编写的源代码能够在计算机硬件上运行。</p>
<h2 id="编译器实现的思路"><a href="#编译器实现的思路" class="headerlink" title="编译器实现的思路"></a>编译器实现的思路</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407142153107.png"
                      alt="image-20240714215346889"
                ></p>
<h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><p>这一部分主要实现的功能是将源码转换为抽象语法树</p>
<p>解析通常分为两个阶段：词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）。</p>
<ol>
<li><p><strong>词法分析</strong> 将原始代码拆分成称为标记（tokens）的部分，这个过程由一个称为分词器（tokenizer）或词法分析器（lexer）的东西完成。</p>
<p>标记是描述语法中独立部分的小对象的数组。它们可以是数字、标签、标点符号、操作符等。</p>
</li>
<li><p><strong>语法分析</strong> 将标记重新格式化为描述语法各部分及其相互关系的表示形式。这被称为中间表示或抽象语法树（AST）。</p>
<p>抽象语法树（AST）是一个深度嵌套的对象，它以一种易于处理并包含大量信息的方式表示代码。</p>
</li>
</ol>
<p>对于以下语法：</p>
<p>  <code>(add 2 (subtract 4 2))</code></p>
<p>Tokens应该是这样的这样：</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;name&#x27;,   value: &#x27;add&#x27;      &#125;,</span><br><span class="line">  &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;name&#x27;,   value: &#x27;subtract&#x27; &#125;,</span><br><span class="line">  &#123; type: &#x27;number&#x27;, value: &#x27;4&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<p>而抽象语法树（AST）可能看起来像这样：</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;Program&#x27;,</span><br><span class="line">  body: [&#123;</span><br><span class="line">    type: &#x27;CallExpression&#x27;,</span><br><span class="line">    name: &#x27;add&#x27;,</span><br><span class="line">    params: [&#123;</span><br><span class="line">      type: &#x27;NumberLiteral&#x27;,</span><br><span class="line">      value: &#x27;2&#x27;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      type: &#x27;CallExpression&#x27;,</span><br><span class="line">      name: &#x27;subtract&#x27;,</span><br><span class="line">      params: [&#123;</span><br><span class="line">        type: &#x27;NumberLiteral&#x27;,</span><br><span class="line">        value: &#x27;4&#x27;,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        type: &#x27;NumberLiteral&#x27;,</span><br><span class="line">        value: &#x27;2&#x27;,</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>这一部分主要实现的功能是对初始的抽象语法树进行操作使其变成我们所期望的抽象语法树。</p>
<p>同样，这个阶段只是接收上一步生成的AST并对其进行更改。它可以在相同的语言中操作AST，也可以将其转换为完全新的语言。</p>
<p>让我们看看如何转换一个AST。</p>
<p>你可能会注意到，我们的AST中有一些看起来非常相似的元素。这些对象都有一个type属性。每个这样的对象都被称为AST节点。这些节点上有定义的属性，用来描述树的一个独立部分。</p>
<p>我们可以有一个表示“NumberLiteral”（数字字面量）的节点：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;NumberLiteral&#x27;</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者一个表示“CallExpression”（调用表达式）的节点：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CallExpression&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;subtract&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: [...嵌套节点在这里...],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在转换AST时，我们可以通过添加&#x2F;移除&#x2F;替换属性来操作节点，我们可以添加新节点，移除节点，或者保留现有的AST不变，基于它创建一个全新的AST。</p>
<p>由于我们目标是一种新语言，因此我们将专注于创建一个特定于目标语言的全新AST。</p>
<h3 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h3><p>将新的语法树转换成新的代码</p>
]]></content>
  </entry>
  <entry>
    <title>浏览器引擎（Browser engine/ layout engine + rendering engine）</title>
    <url>/Yuyang/browserEngine/</url>
    <content><![CDATA[<p><a class="link"   href="https://en.wikipedia.org/wiki/Browser_engine" >https://en.wikipedia.org/wiki/Browser_engine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>浏览器引擎：<a class="link"   href="https://taligarsiel.com/Projects/howbrowserswork1.htm" >https://taligarsiel.com/Projects/howbrowserswork1.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="The-browser-List"><a href="#The-browser-List" class="headerlink" title="The browser List:"></a>The browser List:</h2><p>Internet Explorer, Firefox, Safari, Chrome.</p>
<h2 id="Browser-Functionality"><a href="#Browser-Functionality" class="headerlink" title="Browser Functionality:"></a>Browser Functionality:</h2><p>The browser main functionality is to present the web resource you choose, by requesting it from the server and displaying it on the browser window. The resource format is usually HTML but also PDF, image and more. The location of the resource is specified by the user using a URI (Uniform resource Identifier).<br>Browsers’ user interface have a lot in common with each other. Among the common user interface elements are:</p>
<ul>
<li>Address bar for inserting a URI</li>
<li>Back and forward buttons</li>
<li>Bookmarking options</li>
<li>Refresh and stop buttons for refreshing or stopping the loading of current documents</li>
<li>Home button that gets you to your home page</li>
</ul>
<h2 id="The-main-components-of-a-browser"><a href="#The-main-components-of-a-browser" class="headerlink" title="The main components of a browser:"></a>The main components of a browser:</h2><ul>
<li>The user interface: this includes the address bar, back&#x2F;forward button, bookmarking menu etc.</li>
<li>The browser engine: the interface for querying and manipulating the rendering engine.</li>
<li>The rendering engine: responsible for displaying the requested content. For example if the requested content is HTML, it is responsible for parsing the HTML and CSS and displaying the parsed content on the screen.</li>
<li>Networking: for network calls such as HTTP requests, using different implementations for different platform behind a platform-independent interface.</li>
<li>UI backend: used for drawing basic widgets like combo boxes and windows. It exposes a generic interface that is not platform specific. Underneath it uses the operating system user interface methods.</li>
<li>JavaScript interpreter: Used to parse and execute the JavaScript code.</li>
<li>Data storage: This is a persistence layer. The browser needs to save all sorts of data on the hard disk, such as cookies. Browsers also support storage mechanisms such as localStorage, IndexedDB, WebSQL and FileSystem.</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/layers.png"
                      alt="img"
                ></p>
<h2 id="The-Rendering-Engine"><a href="#The-Rendering-Engine" class="headerlink" title="The Rendering Engine:"></a>The Rendering Engine:</h2><p>Both chrome and safari use the WebKit rendering engine. Firefox uses Gecko. Internet Explorer uses Trident.<br>Webkit is an open source rendering engine which started as an engine for the Linux platform and was modified by Apple to support Mac and Windows. See <a class="link"   href="http://webkit.org/" >http://webkit.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more details.</p>
<h2 id="The-main-flow"><a href="#The-main-flow" class="headerlink" title="The main flow"></a>The main flow</h2><p>The rendering engine will start getting the contents of the requested document from the networking layer. This will usually be done in 8kB chunks.<br>The basic flow of the rendering engine is as follows:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/flow.png"
                      alt="img"
                ></p>
<p>The render tree contains rectangles with visual attributes like color and dimensions. The rectangles are in the right order to be displayed on the screen.</p>
<p>After the construction of the render tree it goes through a “layout” process. This means giving each node the exact coordinates where it should appear on the screen. The next stage is painting – the render tree will be traversed and each node will be painted using the UI backend layer.</p>
<p>It’s important to understand that this is a gradual process. For better user experience, the rendering engine will try to display contents on the screen as soon as possible. It will not wait until all HTML is parsed before starting to build and layout the render tree. Parts of the content will be parsed and displayed, while the process continues with the rest of the contents that keeps coming from the network.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/webkitflow.png"
                      alt="img"
                ></p>
<h2 id="Parsing-general"><a href="#Parsing-general" class="headerlink" title="Parsing - general"></a>Parsing - general</h2><p>Parsing a document means translating it to some structure that makes sense - something the code can understand and use. The output of the parsing is usually a tree which will be used to render the page on the screen.</p>
<h2 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h2><p>Parsing is based on the syntax rules the document obeys.</p>
<h2 id="Parser-Lexer-combination"><a href="#Parser-Lexer-combination" class="headerlink" title="Parser - Lexer combination"></a>Parser - Lexer combination</h2><p>Parser can be separated into two sub processes - Lexical analysis and Syntactic analysis.<br>Lexical analysis is the process of breaking the input into tokens. Tokens are the language vocabulary - the collection of valid building blocks. In human language it will consist of all the words that appear in the dictionary for that language.<br>Syntactic analysis is the application of the language syntax rules. It is the process of analyzing the token sequence to determine the grammatical structure of the language.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/image011.png"
                      alt="img"
                ></p>
<h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>Parsing is often used in translation - transforming the input document to another format.The compiler that compiles a source code into machine code first parses it into a parse tree and then translates the parse tree into machine code.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/image013.png"
                      alt="img"
                ></p>
<h2 id="Parsing-example"><a href="#Parsing-example" class="headerlink" title="Parsing example"></a>Parsing example</h2><p>Example - parsing the expression “2 + 3 - 1”<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/image009.png"
                      alt="img"
                ><br>Vocabulary: Our language can include integers, plus signs and minus signs.<br>Syntax:</p>
<ul>
<li>The language syntax building blocks are expressions, terms and operations.</li>
<li>Our language can include any number of expressions.</li>
<li>A expression is defined as a “term” followed by an “operation” followed by another “term”.</li>
<li>An operation is a plus token or a minus token.</li>
<li>A term is an integer token or an expression.</li>
</ul>
<p><a href="https://github.com/mengjian-github/copilot-analysis">https://github.com/mengjian-github/copilot-analysis</a></p>
<h2 id="Referenc"><a href="#Referenc" class="headerlink" title="Referenc"></a>Referenc</h2><h2 id="抓不到copilot的链接"><a href="#抓不到copilot的链接" class="headerlink" title="抓不到copilot的链接"></a>抓不到copilot的链接</h2><ul>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Browser_engine" >https://en.wikipedia.org/wiki/Browser_engine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://taligarsiel.com/Projects/howbrowserswork1.htm" >https://taligarsiel.com/Projects/howbrowserswork1.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2025-04-28 日报 Day170</title>
    <url>/undefined/2025-04-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>努力寻求最大公约数、画出最大同心圆。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、<a class="link"   href="https://www.youtube.com/watch?v=EVFZazcxAbo" >https://www.youtube.com/watch?v=EVFZazcxAbo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、React生命周期</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202506140759228.png"
                      alt="image-20250614075947244"
                ></p>
<p>2、React生命周期的本质: 组件的“灵魂”和“躯干”</p>
<p>渲染工作流： 指的是从<strong>组件数据改变</strong>到<strong>组件实际更新</strong>发生的过程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202506140808507.png"
                      alt="image-20250614080800212"
                ></p>
<p>Warning: componentReceiveProps并不是由props的变化触发的，而是由父组件的更新触发</p>
<p>componentWillUnmount:</p>
<ul>
<li>组件在父组件中被移除</li>
<li>组件中设置了key属性，且key值发生变化<br>3、React16生命周期工作流详解</li>
</ul>
<p>![image-20250614140841246](..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250614140841246.png)</p>
<p><a class="link"   href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" >https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>getDerivedStateFromProps: 组件的props发生变化时，触发该方法<br>该方法不是componentWillMount的替代品，其对state的更新动作并非覆盖式的更新 而是针对某个属性的定向更新</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202506141420491.png"
                      alt="image-20250614141957043"
                ></p>
<p>为什么要用getDerivedStateFromProps代替componentWillReceiveProps?<br>getDerivedStateFromProps是作为一个试图代替componentWillReceiveProps的API而出现的<br>getDerivedStateFromProps 不能完全和 componentWillReceiveProps画等号</p>
<p>消失的componentWillUpdate与新增的 getSnapshotBeforeUpdate<br>getSnapshotBeforeUpdate的返回值会作为第三个参数给到componentDidUpdate<br>它的执行时机是在render 方法之后,真实 DOM 更新之前<br>同时获取到更新前的真实DOM 和更新前后的state&amp;props 信息</p>
<p>4、React16为何两次求变: Fiber架构<br>Fiber是React16对React核心算法的重写<br>Fiber会使原本同步的渲染过程变成异步的<br>在React16之间 每次更新组件都会创建一个虚拟DOM树，通过与上一次的虚拟DOM树进行对比实现定向更新，这一过程是递归的过程，调用栈非常深</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/Yuyang/autoTest/</url>
    <content><![CDATA[<h2 id="自动化测试与技术选型"><a href="#自动化测试与技术选型" class="headerlink" title="自动化测试与技术选型"></a>自动化测试与技术选型</h2><h3 id="认识并使用jest"><a href="#认识并使用jest" class="headerlink" title="认识并使用jest"></a>认识并使用jest</h3><h3 id="e2e测试"><a href="#e2e测试" class="headerlink" title="e2e测试"></a>e2e测试</h3><h3 id="devops"><a href="#devops" class="headerlink" title="devops"></a>devops</h3><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h4 id="为什么需要测试"><a href="#为什么需要测试" class="headerlink" title="为什么需要测试"></a>为什么需要测试</h4><p>让程序稳定健壮，提高代码质量，减少bug，提高开发效率。</p>
<ul>
<li>频繁变动的需求</li>
<li>人力成本</li>
<li>不太重视</li>
</ul>
<h4 id="什么时候-或者什么场景需要考虑自动化测试"><a href="#什么时候-或者什么场景需要考虑自动化测试" class="headerlink" title="什么时候 或者什么场景需要考虑自动化测试"></a>什么时候 或者什么场景需要考虑自动化测试</h4><ul>
<li>公共库项目开发维护 vue react babel</li>
<li>中长期项目</li>
<li>需求趋于稳定后的系统</li>
</ul>
<h4 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h4><ul>
<li>单元测试 Unit Test 小的功能的测试 Jest @vue&#x2F;test-utils Mocha</li>
<li>集成测试 Integration Test 小的模块测试</li>
<li>端到端测试 End-to-End Test 从页面出发去测试一些功能</li>
<li>E2E测试 End-to-End Test (UI+接口) puppeteer</li>
</ul>
<p>断言库 Assert</p>
<h2 id="单元测试原理"><a href="#单元测试原理" class="headerlink" title="单元测试原理"></a>单元测试原理</h2><p>通过一些测试用例 来编写测试代码 保证测试用例通过</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="comment">// import chalk from &#x27;chalk&#x27;</span></span><br><span class="line"><span class="comment">// 描述测试场景</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">describe</span>(<span class="params">desc, fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(desc))</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试的测试描述</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">it</span>(<span class="params">desc, fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">yellow</span>(desc))</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expect</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">toBe</span>(<span class="params">actual</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result != actual) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;FAIL&#x27;</span>, result, actual))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`预期值和实际值不相等，预期<span class="subst">$&#123;actual&#125;</span>,实际是<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, result, actual)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">toEqual</span>(<span class="params">actual</span>) &#123;</span><br><span class="line">      <span class="comment">//   if (result != actual) &#123;</span></span><br><span class="line">      <span class="comment">//     console.log(chalk.red(&#x27;FAIL&#x27;, result, actual))</span></span><br><span class="line">      <span class="comment">//     throw new Error(`预期值和实际值不相等，预期$&#123;actual&#125;,实际是$&#123;result&#125;`)</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line">      <span class="comment">//   console.log(&#x27;success&#x27;, result, actual)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  describe,</span><br><span class="line">  it,</span><br><span class="line">  expect,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect, describe, it &#125; = <span class="built_in">require</span>(<span class="string">&quot;./test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;用来测试sum函数&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;1 + 1 = 2&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">expect</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">1</span>)).<span class="title function_">toBe</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;1 + 2 = 3&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">expect</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>)).<span class="title function_">toBe</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;2 + 3 = 5&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">expect</span>(<span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">3</span>)).<span class="title function_">toBe</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="JEST"><a href="#JEST" class="headerlink" title="JEST"></a>JEST</h3><ul>
<li>快照测试</li>
<li>测试覆盖率</li>
<li>基本使用<ul>
<li>基本方法测试</li>
</ul>
</li>
</ul>
<h4 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h4><ul>
<li>describe 将多个相关的测试进行组合 组合到一块</li>
<li>it </li>
<li>expect 断言</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul>
<li>beforeAll 所有用例执行前调用</li>
<li>beforeEach 每个测试用例执行前调用</li>
<li>after All 执行结束后调用</li>
<li>afterEach 每个执行后调用</li>
</ul>
<h4 id="断言钩子"><a href="#断言钩子" class="headerlink" title="断言钩子"></a>断言钩子</h4><ul>
<li>toBe 严格比对 &#x3D;&#x3D;&#x3D; 内存空间都是一致的</li>
<li>toEqual 值比对 对象 递归遍历 比对值</li>
</ul>
<h4 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h4><p>确保UI不会有意外的改变</p>
<h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><ul>
<li>stmts 语句覆盖率</li>
<li>branch 是否执行了每个分支</li>
<li>funcs 函数覆盖率</li>
<li>lines 是否执行每一行代码</li>
</ul>
<h2 id="E2E测试"><a href="#E2E测试" class="headerlink" title="E2E测试"></a>E2E测试</h2><p>puppeteer 无头浏览器</p>
<p>cypress</p>
<h3 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h3><p>node库 chrome</p>
<p>在node环境下面对浏览器行为进行控制</p>
<ul>
<li>生成页面快照 图片 pdf</li>
<li>抓取spa</li>
<li>从网站上抓取需要的内容</li>
<li>自动表单提交 UI 测试 键盘输入</li>
<li>测试chrome扩展</li>
<li>抓取应用的性能数据</li>
</ul>
<h4 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h4><ul>
<li>browser 浏览器实例</li>
<li>page页面</li>
<li>executionContext js执行环境</li>
<li>elementhandle 对应dom的元素借点</li>
<li>jshandler js对象</li>
</ul>
<h4 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h4><ul>
<li>表单输入 用户名 密码 提交 页面跳转</li>
<li>体验优化 生成骨架屏 直接使用对应的页面截图</li>
</ul>
<p>puppteer 制定一些规则 img 灰色代码块替换</p>
<h4 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h4><p>工程化 &#x3D;&gt; 研发工作台 &#x3D;&gt; 管理维护 发布 运维</p>
<p>ci </p>
<p>构建 &#x3D;&gt; 生成最终构建产物</p>
<p>Test &#x3D;&gt; 保证产物健壮性</p>
<p>cd</p>
<p>最后阶段 &#x3D;&gt; 发布到对应的环境上 &#x3D;&gt; 线上服务器 nginx</p>
<h4 id="git-action-自动化部署"><a href="#git-action-自动化部署" class="headerlink" title="git action 自动化部署"></a>git action 自动化部署</h4><p>workflow 工作流程</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>   .github&#x2F;workflows</p>
</li>
<li><p>   xxx.yml</p>
<ul>
<li>   name workflow名称</li>
<li>   on:[push pull_request]</li>
</ul>
</li>
<li><p>job 任务 可以配置一项或者多项任务</p>
<ul>
<li>name 名称 任务说明</li>
<li>needs 运行顺序<ul>
<li>jobs:<ul>
<li>job1:</li>
<li>job2:<ul>
<li>needs: job1</li>
</ul>
</li>
<li><h2 id="job3-needs-job1-job2-runs-on-ubuntuxx"><a href="#job3-needs-job1-job2-runs-on-ubuntuxx" class="headerlink" title="job3:- needs: [job1, job2]  - runs-on: ubuntuxx"></a>job3:<br>- needs: [job1, job2]<br>  - runs-on: ubuntuxx</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>step 步骤</p>
<ul>
<li>name 步骤名称</li>
<li>run 执行的命令 action</li>
<li>env 环境变量</li>
</ul>
</li>
<li><p>action 动作</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>从输入URL到页面加载完成的过程</title>
    <url>/Yuyang/borwer/</url>
    <content><![CDATA[<h2 id="输入URL用户发起请求"><a href="#输入URL用户发起请求" class="headerlink" title="输入URL用户发起请求"></a>输入URL用户发起请求</h2><p>当用户在客户端输入一个网址如（如 <a class="link"   href="https://www.example.com),浏览器会根据这个操作发起网络请求./" >https://www.example.com），浏览器会根据这个操作发起网络请求。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="浏览器解析URL"><a href="#浏览器解析URL" class="headerlink" title="浏览器解析URL"></a>浏览器解析URL</h2><p>浏览器会解析用户输入的URL</p>
<ul>
<li>协议：例如HTTP或HTTPS</li>
<li>主机名：例如<a class="link"   href="http://www.example.com/" >www.example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>端口号：例如80或443</li>
<li>路径：例如&#x2F;index.html</li>
<li>查询参数：例如?name&#x3D;example</li>
<li>锚点：例如#section</li>
</ul>
<h2 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h2><p>在发起真正的网络请求之前，浏览器会检查以下几处缓存，以节省时间和资源：</p>
<ul>
<li>浏览器缓存：如果之前已经访问过该网站，浏览器可能已经缓存了该资源，直接从缓存中加载。（强缓存、协商缓存）<ul>
<li>强缓存依赖于请求头的Expires或Cache-Control</li>
</ul>
</li>
<li>DNS 缓存：浏览器会首先检查是否缓存了该域名对应的 IP 地址，避免重复的 DNS 解析。</li>
<li>操作系统的 DNS 缓存：如果浏览器没有缓存 DNS 记录，它会查询操作系统的 DNS 缓存（如 Windows 的 DNS 缓存或 Linux 的 nscd）。</li>
</ul>
<h2 id="发起DNS请求"><a href="#发起DNS请求" class="headerlink" title="发起DNS请求"></a>发起DNS请求</h2><p>如果缓存中没有找到对应的IP地址，浏览器会发起一个DNS请求，将域名解析为IP地址。</p>
<h2 id="构建HTTP-HTTPS请求-应用层"><a href="#构建HTTP-HTTPS请求-应用层" class="headerlink" title="构建HTTP&#x2F;HTTPS请求(应用层)"></a>构建HTTP&#x2F;HTTPS请求(应用层)</h2><p>一旦获取了IP地址，浏览器就可以构建HTTP&#x2F;HTTPS请求。HTTP请求报文包含以下几个部分：</p>
<ul>
<li>请求行：包含请求方法、请求URL和HTTP协议版本</li>
<li>请求头：包含请求的各种信息，如User-Agent、Accept、Cookie等</li>
<li>请求体：包含请求的数据，如POST请求的表单数据</li>
</ul>
<h2 id="建立TCP连接-传输层"><a href="#建立TCP连接-传输层" class="headerlink" title="建立TCP连接(传输层)"></a>建立TCP连接(传输层)</h2><p>HTTP是基于TCP协议的，因此浏览器需要建立TCP连接。TCP是一种面向连接的协议，它提供可靠的数据传输服务。HTTPS还需要建立TLS连接，TLS是SSL的升级版，提供了更强的安全性。</p>
<ul>
<li>三次握手：客户端和服务器之间需要通过三次握手建立连接。</li>
<li>第一次握手：客户端发送一个 SYN 包给服务器，请求建立连接。</li>
<li>第二次握手：服务器收到 SYN 包后，回应一个 SYN+ACK 包。</li>
<li>第三次握手：客户端收到 SYN+ACK 包后，回应一个 ACK 包。</li>
</ul>
<h2 id="构建数据包-网络层"><a href="#构建数据包-网络层" class="headerlink" title="构建数据包(网络层)"></a>构建数据包(网络层)</h2><p>一旦建立了TCP连接，浏览器就可以基于DNS解析得到的IP地址将HTTP请求报文封装成数据包，通过网络层发送给服务器。</p>
<h2 id="数据包在网络中传输-数据链路层"><a href="#数据包在网络中传输-数据链路层" class="headerlink" title="数据包在网络中传输(数据链路层)"></a>数据包在网络中传输(数据链路层)</h2><p>数据包通过数据链路层的设备（如交换机、网卡）在网络中传输，最终到达服务器。</p>
<h2 id="服务器处理请求，浏览器接受HTTP响应"><a href="#服务器处理请求，浏览器接受HTTP响应" class="headerlink" title="服务器处理请求，浏览器接受HTTP响应"></a>服务器处理请求，浏览器接受HTTP响应</h2><p>服务器收到请求后，会根据请求的 URL、<br>请求头等信息，调用相应的处理程序，如处理静态资源的 Nginx、处理动态资源的 Tomcat。</p>
<h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><p>浏览器接收到服务器返回的 HTTP 响应后，会解析响应报文，根据响应头中的 Content-Type 等信息判断响应的类型，然后进行相应的处理。</p>
<ul>
<li>HTML：浏览器会解析 HTML，构建 DOM 树。</li>
<li>CSS：浏览器会解析 CSS，构建 CSSOM 树。</li>
<li>render tree：浏览器会将 DOM 树和 CSSOM 树合并成一个 render tree。</li>
<li>布局：浏览器会根据 render tree 计算每个节点的位置。</li>
<li>绘制：浏览器会将 render tree 绘制到屏幕上。</li>
</ul>
<h2 id="关闭TCP连接-四次挥手"><a href="#关闭TCP连接-四次挥手" class="headerlink" title="关闭TCP连接(四次挥手)"></a>关闭TCP连接(四次挥手)</h2><p>一旦服务器返回了 HTTP 响应，浏览器会关闭 TCP 连接。</p>
<ul>
<li>四次挥手：客户端和服务器之间需要通过四次挥手关闭连接。</li>
<li>第一次挥手：客户端发送一个 FIN 包给服务器，请求关闭连接。</li>
<li>第二次挥手：服务器收到 FIN 包后，回应一个 ACK 包。</li>
<li>第三次挥手：服务器发送一个 FIN 包给客户端，请求关闭连接。</li>
<li>第四次挥手：客户端收到 FIN 包后，回应一个 ACK 包。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是从输入 URL 到页面加载完成的整个过程。在这个过程中，浏览器和服务器之间进行了多次的交互，包括 DNS 解析、建立 TCP 连接、发送 HTTP 请求、处理请求、返回 HTTP 响应等。最终，浏览器会将服务器返回的 HTML、CSS、JavaScript 等资源解析渲染，最终呈现给用户。</p>
]]></content>
  </entry>
  <entry>
    <title>前端编码规范工程化</title>
    <url>/Yuyang/baseconfigcli/</url>
    <content><![CDATA[<h2 id="前端规范"><a href="#前端规范" class="headerlink" title="前端规范"></a>前端规范</h2><p>1、React Vue Js Ts 代码规范 eslint<br>2、Css Less Scss css预处理器 代码规范 stylelint<br>3、git commitlint 规范提交信息 husky<br>4、markdownlint 规范 markdown 代码</p>
<p>lint 收敛 CLI</p>
<p>1、一键接入、一键扫描、一键修复、一键升级</p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>多包：monorepo lerna</li>
<li>包管理工具：pnpm</li>
<li>lint:<ul>
<li>eslint</li>
<li>stylelint</li>
<li>commitlint</li>
<li>markdownlint</li>
<li>prettier</li>
</ul>
</li>
<li>CLI</li>
<li>Jest mocha</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>强缓存和协商缓存</title>
    <url>/Yuyang/cache/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>为了减少资源请求次数，加快资源访问速度，浏览器会对资源文件如图片、css文件、js文件等进行缓存，而浏览器缓存策略又分为强缓存和协商缓存。</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是指浏览器在缓存有效期内直接从本地缓存中读取资源，而不与服务器进行任何通信。强缓存的实现依赖于 HTTP 响应头中的 Expires 或 Cache-Control。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires" >https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>一个绝对的过期时间（GMT 时间），在此时间之前，浏览器会认为缓存是有效的。</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Wed, 21 Oct 2024 07:28:00 GMT</span><br></pre></td></tr></table></figure></div>

<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>max-age代表缓存时间，单位为秒</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=3600</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" >https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121558393.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121558374.webp"
                      alt="img"
                ></p>
<p>使用缓存的话，状态码200后面会标明情况。浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache）。</p>
<p>当缓存时间到期后再次访问时，状态码200后面便没有括号内的内容了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121558501.webp"
                      alt="img"
                ></p>
<p>一般来说，浏览器会将较大的资源缓存到disk cache，而较小的资源则被缓存到memory cache里。内存缓存与磁盘缓存相比，访问速度要更快一些！</p>
<p>Cache-Control除了max-age外，还可以设置其它属性值：</p>
<ul>
<li>no-cache: 不使用强缓存（但仍会使用协商缓存）。</li>
<li>no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。</li>
<li>private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。</li>
<li>public: 客户端和代理服务器都可缓存。</li>
<li>s-maxage: 与max-age类似，区别是s-maxage是设定代理服务器的缓存时间。</li>
</ul>
<p>另外，Cache-control的优先级要高于Expires，如果两者同时设置，会优先使用Cache-control而忽略掉Expires。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><strong>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存</strong>，协商缓存的具体流程如下：</p>
<p>浏览器初次请求资源，服务器返回资源，同时生成一个Etag值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带If-None-Match，值是之前服务器返回的Etag的值，服务器收到之后拿该值与资源文件最新的Etag值做对比。</p>
<ul>
<li>如果没有变化则返回304，告诉浏览器继续使用缓存（不返回资源文件）。</li>
<li>如果发生变化，则返回200和最新的资源文件给浏览器使用。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121603356.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121603175.webp"
                      alt="img"
                ></p>
<p>除了Etag外，还有一个Last-Modified的属性，它是Http1.0规范的，服务器返回Last-Modified，浏览器请求头对应携带的是If-Modified-since，与Etag不同的是，Last-Modified的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121603459.webp"
                      alt="img"
                ></p>
<p>相比Last-Modified，Etag优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，Last-Modified不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。</p>
<p>强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强缓存就是浏览器本地根据服务器设置的过期时间来判断是否使用缓存，未过期则从本地缓存里拿资源，已过期则重新请求服务器获取最新资源。</p>
<p>协商缓存则是浏览器本地每次都向服务器发起请求，由服务器来告诉浏览器是从缓存里拿资源还是返回最新资源给浏览器使用。</p>
<p>Reference: <a class="link"   href="https://juejin.cn/post/7259298281578889273?searchId=20240712153934B2B3A1160462EB235132" >https://juejin.cn/post/7259298281578889273?searchId=20240712153934B2B3A1160462EB235132 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>MAC 内网穿透 cpolar</title>
    <url>/Yuyang/cpolar/</url>
    <content><![CDATA[<blockquote>
<p>介绍如何通过使用cpolar来完成将内网下的本地服务器通过安全隧道暴露至公网，完成公网正常访问内网服务。目前我的本地web服务只能在局域网内访问，使用cpolar内网穿透可以将本地服务映射到公网，实现公网用户也可以访问到本地服务，无需公网IP，也无需设置路由器。<br>cpolar官网：<a class="link"   href="https://www.cpolar.com/" >https://www.cpolar.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="1、安装配置cpolar"><a href="#1、安装配置cpolar" class="headerlink" title="1、安装配置cpolar"></a>1、安装配置cpolar</h2><ul>
<li>通过Homebrew包管理器安装cpolar</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap probezy/core &amp;&amp; brew install cpolar</span><br></pre></td></tr></table></figure></div>

<ul>
<li>token认证：在cpolar官网后台的验证初复制自己的token</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232255851.png"
                      alt="img"
                ></p>
<p>cpolar authtoken xxx</p>
<p>         xxx处用复制的token代替</p>
<ul>
<li><p>安装cpolar服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service install</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2、使用cpolar"><a href="#2、使用cpolar" class="headerlink" title="2、使用cpolar"></a>2、使用cpolar</h2><ul>
<li><p>启动服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service start</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>cpolar web UI管理界面</p>
<p> 访问本地9200端口【<a class="link"   href="http://127.0.0.1:9200/%E3%80%91%EF%BC%8C%E4%BD%BF%E7%94%A8cpolar%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E3%80%82" >http://127.0.0.1:9200/】，使用cpolar账号登录。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232257170.png"
                      alt="img"
                ></p>
<p>         可在UI界面中查看自己的隧道信息 以及编辑、启动、停止和删除。其中状态列表下的的在线隧道列表显示了目前的公网地址和本地地址映射关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232257753.png"
                      alt="img"
                ></p>
<ul>
<li><p> 公网请求测试。</p>
<p>     可借助APIFOX在线测试。官网地址：<a class="link"   href="https://apifox.com/" >https://apifox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232258155.png"
                      alt="img"
                ></p>
<p> 根据自己情况填写。示例中的接口地址为&#x2F;model</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232258116.png"
                      alt="img"
                ></p>
<p>        请求成功🎉 </p>
<ul>
<li> 停止服务</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service stop</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意⚠️：停止后再启动，免费版的域名会发生变化需要重新设置，及时更新。 </p>
</blockquote>
<p>Reference：<a class="link"   href="https://www.cpolar.com/blog/cpolar-quick-start-tutorial-macos-series" >https://www.cpolar.com/blog/cpolar-quick-start-tutorial-macos-series <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>前端路由hash和history</title>
    <url>/Yuyang/hash_history/</url>
    <content><![CDATA[<p>前端路由hash和history</p>
<h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><p>使用window.location.hash属性以及onhashchange事件，实现监听浏览器地址的hash值变化，执行相应的js切换网页</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">location.href</td>
<td align="center">完整的URL字符串</td>
<td align="center"><a class="link"   href="https://www.example.com:8080/pathname/?search=test#hash" >https://www.example.com:8080/pathname/?search=test#hash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="center">location.protocol</td>
<td align="center">协议部分</td>
<td align="center">https:</td>
</tr>
<tr>
<td align="center">location.hostname</td>
<td align="center">主机名</td>
<td align="center"><a class="link"   href="http://www.example.com/" >www.example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="center">location.port</td>
<td align="center">端口号</td>
<td align="center">8080</td>
</tr>
<tr>
<td align="center">location.host</td>
<td align="center">主机名和端口号</td>
<td align="center"><a class="link"   href="http://www.example.com:8080/" >www.example.com:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="center">location.pathname</td>
<td align="center">路径部分</td>
<td align="center">&#x2F;post&#x2F;6993840419041706014</td>
</tr>
<tr>
<td align="center">location.search</td>
<td align="center">查询字符串部分</td>
<td align="center">?search&#x3D;test</td>
</tr>
<tr>
<td align="center">location.hash</td>
<td align="center">哈希值</td>
<td align="center">#hash</td>
</tr>
</tbody></table>
<p>window.location还提供了一些方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">location.assign(url)</td>
<td align="center">加载指定的URL</td>
</tr>
<tr>
<td align="center">location.replace(url)</td>
<td align="center">替换当前的 URL，但不会在历史记录中创建新的条目。即用户无法通过浏览器的“后退”按钮返回到之前的页面。</td>
</tr>
<tr>
<td align="center">location.reload(forceReload)</td>
<td align="center">重新加载当前页面。forceReload 参数为 true 时会强制从服务器重新加载页面（而不是从缓存中加载）。</td>
</tr>
<tr>
<td align="center">location.toString()</td>
<td align="center">返回当前 URL 的字符串表示。</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前 URL 的各种部分</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>);      <span class="comment">// 输出完整的 URL</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>);  <span class="comment">// 输出协议部分</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span>);      <span class="comment">// 输出主机和端口号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span>);  <span class="comment">// 输出主机名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">port</span>);      <span class="comment">// 输出端口号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>);  <span class="comment">// 输出路径</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>);    <span class="comment">// 输出查询字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>);      <span class="comment">// 输出哈希</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">origin</span>);    <span class="comment">// 输出源 URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 URL 并重新加载页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;https://www.example.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换当前 URL，不会在历史记录中创建新的条目</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&#x27;https://www.example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新加载页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();     <span class="comment">// 从缓存中重新加载</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>(<span class="literal">true</span>); <span class="comment">// 强制从服务器重新加载</span></span><br></pre></td></tr></table></figure></div>



<h2 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h2><p>History API是H5提供的新特性，允许开发者直接更改前端路由，即更新浏览器URL地址而不重新发起请求。它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。 History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">history.length</td>
<td align="center">历史记录中的条目数</td>
</tr>
<tr>
<td align="center">history.state</td>
<td align="center">历史记录条目的状态对象</td>
</tr>
</tbody></table>
<p>window.history 还提供了一些方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">history.pushState(state, title, url)</td>
<td align="center">将一个状态对象添加到历史记录栈中</td>
<td>window.history.pushState({ page: 1 }, “title 1”, “&#x2F;page1”);</td>
</tr>
<tr>
<td align="center">history.replaceState(state, title, url)</td>
<td align="center">修改当前历史记录条目的状态对象、标题和 URL</td>
<td>window.history.replaceState({ page: 2 }, “title 2”, “&#x2F;page2”);</td>
</tr>
<tr>
<td align="center">history.back()</td>
<td align="center">加载历史记录列表中的前一个 URL，与用户点击浏览器的后退按钮相同。</td>
<td>window.history.back();</td>
</tr>
<tr>
<td align="center">history.forward()</td>
<td align="center">加载历史记录列表中的下一个 URL，与用户点击浏览器的前进按钮相同。</td>
<td>window.history.forward();</td>
</tr>
<tr>
<td align="center">history.go(delta)</td>
<td align="center">根据 delta 值加载历史记录中的特定页面。delta: 为正值时前进，为负值时后退。</td>
<td>window.history.go(-1); &#x2F;&#x2F; 后退一页<br/>window.history.go(1);  &#x2F;&#x2F; 前进一页</td>
</tr>
</tbody></table>
<h2 id="history代码实现"><a href="#history代码实现" class="headerlink" title="history代码实现"></a>history代码实现</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomHistory</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentIndex</span> = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pushState</span>(<span class="params">state, title, url</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currentIndex</span> &lt; <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">stack</span> = <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">currentIndex</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(&#123; state, title, url &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentIndex</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updateUrl</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">replaceState</span>(<span class="params">state, title, url</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">currentIndex</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">currentIndex</span>] = &#123; state, title, url &#125;;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">updateUrl</span>(url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">pushState</span>(state, title, url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">go</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newIndex = <span class="variable language_">this</span>.<span class="property">currentIndex</span> + index;</span><br><span class="line">    <span class="keyword">if</span> (newIndex &gt;= <span class="number">0</span> &amp;&amp; newIndex &lt; <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentIndex</span> = newIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">back</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">currentIndex</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentIndex</span>--;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">applyState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">forward</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">currentIndex</span> &lt; <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentIndex</span>++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">applyState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">applyState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentState = <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">currentIndex</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updateUrl</span>(currentState.<span class="property">url</span>);</span><br><span class="line">    <span class="comment">// this.dispatchPopStaet(currentState);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">updateUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ CustomHistory ~ updateUrl ~ url:&quot;</span>, url)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dispatchPopStaet</span>(<span class="params">state</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;popstate&#x27;</span>, &#123; <span class="attr">detail</span>: state &#125;);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage example:</span></span><br><span class="line"><span class="keyword">const</span> customHistory = <span class="keyword">new</span> <span class="title class_">CustomHistory</span>();</span><br><span class="line"></span><br><span class="line">customHistory.<span class="title function_">pushState</span>(&#123; <span class="attr">page</span>: <span class="number">1</span> &#125;, <span class="string">&quot;Title 1&quot;</span>, <span class="string">&quot;/page1&quot;</span>);</span><br><span class="line">customHistory.<span class="title function_">pushState</span>(&#123; <span class="attr">page</span>: <span class="number">2</span> &#125;, <span class="string">&quot;Title 2&quot;</span>, <span class="string">&quot;/page2&quot;</span>);</span><br><span class="line">customHistory.<span class="title function_">replaceState</span>(&#123; <span class="attr">page</span>: <span class="number">3</span> &#125;, <span class="string">&quot;Title 3&quot;</span>, <span class="string">&quot;/page3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;popstate&#x27;, (event) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;Popstate event:&#x27;, event.detail);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">customHistory.<span class="title function_">back</span>(); <span class="comment">// Navigating to: /page1</span></span><br><span class="line">customHistory.<span class="title function_">forward</span>(); <span class="comment">// Navigating to: /page3</span></span><br><span class="line">customHistory.<span class="title function_">go</span>(-<span class="number">1</span>); <span class="comment">// Navigating to: /page1</span></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>前端工程化</title>
    <url>/Yuyang/engineering/</url>
    <content><![CDATA[<h1 id="前端工程化讲解-包管理工具"><a href="#前端工程化讲解-包管理工具" class="headerlink" title="前端工程化讲解&amp;包管理工具"></a>前端工程化讲解&amp;包管理工具</h1><h2 id="工程化体系"><a href="#工程化体系" class="headerlink" title="工程化体系"></a>工程化体系</h2><p>前端工程化： 前端+软件工程</p>
<p>整个前端的研发周期当中 我们可以干预的行为</p>
<h3 id="前端工程化开展"><a href="#前端工程化开展" class="headerlink" title="前端工程化开展"></a>前端工程化开展</h3><ul>
<li>模块化：模块复用</li>
<li>自动化：CI&#x2F;CD 研发平台</li>
<li>智能化：AI code</li>
</ul>
<h3 id="脚手架能力"><a href="#脚手架能力" class="headerlink" title="脚手架能力"></a>脚手架能力</h3><p>通过更多的规范 约束开发人员的研发流程</p>
<p>狭义：命令行<br>广义：约束</p>
<p>准备阶段：</p>
<ul>
<li>需求</li>
<li>技术选型</li>
<li>代码规范<ul>
<li>lint 规范</li>
</ul>
</li>
<li>生态规范<ul>
<li>UI库</li>
<li>静态站点 npm github readme types</li>
</ul>
</li>
<li>三方规范<ul>
<li>npm 发布</li>
<li>github ci cd</li>
</ul>
</li>
</ul>
<h4 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h4><p>确定规范内容<br>规范 eslint md stylelint</p>
<p>测试</p>
<ul>
<li>单元测试</li>
<li>e2e测试</li>
</ul>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><ul>
<li>webpack</li>
<li>rollup</li>
<li>vite</li>
</ul>
<h3 id="体验度量"><a href="#体验度量" class="headerlink" title="体验度量"></a>体验度量</h3><p>定义一些指标 衡量当前系统好不好用</p>
<p>埋点：用户行为统计<br>perfomance：性能指标</p>
<h3 id="研发效能流程"><a href="#研发效能流程" class="headerlink" title="研发效能流程"></a>研发效能流程</h3><h3 id="稳定性建设"><a href="#稳定性建设" class="headerlink" title="稳定性建设"></a>稳定性建设</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407220023631.png"
                      alt="image-20240722002317481"
                ></p>
<p>pdd:<br>高端机 2s &#x3D;&gt; 0.8s<br>0.5s<br>低端机 1.2s</p>
<h2 id="npm包"><a href="#npm包" class="headerlink" title="npm包"></a>npm包</h2><p>查看包版本 npm view xxx</p>
<p>peerDependencies<br>基础包约束依赖包版本</p>
<h3 id="打包工具对比"><a href="#打包工具对比" class="headerlink" title="打包工具对比"></a>打包工具对比</h3><p>yarn npm</p>
<ul>
<li>问题？</li>
<li>慢</li>
<li>体积大</li>
</ul>
<p>pnpm 推荐</p>
<ul>
<li>快</li>
<li>体积小</li>
</ul>
<h3 id="前端仓库管理对比"><a href="#前端仓库管理对比" class="headerlink" title="前端仓库管理对比"></a>前端仓库管理对比</h3><ul>
<li>Multirepo</li>
<li>Monorepo</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端埋点与全链路</title>
    <url>/Yuyang/eventTracking/</url>
    <content><![CDATA[<h2 id="什么是埋点："><a href="#什么是埋点：" class="headerlink" title="什么是埋点："></a>什么是埋点：</h2><p>​	前端埋点是一种用于收集用户在网站或应用程序上的行为数据的方法。这些数据可以帮助企业了解用户的行为模式、使用习惯，并对产品进行优化。</p>
<h2 id="为什么要埋点："><a href="#为什么要埋点：" class="headerlink" title="为什么要埋点："></a>为什么要埋点：</h2><ul>
<li>流量监测（按时间空间维度分析，留存分析，转化分析）。</li>
<li>构建行为路径，获取用户的全链路信息获取，实现用户分群、人群洞察、行为细查等，构建用户画像。</li>
<li>通过对埋点数据的处理、分析、建模，判断产品的效果和未来走向。</li>
<li>为营销策略提供数据支持，分析营销效果，提高渠道转化。</li>
<li>热力分析，帮助判断访客热衷的区域，评估网页设计是否合理等。</li>
<li>实施AB Test，持续优化产品，使产品在市场上更具有竞争力。</li>
<li>用户行为异常监测以及问题快速定位与响应。</li>
</ul>
<h2 id="埋点的使用场景有哪些："><a href="#埋点的使用场景有哪些：" class="headerlink" title="埋点的使用场景有哪些："></a>埋点的使用场景有哪些：</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250013175.png"
                      alt="image-20240625001317104"
                ></p>
<h2 id="埋点方式："><a href="#埋点方式：" class="headerlink" title="埋点方式："></a>埋点方式：</h2><table>
<thead>
<tr>
<th></th>
<th>代码埋点</th>
<th>全埋点</th>
<th>可视化埋点</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td><strong>代码埋点</strong>是指在前端代码中手动添加埋点代码，用于捕获特定用户行为事件。这种方法灵活且精确，适用于需要细粒度数据收集的场景。</td>
<td><strong>全埋点</strong>是一种自动化的埋点方式，旨在捕获页面上的所有用户行为事件。通过全埋点，可以自动记录用户在页面上的所有操作，如点击、滑动、输入等，减少了手动添加埋点的工作量。</td>
<td><strong>可视化埋点</strong>是通过可视化界面配置埋点，而不需要修改代码。通过可视化工具，非技术人员也可以方便地配置和管理埋点。</td>
</tr>
<tr>
<td>优点</td>
<td>•	精确控制埋点的位置和事件。	<br />•	可以收集详细的事件信息。</td>
<td>•	覆盖全面，无需手动添加埋点代码。<br />•	能够捕获所有用户行为，数据更完整</td>
<td>•	无需修改代码，配置方便。<br />•	非技术人员也可以配置和管理埋点。</td>
</tr>
<tr>
<td>缺点</td>
<td>•	手动维护埋点代码，工作量大，容易出错。<br />•	需要开发人员介入，维护成本高。</td>
<td>•	数据量大，可能带来存储和处理的压力。<br />•	需要在数据清洗和分析阶段进行大量处理。</td>
<td>•	可能无法满足所有细粒度的埋点需求。<br />•	配置不当可能导致数据不准确。</td>
</tr>
</tbody></table>
<h2 id="埋点例子："><a href="#埋点例子：" class="headerlink" title="埋点例子："></a>埋点例子：</h2><p>代码埋点例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构建埋点数据</span></span><br><span class="line">    <span class="keyword">var</span> eventData = &#123;</span><br><span class="line">        <span class="attr">eventType</span>: <span class="string">&#x27;button_click&#x27;</span>,</span><br><span class="line">        <span class="attr">buttonId</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">        <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送数据到服务器</span></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;https://example.com/track&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(eventData),</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;埋点数据发送成功&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;埋点数据发送失败&#x27;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>全埋点例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全埋点脚本</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 事件监听器</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">eventListener</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> eventData = &#123;</span><br><span class="line">            <span class="attr">eventType</span>: event.<span class="property">type</span>,</span><br><span class="line">            <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(),</span><br><span class="line">            <span class="attr">element</span>: event.<span class="property">target</span>.<span class="property">tagName</span>,</span><br><span class="line">            <span class="attr">id</span>: event.<span class="property">target</span>.<span class="property">id</span>,</span><br><span class="line">            <span class="attr">className</span>: event.<span class="property">target</span>.<span class="property">className</span>,</span><br><span class="line">            <span class="attr">pageX</span>: event.<span class="property">pageX</span>,</span><br><span class="line">            <span class="attr">pageY</span>: event.<span class="property">pageY</span>,</span><br><span class="line">            <span class="attr">url</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送数据到服务器</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://example.com/track&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(eventData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>

<h2 id="埋点模型："><a href="#埋点模型：" class="headerlink" title="埋点模型："></a>埋点模型：</h2><blockquote>
<p>埋点模型包含两个主要概念：<strong>事件(event)</strong> 、<strong>属性(params)</strong></p>
<p><strong>事件</strong>：通过埋点定义的用户行为或业务操作，比如页面打开，页面离开，模块曝光，模块点击</p>
<p><strong>属性</strong>：事件附带的各种维度信息，比如用户信息，网络信息，设备信息，事件具体维度信息等</p>
</blockquote>
<p>一个设计的相对完善的模型,一般包含用户行为五元素</p>
<p>通过这个可以详细的分析是谁在什么地方什么时间，怎么样进行了什么操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250041129.png"
                      alt="image-20240625004123315"
                ></p>
<p>模型事件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250047727.png"
                      alt="image-20240625004727426"
                ></p>
<p>模型信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250053185.png"
                      alt="image-20240625005335046"
                ></p>
<h2 id="埋点上报："><a href="#埋点上报：" class="headerlink" title="埋点上报："></a>埋点上报：</h2><p>数据队列处理：当需要上报的数据量逐渐变多时，就需要考虑进行批量上报和延迟上报，本质上都是为了不阻塞业务程序的执行，上报本来就是用户无感知的事情，用户不能为此耗时买单。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250115952.png"
                      alt="image-20240625011532834"
                ></p>
<p>对于数据请求处理，主要考虑的有三个因素</p>
<ul>
<li>跨域的问题</li>
<li>页面销毁时，如何保障还未成功上传的数据完成数据上传请求</li>
<li>大数据量的上传</li>
</ul>
<p>较为标准的针对模块曝光的定义：窗口可视区域内 &amp;&amp; 组件矩形与视窗区域发生交集 &amp;&amp; 交集垂线距离 &gt;&#x3D; 1px &amp;&amp; 停留时间 &gt;&#x3D; XXms</p>
<p>Reference：<a class="link"   href="https://juejin.cn/post/7324334380373426227?searchId=202406242342178A14CCB0DE15106BCCCB" >https://juejin.cn/post/7324334380373426227?searchId=202406242342178A14CCB0DE15106BCCCB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>备注：近几个月来看到👀过质量最高的文章！学到了！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/helloalgo/</url>
    <content><![CDATA[<h2 id="速刷hello-algo"><a href="#速刷hello-algo" class="headerlink" title="速刷hello-algo"></a>速刷hello-algo</h2><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>复杂度分析: 时间复杂度、空间复杂度<br>数据结构: 数组、链表、栈、队列、哈希表、树、堆、图<br>算法: 搜索、排序、分治、回溯、动态规划、贪心<br><a class="link"   href="https://www.hello-algo.com/" >https://www.hello-algo.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410251743992.png"
                      alt="image-20241025174311243"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410251749524.png"
                      alt="image-20241025174936400"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/Yuyang/jsModule/</url>
    <content><![CDATA[<p>JS模块化</p>
<h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><p>模块化主要解决两个问题：命名冲突和文件依赖。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> 生态             诞生时间</span><br><span class="line"> <span class="title class_">CommonJS</span>         <span class="number">2009</span>年</span><br><span class="line"> <span class="title class_">Node</span>.<span class="property">js</span>          <span class="number">2009</span>年   </span><br><span class="line"> <span class="variable constant_">NPM</span>              <span class="number">2010</span>年   </span><br><span class="line"> requireJS(<span class="variable constant_">AMD</span>)   <span class="number">2010</span>年	异步模块定义 <span class="keyword">async</span> <span class="variable language_">module</span> definition</span><br><span class="line"> <span class="title function_">seaJS</span>(<span class="variable constant_">CMD</span>)       <span class="number">2011</span>年	common <span class="variable language_">module</span> define</span><br><span class="line"> broswerify       <span class="number">2011</span>年</span><br><span class="line"> webpack          <span class="number">2012</span>年</span><br><span class="line"> grunt            <span class="number">2012</span>年 </span><br><span class="line"> gulp             <span class="number">2013</span>年</span><br><span class="line"> react            <span class="number">2013</span>年 </span><br><span class="line"> vue              <span class="number">2014</span>年</span><br><span class="line"> <span class="title class_">ES6</span>(<span class="title class_">Module</span>)      <span class="number">2015</span>年</span><br><span class="line"> angular          <span class="number">2016</span>年</span><br><span class="line"> redux            <span class="number">2015</span>年 </span><br><span class="line"> vite             <span class="number">2020</span>年</span><br><span class="line"> snowpack         <span class="number">2020</span>年  </span><br><span class="line">跨端 rollup truopack</span><br></pre></td></tr></table></figure></div>

<h2 id="模块化的进程"><a href="#模块化的进程" class="headerlink" title="模块化的进程"></a>模块化的进程</h2><h3 id="全局function模式"><a href="#全局function模式" class="headerlink" title="全局function模式"></a>全局function模式</h3><p>将不同的功能封装成不同的全局函数<br>问题：污染全局命名空间，容易引起命名冲突</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="namespace模式"><a href="#namespace模式" class="headerlink" title="namespace模式"></a>namespace模式</h3><p>简单对象封装<br>作用：减少了全局变量，解决命名冲突<br>问题：数据不安全(外部可以直接修改模块内部的数据)</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.<span class="property">data</span> = <span class="string">&#x27;other data&#x27;</span> <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.<span class="title function_">foo</span>() <span class="comment">// foo() other data</span></span><br></pre></td></tr></table></figure></div>


<h3 id="IIFE模式"><a href="#IIFE模式" class="headerlink" title="IIFE模式"></a>IIFE模式</h3><p>immediately-invoked function expression 匿名函数自调用(闭包)<br>作用：数据是私有的, 外部只能通过暴露的方法操作。将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口<br>问题：如果当前这个模块依赖另一个模块怎么办?</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="title function_">foo</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="title function_">bar</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">data</span>) <span class="comment">//undefined 不能访问模块内部数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="property">data</span> = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="title function_">foo</span>() <span class="comment">//没有改变</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    <span class="title function_">otherFun</span>() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">otherFun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">myModule</span> = &#123; foo, bar &#125; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo() www.baidu.com</span></span><br><span class="line"><span class="comment">// bar() www.baidu.com</span></span><br><span class="line"><span class="comment">// otehrFun()</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// foo() www.baidu.com</span></span><br></pre></td></tr></table></figure></div>

<h3 id="IIFE模式增强"><a href="#IIFE模式增强" class="headerlink" title="IIFE模式增强"></a>IIFE模式增强</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span>, $</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    <span class="title function_">otherFun</span>() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">otherFun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">myModule</span> = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, jQuery)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// index.html文件</span></span><br><span class="line">&lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  myModule.foo()</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><ul>
<li>避免命名冲突（减少命名空间污染）</li>
<li>更好的分离，按需加载</li>
<li>更高的复用性</li>
<li>更高的可维护性</li>
</ul>
<h3 id="引入多个的问题"><a href="#引入多个的问题" class="headerlink" title="引入多个的问题"></a>引入多个<script>的问题</h3><ul>
<li>依赖引用顺序、依赖模糊、难以维护<br>因此才有了后续的commonjs, AMD, ESM, CMD规范。</li>
</ul>
<h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>Node.js的模块规范，同步加载模块。每个文件都是一个模块有自己的作用域，模块可以通过module.exports导出变量，通过require()来导入其他模块的输出到当前模块作用域中。其里面定义的变量、函数、类都是私有的，不会污染全局作用域。在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">x</span> = x;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">addX</span> = addX;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);<span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="property">x</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="title function_">addX</span>(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></div>

<h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">incCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>如果需要获取到模块内部变化后的值，可以通过getter函数来获取。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCounter</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">  <span class="attr">getCounter</span>: getCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./example&#x27;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./example&#x27;</span>).<span class="property">incCounter</span>;</span><br><span class="line"><span class="keyword">var</span> getCounter = <span class="built_in">require</span>(<span class="string">&#x27;./example&#x27;</span>).<span class="property">getCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ require(&#x27;./example&#x27;).counter:&quot;</span>, <span class="title function_">getCounter</span>() ) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>

<h3 id="AMD-Asynchronous-Module-Definition"><a href="#AMD-Asynchronous-Module-Definition" class="headerlink" title="AMD(Asynchronous Module Definition)"></a>AMD(Asynchronous Module Definition)</h3><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="keyword">function</span>(<span class="params">m1, m2</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="keyword">function</span>(<span class="params">m1, m2</span>)&#123;</span><br><span class="line">   使用m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="CMD-Common-Module-Definition"><a href="#CMD-Common-Module-Definition" class="headerlink" title="CMD(Common Module Definition)"></a>CMD(Common Module Definition)</h3><p>CMD规范是Sea.js推广过程中产生的，Sea.js是阿里的玉伯大神推出的，Sea.js的推广过程中对模块定义的规范化产生了影响，CMD是Sea.js推广过程中产生的。CMD规范是依赖就近，用的时候再require。CMD规范是依赖就近，用的时候再require。CMD规范是依赖就近，用的时候再require。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>)&#123;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">xxx</span> = value</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>)&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.<span class="title function_">async</span>(<span class="string">&#x27;./module3&#x27;</span>, <span class="keyword">function</span> (<span class="params">m3</span>) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">xxx</span> = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入使用的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.<span class="title function_">show</span>()</span><br><span class="line">  m4.<span class="title function_">show</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6模块是ECMAScript 6标准新增的功能，它是JavaScript模块的标准写法，是未来JS模块的主流标准。ES6模块不是对象，而是通过export命令显示指定输出的代码，再通过import命令输入。ES6模块自动采用严格模式，不管你有没有在模块头部加上"use strict"。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js /</span></span><br><span class="line"><span class="comment">var basicNum = 0;</span></span><br><span class="line"><span class="comment">var add = function (a, b) &#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">export &#123; basicNum, add &#125;;</span></span><br><span class="line"><span class="comment">/ 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">    ele.<span class="property">textContent</span> = <span class="title function_">add</span>(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>ES6模块与CommonJS模块的差异：</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。<br>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>

<p>TreeShaking是指在打包时去除无用的代码，只打包需要的代码。ES6模块静态引入的特性，使得TreeShaking成为可能。</p>
<h3 id="UMD-Universal-Module-Definition"><a href="#UMD-Universal-Module-Definition" class="headerlink" title="UMD(Universal Module Definition)"></a>UMD(Universal Module Definition)</h3><p>UMD是AMD和CommonJS的糅合，既可以支持浏览器端，又可以支持服务器端。UMD规范通常在模块定义中先判断是否支持Node.js模块（exports）是否存在，存在则使用Node.js模块模式，不存在则判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span>.<span class="property">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是commonjs模块规范，nodejs环境&#x27;</span>)</span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是AMD模块规范，如require.js&#x27;</span>)</span><br><span class="line">        <span class="title function_">define</span>(factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">cmd</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是CMD模块规范，如sea.js&#x27;</span>)</span><br><span class="line">        <span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">            <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有模块环境，直接挂载在全局对象上&#x27;</span>)</span><br><span class="line">        root.<span class="property">umdModule</span> = <span class="title function_">factory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;我是一个umd模块&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>]]></content>
  </entry>
  <entry>
    <title>How Browsers Work</title>
    <url>/Yuyang/howbrowserswork/</url>
    <content><![CDATA[<p>Users want web experiences with content that is fast to load and smooth to interact with.They are two goals we want to achieve.</p>
<p>To better achieve these goals, we need to understand how browsers work.</p>
<h2 id="How-Browsers-Work"><a href="#How-Browsers-Work" class="headerlink" title="How Browsers Work"></a>How Browsers Work</h2><p>Two major issues in web performance are issues having to do with network latency and issues having to do with the fact that for the most part, browsers are single-threaded.</p>
<h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><p>Navigation is the process of loading a web page. It involves the following steps:</p>
<ol>
<li>DNS lookup<br>The first step in the navigation process is to look up the IP address of the server that hosts the website. This is done using the Domain Name System (DNS).If you navigate to <a class="link"   href="https://example.com/" >https://example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, the HTML page is located on the server with IP address of 93.184.216.34. If you’ve never visited this site, a DNS lookup must happen.<br>After this initial request, the IP will likely be cached for a time, which speeds up subsequent requests by retrieving the IP address from the cache instead of contacting a name server again.</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180700896.jpeg"
                      alt="img"
                ><br>This can be problematic for performance, particularly on mobile networks. When a user is on a mobile network, each DNS lookup has to go from the phone to the cell tower to reach an authoritative DNS server. The distance between a phone, a cell tower, and the name server can add significant latency.</p>
<ol start="2">
<li>TCP handshake<br>Once the browser has the IP address, it can establish a connection to the server. This is done using the Transmission Control Protocol (TCP). The browser sends a SYN packet to the server, which responds with a SYN-ACK packet, and the browser sends an ACK packet back. This is known as the TCP handshake.</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180705057.png"
                      alt="img"
                ></p>
<ol start="3">
<li>TLS negotiation<br>If the website uses HTTPS, the browser and server must negotiate a secure connection. This is done using the Transport Layer Security (TLS) protocol. The browser sends a ClientHello message to the server, which responds with a ServerHello message, and the browser sends a Finished message. This is known as the TLS handshake.</li>
</ol>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Once we have established a connection to the server, we can request the HTML page. The server responds with the HTML page, which the browser parses and renders.</p>
<h4 id="Congestion-control-TCP-slow-start"><a href="#Congestion-control-TCP-slow-start" class="headerlink" title="Congestion control &#x2F; TCP slow start"></a>Congestion control &#x2F; TCP slow start</h4><p>During the TCP handshake, the browser and server negotiate the maximum segment size (MSS) for the connection. The browser starts by sending a small number of segments and increases the number of segments it sends until it reaches the maximum segment size. This is known as TCP slow start.</p>
<h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><p>Once the browser receives the first chunk of data, it can begin parsing the information.Parsing is the step the browser takes to turn the data it receives over the network into a Document Object Model (DOM) tree and a CSS Object Model (CSSOM), which are used to render the page.  </p>
<p>The browser will begin parsing and attempting to render the page as soon as it receives the first chunk of data. This is known as incremental rendering.</p>
<ul>
<li>Building the DOM tree<br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path" >https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Above describes the process of building the DOM tree.</li>
</ul>
<p>CRP: Critical Rendering Path</p>
<p>Web Performance includes the following:</p>
<ul>
<li>server requests and responses</li>
<li>loading</li>
<li>scripting</li>
<li>rendering</li>
<li>layout</li>
<li>painting</li>
</ul>
<p>The CRP is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen.<br>A request for a web page or app starts with an HTTP request. The server sends a response containing the HTML. The browser then begins parsing the HTML, converting the received bytes to the DOM tree. The browser initiates requests every time it finds links to external resources, be it stylesheets, scripts, or embedded image references. Some requests are blocking, which means the parsing of the rest of the HTML is halted until the imported asset is handled. The browser continues to parse the HTML making requests and building the DOM, until it gets to the end, at which point it constructs the CSS object model. With the DOM and CSSOM complete, the browser builds the render tree, computing the styles for all the visible content. After the render tree is complete, layout occurs, defining the location and size of all the render tree elements. Once complete, the page is rendered, or ‘painted’ on the screen.</p>
<h4 id="Document-Object-Model-DOM"><a href="#Document-Object-Model-DOM" class="headerlink" title="Document Object Model (DOM)"></a>Document Object Model (DOM)</h4><p>DOM construction is incremental.</p>
<h4 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h4><p>CSSOM construction is incremental.CSS is render blocking.</p>
<h4 id="Render-tree"><a href="#Render-tree" class="headerlink" title="Render tree"></a>Render tree</h4><p>The render tree is the combination of the DOM and CSSOM. It is used to render the page.<br>To contrcut the render tree, the browser will:</p>
<ul>
<li>Traverse the DOM tree</li>
<li>Match the CSSOM rules to the DOM nodes</li>
<li>Apply the CSSOM rules to the DOM nodes</li>
<li>Construct the render tree</li>
</ul>
<h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>Layout is the process of determining the size and position of each element on the page. The browser will:</p>
<ul>
<li>Traverse the render tree</li>
<li>Calculate the size and position of each element</li>
<li>Determine the flow of the page</li>
</ul>
<h4 id="Painting"><a href="#Painting" class="headerlink" title="Painting"></a>Painting</h4><p>Painting is the process of filling in pixels on the screen. The browser will:</p>
<ul>
<li>Traverse the render tree</li>
<li>Paint the pixels on the screen</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>monorepo</title>
    <url>/undefined/monorepo/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>之前写过的一个项目是基于vue.js的前端和express的后端,一直是以分开的git repositories管理的。但其实后端内容很少，因此考虑后期的维护和开发，将前后端合并到一个git repository中，这样可以更好的管理项目。</p>
<h2 id="What-is-Monorepo"><a href="#What-is-Monorepo" class="headerlink" title="What is Monorepo"></a>What is Monorepo</h2><p>A monorepo is a code management approach where all code for multiple projects, including components, libraries, and internal dependencies, is stored in a single centralized repository, often involving multiple programming languages and application types.</p>
<h2 id="Why-Monorepo"><a href="#Why-Monorepo" class="headerlink" title="Why Monorepo"></a>Why Monorepo</h2><ul>
<li><strong>Simplified Code Management</strong></li>
<li><strong>Enhanced Collaboration</strong></li>
<li><strong>Streamlined Tooling</strong></li>
<li><strong>Code Sharing and Reusability</strong></li>
<li><strong>Dependency Management</strong></li>
<li><strong>Consistent Development Environment</strong></li>
<li><strong>Flexibility and Scalability</strong></li>
</ul>
<h2 id="How-to-create-a-Monorepo"><a href="#How-to-create-a-Monorepo" class="headerlink" title="How to create a Monorepo"></a>How to create a Monorepo</h2><p>目前主流的monorepo管理工具主要是Lerna(<a class="link"   href="https://lerna.js.org/).%E4%BD%86%E7%94%B1%E4%BA%8E%E6%88%91%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%BB%E8%A6%81%E6%98%AF%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8D%E6%98%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%9A%82%E4%B8%8D%E4%BD%BF%E7%94%A8Lerna%E3%80%82%E4%B8%BB%E8%A6%81%E8%BF%98%E6%98%AF%E5%AE%8C%E6%88%90%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E5%90%88%E5%B9%B6%E3%80%82" >https://lerna.js.org/).但由于我这个项目主要是前后端代码，不是组件化的项目，因此暂不使用Lerna。主要还是完成前后端代码的合并。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411110410947.png"
                      alt="image-20241111041031268"
                ></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a class="link"   href="https://www.sonarsource.com/learn/monorepo/" >https://www.sonarsource.com/learn/monorepo/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://juejin.cn/post/7215886869199896637" >https://juejin.cn/post/7215886869199896637 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>monorepo</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM和MVC</title>
    <url>/Yuyang/mvvmAndMvc/</url>
    <content><![CDATA[<p>众所周知，Vue.js是一个MVVM框架</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411042301055.png"
                      alt="image-20241104230111263"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>node_modules困境以及pnpm</title>
    <url>/Yuyang/pnpm/</url>
    <content><![CDATA[<p>node_modules的设计虽然能满足大部分的场景，但是其仍然存在着种种缺陷由于每个项目可能依赖成百上千个小模块，node_modules 目录的体积往往非常庞大，动辄几百MB甚至超过1GB。这不仅增加了存储负担，也影响了项目的克隆、备份和部署速度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232217640.png"
                      alt="image.png"
                ></p>
<p>pnpm 的机制对于 yarn 和 npm 来说是降维打击。</p>
<p>包管理工具发展史，npm2 开始</p>
<h2 id="npm2"><a href="#npm2" class="headerlink" title="npm2"></a>npm2</h2><p>用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。</p>
<p>然后找个目录，执行下 npm init -y，快速创建个 package.json。然后执行 npm install express，那么 express 包和它的依赖都会被下载下来：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247533.webp"
                      alt="img"
                ></p>
<p>展开 express，它也有 node_modules：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247605.webp"
                      alt="img"
                ></p>
<p>再展开几层，每个依赖都有自己的 node_modules：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247887.webp"
                      alt="img"
                ></p>
<p>也就是说 npm2 的 node_modules 是嵌套的。</p>
<p><strong>存在的缺陷：</strong></p>
<ul>
<li>嵌套深度问题：深层嵌套结构容易导致路径过长，特别是在 Windows 系统中，这可能导致系统路径长度限制问题。 windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247173.png"
                      alt="img"
                ></p>
<ul>
<li>重复的包：多层嵌套意味着大量重复的包实例，这无疑增加了磁盘空间的使用且影响安装速度。多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。</li>
</ul>
<h2 id="YARN-NPM-3"><a href="#YARN-NPM-3" class="headerlink" title="YARN &amp; NPM@3"></a>YARN &amp; NPM@3</h2><p>yarn 是怎么解决依赖重复很多次，嵌套路径过长的问题的呢？</p>
<p><strong>处理方式：</strong></p>
<ul>
<li>扁平化结构：大部分依赖被安装在顶层 node_modules 目录，减少了重复安装相同包的情况。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247543.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247991.png"
                      alt="img"
                ></p>
<ul>
<li>版本冲突处理：当两个包需要不同版本的同一个依赖时，无法被提升至顶层的依赖会被安装在需要它们的包的 node_modules 目录下。</li>
</ul>
<p><strong>存在的缺陷：</strong></p>
<ul>
<li>依赖结构的不确定性导致扁平化结果的不确定解决方法.lock 文件</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247361.png"
                      alt="img"
                ></p>
<ul>
<li>幽灵依赖：最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。这就是幽灵依赖的问题。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248078.png"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248136.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248329.png"
                      alt="img"
                ></p>
<ul>
<li>包重复安装问题。提升机制仍然可能导致大量的依赖被重复安装。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248172.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248183.png"
                      alt="img"
                ></p>
<p>扁平化处理：</p>
<p>我们把 node_modules 删了，用 yarn 再重新安装下，执行 yarn add express：</p>
<p>这时候 node_modules 就是这样了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249070.webp"
                      alt="img"
                ></p>
<p>全部铺平在了一层，展开下面的包大部分是没有二层 node_modules 的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249644.webp"
                      alt="img"
                ></p>
<p>当然也有的包还是有 node_modules 的，比如这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249531.webp"
                      alt="img"
                ></p>
<p>为什么还有嵌套呢？</p>
<p>因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。</p>
<p>npm 后来升级到 3 之后，也是采用这种铺平的方案了，和 yarn 很类似：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249282.webp"
                      alt="img"
                ></p>
<p>当然，yarn 还实现了 yarn.lock 来锁定依赖版本的功能，不过这个 npm 也实现了。</p>
<p>扁平化的方案也有相应的问题。而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题。</p>
<p>那 pnpm 是怎么解决这俩问题的呢？</p>
<h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p><strong>pnpm：</strong>是一个更新的包管理工具，旨在提供比 npm 和 Yarn 更好的磁盘空间效率和更快的安装速度。</p>
<p>pnpm 通过使用软硬链接解决这个问题。</p>
<p>软链接：软链接是一个指向文件路径的引用。</p>
<p>硬链接：硬链接是一个指向文件数据的直接引用。</p>
<p>这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。</p>
<p>没错，pnpm 就是通过这种思路来实现的。</p>
<p>再把 node_modules 删掉，然后用 pnpm 重新装一遍，执行 pnpm install。</p>
<p>你会发现它打印了这样一句话：</p>
<p>包是从全局 store 硬连接到虚拟 store 的，这里的虚拟 store 就是 node_modules&#x2F;.pnpm。</p>
<p>我们打开 node_modules 看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249706.webp"
                      alt="img"
                ></p>
<p>确实不是扁平化的了，依赖了 express，那 node_modules 下就只有 express，没有幽灵依赖。</p>
<p>展开 .pnpm 看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249750.webp"
                      alt="img"
                ></p>
<p>所有的依赖都在这里铺平了，都是从全局 store 硬连接过来的，然后包和包之间的依赖关系是通过软链接组织的。</p>
<p>比如 .pnpm 下的 expresss，这些都是软链接，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249099.webp"
                      alt="img"
                ></p>
<p>也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules&#x2F;.pnpm 下，然后之间通过软链接来相互依赖。</p>
<p>官方给了一张原理图，配合着看一下就明白了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249755.webp"
                      alt="img"
                ></p>
<p>这就是 pnpm 的实现原理。</p>
<p>那么回过头来看一下，pnpm 为什么优秀呢？</p>
<p>首先，最大的优点是节省磁盘空间呀，一个包全局只保存一份，剩下的都是软硬连接，这得节省多少磁盘空间呀。</p>
<p>其次就是快，因为通过链接的方式而不是复制，自然会快。</p>
<p>这也是它所标榜的优点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232250962.webp"
                      alt="img"
                ></p>
<p>相比 npm2 的优点就是不会进行同样依赖的多次复制。</p>
<p>相比 yarn 和 npm3+ 呢，那就是没有幽灵依赖，也不会有没有被提升的依赖依然复制多份的问题。</p>
<p>这就已经足够优秀了，对 yarn 和 npm 可以说是降维打击。</p>
<p>Reference：<a class="link"   href="https://juejin.cn/post/7127295203177676837?searchId=20240623222554B51B38FF0362E0D545BE" >https://juejin.cn/post/7127295203177676837?searchId=20240623222554B51B38FF0362E0D545BE <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/redbook/</url>
    <content><![CDATA[<h2 id="问题准备"><a href="#问题准备" class="headerlink" title="问题准备"></a>问题准备</h2><h2 id="Vite构建"><a href="#Vite构建" class="headerlink" title="Vite构建"></a>Vite构建</h2><p>几大特点</p>
<p>1、冷启动<br>2、快速热更新<br>3、bundleless<br>4、优化构建</p>
<p>特性说明：<br>1、开发环境冷启动，构建基于ESBuild，线上产物构建 rollup<br>2、本地HMR，做了很多优化，webpack是不是需要分析依赖图（耗时的），因为开发环境ESM方式请求资源文件<br>3、配置简单，比parcel还是复杂点</p>
<p>区分环境构建</p>
<p>开发环境 esbuild，bundleless方案进行构建<br>开发环境 rollup<br>如果你想在低版本浏览器调试，不好意思，vite不支持，因为vite是基于ESM的，低版本浏览器不支持ESM</p>
<p>热更新原理</p>
<p>建立长链接，websocket</p>
<p>vite&#x2F;client 插入到客户端<br>vite websocket 服务</p>
<p>浏览器的热更新需要结合，定义一些事件来处理：connect、disconnect、message<br>vite&#x2F;client 会监听文件变化，然后通知vite服务，vite服务会推送到客户端</p>
<p>turbopack</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="前端工程化方向"><a href="#前端工程化方向" class="headerlink" title="前端工程化方向"></a>前端工程化方向</h3><p>1、构建工具<br>2、自动化测试<br>3、代码规范<br>4、性能优化<br>5、持续集成<br>6、部署</p>
<h2 id="React性能优化，性能优化指标采集"><a href="#React性能优化，性能优化指标采集" class="headerlink" title="React性能优化，性能优化指标采集"></a>React性能优化，性能优化指标采集</h2><p>React性能优化Hooks<br>1、React.memo<br>React.memo是一个高阶组件，类似于React.PureComponent，用于函数组件的性能优化，它只会在props发生变化时重新渲染组件，如果props没有发生变化，它会返回上一次的渲染结果，从而避免不必要的渲染。<br>2、useMemo<br>useMemo是一个自定义Hook，用于缓存计算结果，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useMemo才会重新计算结果，否则直接返回上一次的计算结果。<br>3、useCallback<br>useCallback是一个自定义Hook，用于缓存函数，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useCallback才会返回新的函数，否则直接返回上一次的函数。<br>4、useEffect<br>useEffect是一个自定义Hook，用于处理副作用，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useEffect才会执行函数，否则直接返回上一次的执行结果。<br>5、useLayoutEffect<br>useLayoutEffect是一个自定义Hook，用于处理副作用，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useLayoutEffect才会执行函数，否则直接返回上一次的执行结果。</p>
<h2 id="React-Hooks实现原理-useEffect的实现原理以及执行时机"><a href="#React-Hooks实现原理-useEffect的实现原理以及执行时机" class="headerlink" title="React Hooks实现原理 useEffect的实现原理以及执行时机"></a>React Hooks实现原理 useEffect的实现原理以及执行时机</h2><p>React Hooks实现原理:</p>
<h2 id="function组件如何保存状态"><a href="#function组件如何保存状态" class="headerlink" title="function组件如何保存状态"></a>function组件如何保存状态</h2><p>1、useState<br>2、useReducer<br>3、useRef<br>4、useMemo<br>5、useCallback</p>
<h2 id="React事件处理机制是什么？以及为什么？"><a href="#React事件处理机制是什么？以及为什么？" class="headerlink" title="React事件处理机制是什么？以及为什么？"></a>React事件处理机制是什么？以及为什么？</h2><p>React事件处理机制是基于合成事件的，React会将原生事件封装成合成事件，然后通过事件委托的方式统一管理事件，从而提高性能。</p>
<h2 id="输入url到页面呈现的过程，以及render树是怎么渲染的"><a href="#输入url到页面呈现的过程，以及render树是怎么渲染的" class="headerlink" title="输入url到页面呈现的过程，以及render树是怎么渲染的"></a>输入url到页面呈现的过程，以及render树是怎么渲染的</h2><h2 id="script-async和defer的区别"><a href="#script-async和defer的区别" class="headerlink" title="script async和defer的区别"></a>script async和defer的区别</h2><p>script async和script defer都是用于异步加载脚本的，但是它们之间有一些区别：<br>1、执行时机<br>script async是在下载完成后立即执行脚本，不会阻塞页面的渲染，但是执行顺序不确定；<br>script defer是在DOM解析完成后按照顺序执行脚本，不会阻塞页面的渲染，但是执行顺序是按照顺序执行的。</p>
<h2 id="微任务和红任务"><a href="#微任务和红任务" class="headerlink" title="微任务和红任务"></a>微任务和红任务</h2><h2 id="css绘制同心圆"><a href="#css绘制同心圆" class="headerlink" title="css绘制同心圆"></a>css绘制同心圆</h2><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h2 id="Promise-all-和-Promise-allSettled"><a href="#Promise-all-和-Promise-allSettled" class="headerlink" title="Promise.all 和 Promise.allSettled"></a>Promise.all 和 Promise.allSettled</h2><p>function myPromiseAll(promises) {<br>  return new Promise((resolve, reject) &#x3D;&gt; {<br>    if (!Array.isArray(promises)) {<br>      return reject(new TypeError(“Argument must be an array”));<br>    }</p>
<pre><code>const resultArray = [];
let resolvedCount = 0;

promises.forEach((promise, index) =&gt; &#123;
  // 处理非 Promise 对象
  Promise.resolve(promise)
    .then((value) =&gt; &#123;
      resultArray[index] = value; // 保存结果在对应位置
      resolvedCount++; // 记录已成功的 Promise 数量

      // 如果所有 Promise 都成功，resolve 返回结果
      if (resolvedCount === promises.length) &#123;
        resolve(resultArray);
      &#125;
    &#125;)
    .catch((error) =&gt; &#123;
      reject(error); // 一旦有 Promise 失败，立即 reject
    &#125;);
&#125;);

// 如果传入空数组，直接 resolve
if (promises.length === 0) &#123;
  resolve(resultArray);
&#125;
</code></pre>
<p>  });<br>}</p>
<p>&#x2F;&#x2F; 测试用例<br>const p1 &#x3D; Promise.resolve(1);<br>const p2 &#x3D; Promise.resolve(2);<br>const p3 &#x3D; Promise.resolve(3);</p>
<p>myPromiseAll([p1, p2, p3])<br>  .then((result) &#x3D;&gt; console.log(“成功:”, result)) &#x2F;&#x2F; 成功: [1, 2, 3]<br>  .catch((error) &#x3D;&gt; console.log(“失败:”, error));</p>
<h2 id="实现一个URL解析"><a href="#实现一个URL解析" class="headerlink" title="实现一个URL解析"></a>实现一个URL解析</h2><p>url解析是一个比较复杂的过程，需要考虑很多情况，比如协议、主机、端口、路径、查询参数、锚点等，下面是一个简单的实现：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> urlObject = <span class="keyword">new</span> <span class="title function_">URL</span>(url); <span class="comment">// 使用 URL 构造函数解析</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">protocol</span>: urlObject.<span class="property">protocol</span>,  <span class="comment">// 协议，如 &#x27;https:&#x27;</span></span><br><span class="line">    <span class="attr">host</span>: urlObject.<span class="property">host</span>,          <span class="comment">// 主机名和端口号，如 &#x27;example.com:8080&#x27;</span></span><br><span class="line">    <span class="attr">hostname</span>: urlObject.<span class="property">hostname</span>,  <span class="comment">// 主机名，如 &#x27;example.com&#x27;</span></span><br><span class="line">    <span class="attr">port</span>: urlObject.<span class="property">port</span>,          <span class="comment">// 端口号，如 &#x27;8080&#x27;</span></span><br><span class="line">    <span class="attr">pathname</span>: urlObject.<span class="property">pathname</span>,  <span class="comment">// 路径，如 &#x27;/path/to/resource&#x27;</span></span><br><span class="line">    <span class="attr">search</span>: urlObject.<span class="property">search</span>,      <span class="comment">// 查询字符串，如 &#x27;?name=John&amp;age=30&#x27;</span></span><br><span class="line">    <span class="attr">params</span>: <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(urlObject.<span class="property">search</span>)), <span class="comment">// 查询参数对象</span></span><br><span class="line">    <span class="attr">hash</span>: urlObject.<span class="property">hash</span>           <span class="comment">// 锚点，如 &#x27;#section1&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://example.com:8080/path/to/resource?name=John&amp;age=30#section1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">parseUrl</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></div>

<h2 id="React-memo-useCallback-useEffect"><a href="#React-memo-useCallback-useEffect" class="headerlink" title="React.memo&#x2F;useCallback&#x2F;useEffect"></a>React.memo&#x2F;useCallback&#x2F;useEffect</h2><h2 id="介绍created和beforeRouteEnter区别-优劣"><a href="#介绍created和beforeRouteEnter区别-优劣" class="headerlink" title="介绍created和beforeRouteEnter区别 优劣"></a>介绍created和beforeRouteEnter区别 优劣</h2><h2 id="父子组建生命周期的顺序，为什么是这样的-为什么是在beforeMount的时候渲染子组件"><a href="#父子组建生命周期的顺序，为什么是这样的-为什么是在beforeMount的时候渲染子组件" class="headerlink" title="父子组建生命周期的顺序，为什么是这样的?为什么是在beforeMount的时候渲染子组件?"></a>父子组建生命周期的顺序，为什么是这样的?为什么是在beforeMount的时候渲染子组件?</h2><h2 id="http和tcp的关系"><a href="#http和tcp的关系" class="headerlink" title="http和tcp的关系"></a>http和tcp的关系</h2><h2 id="http状态码以及常见状态码"><a href="#http状态码以及常见状态码" class="headerlink" title="http状态码以及常见状态码"></a>http状态码以及常见状态码</h2><h2 id="介绍下三次握手"><a href="#介绍下三次握手" class="headerlink" title="介绍下三次握手"></a>介绍下三次握手</h2><h2 id="为什么需要三次"><a href="#为什么需要三次" class="headerlink" title="为什么需要三次"></a>为什么需要三次</h2><h2 id="二叉树-求根节点到叶子节点的路径之间数字构成的数总和，如路径4-1-5-表示415，故答案为414-415-436"><a href="#二叉树-求根节点到叶子节点的路径之间数字构成的数总和，如路径4-1-5-表示415，故答案为414-415-436" class="headerlink" title="二叉树 求根节点到叶子节点的路径之间数字构成的数总和，如路径4-&gt;1-&gt;5 表示415，故答案为414+415+436"></a>二叉树 求根节点到叶子节点的路径之间数字构成的数总和，如路径4-&gt;1-&gt;5 表示415，故答案为414+415+436</h2>]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/Yuyang/reg/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。具有强大的模式匹配和文本检索与替换功能。</p>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>在 JavaScript 中，可以通过两种方式定义正则表达式：</p>
<ol>
<li><p><strong>正则表达式字面量</strong>： 使用一对斜杠（<code>/</code>）包围正则表达式模式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/i</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>RegExp 构造函数</strong>： 使用 <code>RegExp</code> 构造函数来创建正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;pattern&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="正则表达式的标志（Flags）"><a href="#正则表达式的标志（Flags）" class="headerlink" title="正则表达式的标志（Flags）"></a>正则表达式的标志（Flags）</h2><p>正则表达式标志用于修改正则表达式的行为。常见的标志包括：</p>
<ul>
<li><code>g</code>：全局搜索（global search）。</li>
<li><code>i</code>：不区分大小写搜索（case-insensitive search）。</li>
<li><code>m</code>：多行搜索（multi-line search）。</li>
<li><code>s</code>：允许点号（<code>.</code>）匹配换行符（newline characters）。</li>
<li><code>u</code>：启用 Unicode 匹配。</li>
<li><code>y</code>：粘性匹配（sticky search），从目标字符串的当前位置开始匹配。</li>
</ul>
<h2 id="常用的正则表达式方法"><a href="#常用的正则表达式方法" class="headerlink" title="常用的正则表达式方法"></a>常用的正则表达式方法</h2><p>1、**<code>test()</code>**： 测试字符串中是否存在与正则表达式模式匹配的文本，返回布尔值。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.<span class="title function_">test</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>2、**<code>exec()</code>**： 搜索字符串中与正则表达式模式匹配的文本，返回一个结果数组或 <code>null</code>。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.<span class="title function_">exec</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&quot;hello&quot;]</span></span><br></pre></td></tr></table></figure></div>

<h2 id="正则表达式的基本模式"><a href="#正则表达式的基本模式" class="headerlink" title="正则表达式的基本模式"></a>正则表达式的基本模式</h2><p><strong>字符类</strong>：</p>
<ul>
<li><code>.</code>：匹配除换行符外的任何单个字符。</li>
<li><code>\d</code>：匹配一个数字（0-9）。</li>
<li><code>\D</code>：匹配一个非数字字符。</li>
<li><code>\w</code>：匹配一个字母、数字或下划线字符。</li>
<li><code>\W</code>：匹配一个非字母、数字或下划线字符。</li>
<li><code>\s</code>：匹配一个空白字符（包括空格、制表符等）。</li>
<li><code>\S</code>：匹配一个非空白字符。</li>
</ul>
<p><strong>边界匹配</strong>：</p>
<ul>
<li><code>^</code>：匹配字符串的开始。</li>
<li><code>$</code>：匹配字符串的结束。</li>
<li><code>\b</code>：匹配单词边界。</li>
<li><code>\B</code>：匹配非单词边界。</li>
</ul>
<p><strong>量词</strong>：</p>
<ul>
<li><code>*</code>：匹配前一个字符 0 次或多次。</li>
<li><code>+</code>：匹配前一个字符 1 次或多次。</li>
<li><code>?</code>：匹配前一个字符 0 次或 1 次。</li>
<li><code>&#123;n&#125;</code>：匹配前一个字符恰好 n 次。</li>
<li><code>&#123;n,&#125;</code>：匹配前一个字符至少 n 次。</li>
<li><code>&#123;n,m&#125;</code>：匹配前一个字符至少 n 次，但不超过 m 次。</li>
</ul>
<p><strong>什么是贪婪匹配和非贪婪匹配</strong>：</p>
<h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p><strong>贪婪匹配（Greedy Matching）</strong> 会尽可能多地匹配字符。这是正则表达式的默认行为。</p>
<p>例如，考虑以下正则表达式和字符串：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a.*b/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aabab&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> match = str.<span class="title function_">match</span>(regex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>]); <span class="comment">// &quot;aabab&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>.*</code> 是贪婪的，它会尝试匹配尽可能多的字符，以使整个表达式匹配成功。因此，它从第一个 <code>a</code> 开始，直到最后一个 <code>b</code> 才停止匹配。</p>
<p>在正则表达式中，“贪婪匹配”和“非贪婪匹配”是用于描述重复量词（如 <code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;&#125;</code>）的两种不同行为。</p>
<h3 id="贪婪匹配-1"><a href="#贪婪匹配-1" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p><strong>贪婪匹配（Greedy Matching）</strong> 会尽可能多地匹配字符。这是正则表达式的默认行为。</p>
<p>例如，考虑以下正则表达式和字符串：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码</span><br><span class="line">let regex = /a.*b/;</span><br><span class="line">let str = &quot;aabab&quot;;</span><br><span class="line">let match = str.match(regex);</span><br><span class="line">console.log(match[0]); // &quot;aabab&quot;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>.*</code> 是贪婪的，它会尝试匹配尽可能多的字符，以使整个表达式匹配成功。因此，它从第一个 <code>a</code> 开始，直到最后一个 <code>b</code> 才停止匹配。</p>
<h3 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h3><p><strong>非贪婪匹配（Non-Greedy Matching）</strong>，也称为“懒惰匹配（Lazy Matching）”，会尽可能少地匹配字符。使用 <code>?</code> 来表示非贪婪匹配。</p>
<p>例如，考虑以下正则表达式和字符串：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a.*?b/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aabab&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> match = str.<span class="title function_">match</span>(regex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>]); <span class="comment">// &quot;aab&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>.*?</code> 是非贪婪的，它会尽可能少地匹配字符。因此，它从第一个 <code>a</code> 开始，匹配到第一个 <code>b</code> 就停止匹配。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
  </entry>
  <entry>
    <title>Process and Thread</title>
    <url>/Yuyang/processandthread/</url>
    <content><![CDATA[<h2 id="Process-and-Thread"><a href="#Process-and-Thread" class="headerlink" title="Process and Thread"></a>Process and Thread</h2><p>What is process and thread?And what is the difference between them?In this article, we will discuss the concept of process and thread.To better understand the concept of process and thread, we need to understand the concept of program.</p>
<h3 id="What-program-is"><a href="#What-program-is" class="headerlink" title="What program is"></a>What program is</h3><p>A program is a excutable file that is stored on disk and is loaded into memory when it is run.<br>When a program is loaded into memory, it becomes a process. </p>
<h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>Process is a program in execution. A process is an instance of a program running on a computer. When a program is executed, it is loaded into memory and becomes a process. A process is an independent entity to which system resources (such as CPU time and memory) are allocated. Each process is executed in a separate address space, and one process cannot access the variables and data structures of another process. If a process wishes to access another process’ resources, inter-process communications have to be used. These include pipes, files, sockets, and other forms.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180633691.png"
                      alt="image-20240818063319857"
                ></p>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread is a basic unit of CPU utilization, consisting of a program counter, a stack, and a set of registers, (and a thread ID.) Each thread shares with other threads belonging to the same process its code section, data section, and other operating-system resources, such as open files and signals.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180632067.png"
                      alt="image-20240818063237021"
                ></p>
<h3 id="How-does-the-operating-system-manage-processes-and-threads"><a href="#How-does-the-operating-system-manage-processes-and-threads" class="headerlink" title="How does the operating system manage processes and threads"></a>How does the operating system manage processes and threads</h3><p>This is handled by the context switching mechanism, which enables the CPU to switch rapidly from one thread to another. This is done by saving the context of the thread that is currently running and loading the saved context of the thread that is to be executed. The operating system is responsible for managing the execution of processes and threads, and it does this by scheduling them to run on the CPU.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180634154.png"
                      alt="image-20240818063447864"
                ></p>
<p>![image-20240818064017828](..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240818064017828.png)</p>
<p>The thread switching is also need context switching, but the thread switching is faster than the process switching.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180642421.png"
                      alt="image-20240818064201566"
                ></p>
<p>Because the expansive cost of context switching, there also have some other ways, such as fiber, coroutine, etc.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180645121.png"
                      alt="image-20240818064530759"
                ></p>
<p>Thanks <a class="link"   href="https://www.youtube.com/watch?v=4rLW7zg21gI" >https://www.youtube.com/watch?v=4rLW7zg21gI <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
]]></content>
  </entry>
  <entry>
    <title>webpack 与 打包工具开发</title>
    <url>/Yuyang/webpack/</url>
    <content><![CDATA[<h1 id="webpack-与-打包工具开发"><a href="#webpack-与-打包工具开发" class="headerlink" title="webpack 与 打包工具开发"></a>webpack 与 打包工具开发</h1><h2 id="webpack核心配置"><a href="#webpack核心配置" class="headerlink" title="webpack核心配置"></a>webpack核心配置</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><h3 id="MiniCssExtractPlugin"><a href="#MiniCssExtractPlugin" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h3><p>用于提取css样式内容</p>
<h3 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h3><p>用于解析</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><h2 id="grunt、gulp-15、16年"><a href="#grunt、gulp-15、16年" class="headerlink" title="grunt、gulp 15、16年"></a>grunt、gulp 15、16年</h2><h2 id="新晋打包工具"><a href="#新晋打包工具" class="headerlink" title="新晋打包工具"></a>新晋打包工具</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>1、2009，commonjs，Modules&#x2F;1.0；<br>2、2011，为commonjs引入异步加载特性，Module&#x2F;Transfer&#x2F;C 提案，独立成AMD规范；<br>3、2013，grunt、gulp，基于任务的自动化构建工具；<br>4、2014，定义跨平台的模块规范，定义了一个新的规范，叫做UMD；<br>5、2014，将ES6 -&gt; ES5的工具，命名为babel；<br>6、2014，systemjs问世，简化了模块加载和处理的过程；<br>7、2014，Webpack问世，基于模块化的打包工具；<br>8、2015，正式ES6（ECMAScript 2015）规范正式发布<br>9、2015，Rollup，因为ES6的发布，借用ESModul，提出了tree-shaking的概念；<br>10、2017，webpack逐渐让人厌倦，Parcel问世，零配置的打包工具；<br>11、2019，snowpack出现 node_modules转ESM构建工具出现；<br>12、2020，浏览器对于ESM和HTTP2的更全面化支持，bundleless思路出现，ESBuild，出现在大众视野<br>13、2021，Vite发布</p>
<p>阶段分为：<br>1、初版构建工具：grunt（task）、gulp（flow）<br>2、webpack<br>3、基于webpack思维，扩展一些新兴构建工具<br>4、bundleless构建工具<br>5、正在进行时，基于Rust的前端工具链重构（swc、rspack）</p>
<h3 id="grunt-11年"><a href="#grunt-11年" class="headerlink" title="grunt 11年"></a>grunt 11年</h3><p>基于Task的构建工具，对应任务的配置，我们通过Plugins来完成</p>
<h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><p>通过定义Task与Flow，自定义打包构建流程</p>
<h2 id="构建基石-Webpack"><a href="#构建基石-Webpack" class="headerlink" title="构建基石 Webpack"></a>构建基石 Webpack</h2><h2 id="衍生出rollup、parcel"><a href="#衍生出rollup、parcel" class="headerlink" title="衍生出rollup、parcel"></a>衍生出rollup、parcel</h2><p>突破性的构建工具<br>go、rust来去编写构建工具<br>webpack+babel 比较受人诟病</p>
<h3 id="ESBuild"><a href="#ESBuild" class="headerlink" title="ESBuild"></a>ESBuild</h3><p>js编译引擎v8，v8引擎是基于C++编写的<br>js属于解释性语言，go语言是编译型语言不存在编译时的开销，只有运行时，所以速度快<br>基于Go语言，速度快，但是功能不够完善 多线程</p>
<p>在webpack、rollup使用中，相关的依赖我们需要第三方库来支持</p>
<ul>
<li>babel来去转译和检查</li>
<li>eslint来去检查</li>
<li>tsc 实现ts的转译和检查</li>
<li>less、sass这些都需要预处理器工具来完成</li>
</ul>
<h3 id="swc"><a href="#swc" class="headerlink" title="swc"></a>swc</h3><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>几大特点</p>
<p>1、冷启动<br>2、快速热更新<br>3、bundleless<br>4、优化构建</p>
<p>特性说明：<br>1、开发环境冷启动，构建基于ESBuild，线上产物构建 rollup<br>2、本地HMR，做了很多优化，webpack是不是需要分析依赖图（耗时的），因为开发环境ESM方式请求资源文件<br>3、配置简单，比parcel还是复杂点</p>
<p>区分环境构建</p>
<ul>
<li>开发环境 esbuild，bundleless方案进行构建</li>
<li>开发环境 rollup</li>
</ul>
<p>如果你想在低版本浏览器调试，不好意思，vite不支持，因为vite是基于ESM的，低版本浏览器不支持ESM</p>
<p>热更新原理</p>
<p>建立长链接，websocket</p>
<p>vite&#x2F;client 插入到客户端<br>vite websocket 服务</p>
<p>浏览器的热更新需要结合，定义一些事件来处理：connect、disconnect、message<br>vite&#x2F;client 会监听文件变化，然后通知vite服务，vite服务会推送到客户端</p>
<p>turbopack</p>
]]></content>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/Yuyang/prototype/</url>
    <content><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>什么是原型？什么是构造函数、实例原型、实例？它们的关系是什么？</p>
<h3 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h3><p>每个 JavaScript 对象都有一个内部链接到另一个对象的引用，这个对象被称为原型。当试图访问一个对象的属性时，JavaScript 会首先在这个对象自身上寻找该属性，如果找不到，则会查找该对象的原型，如此递归下去，直到找到该属性或达到原型链的末端。</p>
<h3 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h3><p>构造函数是用于创建对象的函数。通过 new 操作符调用构造函数时，它会创建一个新对象，并将这个新对象的内部 [[Prototype]] 连接到构造函数的 prototype 属性。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Yuyang&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>Person是构造函数，person是创建的对象</p>
<h3 id="实例原型（Instance-Prototype）"><a href="#实例原型（Instance-Prototype）" class="headerlink" title="实例原型（Instance Prototype）"></a>实例原型（Instance Prototype）</h3><p>实例原型是由构造函数的 <code>prototype</code> 属性引用的对象。所有由该构造函数创建的实例对象都将共享这个实例原型对象的属性和方法。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;zyz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Yuyang&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;YuyangA&quot;</span>);</span><br><span class="line">person1.<span class="property">callName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">person1.<span class="title function_">callName</span>();</span><br><span class="line">person2.<span class="title function_">callName</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="实例（Instance）"><a href="#实例（Instance）" class="headerlink" title="实例（Instance）"></a>实例（Instance）</h3><p>实例是通过构造函数创建的具体对象。每个实例都有一个内部链接到它的构造函数的 <code>prototype</code> 属性的引用，这个链接可以通过 <code>__proto__</code>（非标准）或 <code>Object.getPrototypeOf</code> 方法来访问。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person3 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Charlie&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person3.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121647943.png"
                      alt="image.png"
                ></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121648478.png"
                      alt="image.png"
                ></p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><strong>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</strong></p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>JavaScript中的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。</p>
<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li>Function.prototype.call 或 Function.prototype.apply 调用</li>
</ul>
<h4 id="作为对象的方法调用："><a href="#作为对象的方法调用：" class="headerlink" title="作为对象的方法调用："></a>作为对象的方法调用：</h4><p>函数作为对象的方法被调用时，this指向该对象：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getA</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span> === obj);</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getA</span>();</span><br></pre></td></tr></table></figure></div>

<h4 id="作为普通函数调用："><a href="#作为普通函数调用：" class="headerlink" title="作为普通函数调用："></a>作为普通函数调用：</h4><p>当函数不作为对象的属性被调用时，此时的this总是指向全局对象。在浏览器的javascript里，这个全局对象是window对象。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;globalName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>()); <span class="comment">//输出: globalName</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;globalName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;sven&quot;</span>,</span><br><span class="line">	<span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = myObject.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>()); <span class="comment">// globalName</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">id</span> = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>) </span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>)</span><br><span class="line">  &#125;        </span><br><span class="line">  <span class="title function_">callback</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback中的this指向window</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;;        </span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数没有this 捕获其上下文的this值</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>);        </span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 显式地将 this 绑定到 div1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, self.<span class="property">id</span>, self);</span><br><span class="line">  &#125;;        </span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂存this</span></span><br></pre></td></tr></table></figure></div>

<h4 id="构造器调用："><a href="#构造器调用：" class="headerlink" title="构造器调用："></a>构造器调用：</h4><p>用new调用函数时，该函数会返回一个对象，通常情况下，构造器的this就会指向返回的这个对象，</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;seven&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="property">name</span>);</span><br></pre></td></tr></table></figure></div>

<p>当构造器显式的返回一个对象时，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;sven&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&quot;anne&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="property">name</span>); <span class="comment">//anne</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Function-prototype-call-或-Function-prototype-apply-调用"><a href="#Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="Function.prototype.call 或 Function.prototype.apply 调用:"></a>Function.prototype.call 或 Function.prototype.apply 调用:</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;anne&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>()) <span class="comment">// seven</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">getName</span>.<span class="title function_">call</span>(obj2)) <span class="comment">// anne</span></span><br></pre></td></tr></table></figure></div>

<p><code>call</code> 方法调用一个函数，并显式地指定 <code>this</code> 值和传递的参数。</p>
<p>call源码实现：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果没有提供 context，默认设置为全局对象（在浏览器中是 window）</span></span><br><span class="line">  context = context || globalThis;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 为 context 创建一个唯一的临时属性来存储函数</span></span><br><span class="line">  <span class="keyword">const</span> fnSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line">  context[fnSymbol] = <span class="variable language_">this</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 context 调用函数，并传递参数</span></span><br><span class="line">  <span class="keyword">const</span> result = context[fnSymbol](...args);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">delete</span> context[fnSymbol];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例使用 myCall</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting, punctuation</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + punctuation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">myCall</span>(person, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;!&#x27;</span>);  <span class="comment">// 输出: &quot;Hello, Alice!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p> <strong>call() 方法接受的是参数列表，而 apply() 方法接受的是一个参数数组</strong>。</p>
<p>call：</p>
<blockquote>
<p><em>function</em>.call(<em>thisArg</em>, <em>arg1</em>, <em>arg2</em>, …)</p>
</blockquote>
<p>apply：</p>
<blockquote>
<p><em>func</em>.apply(<em>thisArg, [argsArray</em>])</p>
</blockquote>
<p><code>bind</code> 方法创建一个新的函数，该函数在调用时，其 <code>this</code> 值和传递的参数被预先设置。与 <code>call</code> 方法不同，<code>bind</code> 不会立即调用函数，而是返回一个新的函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind2</span> = <span class="keyword">function</span>(<span class="params">context</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    _this.<span class="title function_">apply</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo2 = bar.<span class="title function_">bind2</span>(foo);</span><br></pre></td></tr></table></figure></div>

<h3 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h3>]]></content>
  </entry>
  <entry>
    <title>RSA前端js加密 后端java解密</title>
    <url>/Yuyang/rsa/</url>
    <content><![CDATA[<h1 id="什么是RSA加密"><a href="#什么是RSA加密" class="headerlink" title="什么是RSA加密"></a>什么是RSA加密</h1><p>RSA加密是一种非对称加密算法，其具体实现如下：<br>1、选择两个不相等的质数p和q，计算n&#x3D;p<em>q<br>2、计算n的欧拉函数φ(n)&#x3D;(p-1)</em>(q-1)<br>3、选择一个整数e，1&lt;e&lt;φ(n)，且e与φ(n)互质<br>4、计算d, 使得(d*e)modφ(n)&#x3D;1<br>5、公钥是(n, e)，私钥是(n, d)<br>6、加密时，将明文m^e mod n，解密时，将密文c^d mod n</p>
<p>例如公钥(n, e) &#x3D; (33, 3)，私钥(n, d) &#x3D; (33, 7)，明文m &#x3D; 24，加密后的密文c &#x3D; 24^3 mod 33 &#x3D; 24，解密后的明文m &#x3D; 24^7 mod 33 &#x3D; 24</p>
<p>p &#x3D; 11, q &#x3D; 3, n &#x3D; 33, φ(n) &#x3D; 20, e &#x3D; 3, d &#x3D; 7</p>
<h2 id="前端js加密"><a href="#前端js加密" class="headerlink" title="前端js加密"></a>前端js加密</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jsencrypt</span><br><span class="line">npm install node-forge</span><br></pre></td></tr></table></figure></div>
<h3 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> forge <span class="keyword">from</span> <span class="string">&#x27;node-forge&#x27;</span></span><br><span class="line"><span class="comment">// 生成RSA密钥对</span></span><br><span class="line"><span class="keyword">const</span> &#123; privateKey, publicKey &#125; = forge.<span class="property">pki</span>.<span class="property">rsa</span>.<span class="title function_">generateKeyPair</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换公钥和私钥为PEM格式字符串</span></span><br><span class="line"><span class="keyword">const</span> publicKeyPem = forge.<span class="property">pki</span>.<span class="title function_">publicKeyToPem</span>(publicKey);</span><br><span class="line"><span class="keyword">const</span> privateKeyPem = forge.<span class="property">pki</span>.<span class="title function_">privateKeyToPem</span>(privateKey);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Public Key:&#x27;</span>, publicKeyPem);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Private Key:&#x27;</span>, privateKeyPem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的公钥和私钥</span></span><br><span class="line"><span class="comment">// 公钥</span></span><br><span class="line"><span class="comment">// -----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="comment">// MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCjXq96Iz4+TShUSGkPO2LpCWue</span></span><br><span class="line"><span class="comment">// C56FQoEFGZqx/7F6JIqLdF8qA773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDp</span></span><br><span class="line"><span class="comment">// cGM4QbMwDhYN2WgUHbnaAPJOLpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5f</span></span><br><span class="line"><span class="comment">// lf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="comment">// -----END PUBLIC KEY-----</span></span><br><span class="line"><span class="comment">// 私钥</span></span><br><span class="line"><span class="comment">// -----BEGIN RSA PRIVATE KEY-----</span></span><br><span class="line"><span class="comment">// MIICXAIBAAKBgQCjXq96Iz4+TShUSGkPO2LpCWueC56FQoEFGZqx/7F6JIqLdF8q</span></span><br><span class="line"><span class="comment">// A773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDpcGM4QbMwDhYN2WgUHbnaAPJO</span></span><br><span class="line"><span class="comment">// LpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5flf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="comment">// AoGAUfw9gcTYAroD6DAikSNTYvF4UWsxVVznlKCh0nwoG8zkvlFbRKF2n5Dcx8Jy</span></span><br><span class="line"><span class="comment">// v/PhdzN4jX0mot38oCrCFbGq9UoohUYo0tKKroWjV6Tz2Cbfv/9/GGi6I3nrn409</span></span><br><span class="line"><span class="comment">// hh9LzyRoIddLRaBBL91bZZ7OKF9G98Ya27y3teUM1MfX5uECQQDcD6dtZsNTjqFm</span></span><br><span class="line"><span class="comment">// haWKlcvEB3z/+brgwMFU53g0PLhfCTD7dXfh83Sc9zcrMDMYAnM6bDBTKrMet6LV</span></span><br><span class="line"><span class="comment">// M33OmyURAkEAvgzf6luLFHlQZ8T8CpPRMOcfYrn6qnVBeZ5FsQx+Le84rqk3Tcv+</span></span><br><span class="line"><span class="comment">// mXqhjJia49J2n6qlSRyiY5loos6A64Qm/wJASY5p9mWNEJbyWCSACuy7KZEfNSiy</span></span><br><span class="line"><span class="comment">// UIHdnZWpVjydnBakasj/A2WvKvBvXl5EFdhrz7FuDb6OFMxo/z6w5KhzIQJAZVHB</span></span><br><span class="line"><span class="comment">// 0lRpikm+twPKhu0VOmgNUHnsDBIlDOx3JROO9XgylNM726rkmfhJxgXZlZmviiHU</span></span><br><span class="line"><span class="comment">// qmysmkLACQPksSqsCwJBAJVEcG3gonm0BGmZiMDmwwP0M7grYTOUHDAVDJV1u1cB</span></span><br><span class="line"><span class="comment">// hYoV6mr5ZDBOMMIMroIHorcuYdqEKfiV8ulHc8hxBmo=</span></span><br><span class="line"><span class="comment">// -----END RSA PRIVATE KEY-----</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="前端加密"><a href="#前端加密" class="headerlink" title="前端加密"></a>前端加密</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Encrypt</span> <span class="keyword">from</span> <span class="string">&#x27;jsencrypt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publulicKey = <span class="string">`-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCjXq96Iz4+TShUSGkPO2LpCWue</span></span><br><span class="line"><span class="string">C56FQoEFGZqx/7F6JIqLdF8qA773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDp</span></span><br><span class="line"><span class="string">cGM4QbMwDhYN2WgUHbnaAPJOLpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5f</span></span><br><span class="line"><span class="string">lf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----`</span>;</span><br><span class="line"><span class="keyword">const</span> encryptor = <span class="keyword">new</span> <span class="title class_">Encrypt</span>();</span><br><span class="line">encryptor.<span class="title function_">setPublicKey</span>(publulicKey);</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> encrypted = encryptor.<span class="title function_">encrypt</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ encrypted:&quot;</span>, encrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🚀 ~ encrypted: HFzmziwImUXYOfVDy2RnlFm73rjWRQ/sacZ/hV7/XEATCaIjQdTbIPeH3iy+Kc6rIRJRp42LKMWLGq0x2pBdHauCEbJeKDGF3t3RXKk+AM/CFsODv3rXwXt4ArDMkhrtDg7ha6Zgr4jIqvkhauV9hVrB34RUK4jRBw8gBO9rmoM=</span></span><br></pre></td></tr></table></figure></div>

<h3 id="后端解密"><a href="#后端解密" class="headerlink" title="后端解密"></a>后端解密</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.util.io.pem.PemObject;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.util.io.pem.PemReader;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RSA_KEY_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHUNK_SIZE</span> <span class="operator">=</span> RSA_KEY_SIZE / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRsa</span><span class="params">(String encryptedData)</span>&#123;</span><br><span class="line">        System.out.println(encryptedData);</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">privateKeyStr</span> <span class="operator">=</span> <span class="string">&quot; -----BEGIN RSA PRIVATE KEY-----\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; MIICXAIBAAKBgQCjXq96Iz4+TShUSGkPO2LpCWueC56FQoEFGZqx/7F6JIqLdF8q\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; A773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDpcGM4QbMwDhYN2WgUHbnaAPJO\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; LpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5flf6KAddjsiCBi85x7wIDAQAB\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; AoGAUfw9gcTYAroD6DAikSNTYvF4UWsxVVznlKCh0nwoG8zkvlFbRKF2n5Dcx8Jy\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; v/PhdzN4jX0mot38oCrCFbGq9UoohUYo0tKKroWjV6Tz2Cbfv/9/GGi6I3nrn409\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; hh9LzyRoIddLRaBBL91bZZ7OKF9G98Ya27y3teUM1MfX5uECQQDcD6dtZsNTjqFm\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; haWKlcvEB3z/+brgwMFU53g0PLhfCTD7dXfh83Sc9zcrMDMYAnM6bDBTKrMet6LV\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; M33OmyURAkEAvgzf6luLFHlQZ8T8CpPRMOcfYrn6qnVBeZ5FsQx+Le84rqk3Tcv+\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; mXqhjJia49J2n6qlSRyiY5loos6A64Qm/wJASY5p9mWNEJbyWCSACuy7KZEfNSiy\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; UIHdnZWpVjydnBakasj/A2WvKvBvXl5EFdhrz7FuDb6OFMxo/z6w5KhzIQJAZVHB\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; 0lRpikm+twPKhu0VOmgNUHnsDBIlDOx3JROO9XgylNM726rkmfhJxgXZlZmviiHU\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; qmysmkLACQPksSqsCwJBAJVEcG3gonm0BGmZiMDmwwP0M7grYTOUHDAVDJV1u1cB\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; hYoV6mr5ZDBOMMIMroIHorcuYdqEKfiV8ulHc8hxBmo=\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; -----END RSA PRIVATE KEY-----&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> getPrivateKeyFromPem(privateKeyStr);</span><br><span class="line">            <span class="type">String</span> <span class="variable">decryptedData</span> <span class="operator">=</span> decryptData(encryptedData, privateKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将解密后的 Base64 编码字符串转换回原始的 JSON 字符串</span></span><br><span class="line"><span class="comment">//            byte[] decodedBytes = Base64.getDecoder().decode(decryptedData);</span></span><br><span class="line"><span class="comment">//            String jsonString = new String(decodedBytes, StandardCharsets.UTF_8);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(&quot;Decrypted Data: &quot; + jsonString);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Decrypted Data: &quot;</span> + decryptedData);</span><br><span class="line"><span class="comment">//            System.out.println(java.net.URLDecoder.decode(decryptedData ,&quot;UTF-8&quot;));</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title function_">getPrivateKeyFromPem</span><span class="params">(String pemString)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        PemReader pemReader = new PemReader(new StringReader(pemString));</span></span><br><span class="line"><span class="comment">//        PemObject pemObject = pemReader.readPemObject();</span></span><br><span class="line"><span class="comment">//        byte[] keyBytes = pemObject.getContent();</span></span><br><span class="line"><span class="comment">//        pemReader.close();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);</span></span><br><span class="line"><span class="comment">//        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span></span><br><span class="line"><span class="comment">//        return keyFactory.generatePrivate(keySpec);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyPEM</span> <span class="operator">=</span> pemString</span><br><span class="line">                .replace(<span class="string">&quot;-----BEGIN RSA PRIVATE KEY-----&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .replace(<span class="string">&quot;-----END RSA PRIVATE KEY-----&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .replaceAll(<span class="string">&quot;\\s&quot;</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 删除所有空格和换行</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] encoded = Base64.getDecoder().decode(privateKeyPEM);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(encoded);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">decryptData</span><span class="params">(String encryptedData, PrivateKey privateKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] encryptedBytes = Base64.getDecoder().decode(encryptedData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the buffer is large enough to hold all decrypted chunks</span></span><br><span class="line">        <span class="type">byte</span>[] decryptedBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[encryptedBytes.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">decryptedLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; encryptedBytes.length; i += CHUNK_SIZE) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">chunkLength</span> <span class="operator">=</span> Math.min(CHUNK_SIZE, encryptedBytes.length - i);</span><br><span class="line">            <span class="type">byte</span>[] chunk = <span class="keyword">new</span> <span class="title class_">byte</span>[chunkLength];</span><br><span class="line">            System.arraycopy(encryptedBytes, i, chunk, <span class="number">0</span>, chunkLength);</span><br><span class="line">            <span class="type">byte</span>[] decryptedChunk = cipher.doFinal(chunk);</span><br><span class="line">            System.arraycopy(decryptedChunk, <span class="number">0</span>, decryptedBytes, decryptedLength, decryptedChunk.length);</span><br><span class="line">            decryptedLength += decryptedChunk.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(decryptedBytes, <span class="number">0</span>, decryptedLength, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="存在的问题-当前端解密信息超长时jsencrypt库无法分段加密"><a href="#存在的问题-当前端解密信息超长时jsencrypt库无法分段加密" class="headerlink" title="存在的问题 当前端解密信息超长时jsencrypt库无法分段加密"></a>存在的问题 当前端解密信息超长时jsencrypt库无法分段加密</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数据替换为以下数据即会显示Message too long for RSA 原因：RSA 加密算法对单个消息块的长度有限制。这是因为 RSA 加密使用公钥对消息进行加密，而消息的长度不能超过密钥的长度减去填充字节数。因此对于 1024 位（128 字节）的 RSA 密钥，最大消息长度为：128 - 11 - 3 = 128 - 14 = 117</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">result</span>: &#123;</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="number">1572321851823</span>,</span><br><span class="line">    <span class="attr">inter1</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter2</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter3</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter4</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter5</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123s123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter6</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">stream</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">caton</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">card</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>解决方法使用encryptlong库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install encryptlong</span><br></pre></td></tr></table></figure></div>

<p>验证</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">JSEncrypt</span> <span class="keyword">from</span> <span class="string">&#x27;encryptlong&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> publulicKey = <span class="string">`-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCjXq96Iz4+TShUSGkPO2LpCWue</span></span><br><span class="line"><span class="string">C56FQoEFGZqx/7F6JIqLdF8qA773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDp</span></span><br><span class="line"><span class="string">cGM4QbMwDhYN2WgUHbnaAPJOLpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5f</span></span><br><span class="line"><span class="string">lf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----`</span>;</span><br><span class="line"><span class="keyword">const</span> encryptor = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>();</span><br><span class="line">encryptor.<span class="title function_">setPublicKey</span>(publulicKey);</span><br><span class="line"><span class="comment">// const data = &#123;</span></span><br><span class="line"><span class="comment">//   password: &#x27;123456&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">result</span>: &#123;</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="number">1572321851823</span>,</span><br><span class="line">    <span class="attr">inter1</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter2</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter3</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter4</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter5</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123s123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter6</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">stream</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">caton</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">card</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> encrypted = encryptor.<span class="title function_">encryptLong</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ encrypted:&quot;</span>, encrypted)</span><br></pre></td></tr></table></figure></div>

<p>后端可以解析 but 当内容过长且出现中文时后端就会解析失败😭 例如加密输入改为：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">result</span>: &#123;</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="number">1572321851823</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;宇阳&quot;</span>,</span><br><span class="line">    <span class="attr">inter1</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter2</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter3</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter4</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter5</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123s123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter6</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">stream</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">caton</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">card</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>后端解析报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408042344886.png"
                      alt="image-20240804234409275"
                ></p>
<p>原因排查 源码解析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050036985.png"
                      alt="image-20240805001758724"
                ></p>
<p><strong>PKCS#1 v1.5 填充方案</strong></p>
<p>PKCS#1 v1.5 是一种填充方案，用于确保 RSA 加密的安全性和一致性。它在加密前对数据进行填充，以确保填充后的数据长度与 RSA 密钥长度相匹配。具体填充格式如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x00</span> || <span class="number">0x02</span> || <span class="variable constant_">PS</span> || <span class="number">0x00</span> || D</span><br></pre></td></tr></table></figure></div>

<p>代码中体现</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050036260.png"
                      alt="image-20240805001918947"
                ></p>
<p>中文问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050036574.png"
                      alt="image-20240805003508983"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050037323.png"
                      alt="image-20240805003620646"
                ></p>
<p>当出现中文时由于其占3个字符 所以会导致传入的ba数组出现负索引的情况 导致后续解密失败</p>
<p><a class="link"   href="https://www.npmjs.com/package/jsencrypt-ext" >https://www.npmjs.com/package/jsencrypt-ext <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>使用这位大哥改进的代码就可以，但是我在使用其打包构建后的文件script导入仍有问题。</p>
]]></content>
  </entry>
</search>
