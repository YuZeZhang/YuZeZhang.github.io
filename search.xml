<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MAC 内网穿透 cpolar</title>
    <url>/Yuyang/cpolar/</url>
    <content><![CDATA[<blockquote>
<p>介绍如何通过使用cpolar来完成将内网下的本地服务器通过安全隧道暴露至公网，完成公网正常访问内网服务。目前我的本地web服务只能在局域网内访问，使用cpolar内网穿透可以将本地服务映射到公网，实现公网用户也可以访问到本地服务，无需公网IP，也无需设置路由器。<br>cpolar官网：<a class="link"   href="https://www.cpolar.com/" >https://www.cpolar.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="1、安装配置cpolar"><a href="#1、安装配置cpolar" class="headerlink" title="1、安装配置cpolar"></a>1、安装配置cpolar</h2><ul>
<li>通过Homebrew包管理器安装cpolar</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap probezy/core &amp;&amp; brew install cpolar</span><br></pre></td></tr></table></figure></div>

<ul>
<li>token认证：在cpolar官网后台的验证初复制自己的token</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232255851.png"
                      alt="img"
                ></p>
<p>cpolar authtoken xxx</p>
<p>         xxx处用复制的token代替</p>
<ul>
<li><p>安装cpolar服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service install</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2、使用cpolar"><a href="#2、使用cpolar" class="headerlink" title="2、使用cpolar"></a>2、使用cpolar</h2><ul>
<li><p>启动服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service start</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>cpolar web UI管理界面</p>
<p> 访问本地9200端口【<a class="link"   href="http://127.0.0.1:9200/%E3%80%91%EF%BC%8C%E4%BD%BF%E7%94%A8cpolar%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E3%80%82" >http://127.0.0.1:9200/】，使用cpolar账号登录。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232257170.png"
                      alt="img"
                ></p>
<p>         可在UI界面中查看自己的隧道信息 以及编辑、启动、停止和删除。其中状态列表下的的在线隧道列表显示了目前的公网地址和本地地址映射关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232257753.png"
                      alt="img"
                ></p>
<ul>
<li><p> 公网请求测试。</p>
<p>     可借助APIFOX在线测试。官网地址：<a class="link"   href="https://apifox.com/" >https://apifox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232258155.png"
                      alt="img"
                ></p>
<p> 根据自己情况填写。示例中的接口地址为&#x2F;model</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232258116.png"
                      alt="img"
                ></p>
<p>        请求成功🎉 </p>
<ul>
<li> 停止服务</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service stop</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意⚠️：停止后再启动，免费版的域名会发生变化需要重新设置，及时更新。 </p>
</blockquote>
<p>Reference：<a class="link"   href="https://www.cpolar.com/blog/cpolar-quick-start-tutorial-macos-series" >https://www.cpolar.com/blog/cpolar-quick-start-tutorial-macos-series <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>前端埋点与全链路</title>
    <url>/Yuyang/eventTracking/</url>
    <content><![CDATA[<h2 id="什么是埋点："><a href="#什么是埋点：" class="headerlink" title="什么是埋点："></a>什么是埋点：</h2><p>​	前端埋点是一种用于收集用户在网站或应用程序上的行为数据的方法。这些数据可以帮助企业了解用户的行为模式、使用习惯，并对产品进行优化。</p>
<h2 id="为什么要埋点："><a href="#为什么要埋点：" class="headerlink" title="为什么要埋点："></a>为什么要埋点：</h2><ul>
<li>流量监测（按时间空间维度分析，留存分析，转化分析）。</li>
<li>构建行为路径，获取用户的全链路信息获取，实现用户分群、人群洞察、行为细查等，构建用户画像。</li>
<li>通过对埋点数据的处理、分析、建模，判断产品的效果和未来走向。</li>
<li>为营销策略提供数据支持，分析营销效果，提高渠道转化。</li>
<li>热力分析，帮助判断访客热衷的区域，评估网页设计是否合理等。</li>
<li>实施AB Test，持续优化产品，使产品在市场上更具有竞争力。</li>
<li>用户行为异常监测以及问题快速定位与响应。</li>
</ul>
<h2 id="埋点的使用场景有哪些："><a href="#埋点的使用场景有哪些：" class="headerlink" title="埋点的使用场景有哪些："></a>埋点的使用场景有哪些：</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250013175.png"
                      alt="image-20240625001317104"
                ></p>
<h2 id="埋点方式："><a href="#埋点方式：" class="headerlink" title="埋点方式："></a>埋点方式：</h2><table>
<thead>
<tr>
<th></th>
<th>代码埋点</th>
<th>全埋点</th>
<th>可视化埋点</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td><strong>代码埋点</strong>是指在前端代码中手动添加埋点代码，用于捕获特定用户行为事件。这种方法灵活且精确，适用于需要细粒度数据收集的场景。</td>
<td><strong>全埋点</strong>是一种自动化的埋点方式，旨在捕获页面上的所有用户行为事件。通过全埋点，可以自动记录用户在页面上的所有操作，如点击、滑动、输入等，减少了手动添加埋点的工作量。</td>
<td><strong>可视化埋点</strong>是通过可视化界面配置埋点，而不需要修改代码。通过可视化工具，非技术人员也可以方便地配置和管理埋点。</td>
</tr>
<tr>
<td>优点</td>
<td>•	精确控制埋点的位置和事件。	<br />•	可以收集详细的事件信息。</td>
<td>•	覆盖全面，无需手动添加埋点代码。<br />•	能够捕获所有用户行为，数据更完整</td>
<td>•	无需修改代码，配置方便。<br />•	非技术人员也可以配置和管理埋点。</td>
</tr>
<tr>
<td>缺点</td>
<td>•	手动维护埋点代码，工作量大，容易出错。<br />•	需要开发人员介入，维护成本高。</td>
<td>•	数据量大，可能带来存储和处理的压力。<br />•	需要在数据清洗和分析阶段进行大量处理。</td>
<td>•	可能无法满足所有细粒度的埋点需求。<br />•	配置不当可能导致数据不准确。</td>
</tr>
</tbody></table>
<h2 id="埋点例子："><a href="#埋点例子：" class="headerlink" title="埋点例子："></a>埋点例子：</h2><p>代码埋点例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构建埋点数据</span></span><br><span class="line">    <span class="keyword">var</span> eventData = &#123;</span><br><span class="line">        <span class="attr">eventType</span>: <span class="string">&#x27;button_click&#x27;</span>,</span><br><span class="line">        <span class="attr">buttonId</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">        <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送数据到服务器</span></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;https://example.com/track&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(eventData),</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;埋点数据发送成功&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;埋点数据发送失败&#x27;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>全埋点例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全埋点脚本</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 事件监听器</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">eventListener</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> eventData = &#123;</span><br><span class="line">            <span class="attr">eventType</span>: event.<span class="property">type</span>,</span><br><span class="line">            <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(),</span><br><span class="line">            <span class="attr">element</span>: event.<span class="property">target</span>.<span class="property">tagName</span>,</span><br><span class="line">            <span class="attr">id</span>: event.<span class="property">target</span>.<span class="property">id</span>,</span><br><span class="line">            <span class="attr">className</span>: event.<span class="property">target</span>.<span class="property">className</span>,</span><br><span class="line">            <span class="attr">pageX</span>: event.<span class="property">pageX</span>,</span><br><span class="line">            <span class="attr">pageY</span>: event.<span class="property">pageY</span>,</span><br><span class="line">            <span class="attr">url</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送数据到服务器</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://example.com/track&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(eventData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>

<h2 id="埋点模型："><a href="#埋点模型：" class="headerlink" title="埋点模型："></a>埋点模型：</h2><blockquote>
<p>埋点模型包含两个主要概念：<strong>事件(event)</strong> 、<strong>属性(params)</strong></p>
<p><strong>事件</strong>：通过埋点定义的用户行为或业务操作，比如页面打开，页面离开，模块曝光，模块点击</p>
<p><strong>属性</strong>：事件附带的各种维度信息，比如用户信息，网络信息，设备信息，事件具体维度信息等</p>
</blockquote>
<p>一个设计的相对完善的模型,一般包含用户行为五元素</p>
<p>通过这个可以详细的分析是谁在什么地方什么时间，怎么样进行了什么操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250041129.png"
                      alt="image-20240625004123315"
                ></p>
<p>模型事件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250047727.png"
                      alt="image-20240625004727426"
                ></p>
<p>模型信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250053185.png"
                      alt="image-20240625005335046"
                ></p>
<h2 id="埋点上报："><a href="#埋点上报：" class="headerlink" title="埋点上报："></a>埋点上报：</h2><p>数据队列处理：当需要上报的数据量逐渐变多时，就需要考虑进行批量上报和延迟上报，本质上都是为了不阻塞业务程序的执行，上报本来就是用户无感知的事情，用户不能为此耗时买单。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250115952.png"
                      alt="image-20240625011532834"
                ></p>
<p>对于数据请求处理，主要考虑的有三个因素</p>
<ul>
<li>跨域的问题</li>
<li>页面销毁时，如何保障还未成功上传的数据完成数据上传请求</li>
<li>大数据量的上传</li>
</ul>
<p>较为标准的针对模块曝光的定义：窗口可视区域内 &amp;&amp; 组件矩形与视窗区域发生交集 &amp;&amp; 交集垂线距离 &gt;&#x3D; 1px &amp;&amp; 停留时间 &gt;&#x3D; XXms</p>
<p>Reference：<a class="link"   href="https://juejin.cn/post/7324334380373426227?searchId=202406242342178A14CCB0DE15106BCCCB" >https://juejin.cn/post/7324334380373426227?searchId=202406242342178A14CCB0DE15106BCCCB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>备注：近几个月来看到👀过质量最高的文章！学到了！</p>
]]></content>
  </entry>
  <entry>
    <title>node_modules困境以及pnpm</title>
    <url>/Yuyang/pnpm/</url>
    <content><![CDATA[<p>node_modules的设计虽然能满足大部分的场景，但是其仍然存在着种种缺陷由于每个项目可能依赖成百上千个小模块，node_modules 目录的体积往往非常庞大，动辄几百MB甚至超过1GB。这不仅增加了存储负担，也影响了项目的克隆、备份和部署速度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232217640.png"
                      alt="image.png"
                ></p>
<p>pnpm 的机制对于 yarn 和 npm 来说是降维打击。</p>
<p>包管理工具发展史，npm2 开始</p>
<h2 id="npm2"><a href="#npm2" class="headerlink" title="npm2"></a>npm2</h2><p>用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。</p>
<p>然后找个目录，执行下 npm init -y，快速创建个 package.json。然后执行 npm install express，那么 express 包和它的依赖都会被下载下来：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247533.webp"
                      alt="img"
                ></p>
<p>展开 express，它也有 node_modules：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247605.webp"
                      alt="img"
                ></p>
<p>再展开几层，每个依赖都有自己的 node_modules：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247887.webp"
                      alt="img"
                ></p>
<p>也就是说 npm2 的 node_modules 是嵌套的。</p>
<p><strong>存在的缺陷：</strong></p>
<ul>
<li>嵌套深度问题：深层嵌套结构容易导致路径过长，特别是在 Windows 系统中，这可能导致系统路径长度限制问题。 windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247173.png"
                      alt="img"
                ></p>
<ul>
<li>重复的包：多层嵌套意味着大量重复的包实例，这无疑增加了磁盘空间的使用且影响安装速度。多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。</li>
</ul>
<h2 id="YARN-NPM-3"><a href="#YARN-NPM-3" class="headerlink" title="YARN &amp; NPM@3"></a>YARN &amp; NPM@3</h2><p>yarn 是怎么解决依赖重复很多次，嵌套路径过长的问题的呢？</p>
<p><strong>处理方式：</strong></p>
<ul>
<li>扁平化结构：大部分依赖被安装在顶层 node_modules 目录，减少了重复安装相同包的情况。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247543.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247991.png"
                      alt="img"
                ></p>
<ul>
<li>版本冲突处理：当两个包需要不同版本的同一个依赖时，无法被提升至顶层的依赖会被安装在需要它们的包的 node_modules 目录下。</li>
</ul>
<p><strong>存在的缺陷：</strong></p>
<ul>
<li>依赖结构的不确定性导致扁平化结果的不确定解决方法.lock 文件</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247361.png"
                      alt="img"
                ></p>
<ul>
<li>幽灵依赖：最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。这就是幽灵依赖的问题。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248078.png"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248136.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248329.png"
                      alt="img"
                ></p>
<ul>
<li>包重复安装问题。提升机制仍然可能导致大量的依赖被重复安装。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248172.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248183.png"
                      alt="img"
                ></p>
<p>扁平化处理：</p>
<p>我们把 node_modules 删了，用 yarn 再重新安装下，执行 yarn add express：</p>
<p>这时候 node_modules 就是这样了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249070.webp"
                      alt="img"
                ></p>
<p>全部铺平在了一层，展开下面的包大部分是没有二层 node_modules 的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249644.webp"
                      alt="img"
                ></p>
<p>当然也有的包还是有 node_modules 的，比如这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249531.webp"
                      alt="img"
                ></p>
<p>为什么还有嵌套呢？</p>
<p>因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。</p>
<p>npm 后来升级到 3 之后，也是采用这种铺平的方案了，和 yarn 很类似：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249282.webp"
                      alt="img"
                ></p>
<p>当然，yarn 还实现了 yarn.lock 来锁定依赖版本的功能，不过这个 npm 也实现了。</p>
<p>扁平化的方案也有相应的问题。而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题。</p>
<p>那 pnpm 是怎么解决这俩问题的呢？</p>
<h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p><strong>pnpm：</strong>是一个更新的包管理工具，旨在提供比 npm 和 Yarn 更好的磁盘空间效率和更快的安装速度。</p>
<p>pnpm 通过使用软硬链接解决这个问题。</p>
<p>软链接：</p>
<p>硬链接：</p>
<p>这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。</p>
<p>没错，pnpm 就是通过这种思路来实现的。</p>
<p>再把 node_modules 删掉，然后用 pnpm 重新装一遍，执行 pnpm install。</p>
<p>你会发现它打印了这样一句话：</p>
<p>包是从全局 store 硬连接到虚拟 store 的，这里的虚拟 store 就是 node_modules&#x2F;.pnpm。</p>
<p>我们打开 node_modules 看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249706.webp"
                      alt="img"
                ></p>
<p>确实不是扁平化的了，依赖了 express，那 node_modules 下就只有 express，没有幽灵依赖。</p>
<p>展开 .pnpm 看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249750.webp"
                      alt="img"
                ></p>
<p>所有的依赖都在这里铺平了，都是从全局 store 硬连接过来的，然后包和包之间的依赖关系是通过软链接组织的。</p>
<p>比如 .pnpm 下的 expresss，这些都是软链接，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249099.webp"
                      alt="img"
                ></p>
<p>也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules&#x2F;.pnpm 下，然后之间通过软链接来相互依赖。</p>
<p>官方给了一张原理图，配合着看一下就明白了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249755.webp"
                      alt="img"
                ></p>
<p>这就是 pnpm 的实现原理。</p>
<p>那么回过头来看一下，pnpm 为什么优秀呢？</p>
<p>首先，最大的优点是节省磁盘空间呀，一个包全局只保存一份，剩下的都是软硬连接，这得节省多少磁盘空间呀。</p>
<p>其次就是快，因为通过链接的方式而不是复制，自然会快。</p>
<p>这也是它所标榜的优点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232250962.webp"
                      alt="img"
                ></p>
<p>相比 npm2 的优点就是不会进行同样依赖的多次复制。</p>
<p>相比 yarn 和 npm3+ 呢，那就是没有幽灵依赖，也不会有没有被提升的依赖依然复制多份的问题。</p>
<p>这就已经足够优秀了，对 yarn 和 npm 可以说是降维打击。</p>
<p>Reference：<a class="link"   href="https://juejin.cn/post/7127295203177676837?searchId=20240623222554B51B38FF0362E0D545BE" >https://juejin.cn/post/7127295203177676837?searchId=20240623222554B51B38FF0362E0D545BE <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
</search>
