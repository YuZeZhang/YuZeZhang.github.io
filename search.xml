<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024-11-13 日报 Day5</title>
    <url>/undefined/2024-11-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>理想是赶路人的月，是逆流者的桨<br>是荆棘尽处的繁华，是万仞山上的日出<br>让人在现实的泥沼中甘愿苦苦跋涉</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《图解HTTP》 P141-200
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><ul>
<li>1、在HTTP协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。</li>
<li>2、HTTP的缺点:<br>  通信使用明文(不加密)，内容可能会被窃听。<br>  不验证通信方的身份，因此有可能遭遇伪装。<br>  无法证明报文的完整性，所以有可能已遭篡改。</li>
<li>3、HTTP协议中没有加密机制，但可以通过和SSL(Secure Socket Layer, 安全套接层)或TLS(Transport Layer Security, 传输层安全)的组合使用，加密HTTP的通信内容。</li>
<li>4、认证本人核对的信息通常是指:<ul>
<li>密码: 只有本人才知道的字符串信息。</li>
<li>动态令牌: 仅限本人持有的设备内显示的一次性密码。</li>
<li>数字证书: 仅限本人(终端)持有的信息。</li>
<li>生物认证: 指纹和虹膜等本人的生理信息。</li>
<li>IC卡等: 仅限本人持有的信息。</li>
</ul>
</li>
<li>5、HTTP&#x2F;1.1使用的认证方式:<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
</li>
<li>6、WebSocket是一种在单个TCP连接上进行全双工通信的协议。通过WebSocket，浏览器和服务器之间的数据交换变得更加高效。为实现WebSocket通信，需要借助于HTTP协议。<br>HTTP的Upgrade首部字段可以将通信的协议切换为其他协议。通过发送Upgrade: websocket首部字段，通信过程从HTTP协议变成了WebSocket协议。同时Connection也会变为Upgrade。</li>
<li>7、HTTP防火墙(80&#x2F;tcp)和HTTPS防火墙(443&#x2F;tcp)</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-14 日报 Day6</title>
    <url>/undefined/2024-11-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>遇见，获得，失去，成长，释怀，完结<br>我与旧事归于尽，来年依旧迎花开</p>
<p>Encounter, gain, loss, growth, release, and completion.<br>I am at the end of old things, and the next year will still welcome the blooming flowers.</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《图解HTTP》 P141-完结
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、CGI(Common Gateway Interface)是一种Web服务器和应用程序之间的接口标准。通过CGI，Web服务器可以调用外部程序处理客户端发送的请求。CGI程序是一种独立于服务器的程序，可以用任何语言编写。<br>2、Java Servlet可以处理 HTTP 请求并生成动态响应。与 CGI 不同，Servlet 直接运行在服务器中，无需每次请求都启动新的进程，因此性能更高。Servlet 部署在 Servlet 容器中（如 Apache Tomcat）。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>CGI(Common Gateway Interface): 通用网关接口</li>
<li>XSS(Cross-Site Scripting): 跨站脚本攻击</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-10 日报 Day2</title>
    <url>/undefined/2024-11-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>于高山之巅，方见大河奔涌；于群峰之上，便觉长风浩荡。<br>As the top of the mountain, one can see the rushing river; Above the peaks, i feel the long and mighty wind.</p>

    </div>
  </div>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《网络是怎样连接的》 P13 - P74
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、GET、POST、PUT、DELETE</p>
<ul>
<li>GET: 从服务器获取资源<br>  GET用于获取资源。请求参数附加在 URL 中，因此这些参数可以被缓存、记录到日志中，并且可能暴露在网络中，容易被拦截。</li>
<li>POST：用于提交数据或创建资源。<br>数据在请求体中，表面上看似比 GET 更安全，实际上 POST 也存在被拦截的风险，尤其是通过明文 HTTP 传输时。</li>
<li>PUT和DELETE：用于更新和删除资源。<br>在RESTful API中，PUT和DELETE用于更新和删除资源。HTTP中的PUT、DELETE等请求不被认为安全，主要是因为它们旨在修改服务器上的资源、这些方法未必包含足够的安全机制来验证请求者的权限、容易受到跨站请求伪造（CSRF）等安全攻击。<br>Reference: <a class="link"   href="https://docs.pingcode.com/ask/244551.html" >https://docs.pingcode.com/ask/244551.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>2、CSRF（Cross-site request forgery）跨站请求伪造</p>
<ul>
<li>CSRF是一种网络攻击，它利用用户已登录的身份在用户不知情的情况下以用户的名义发送恶意请求。</li>
<li>CSRF Token:<ul>
<li>生成一个唯一的CSR Token并附加到每一个请求</li>
<li>服务器接收请求后，验证请求中的Token是否有效</li>
<li>每次生成的Token都是独立的、随机的，攻击者无法伪造</li>
</ul>
</li>
<li>同源检查:<ul>
<li>服务器检查请求来源的Referer或Origin头部，确保请求来自合法的源</li>
<li>如果Origin或Referer头部不匹配，服务器拒绝请求</li>
<li>例如发短信……</li>
</ul>
</li>
<li>使用双重Cookie验证<ul>
<li>用户登录时，将一个CSRF Token存储在Cookie中，同时在每个请求中都带上相同的CSRF Token</li>
<li>服务检验请求携带的Token和Cookie中的Token是否匹配</li>
</ul>
</li>
<li>设置Cookie的SameSite属性<ul>
<li>将Cookie的SameSite属性设置为Strict或Lax，可以防止CSRF攻击</li>
<li>SameSite&#x3D;Strict：只有在同源请求时才会发送Cookie</li>
<li>SameSite&#x3D;Lax：允许部分第三方请求（如 GET 请求）使用，但可以阻止大多数 CSRF 攻击。</li>
</ul>
</li>
</ul>
<p>Reference: <a class="link"   href="https://portswigger.net/web-security/csrf" >https://portswigger.net/web-security/csrf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>CSRF（Cross-site request forgery）: 跨站请求伪造</li>
<li>web security vulnerability: 网络安全漏洞</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-12 日报 Day4</title>
    <url>/undefined/2024-11-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>流水不争先，争的是滔滔不绝。</p>
<p>姜子牙年轻时也做过屠夫卖过酒，直到暮年遇到周文王才得以大展宏图。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《图解HTTP》 P1-140
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><ul>
<li><p>1、TCP&#x2F;IP协议族分为以下4层: 应用层、传输层、网络层、数据链路层。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411121823887.png"
                      alt="network"
                ></p>
</li>
<li><p>2、请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</p>
</li>
<li><p>3、响应报文是由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
</li>
<li><p>4、HTTP是一种无状态(stateless)协议，HTTP&#x2F;1.1引入了Cookie技术。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
</li>
<li><p>5、Cookie会根据服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务端发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
</li>
<li><p>6、内容协商机制(Content Negotiation)是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商机制有3种类型：</p>
<p>​	服务器驱动协商: 以请求的首部字段为参考，在服务器端自动处理。</p>
<p>​	客户端驱动协商: 比如按OS类型或浏览器类型自行切换成PC版页面或手机版页面。</p>
<p>​	透明协商</p>
</li>
<li><p>7、状态码类型：</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务端错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>具体状态码</th>
<th>状态名称</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>请求成功但无资源返回</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td></td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>8、通信数据转发程序: 代理、网关、隧道。</p>
</li>
<li><p>9、为Cookie服务的首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody></table>
</li>
<li><p>10、Set-Cookie字段的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME&#x3D;VALUE</td>
<td>赋予Cookie的名称和值</td>
</tr>
<tr>
<td>expires&#x3D;DATE</td>
<td>Cookie的有效期</td>
</tr>
<tr>
<td>path&#x3D;PATH</td>
<td></td>
</tr>
<tr>
<td>domain&#x3D;域名</td>
<td>Cookie适用对象的域名</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在HTTPS安全通信时才会发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使Cookie不能被JavaScript脚本访问</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>HTTP(HyperText Transfer Protocol): 超文本传输协议</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-15 日报 Day7</title>
    <url>/undefined/2024-11-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>无人扶我青云志，我自踏雪至山巅。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P1-53
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、JS的基本数据类型有: Undefined、Null、Boolean、Number、String、Symbol、BigInt。<br>2、JS的引用数据类型有: Object、Array、Function、Date、RegExp、Error。<br>3、JS中的真值和假值: </p>
<table>
<thead>
<tr>
<th>数值类型</th>
<th>转换成布尔值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>undefined</strong></td>
<td><strong>false</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>false</strong></td>
</tr>
<tr>
<td><strong>布尔值</strong></td>
<td><strong>true时true false时false</strong></td>
</tr>
<tr>
<td><strong>数字</strong></td>
<td><strong>+0、-0和NaN都是false，其他都是true</strong></td>
</tr>
<tr>
<td><strong>字符串</strong></td>
<td><strong>如果字符串是空的（长度是0）就是false，其他都是true</strong></td>
</tr>
<tr>
<td><strong>对象</strong></td>
<td><strong>true</strong></td>
</tr>
</tbody></table>
<p>4、相等运算符（ &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; ）</p>
<ul>
<li><strong>&#x3D;&#x3D;</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型(x)</th>
<th>类型(y)</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>undefined</td>
<td>True</td>
</tr>
<tr>
<td>undefined</td>
<td>null</td>
<td>True</td>
</tr>
<tr>
<td>数字</td>
<td>字符串</td>
<td>x &#x3D;&#x3D; toNumber(y)</td>
</tr>
<tr>
<td>字符串</td>
<td>数字</td>
<td>toNumber(x) &#x3D;&#x3D; y</td>
</tr>
<tr>
<td>布尔值</td>
<td>任何类型</td>
<td>toNumber(x) &#x3D;&#x3D; y</td>
</tr>
<tr>
<td>任何类型</td>
<td>布尔值</td>
<td>x &#x3D;&#x3D; toNumber(y)</td>
</tr>
<tr>
<td>字符串或数字</td>
<td>对象</td>
<td>x &#x3D;&#x3D; toPrimitive(y)</td>
</tr>
<tr>
<td>对象</td>
<td>字符串或数字</td>
<td>toPrimitive(x) &#x3D;&#x3D; y</td>
</tr>
</tbody></table>
<p>toNumber</p>
<table>
<thead>
<tr>
<th>值类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>+0</td>
</tr>
<tr>
<td>布尔值</td>
<td>如果是true,返回1;如果是false,返回+0;</td>
</tr>
<tr>
<td>数字</td>
<td>数字对应的值</td>
</tr>
<tr>
<td>字符串</td>
<td>将字符串解析成数字。如果字符串中包含字母，返回NaN；如果是由数字字符组成的，转换成数字</td>
</tr>
<tr>
<td>对象</td>
<td>Number(toPrimitive(value))</td>
</tr>
</tbody></table>
<p>toPrimitive</p>
<table>
<thead>
<tr>
<th>值类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>如果对象的valueOf方法的结果是原始值，返回原始值。如果对象的toString方法返回原始值，就返回这个值；其他情况都返回一个错误。</td>
</tr>
</tbody></table>
<ul>
<li><strong>&#x3D;&#x3D;&#x3D;</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型(x)</th>
<th>值</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>数字</td>
<td>x和y数值相同(但不是NaN)</td>
<td>true</td>
</tr>
<tr>
<td>字符串</td>
<td>x和y是相同的字符</td>
<td>true</td>
</tr>
<tr>
<td>布尔值</td>
<td>x和y都是true或false</td>
<td>true</td>
</tr>
<tr>
<td>对象</td>
<td>x和y引用同一个对象</td>
<td>true</td>
</tr>
</tbody></table>
<p>5、在类的定义里声明每个实例都会创建自己的函数副本。使用原型方法可以节约内存和降低实例化的开销。不过原型方法只能声明公共函数和属性，而类定义可以声明只在类的内部访问的私有函数和属性。<br>6、ES6展开运算符（…）可以将数组展开成参数列表，也可以将对象展开成键值对列表。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(...params)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数中展开操作符可以代替arguments,当作剩余参数使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">restParamaterFunction</span>(<span class="params">x, y, ...a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x + y) * a.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">restParamaterFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="number">7</span>)); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></div>
<p>等价于</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">restParamaterFunction</span> (x, y) &#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">2</span>);</span><br><span class="line"> <span class="keyword">return</span> (x + y) * a.<span class="property">length</span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>
<p>7、ES6引入了数组解构的概念，可以用来一次初始化多个变量。<br>8、虽然ES6引入了声明类的方法但是JavaScript仍然是基于原型的。类只是原型的语法糖。使用新的类语法可以为属性创建存取器函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-16 日报 Day8</title>
    <url>/undefined/2024-11-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>心存希冀，目有繁星；<br>追光而遇，沐光而行。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P54-78
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、数据方法: </p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat</td>
<td>连接2个或更多数组，并返回结果</td>
</tr>
<tr>
<td>every</td>
<td>对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true</td>
</tr>
<tr>
<td>filter</td>
<td>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组</td>
</tr>
<tr>
<td>forEach</td>
<td>对数组中的每一项运行给定函数。这个方法没有返回值</td>
</tr>
<tr>
<td>join</td>
<td>将所有的数组元素连接成一个字符串</td>
</tr>
<tr>
<td>indexOf</td>
<td>返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>返回在数组中搜索到的与给定参数相等的元素的索引里最大的值</td>
</tr>
<tr>
<td>map</td>
<td>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</td>
</tr>
<tr>
<td>reverse</td>
<td>颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在 的第一个</td>
</tr>
<tr>
<td>slice</td>
<td>传入索引值，将数组里对应索引范围内的元素作为新数组返回</td>
</tr>
<tr>
<td>some</td>
<td>对数组中的每一项运行给定函数，如果任一项返回true，则返回true</td>
</tr>
<tr>
<td>sort</td>
<td>按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数</td>
</tr>
<tr>
<td>toString</td>
<td>将数组作为字符串返回</td>
</tr>
<tr>
<td>valueOf</td>
<td>和toString类似，将数组作为字符串返回</td>
</tr>
<tr>
<td>reduce</td>
<td>array.reduce(callback, initialValue) callback接收四个参数 。accumulator：累加器，保存回调函数的返回值，并将其在下一次迭代中传递。currentValue：当前处理的数组元素。currentIndex：当前元素的索引（可选）。array：调用 reduce 的数组本身（可选）。</td>
</tr>
</tbody></table>
<p>2、栈</p>
<p>栈实现</p>
<p>最简单的: 存在的缺点 希望Stack类的用户只能访问暴露给类的方法。否则，就有 可能从栈的中间移除元素（因为我们用数组来存储其值），这不是我们希望看到的。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span> = []; <span class="comment">// 用数组存储栈元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入栈操作：添加一个元素到栈顶</span></span><br><span class="line">    <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作：移除并返回栈顶元素</span></span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Stack is empty, cannot pop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Stack is empty, no top element&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空栈</span></span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用ES6的限定作用域Symbol实现</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _items = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span> () &#123;</span><br><span class="line"> <span class="variable language_">this</span>[_items] = []; <span class="comment">//&#123;2&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//Stack方法</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(stack);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols); <span class="comment">// [Symbol()]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol()</span></span><br><span class="line">stack[objectSymbols[<span class="number">0</span>]].<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_">print</span>(); <span class="comment">//输出 5, 8, 1</span></span><br></pre></td></tr></table></figure></div>

<p>虽然创建了一个symbol属性 但是依然可以获取到数组</p>
<p>用ES6的WeakMap</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); <span class="comment">//&#123;1&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span> () &#123;</span><br><span class="line"> items.<span class="title function_">set</span>(<span class="variable language_">this</span>, []); <span class="comment">//&#123;2&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>); <span class="comment">//&#123;3&#125;</span></span><br><span class="line"> s.<span class="title function_">push</span>(element);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line"> <span class="keyword">let</span> r = s.<span class="title function_">pop</span>();</span><br><span class="line"> <span class="keyword">return</span> r;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//其他方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><p>栈: 例子(书堆) 先进后出(LIFO)<br>方法包含: push、pop、peek、isEmpty、getSize、clear<br>应用: 回溯问题中，它可以存储访问过的任务或路径、撤销的操作（后<br>面的章节讨论图和回溯问题时，</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-18 日报 Day10</title>
    <url>/undefined/2024-11-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>与时俱进，良性循环。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、巴菲特致股东的信P1-26</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、巴菲特成功的八字诀：与时俱进，良性循环。<br>2、坚持与合适的人、合适的企业打交道，与人为善、良性互动、相濡以沫、相互尊重、相得益彰、交相辉映，这是巴菲特多年一直保持成功的关键。<br>3、从别人的故事里，找到自己的人生启发，这就是读书的意义所在。<br>4、一家餐馆可以定位于特定的食客阶层-喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困感,最终离开。公司定位与股东之间的相处关系，与餐馆和食客的关系类似。你不可能在所有的时候满足所有的人。<br>5、总之，伯克希尔和它的长期持有者会从下跌的股市中获得好处，就像一个需要购买日常食品的消费者，从食品价格的下跌中获得的好处一样。所以当市场大跌时，和平常一样，不用担忧，不用沮丧，这对于伯克希尔反而是个好消息。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-19 日报 Day11</title>
    <url>/undefined/2024-11-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每次归程，都是为了更好出发。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P1-10 第一章: 什么是JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、完整的JavaScript包含</p>
<ul>
<li>ECMAScript，描述了该语言的语法和基本对象</li>
<li>文档对象模型（DOM），描述处理网页内容的方法和接口</li>
<li>浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口<br>2、ECMA描述这门语言的如下部分:</li>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>全局对象<br>3、DOM: 文档对象模型(DOM, Document Object Model)是一个应用编程接口，用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。<br>DOM通过创建表示文档的树，让开发者可以随心所欲控制网页的内容和结构。可以通过DOM API可以轻松地删除、添加、替换、修改节点。<br>4、BOM: 浏览器对象模型(BOM, Browser Object Model)，用于访问和操作浏览器窗口。BOM主要针对浏览器窗口和子窗口。</li>
<li>弹出新浏览器窗口</li>
<li>移动、缩放和关闭浏览器窗口</li>
<li>navigator对象，提供关于浏览器的详尽信息</li>
<li>location对象，提供浏览器加载页面的详尽信息</li>
<li>screen对象，提供关于用户屏幕分辨率的详尽信息</li>
<li>performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息</li>
<li>对cookie的支持<br>5、小结:</li>
<li>JavaScript是一种专为网页交互设计的脚本语言，由下列三个不同的部分组成:<ul>
<li>ECMAScript：由ECMA-262定义，提供核心语言功能</li>
<li>文档对象模型(DOM)：提供与网页内容交互的方法和接口</li>
<li>浏览器对象模型(BOM)：提供与浏览器交互的方法和接口</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-20 日报 Day12</title>
    <url>/undefined/2024-11-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每次停歇，都是为了积攒力量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P11-13 第二章：HTML中的JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、<script>元素有下列8个属性：</p>
<ul>
<li>async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。</li>
<li>charset：可选。表示通过src属性指定的代码的字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</li>
<li>crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。可以设置的值为anonymous和use-credentials。</li>
<li>defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>
<li>integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性。如果接收到的资源没有完整性验证通过，会阻止资源加载。</li>
<li>src：可选。表示包含要执行代码的外部文件。</li>
<li>type：可选。代替language属性，表示代码块中脚本的内容类型（也称为MIME类型）。这个值是text/javascript，除非代码块是在JavaScript以外的语言编写的。</li>
<li>language：废弃。最初用于表示代码块中脚本的语言。大多数浏览器会忽略这个属性，因此不应该再使用它。</li>
</ul>
<p>外部javascript文件的扩展名不是必须是js。因为浏览器不会检察所包含javascript文件的扩展名，这位服务器端动态生成javascript文件提供了可能性。<br>2、<script>可以包含来自外部域的javascript文件, 这个URL指向的资源可以跟包含它的HTML页面不在同一个域中。<br>浏览器在解析这个资源时会向src属性指定的路径发送一个GET请求，以取得相应资源，假定是一个js文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的javascript则受限制。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-17 日报 Day9</title>
    <url>/undefined/2024-11-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>少年应有鸿鹄志，当骑骏马踏平川。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P79-88
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、队列是一种遵循先进先出（FIFO）原则的有序集合。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p>
<ul>
<li>enqueue(element(s))：向队列尾部添加一个（或多个）新的项。</li>
<li>dequeue()：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li>
<li>front()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与Stack类的peek方法非常类似）。</li>
<li>isEmpty()：如果队列中不包含任何元素，返回true，否则返回false。</li>
<li>size()：返回队列包含的元素个数，与数组的length属性类似。<br>2、普通队列类实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">element</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="数据结构总结"><a href="#数据结构总结" class="headerlink" title="数据结构总结"></a>数据结构总结</h3><p>队列: 先进先出(FIFO)<br>方法包含: enqueue, dequeue, front, isEmpty, size<br>应用: 任务队列，因为每个标签页都是单线程处理的，它被称为事件循环。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-11 日报 Day3</title>
    <url>/undefined/2024-11-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>最慢的步伐不是跬步，而是徘徊;<br>最快的脚步不是冲刺，而是坚持。<br>The slowest pace is not a step, but wandering;<br>The fastest pace is not to sprint, but to persevere.</p>

    </div>
  </div>

<h3 id="今日思考"><a href="#今日思考" class="headerlink" title="今日思考"></a>今日思考</h3><p>今天看到了一个youtube博主分享的一个行为习惯视频(<a class="link"   href="https://www.youtube.com/watch?v=4zXTyc2ZjXM)%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%8F%90%E5%88%B0%E7%9A%84%E8%BF%99%E6%9C%AC%E3%80%8AThe" >https://www.youtube.com/watch?v=4zXTyc2ZjXM)，其中提到的这本《The <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 5 AM CLUB》以及5 AM Project.想要做到真正的早起需要一个明确的5 AM Project.<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411110002901.jpg"
                      alt="image-202411110002901"
                ></p>
<p>这边就有一个问题，为什么非得是早上起来为什么不能是晚上熬夜呢？<br>早起奥义:<br>早上大脑是清空的 因此可以更好的学习自己的事情<br>晚上大脑经历了早上忙碌的工作，下班之后的时间都是垃圾时间，因此晚上经常会习惯刷短视频 一刷刷到后半夜</p>
<p>-针对这个视频内容对我个人有什么思考呢？<br>可以考虑把下班后的学习时间提前到上班前。</p>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《网络是怎样连接的》 P75 - 完结🎉
2、https://www.sonarsource.com/learn/monorepo/
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><ul>
<li><p>1、地址转换的基本原理是在转发网络包时对IP头部中的IP地址和端口号进行修改。</p>
</li>
<li><p>2、缓存服务器是一台通过<strong>代理机制</strong>对数据进行缓存的服务器。代理介于Web服务器和客户端之间，具有对Web服务器访问进行中转的功能。</p>
</li>
<li><p>3、正向代理: 在客户端部署一个代理。比如VPN、科学上网工具等。</p>
</li>
<li><p>4、反向代理: Nginx反向代理用于负载均衡和缓存、CDN加速服务。</p>
</li>
<li><p>5、CDN（Content Delivery Network）内容分发网络: 通过将内容分发到全球各地的服务器，使用户可以从距离较近的服务器获取内容，提高访问速度。<br>CDN基于WEB服务器运营者和网络运营商签约将自己的缓存服务器放在客户端的运营商处。一般有厂商提供CDN服务，提供这种服务的厂商称为CDSP（Content Delivery Service Provider）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411110345416.png"
                      alt="image-20241111034457433"
                ></p>
</li>
</ul>
<p>Reference: <a class="link"   href="https://bg.qianzhan.com/trends/detail/506/240226-8132891d.html" >https://bg.qianzhan.com/trends/detail/506/240226-8132891d.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>6、根据响应头的Content-Type字段，浏览器会决定如何处理响应的内容。例如，如果Content-Type字段的值是text&#x2F;html，浏览器会将响应的内容解析为HTML文档并显示在页面上。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-23 日报 Day15</title>
    <url>/undefined/2024-11-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你有多自律，就有多自由。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P21-29 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、标识符：指变量、函数、属性的名字，或者函数的参数。标识符可以是下列几种：</p>
<ul>
<li>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；</li>
<li>其他字符可以是字母、下划线、美元符号或数字；<br>2、注释：单行注释以两个斜杠（&#x2F;&#x2F;）开头，多行注释以斜杠加星号（&#x2F;<em>）开头，以星号加斜杠（</em>&#x2F;）结尾。<br>macOS系统中，可以使用 Command + &#x2F; 快捷键来快速注释代码。</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">单行注释：</span><br><span class="line">快捷键：<span class="title class_">Command</span>+/</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">多行注释:</span><br><span class="line">快捷键：<span class="title class_">Command</span>+shift+/</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 12</span></span><br><span class="line"><span class="comment">12 */</span></span><br></pre></td></tr></table></figure></div>
<p>3、严格模式: 通过在脚本开头添加”use strict”，可以强制开启 ECMAScript 5 的严格模式。use strict是一个预处理指令，用于指定代码在严格模式下执行。<br>也可以单独在函数内部开启严格模式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4、关键词和保留字：ECMAScript中有一些关键词和保留字，它们有特殊用途，不能用作标识符。</p>
<ul>
<li>关键词：break、case、catch、continue、debugger、default、delete、do、else、false、finally、for、function、if、in、instanceof、new、null、return、switch、this、throw、true、try、typeof、var、void、while、with</li>
<li>保留字：abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile<br>5、变量：ECMAScript 的变量是松散类型的，可以用来保存任何类型的数据。有三种方式声明变量：var、let、const。</li>
<li>var：</li>
<li>声明作用域：函数作用域</li>
<li>变量提升：变量声明会被提升到函数作用域的顶部<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure></div></li>
<li>let：</li>
<li>声明作用域：块作用域<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// ReferenceError: age is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
<li>变量提升：不存在变量提升<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// ReferenceError: Cannot access &#x27;age&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure></div></li>
<li>let的暂时性死区：在块作用域内，使用 let 声明的变量不会被提升，而且在声明之前使用这个变量会抛出错误。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暂时性死区</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">    name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>全局声明：使用let声明的全局变量不会成为window对象的属性。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">age</span>); <span class="comment">// 26</span></span><br></pre></td></tr></table></figure></div></li>
<li>条件声明：使用let声明的变量只在块作用域内有效。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure></div></li>
<li>for循环中的let声明：<br>在let出现之前，for循环定义的迭代变量会渗透到循环体外部。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5 5 5 5 5</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>const：声明一个只读的常量。一旦声明，常量的值就不能改变。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"><span class="comment">// const也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">name = <span class="string">&#x27;Nicholas&#x27;</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"><span class="comment">// const声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure></div>
const 声明的限制只适用于它指向的变量的引用，而不适用于它指向的变量的值。</li>
</ul>
<pre><code class="javascript">const person = &#123;&#125;;
person.name = &#39;Matt&#39;;
console.log(person.name); // Matt
</code></pre>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-24 日报 Day16</title>
    <url>/undefined/2024-11-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你有多自律，就有多自由。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P30-37 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript中有6种简单数据类型（也称为原始数据类型）：Undefined、Null、Boolean、Number、String、Symbol（ES6新增）。<br>2、ECMAScript中有一种复杂数据类型——对象（Object）。<br>3、typeof操作符：用于检测给定变量的数据类型。typeof会返回下列字符串之一:<br>    - “undefined”：如果这个值未定义<br>    - “boolean”：如果这个值是布尔值<br>    - “string”：如果这个值是字符串<br>    - “number”：如果这个值是数值<br>    - “object”：如果这个值是对象或null<br>    - “function”：如果这个值是函数<br>    - “symbol”：如果这个值是符号</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (message)); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">95</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>调用typeof null会返回”object”，这是因为特殊值null被认为是一个对空对象的引用。<br>注意 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，<br>函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(message)&#123;</span><br><span class="line">    <span class="comment">// 这个代码块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!message)&#123;</span><br><span class="line">    <span class="comment">// 这个代码块会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(age)&#123;</span><br><span class="line">    <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4、Null类型：Null类型只有一个值，即特殊的null。逻辑上讲，null值表示一个空对象指针，因此用typeof操作符检测null值会返回”object”。<br>let car &#x3D; null;<br>console.log(typeof car); &#x2F;&#x2F; “object”<br>5、Boolean类型：Boolean类型有两个字面值：true和false。这两个值不是数字，但它们在需要时会被转换为数字。true转换为1，false转换为0。<br>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：<br>let message &#x3D; “Hello world!”;<br>let messageAsBoolean &#x3D; Boolean(message);<br>其转化规则如下表：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字（包含无穷值）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>N&#x2F;A（不存在）</td>
<td>undefined</td>
</tr>
<tr>
<td>6、Number类型：ECMAScript 中的所有数字都是浮点数。在其他编程语言中，整数和浮点数是不同的数据类型，但在 ECMAScript 中，它们是同一种数据类型。在 ECMAScript 中，可以使用十进制、八进制（在数字前加0）和十六进制（在数字前加0x）。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，</td>
<td></td>
<td></td>
</tr>
<tr>
<td>第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出了应</td>
<td></td>
<td></td>
</tr>
<tr>
<td>有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>; <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>; <span class="comment">// 无效的八进制数值——解析为79</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span>; <span class="comment">// 无效的八进制数值——解析为8</span></span><br></pre></td></tr></table></figure></div>
<p>十六进制字面量的第一部分必须是 0x，然后是任何十六进制数字（0<del>9 和 a</del>f）。字母 a~f 可以是大写的，也可以是小写的。如下所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十六进制的10</span></span><br><span class="line"><span class="keyword">let</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">// 十六进制的31</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>浮点数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>; <span class="comment">// 小数点后没有数字</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>; <span class="comment">// 小数点前没有数字</span></span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 可以省略整数部分和小数点</span></span><br></pre></td></tr></table></figure></div>
科学计数法表示的浮点数：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure></div>
浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不<br>是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下<br>面的例子：<br>if (a + b &#x3D;&#x3D; 0.3) { &#x2F;&#x2F; 别这么干！<br> console.log(“You got 0.3.”);<br>}<br>这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。<br>注意 之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript<br>所独有。其他使用相同格式的语言也有这个问题。</li>
<li>值的范围：由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。</li>
<li>NaN(Not a Number)，用来表示本来要返回数值的操作失败了（而不是抛出错误）。NaN 是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，0 除以 0 会返回 NaN——这是一个数学错误，而不是一个 JavaScript 错误。NaN 与任何值都不相等，包括它自己：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>/<span class="number">0</span>); <span class="comment">// Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">5</span>/<span class="number">0</span>); <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure></div>
NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN&#x2F;10），在连续多步计算时这可能是个问题。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：<br>console.log(NaN &#x3D;&#x3D; NaN); &#x2F;&#x2F; false</li>
<li>数值转换：Number()、parseInt()和parseFloat()。<br>Number()函数：</li>
<li>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是 null 值，返回 0。</li>
<li>如果是 undefined，返回 NaN。</li>
<li>如果是字符串，遵循下列规则：<ul>
<li>字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值（忽略前导零）。</li>
<li>字符串中包含有效的浮点格式，如”10.1”，则将其转换为对应的浮点数值（同样忽略前导零）。</li>
<li>字符串中包含有效的十六进制格式，如”0xf”，则将其转换为对应的十进制整数值。</li>
<li>字符串中包含字面量”null”，返回 0。</li>
<li>字符串中包含字面量”undefined”，返回 NaN。</li>
<li>如果字符串是空的（不包含任何字符），则返回 0。</li>
<li>如果字符串中包含除上述情况之外的字符，则返回 NaN。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;Hello world!&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&quot;000011&quot;</span>)); <span class="comment">// 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="literal">false</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。<br>parseInt()函数：parseInt()函数会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()会返回 NaN。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="number">22.5</span>)); <span class="comment">// 22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;070&quot;</span>)); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure></div>
parseInt()函数还可以接受第二个参数，用于指定转换时使用的基数（即多少进制）。如果字符串以”0x”开头，那么基数是 16（十六进制）。如果字符串以”0”开头，那么基数是 8（八进制）。如果字符串以其他任何值开头，那么基数是 10（十进制）。例如：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>)); <span class="comment">// 175</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>)); <span class="comment">// 175</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>)); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></div>
parseFloat()函数：parseFloat()函数用于解析浮点数，但它始终会忽略字符串前面的空格。如果字符串的第一个字符不能转换为数字，parseFloat()会返回 NaN。例如：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>)); <span class="comment">// 22.5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>)); <span class="comment">// 22.34</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-22 日报 Day14</title>
    <url>/undefined/2024-11-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>想，全是问题；做，才有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P18-20 第二章：HTML中的JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、外部js文件和行内代码相比的优势：</p>
<ul>
<li>可维护性：把js代码放在单独的文件中，可以让代码更易于维护。</li>
<li>可缓存：如果js代码在多个页面中使用，浏览器会缓存js文件，从而提高页面加载速度。</li>
<li>适应未来：通过使用外部文件，可以把js和HTML分离，从而提高代码的可维护性和适应未来的能力。<br>2、noscript元素：当浏览器不支持脚本或者禁用脚本时，noscript元素会显示替代内容。noscript元素可以包含任何HTML元素，除了script元素。<br>3、🚀 问题描述: 为什么使用 defer 的 <script> 不一定在 DOMContentLoaded 事件之前执行？<br>理论上: 带有 defer 属性的 <script> 应该在 HTML 解析完成后、DOMContentLoaded 事件触发之前执行。<br>实际中: 有时候会出现 defer 脚本在 DOMContentLoaded 事件之后才执行的情况。<br>⸻</li>
</ul>
<p>💡 原因一: 外部资源加载延迟</p>
<p>defer 属性只保证脚本 按顺序执行，且在 DOM 解析完成后执行，但不保证加载速度。</p>
<p>场景:<br>    •	如果 <script> 的外部资源 (如 CDN 上的 JS 文件) 加载很慢，可能导致脚本在 DOMContentLoaded 之后才执行。<br>    •	尤其是当网络环境较差时，外部资源加载速度直接影响脚本执行时间。</p>
<p>解决方法:<br>    •	确保外部资源的加载速度，例如使用本地缓存或可靠的 CDN。<br>    •	通过设置 Cache-Control 或使用 Service Worker 缓存脚本资源。</p>
<p>⸻</p>
<p>💡 原因二: 解析器阻塞与渲染阻塞</p>
<p>defer 脚本在 DOM 解析完成后执行，但如果有其他原因导致解析器或渲染阻塞，可能延后执行时间。</p>
<p>常见阻塞原因:<br>    1.	样式阻塞:<br>    •	CSS 文件的加载和解析可能阻塞 DOMContentLoaded 事件。<br>    •	如果 CSS 加载时间过长，可能导致 defer 脚本延后执行。<br>    2.	同步脚本阻塞:<br>    •	页面中如果有同步执行的 <script> (未加 async 或 defer)，会阻塞 DOM 解析，进而影响 defer 脚本的执行。</p>
<p>解决方法:<br>    •	使用 <link rel="preload"> 预加载关键 CSS。<br>    •	避免使用同步脚本或放置到页面底部。</p>
<p>⸻</p>
<p>💡 原因三: 异步脚本的干扰 (async vs defer)</p>
<p>async 和 defer 属性的执行顺序不同：<br>    •	async: 脚本加载完成后立即执行，可能在 defer 脚本之前执行。<br>    •	defer: 按顺序执行，且保证在 DOMContentLoaded 前执行。</p>
<p>问题:<br>    •	如果 async 脚本的执行时间过长，可能影响 defer 脚本的执行时间，导致其在 DOMContentLoaded 之后才执行。</p>
<p>解决方法:<br>    •	尽量避免 async 和 defer 混用。<br>    •	或者将 async 用于独立的、不影响 DOM 操作的脚本。</p>
<p>⸻</p>
<p>💡 原因四: 网络延迟与资源优先级<br>    1.	资源优先级:<br>    •	浏览器对脚本、样式、图片等资源有不同的加载优先级。<br>    •	某些资源 (如大图片) 的加载可能会影响 defer 脚本的下载速度，进而延后执行。<br>    2.	HTTP/2 的多路复用:<br>    •	使用 HTTP/2 时，资源加载顺序可能会被优化或调整，导致 defer 脚本的加载时间不确定。</p>
<p>解决方法:<br>    •	使用 <link rel="preload"> 提前加载关键资源。<br>    •	合理配置 CDN 和缓存策略。</p>
<p>⸻</p>
<p>💡 原因五: 浏览器兼容性与差异</p>
<p>不同浏览器对 defer 的支持存在细微差异，尤其是一些旧版本浏览器可能有 Bug:<br>    •	例如，早期的 IE 可能在 defer 执行时机上存在不一致。<br>    •	某些移动浏览器在解析 DOM 时处理 defer 方式不同。</p>
<p>解决方法:<br>    •	使用现代浏览器进行测试，必要时做兼容性处理。<br>    •	可以考虑使用 DOMContentLoaded 事件监听脚本执行情况进行调试。</p>
<p>⸻</p>
<p>🛠️ 总结与建议</p>
<p>原因	解决方法<br>外部资源加载延迟	使用可靠的 CDN 或缓存策略<br>解析器与渲染阻塞	预加载 CSS，避免同步脚本<br>async 与 defer 干扰	尽量避免混用，async 用于独立脚本<br>网络延迟与资源优先级	使用 <link rel="preload"> 和 HTTP/2 优化<br>浏览器兼容性问题	确保在现代浏览器上测试，必要时加条件注释处理</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-21 日报 Day13</title>
    <url>/undefined/2024-11-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>生活的真谛从来都不在别处，就在日常一点一滴的奋斗里。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P14-17 第二章：HTML中的JavaScript</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、推迟执行脚本：defer属性，表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。<br>延迟脚本会在文档解析完毕后，DOMContentLoaded事件触发前执行。这样可以确保脚本在文档解析期间不会对DOM进行操作，从而加快页面加载速度。<br>2、异步执行脚本：async属性，表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。<br>异步脚本不会按照它们在页面中出现的顺序执行，而是在下载完成后立即执行。这种方式对于不需要按照顺序执行的脚本非常有用，比如对页面进行统计分析或加载广告。<br>给脚本添加async属性，可以使脚本异步加载，不会阻塞页面的加载。但是异步脚本不能保证按照它们在页面中出现的顺序执行，所以要谨慎使用。异步脚本保证在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。<br>3、动态加载脚本：可以通过JavaScript动态创建script元素，然后将其添加到页面中。这种方式可以实现按需加载脚本，从而提高页面加载速度。使用预加载器</p>
<link rel="preload" href="example.js" as="script">可以在页面加载时预加载脚本，但不会执行它。]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-25 日报 Day17</title>
    <url>/undefined/2024-11-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>把行动交给现在，把结果交给时间。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P38-47 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、String类型: 表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示，因此下面的代码都是合法的：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Zakas&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">`Hello, <span class="subst">$&#123;firstName&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>字符字面量: 如下表所示:<table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>`</td>
<td>反引号</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制代码nn表示的一个字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>以十六进制代码nnnn表示的一个 Unicode 字符</td>
</tr>
<tr>
<td>2、字符串的特点：变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</td>
<td></td>
</tr>
<tr>
<td>let lang &#x3D; “Java”;</td>
<td></td>
</tr>
<tr>
<td>lang &#x3D; lang + “Script”;</td>
<td></td>
</tr>
<tr>
<td>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如 Firefox 1.0 之前的版本和 IE6.0）在拼接字符串时非常慢的原因。这些浏览器在后来的版本中都有针对性地解决了这个问题</td>
<td></td>
</tr>
<tr>
<td>3、转换为字符串：有三种方法可以把值转换为字符串：toString()、String()和模板字面量。</td>
<td></td>
</tr>
</tbody></table>
</li>
<li>toString()方法: 该方法是所有引用类型中都具有的方法，其基本思想是返回一个表示该对象的字符串。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.<span class="title function_">toString</span>(); <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.<span class="title function_">toString</span>(); <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure></div>
null和undefined值没有toString()方法，如果调用这两个值的这个方法会导致错误。如果不确定一个值是不是null或undefined，可以使用String()转型函数。String()函数遵循如下规则:</li>
<li>如果值有toString()方法，则调用该方法（没有参数）并返回结果。</li>
<li>如果值是null，则返回”null”。</li>
<li>如果值是undefined，则返回”undefined”。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> value4;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value1)); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value2)); <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value3)); <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(value4)); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure></div>
注意 用加号操作符给一个值加上一个空字符串””也可以将其转换为字符串<br>3、模版字面量：ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：<br>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：<br>let pageHTML &#x3D; &#96; <div> 
 <a href="#"> 
 <span>Jake</span> 
 </a> 
</div>`; 
由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：
4、字符串插值：字符串插值通过在${}中使用一个 JavaScript 表达式实现：
`${ value } to the ${ exponent } power is ${ value * value }`
所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义：
将表达式转换为字符串时会调用 toString()：
let foo = { toString: () => 'World' }; 
console.log(`Hello, ${ foo }!`); // Hello, World!
5、模版字面量标签函数：标签函数可以自定义插值行为。标签函数
会接收被插值记号分隔后的模板和对每个表达式求值的结果。
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(strings); <span class="comment">// [&quot;The sum of &quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(aValExpression); <span class="comment">// 6</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(bValExpression); <span class="comment">// 9</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(sumExpression); <span class="comment">// 15</span></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(untaggedResult); <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure></div>
因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleTag</span>(<span class="params">strings, ...expressions</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(strings); </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(expression); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; </span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure></div>
6、原始字符串：使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数：
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unicode示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\u00A9`</span>); <span class="comment">// ©</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`\u00A9`</span>); <span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hello\nWorld`</span>); <span class="comment">// &quot;Hello\nWorld&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printRaw</span>(<span class="params">strings</span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Actual characters:&#x27;</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(string); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Escaped characters;&#x27;</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.<span class="property">raw</span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(rawString); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>; </span><br><span class="line"><span class="comment">// Actual characters: </span></span><br><span class="line"><span class="comment">// © </span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters: </span></span><br><span class="line"><span class="comment">// \u00A9 </span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure></div>
🔹 模板字面量的行为</li>
</ul>
<p>当你使用标签模板时，字符串部分和插值部分是分开的，具体来说：<br>    •	strings 是一个 数组，包含字符串部分。<br>    •	strings.raw 是原始字符串数组，不会对 \u00A9 或 \n 进行转义解析。<br>    •	插值的 ${‘and’} 不会包含在 strings 数组中，而是作为函数的额外参数传递。</p>
<p>⸻</p>
<p>🔹 解析 printRaw\u00A9${ ‘and’ }\n&#96;&#96;</p>
<p>printRaw 函数的实际接收参数是：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">printRaw</span>([<span class="string">&quot;\u00A9&quot;</span>, <span class="string">&quot;\n&quot;</span>], <span class="string">&quot;and&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>参数解析</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">strings = [<span class="string">&quot;\u00A9&quot;</span>, <span class="string">&quot;\n&quot;</span>]; <span class="comment">// 解析后是 [&quot;©&quot;, &quot;\n&quot;]</span></span><br><span class="line">strings.<span class="property">raw</span> = [<span class="string">&quot;\\u00A9&quot;</span>, <span class="string">&quot;\\n&quot;</span>]; <span class="comment">// 原始字符串</span></span><br></pre></td></tr></table></figure></div>
<p>7、Symbol类型：Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。<br>symbol符号的基本使用方法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> sym); <span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建 Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。<br>最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：<br>let myBoolean &#x3D; new Boolean();<br>console.log(typeof myBoolean); &#x2F;&#x2F; “object”<br>let myString &#x3D; new String();<br>console.log(typeof myString); &#x2F;&#x2F; “object”<br>let myNumber &#x3D; new Number();<br>console.log(typeof myNumber); &#x2F;&#x2F; “object”</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 使用全局符号注册表：如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。使用Symbol.for()方法</span><br><span class="line">```javascript</span><br><span class="line">let fooGlobalSymbol = Symbol.for(&#x27;foo&#x27;);</span><br><span class="line">console.log(typeof fooGlobalSymbol); // &quot;symbol&quot;</span><br></pre></td></tr></table></figure></div>
<p>Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>可以使用 Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字<br>符串键。如果查询的不是全局符号，则返回 undefined。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s)); <span class="comment">// foo </span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)); <span class="comment">// undefined </span></span><br><span class="line">如果传给 <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>()的不是符号，则该方法抛出 <span class="title class_">TypeError</span>：</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用符号作为属性：凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()&#x2F;Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>), </span><br><span class="line"> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>), </span><br><span class="line"> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>), </span><br><span class="line"> s4 = <span class="title class_">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> [s1]: <span class="string">&#x27;foo val&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); </span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val&#125; </span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); </span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125; </span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(o, &#123; </span><br><span class="line"> [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;, </span><br><span class="line"> [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); </span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val, </span></span><br><span class="line"><span class="comment">// Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure></div>
类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型<br>的键<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>), </span><br><span class="line"> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> [s1]: <span class="string">&#x27;foo val&#x27;</span>, </span><br><span class="line"> [s2]: <span class="string">&#x27;bar val&#x27;</span>, </span><br><span class="line"> <span class="attr">baz</span>: <span class="string">&#x27;baz val&#x27;</span>, </span><br><span class="line"> <span class="attr">qux</span>: <span class="string">&#x27;qux val&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o)); </span><br><span class="line"><span class="comment">// [Symbol(foo), Symbol(bar)] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o)); </span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(o)); </span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(o)); </span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-28 日报 Day19</title>
    <url>/undefined/2024-11-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>记住，能打败自己的永远只有下一秒的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P56-59 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Object类型：ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>; <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure></div>
<p>2、Object 的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数。对于前面的例子，这个属性的值就是 Object()。</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必題是字符串（如 o.hasOwnProperty(‘name’)）。</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。</li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必題是字符串。</li>
<li>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。<br>3、操作符：数学操作符、位操作符、关系操作符、相等操作符。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和&#x2F;或 toString()方法来取得可以计算的值。<br>4、一元操作符之递增&#x2F;递减操作符：前缀和后缀递增&#x2F;递减操作符。前缀递增&#x2F;递减操作符会在语句被求值之前改变变量的值，而后缀递增&#x2F;递减操作符则是在包含它们的语句被求值之后再改变变量的值。以下例子展示了这两种操作符的区别：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherAge); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2; </span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 21 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num4); <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2; </span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 22 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num4); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></div>
这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。<br> 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。<br> 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。<br> 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。<br> 对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。<br> 对于浮点值，加 1 或减 1。<br> 如果是对象，则调用其（第 5 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。<br>下面的例子演示了这些规则：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="title function_">valueOf</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">s1++; <span class="comment">// 值变成数值 3 </span></span><br><span class="line">s2++; <span class="comment">// 值变成 NaN </span></span><br><span class="line">b++; <span class="comment">// 值变成数值 1 </span></span><br><span class="line">f--; <span class="comment">// 值变成 0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--; <span class="comment">// 值变成-2</span></span><br></pre></td></tr></table></figure></div>
5、一元操作符之加和减: 一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：<br>let num &#x3D; 25;<br>num &#x3D; +num;<br>console.log(num); &#x2F;&#x2F; 25<br>如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和&#x2F;或 toString()方法以得到可以转换的值。<br>下面的例子演示了一元加在应用到不同数据类型时的行为：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> <span class="title function_">valueOf</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">s1 = +s1; <span class="comment">// 值变成数值 1 </span></span><br><span class="line">s2 = +s2; <span class="comment">// 值变成数值 1.1 </span></span><br><span class="line">s3 = +s3; <span class="comment">// 值变成 NaN </span></span><br><span class="line">b = +b; <span class="comment">// 值变成数值 0 </span></span><br><span class="line">f = +f; <span class="comment">// 不变，还是 1.1 </span></span><br><span class="line">o = +o; <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-26 日报 Day18</title>
    <url>/undefined/2024-11-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你自己不放弃，别人才有机会帮你。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P48-54 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。<br>for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。<br>全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。<br>注意 在提到 ECMAScript 规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator 指的就是 Symbol.iterator。<br>2、Symbol.asyncIterator: 根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的 AsyncIterator。由 for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emitter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">max</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">max</span> = max; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">asyncIdx</span> = <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">async</span> *[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">asyncIdx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">asyncIdx</span>++)); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncCount</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>(<span class="number">5</span>); </span><br><span class="line"> <span class="keyword">for</span> <span class="title function_">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">asyncCount</span>(); </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
<p>3、Symbol.hasInstance: 这个符号作为一个属性表示“一个方法，该方法确定一个构造器对象识别的对象是否为其实例”。由instanceof 操作符使用”。instanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。instanceof 的典型使用场景如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f <span class="keyword">instanceof</span> <span class="title class_">Foo</span>); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系。以 Symbol.hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](f)); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Bar</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用。由于 instanceof操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Bar</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>]() &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Baz</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Bar</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Baz</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Baz</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>4、Symbol.isConcatSpreadable: 这个符号作为一个属性表示“一个布尔值，指示对象是否应该展开为数组元素”。这个属性会影响数组的 concat() 方法，如果一个对象的 Symbol.isConcatSpreadable 属性为 true，那么 concat() 方法会展开这个对象，否则会将这个对象作为一个整体添加到数组中。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>]; </span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>]; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(array)); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;] </span></span><br><span class="line">array[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(array)); <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLikeObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;] </span></span><br><span class="line">arrayLikeObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;] </span></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;qux&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(otherObject)); <span class="comment">// [&#x27;foo&#x27;, Set(1)] </span></span><br><span class="line">otherObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(otherObject)); <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure></div>
<p>5、Symbol.iterator: 这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="title function_">constructor</span>(<span class="params">max</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">max</span> = max; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">idx</span> = <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">idx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">idx</span>++; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>(<span class="number">5</span>); </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">count</span>(); </span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
<p>6、Symbol.match: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于匹配字符串”。这个属性会影响 String.prototype.match() 方法，如果一个对象的 Symbol.match 属性为一个函数，那么 match() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">match</span>]); </span><br><span class="line"><span class="comment">// ƒ [Symbol.match]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/bar/</span>)); </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooMatcher</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringMatcher</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">match</span>](target) &#123; </span><br><span class="line"> <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="variable language_">this</span>.<span class="property">str</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>7、Symbol.replace: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于替换字符串”。这个属性会影响 String.prototype.replace() 方法，如果一个对象的 Symbol.replace 属性为一个函数，那么 replace() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">replace</span>]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobarbaz&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooReplacer</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">replace</span>](target, replacement) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="title function_">join</span>(replacement); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">replace</span>(<span class="title class_">FooReplacer</span>, <span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringReplacer</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">replace</span>](target, replacement) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="variable language_">this</span>.<span class="property">str</span>).<span class="title function_">join</span>(replacement); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">StringReplacer</span>(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>)); </span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>8、Symbol.search: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于搜索字符串”。这个属性会影响 String.prototype.search() 方法，如果一个对象的 Symbol.search 属性为一个函数，那么 search() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">search</span>]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooSearcher</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">search</span>](target) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">indexOf</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoo&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringSearcher</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">search</span>](target) &#123; </span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">str</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoo&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>
<p>9、Symbol.species: 这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true </span></span><br><span class="line">bar = bar.<span class="title function_">concat</span>(<span class="string">&#x27;bar&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> <span class="title class_">Baz</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Baz</span>); <span class="comment">// true </span></span><br><span class="line">baz = baz.<span class="title function_">concat</span>(<span class="string">&#x27;baz&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Baz</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>10、Symbol.split: 这个符号作为一个属性表示“一个正则表达式方法，该方法用于拆分字符串”。这个属性会影响 String.prototype.split() 方法，如果一个对象的 Symbol.split 属性为一个函数，那么 split() 方法会调用这个函数，而不是使用正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">split</span>]);</span><br><span class="line"><span class="comment">// ƒ [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobarbaz&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooSplitter</span> &#123; </span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">split</span>](target) &#123; </span><br><span class="line"> <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">split</span>(<span class="title class_">FooSplitter</span>)); </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;] </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringSplitter</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">str</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">str</span> = str; </span><br><span class="line"> &#125; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">split</span>](target) &#123; </span><br><span class="line"> <span class="keyword">return</span> target.<span class="title function_">split</span>(<span class="variable language_">this</span>.<span class="property">str</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">StringSplitter</span>(<span class="string">&#x27;foo&#x27;</span>))); </span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>11、Symbol.toPrimitive: 这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值”。这个属性会影响对象的类型转换，如果一个对象的 Symbol.toPrimitive 属性为一个函数，那么对象会调用这个函数，而不是使用默认的类型转换。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + foo); <span class="comment">// &quot;3[object Object]&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> - foo); <span class="comment">// NaN </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(foo)); <span class="comment">// &quot;[object Object]&quot; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>] = <span class="keyword">function</span>(<span class="params">hint</span>) &#123; </span><br><span class="line">        <span class="keyword">switch</span> (hint) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>: </span><br><span class="line">            <span class="attr">default</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + bar); <span class="comment">// &quot;3default bar&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> - bar); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-27 日报 Day18</title>
    <url>/undefined/2024-11-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>脆弱的人总是有很多借口，但勇者却从不逃走。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P54-55 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Symbol.toStringTag: 用来定制对象的toString方法返回的字符串的标签值。<br>通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Set(0) &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toString</span>()); <span class="comment">// [object Set] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// Set </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// Foo &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()); <span class="comment">// [object Object] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&#x27;Bar&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// Bar &#123;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">toString</span>()); <span class="comment">// [object Bar] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure></div>
<p>2、Symbol.unscopables: 用来定制对象的with语句行为。这个符号作为一个属性表示“一个对象，其自有属性指定了使用 with 语句时要排除的属性”。这个符号的值是一个对象，其属性名指定了在 with 语句中排除的属性。这个符号的值是一个对象，其属性名指定了在 with 语句中排除的属性。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// bar </span></span><br><span class="line">&#125; </span><br><span class="line">o[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>] = &#123; </span><br><span class="line"> <span class="attr">foo</span>: <span class="literal">true</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3、with 是 JavaScript 中的一个语句，用来扩展一个对象的作用域链，临时将一个对象的属性作为当前作用域的变量使用。with 语句的语法如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) </span><br><span class="line"> statement</span><br><span class="line"><span class="keyword">with</span> (object) &#123;</span><br><span class="line">  <span class="comment">// 在这个块中，可以直接访问 object 的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>expression 是一个对象表达式，statement 是一个语句或一个代码块。with 语句的执行过程如下：</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-30 日报 Day21</title>
    <url>/undefined/2024-11-30/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>焦虑不会消除明天的悲伤，它只会消耗今天的力量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P66-70 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、乘性操作符：乘性操作符包括乘法（*）、除法（&#x2F;）和求模（%）。这些操作符都是二元操作符，因为它们都需要两个值。乘法和除法的优先级相等，而求模的优先级略低。在使用多个乘性操作符时，需要注意它们的执行顺序。如果有多个乘性操作符，那么它们的执行顺序是从左到右。例如：<br>2、指数操作符：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> ** <span class="number">3</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">square **= <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></div>
<p>3、加性操作符之加法操作符：<br>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：<br> 如果有任一操作数是 NaN，则返回 NaN；<br> 如果是 Infinity 加 Infinity，则返回 Infinity；<br> 如果是-Infinity 加-Infinity，则返回-Infinity；<br> 如果是 Infinity 加-Infinity，则返回 NaN；<br> 如果是+0 加+0，则返回+0；<br> 如果是-0 加+0，则返回+0；<br> 如果是-0 加-0，则返回-0。<br>不过，如果有一个操作数是字符串，则要应用如下规则：<br> 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；<br> 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。<br>如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。<br>看下面的例子：<br>let result1 &#x3D; 5 + 5; &#x2F;&#x2F; 两个数值<br>console.log(result1); &#x2F;&#x2F; 10<br>let result2 &#x3D; 5 + “5”; &#x2F;&#x2F; 一个数值和一个字符串<br>console.log(result2); &#x2F;&#x2F; “55”<br>以上代码展示了加法操作符的两种运算模式。正常情况下，5 + 5 等于 10（数值），如前两行代码所示。但是，如果将一个操作数改为字符串，比如”5”，则相加的结果就变成了”55”（原始字符串值），因为第一个操作数也会被转换为字符串。<br>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：<br>let num1 &#x3D; 5;<br>let num2 &#x3D; 10;<br>let message &#x3D; “The sum of 5 and 10 is “ + num1 + num2;<br>console.log(message); &#x2F;&#x2F; “The sum of 5 and 10 is 510”<br>4、加性操作符之减法操作符：<br>减法操作符（-）也是使用很频繁的一种操作符，比如：<br>let result &#x3D; 2 - 1;<br>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。<br> 如果两个操作数都是数值，则执行数学减法运算并返回结果。<br> 如果有任一操作数是 NaN，则返回 NaN。<br> 如果是 Infinity 减 Infinity，则返回 NaN。<br> 如果是-Infinity 减-Infinity，则返回 NaN。<br> 如果是 Infinity 减-Infinity，则返回 Infinity。<br> 如果是-Infinity 减 Infinity，则返回-Infinity。<br> 如果是+0 减+0，则返回+0。<br> 如果是+0 减-0，则返回-0。<br> 如果是-0 减-0，则返回+0。<br> 如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转<br>换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是<br>NaN。<br> 如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则<br>减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再<br>将得到的字符串转换为数值。<br>以下示例演示了上面的规则：<br>let result1 &#x3D; 5 - true; &#x2F;&#x2F; true 被转换为 1，所以结果是 4<br>let result2 &#x3D; NaN - 1; &#x2F;&#x2F; NaN<br>let result3 &#x3D; 5 - 3; &#x2F;&#x2F; 2<br>let result4 &#x3D; 5 - “”; &#x2F;&#x2F; “”被转换为 0，所以结果是 5<br>let result5 &#x3D; 5 - “2”; &#x2F;&#x2F; “2”被转换为 2，所以结果是 3<br>let result6 &#x3D; 5 - null; &#x2F;&#x2F; null 被转换为 0，所以结果是 5<br>5、关系操作符：括小于（&lt;）、大于（&gt;）、小于等于（&lt;&#x3D;）和大于等于（&gt;&#x3D;）。这几个操作符都返回布尔值，用于比较两个值的大小关系。在比较两个值时，会遵循如下规则：<br> 如果两个操作数都是数值，则执行数值比较。<br> 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。<br> 如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较。<br> 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执行比较。如果没有 valueOf()方法，则调用 toString()方法，并按照前面的规则执行比较。<br> 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。<br>5、关系操作符：小于（&lt;）、大于（&gt;）、小于等于（&lt;&#x3D;）和大于等于（&gt;&#x3D;）。这几个操作符都返回布尔值，用于比较两个值的大小关系。与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。<br> 如果操作数都是数值，则执行数值比较。<br> 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。<br> 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。<br> 如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。<br>如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。<br> 如果有任一操作数是布尔值，则将其转换为数值再执行比较。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>
<p>因为字符”a”不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即任何关系操作符在涉及比较 NaN 时都返回 false。这样一来，下面的例子有趣了：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="title class_">NaN</span> &lt; <span class="number">3</span>; <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title class_">NaN</span> &gt;= <span class="number">3</span>; <span class="comment">// false </span></span><br></pre></td></tr></table></figure></div>
<p>在大多数比较的场景中，如果一个值不小于另一个值，那就一定大于或等于它。但在比较 NaN 时，无论是小于还是大于等于，比较的结果都会返回 false。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-29 日报 Day20</title>
    <url>/undefined/2024-11-29/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>躲起来的星星也在努力发光，你也要加油。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P60-65 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、位操作符: ECMAScript<br>中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑 32 位整数即可。<br>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。<br>负值是以补码形式存储的，即数值的绝对值的二进制形式取反后加 1。例如，-18 的二进制形式是 00000000 00000000 00000000 00010010，取反后是 11111111 11111111 11111111 11101101，加 1 后是 11111111 11111111 11111111 11101110。<br>2、按位非~</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>; <span class="comment">// 二进制 00000000000000000000000000011001 </span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1; <span class="comment">// 二进制 11111111111111111111111111100110 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num2); <span class="comment">// -26</span></span><br></pre></td></tr></table></figure></div>
<p>这里，按位非操作符作用到了数值 25，得到的结果是26。由此可以看出，按位非的最终效果是对<br>数值取反并减 1，就像执行如下操作的结果一样：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>; </span><br><span class="line"><span class="keyword">let</span> num2 = -num1 - <span class="number">1</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num2); <span class="comment">// &quot;-26&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>3、按位与&amp;、按位或|、按位异或^、左移&lt;&lt;、有符号右移&gt;&gt;、无符号右移&gt;&gt;&gt;。有符号右移由两个大于号（&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。无符号右移由三个大于号（&gt;&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时用 0 填充最高位。<br>4、布尔操作符：逻辑非!、逻辑与&amp;&amp;、逻辑或||。<br>逻辑非操作符会遵循如下规则。<br> 如果操作数是对象，则返回 false。<br> 如果操作数是空字符串，则返回 true。<br> 如果操作数是非空字符串，则返回 false。<br> 如果操作数是数值 0，则返回 true。<br> 如果操作数是非 0 数值（包括 Infinity），则返回 false。<br> 如果操作数是 null，则返回 true。<br> 如果操作数是 NaN，则返回 true。<br> 如果操作数是 undefined，则返回 true。<br>以下示例验证了上述行为：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="literal">false</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="string">&quot;blue&quot;</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="number">0</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="title class_">NaN</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="string">&quot;&quot;</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!<span class="number">12345</span>); <span class="comment">// false </span></span><br></pre></td></tr></table></figure></div>
<p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="string">&quot;blue&quot;</span>); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="number">0</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="title class_">NaN</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="string">&quot;&quot;</span>); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!<span class="number">12345</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值，如下所示：<br>let result &#x3D; true &amp;&amp; false;<br>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不<br>一定会返回布尔值，而是遵循如下规则。<br> 如果第一个操作数是对象，则返回第二个操作数。<br> 如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。<br> 如果两个操作数都是对象，则返回第二个操作数。<br> 如果有一个操作数是 null，则返回 null。<br> 如果有一个操作数是 NaN，则返回 NaN。<br> 如果有一个操作数是 undefined，则返回 undefined。<br>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个<br>操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结<br>果也不可能等于 true。看下面的例子：<br>let found &#x3D; true;<br>let result &#x3D; (found &amp;&amp; someUndeclaredVariable); &#x2F;&#x2F; 这里会出错<br>console.log(result); &#x2F;&#x2F; 不会执行这一行<br>上面的代码之所以会出错，是因为 someUndeclaredVariable 没有事先声明，所以当逻辑与操作符对它求值时就会报错。变量 found 的值是 true，逻辑与操作符会继续求值变量 someUndeclaredVariable。<br>但是由于 someUndeclaredVariable 没有定义，不能对它应用逻辑与操作符，因此就报错了。假如变量 found 的值是 false，那么就不会报错了：<br>let found &#x3D; false;<br>let result &#x3D; (found &amp;&amp; someUndeclaredVariable); &#x2F;&#x2F; 不会出错<br>console.log(result); &#x2F;&#x2F; 会执行这里，console.log 会成功执行。即使变量 someUndeclaredVariable 没有定义，由于第一个操作数是 false，逻辑与操作符也不会对它求值，因为此时对&amp;&amp;右边的操作数求值是没有意义的。在使用逻辑与操作符时，一定别忘了它的这个短路的特性。<br>逻辑或操作符由两个竖线（||）表示，应用到两个值，如下所示：<br>let result &#x3D; true || false;<br>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则。<br> 如果第一个操作数是对象，则返回第一个操作数。<br> 如果第一个操作数求值为 false，则返回第二个操作数。<br> 如果两个操作数都是对象，则返回第一个操作数。<br> 如果两个操作数都是 null，则返回 null。<br> 如果两个操作数都是 NaN，则返回 NaN。<br> 如果两个操作数都是 undefined，则返回 undefined。<br>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。看下面的例子：<br>let found &#x3D; true;<br>let result &#x3D; (found || someUndeclaredVariable); &#x2F;&#x2F; 不会出错<br>console.log(result); &#x2F;&#x2F; 会执行<br>跟前面的例子一样，变量 someUndeclaredVariable 也没有定义。但是，因为变量 found 的值为 true，所以逻辑或操作符不会对变量 someUndeclaredVariable 求值，而直接返回 true。假如把<br>found 的值改为 false，那就会报错了：<br>let found &#x3D; false;<br>let result &#x3D; (found || someUndeclaredVariable); &#x2F;&#x2F; 这里会出错<br>console.log(result); &#x2F;&#x2F; 不会执行这一行<br>利用这个行为，可以避免给变量赋值 null 或 undefined。比如：<br>let myObject &#x3D; preferredObject || backupObject;</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-9 日报 Day1</title>
    <url>/undefined/2024-11-9/</url>
    <content><![CDATA[<h2 id="写在本类目的最前面"><a href="#写在本类目的最前面" class="headerlink" title="写在本类目的最前面"></a>写在本类目的最前面</h2><p>   不知道以什么开始，就以最近看到的《我与地坛》中的一句话作为本类目的开头吧：</p>
<blockquote>
<p>但是太阳，它每时每刻都是夕阳也都是旭日。当它熄灭着走下山去收尽苍凉残照之际，正是它在另一面燃烧着爬上山巅布散烈烈朝晖之时。<br>那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。<br>当然，那不是我。<br>但是，那不是我吗？</p>
</blockquote>
<h3 id="今天的思考"><a href="#今天的思考" class="headerlink" title="今天的思考"></a>今天的思考</h3><pre><code>不满足于当前的苟且，却又无能为力改变现状。何以破局，唯有涅槃重生。所以从今天开始从最基本的知识学起，每日保持不间断的更新，去到自己想要去到的高度。
</code></pre>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《网络是怎样连接的》 P1 - P12
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>URL协议标识符如HTTP、HTTPS、FTP等，是用来标识资源的协议的。URL的格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://host:port/path?query#fragment</span><br></pre></td></tr></table></figure></div>

<ul>
<li>scheme：协议标识符，如HTTP、HTTPS、FTP等</li>
</ul>
<p>native上还有一些特殊的scheme，如：</p>
<ul>
<li>tell：用于电话号码</li>
<li>sms：用于短信</li>
<li>mailto：用于发送邮件</li>
<li>geo：用于地理位置</li>
<li>AppName：用于调起App</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-11 日报 Day32</title>
    <url>/undefined/2024-12-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>世间从不缺少辉煌的花冠，缺少的是不被花冠晕染的淡定。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P106-112
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、构建数据集合</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2、集合的一些基本方法</p>
<ul>
<li>add(value)：向集合添加一个新的项。</li>
<li>delete(value)：从集合移除一个值。</li>
<li>has(value)：如果值在集合中，返回true，否则返回false。</li>
<li>clear()：移除集合中的所有项。</li>
<li>size()：返回集合所包含元素的数量。与数组的length属性类似。</li>
<li>values()：返回一个包含集合中所有值的数组。<br>3、集合的实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="comment">// this.has = function(value)&#123;</span></span><br><span class="line">    <span class="comment">//     return value in items;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">has</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="title function_">hasOwnProperty</span>(value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">            items[value] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(value))&#123;</span><br><span class="line">            <span class="keyword">delete</span> items[value];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> values = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(items); i &lt; keys.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            values.<span class="title function_">push</span>(items[keys[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
4、集合操作</li>
<li>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</li>
<li>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</li>
<li>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</li>
<li>子集：验证一个集合是否是另一个集合的子集。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-12 日报 Day33</title>
    <url>/undefined/2024-12-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>莫道春光难揽取，浮云过后艳阳天。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P113-160
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、集合并集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">union</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> unionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    values = otherSet.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unionAB = setA.<span class="title function_">union</span>(setB);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unionAB.<span class="title function_">values</span>());</span><br></pre></td></tr></table></figure></div>

<p>2、集合交集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">intersection</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">            intersectionSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intersectionAB = setA.<span class="title function_">intersection</span>(setB);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(intersectionAB.<span class="title function_">values</span>());</span><br></pre></td></tr></table></figure></div>

<p>3、集合差集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">difference</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> differenceSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">            differenceSet.<span class="title function_">add</span>(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> differenceAB = setA.<span class="title function_">difference</span>(setB);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(differenceAB.<span class="title function_">values</span>());</span><br></pre></td></tr></table></figure></div>

<p>4、集合子集</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">subset</span> = <span class="keyword">function</span>(<span class="params">otherSet</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">size</span>() &gt; otherSet.<span class="title function_">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> values = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; values.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!otherSet.<span class="title function_">has</span>(values[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setA = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setA.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setB = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setB.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> setC = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">setC.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">setC.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">setC.<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(setA.<span class="title function_">subset</span>(setB));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(setA.<span class="title function_">subset</span>(setC));</span><br></pre></td></tr></table></figure></div>
<p>5、ES6中的集合。ES6的Set的values方法返回的是Iterator对象，可以使用for…of循环遍历。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>6、使用ES6的Set实现数组去重</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...set]);</span><br></pre></td></tr></table></figure></div>
<p>7、字典和散列表<br>ES6中字典为Map,散列表为HashMap。<br>一般字典需要包含的方法：</p>
<ul>
<li>set(key, value)：向字典中添加新元素。</li>
<li>delete(key)：通过使用键值来从字典中移除键值对应的数据值。</li>
<li>has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。</li>
<li>get(key)：通过键值查找特定的数值并返回。</li>
<li>clear()：将这个字典中的所有元素全部删除。</li>
<li>size()：返回字典所包含元素的数量。与数组的length属性类似。</li>
<li>keys()：将字典所包含的所有键名以数组形式返回。</li>
<li>values()：将字典所包含的所有数值以数组形式返回。<br>8、方法实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dictionary</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">has</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> items;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">set</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">        items[key] = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">delete</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(key))&#123;</span><br><span class="line">            <span class="keyword">delete</span> items[key];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? items[key] : <span class="literal">undefined</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">values</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> values = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> items)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">has</span>(k))&#123;</span><br><span class="line">                values.<span class="title function_">push</span>(items[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clear</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items).<span class="property">length</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(items);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getItems</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dictionary = <span class="keyword">new</span> <span class="title class_">Dictionary</span>();</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">dictionary.<span class="title function_">set</span>(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">has</span>(<span class="string">&#x27;Gandalf&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">size</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">keys</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dictionary.<span class="title function_">get</span>(<span class="string">&#x27;John&#x27;</span>));</span><br></pre></td></tr></table></figure></div>
9、散列表<br>散列算法的作用是尽可能快地在数据结构中找到一个值。在散列表中插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下。最简单的散列方法是简单地将每个键值中的每个字母的ASCII值相加。<br>三个基本的方法:</li>
<li>put(key, value)：向散列表增加一个新的项（也能更新散列表）。</li>
<li>remove(key)：根据键值从散列表中移除值。</li>
<li>get(key)：返回根据键值检索到的特定的值。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HashTable</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> table = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
10、散列函数<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">loseloseHashCode</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        hash += key.<span class="title function_">charCodeAt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
11、基本方法实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(position + <span class="string">&#x27; - &#x27;</span> + key);</span><br><span class="line">    table[position] = value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> table[<span class="title function_">loseloseHashCode</span>(key)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    table[<span class="title function_">loseloseHashCode</span>(key)] = <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
12、测试<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hash = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;gandalf@email.com&#x27;</span>);</span><br><span class="line">hash.<span class="title function_">put</span>(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;johnsnow@email.com&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash.<span class="title function_">get</span>(<span class="string">&#x27;Gandalf&#x27;</span>));</span><br></pre></td></tr></table></figure></div>
13、散列冲突<br>一些键会有相同的散列值,不同的值在散列表中对应相同的位置，这种现象称为散列冲突。解决冲突的方法有两种：分离链接、线性探查和双散列法。</li>
<li>分离链接: 散列表的每一个位置创建一个链表并将元素存储在里面。但是其在HashTable实例之外还需要额外的存储空间。<br>其需要重写三个方法: put、get、remove。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(table[position] == <span class="literal">undefined</span>)&#123;</span><br><span class="line">        table[position] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    table[position].<span class="title function_">append</span>(<span class="keyword">new</span> <span class="title class_">ValuePair</span>(key, value));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> current = table[position].<span class="title function_">getHead</span>();</span><br><span class="line">        <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">                <span class="keyword">return</span> current.<span class="property">element</span>.<span class="property">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">element</span>.<span class="property">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> current = table[position].<span class="title function_">getHead</span>();</span><br><span class="line">        <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">                table[position].<span class="title function_">remove</span>(current.<span class="property">element</span>);</span><br><span class="line">                <span class="keyword">if</span>(table[position].<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">                    table[position] = <span class="literal">undefined</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current.<span class="property">element</span>.<span class="property">key</span> === key)&#123;</span><br><span class="line">            table[position].<span class="title function_">remove</span>(current.<span class="property">element</span>);</span><br><span class="line">            <span class="keyword">if</span>(table[position].<span class="title function_">isEmpty</span>())&#123;</span><br><span class="line">                table[position] = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
14、线性探查<br>当发生冲突时，线性探查会检查散列表中的下一个位置是否为空。如果为空，就将数据存入。如果不为空，就继续检查下一个位置。直到找到一个空的位置。<br>统一需要重写put、get、remove方法<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(table[position] == <span class="literal">undefined</span>)&#123;</span><br><span class="line">        table[position] = <span class="keyword">new</span> <span class="title class_">ValuePair</span>(key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index = ++position;</span><br><span class="line">        <span class="keyword">while</span>(table[index] != <span class="literal">undefined</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = <span class="keyword">new</span> <span class="title class_">ValuePair</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table[position].<span class="property">key</span> === key)&#123;</span><br><span class="line">            <span class="keyword">return</span> table[position].<span class="property">value</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> index = ++position;</span><br><span class="line">            <span class="keyword">while</span>(table[index] === <span class="literal">undefined</span> || table[index].<span class="property">key</span> !== key)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(table[index].<span class="property">key</span> === key)&#123;</span><br><span class="line">                <span class="keyword">return</span> table[index].<span class="property">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="title function_">loseloseHashCode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(table[position] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table[position].<span class="property">key</span> === key)&#123;</span><br><span class="line">            table[position] = <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> index = ++position;</span><br><span class="line">            <span class="keyword">while</span>(table[index] === <span class="literal">undefined</span> || table[index].<span class="property">key</span> !== key)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(table[index].<span class="property">key</span> === key)&#123;</span><br><span class="line">                table[index] = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
15、树<br>非顺序数据结构–树。树是一种非线性数据结构，以分层的方式存储数据。树的第一个节点叫做根节点。树的最大层级叫做树的深度。<br>二叉树和二叉搜索树(BST, Binary Search Tree):二叉树的每个节点最多只能有两个子节点：左侧子节点和右侧子节点;二叉搜索树是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BinarySearchTree</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
树类中需要实现的方法有：</li>
<li>insert(key)：向树中插入一个新的键。</li>
<li>search(key)：在树中查找一个键。如果节点存在，则返回true；如果不存在，则返回false。</li>
<li>inOrderTraverse()：通过中序遍历方式遍历所有节点。</li>
<li>preOrderTraverse()：通过先序遍历方式遍历所有节点。</li>
<li>postOrderTraverse()：通过后序遍历方式遍历所有节点。</li>
<li>min()：返回树中最小的值&#x2F;键。</li>
<li>max()：返回树中最大的值&#x2F;键。</li>
<li>remove(key)：从树中移除某个键。<br>16、方法实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">key</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">insertNode</span>(root, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> insertNode = <span class="keyword">function</span>(<span class="params">node, newNode</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newNode.<span class="property">key</span> &lt; node.<span class="property">key</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">            node.<span class="property">left</span> = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">insertNode</span>(node.<span class="property">left</span>, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">            node.<span class="property">right</span> = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">insertNode</span>(node.<span class="property">right</span>, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
17、树的遍历: 中序、先序、后序<br>采用访问者模式，将回调函数作为参数传入遍历方法中。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">inOrderTraverse</span> = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="title function_">inOrderTraverseNode</span>(root, callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inOrderTraverseNode = <span class="keyword">function</span>(<span class="params">node, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">inOrderTraverseNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line">        <span class="title function_">callback</span>(node.<span class="property">key</span>);</span><br><span class="line">        <span class="title function_">inOrderTraverseNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">preOrderTraverse</span> = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="title function_">preOrderTraverseNode</span>(root, callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> preOrderTraverseNode = <span class="keyword">function</span>(<span class="params">node, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">callback</span>(node.<span class="property">key</span>);</span><br><span class="line">        <span class="title function_">preOrderTraverseNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line">        <span class="title function_">preOrderTraverseNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">postOrderTraverse</span> = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="title function_">postOrderTraverseNode</span>(root, callback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> postOrderTraverseNode = <span class="keyword">function</span>(<span class="params">node, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">postOrderTraverseNode</span>(node.<span class="property">left</span>, callback);</span><br><span class="line">        <span class="title function_">postOrderTraverseNode</span>(node.<span class="property">right</span>, callback);</span><br><span class="line">        <span class="title function_">callback</span>(node.<span class="property">key</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
18、自平衡树(Adelson-Velskii-Landi, AVL)<br>AVL树是最先发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1。AVL树是一种自平衡二叉查找树，任一节点对应的两棵子树的最大高度差为1。<br>19、红黑树: 红黑树是一种自平衡二叉查找树，它在每个节点上增加了存储位来表示节点的颜色，可以是红色或黑色。通过对任何一条从根到叶子的路径上各个节点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出两倍，因此是接近平衡的。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-1 日报 Day22</title>
    <url>/undefined/2024-12-1/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>愿你拥有坚如磐石的信念，还有无问西东的勇气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P71-72 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、相等操作符：ECMAScript提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换。<br>2、等于和不等于（&#x3D;&#x3D;和!&#x3D;）：<br>ECMAScript 中的等于操作符用两个等于号（&#x3D;&#x3D;）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!&#x3D;）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。<br>在转换操作数的类型时，相等和不相等操作符遵循如下规则。<br> 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。<br> 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。<br> 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。<br>在进行比较时，这两个操作符会遵循如下规则。<br> null 和 undefined 相等。<br> null 和 undefined 不能转换为其他类型的值再进行比较。<br> 如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。<br> 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。<br>下表总结了一些特殊情况及比较的结果：</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">null &#x3D;&#x3D; undefined</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“NaN” &#x3D;&#x3D; NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">5 &#x3D;&#x3D; NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN &#x3D;&#x3D; NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN !&#x3D; NaN</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false &#x3D;&#x3D; 0</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true &#x3D;&#x3D; 1</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true &#x3D;&#x3D; 2</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">undefined &#x3D;&#x3D; 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">null &#x3D;&#x3D; 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">“5” &#x3D;&#x3D; 5</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">3、全等和不全等（&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;）：全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（&#x3D;&#x3D;&#x3D;）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let result1 &#x3D; (“55” &#x3D;&#x3D; 55); &#x2F;&#x2F; true，转换后相等</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let result2 &#x3D; (“55” &#x3D;&#x3D;&#x3D; 55); &#x2F;&#x2F; false，不相等，因为数据类型不同</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4、条件操作符：variable &#x3D; boolean_expression ? true_value : false_value;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5、赋值操作符：赋值操作符用于给变量赋值。赋值操作符由等于号（&#x3D;）表示，它将右侧的值赋给左侧的变量。赋值操作符的右侧可以是任何类型的值，包括变量、常量、表达式等。赋值操作符的右侧可以是任何类型的值，包括变量、常量、表达式等。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">复合赋值操作符：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 乘后赋值（*&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 除后赋值（&#x2F;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 取模后赋值（%&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 加后赋值（+&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 减后赋值（-&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 左移后赋值（&lt;&lt;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 右移后赋值（&gt;&gt;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> 无符号右移后赋值（&gt;&gt;&gt;&#x3D;）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这些操作符仅仅是简写语法，使用它们不会提升性能。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6、逗号操作符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">逗号操作符可以用来在一条语句中执行多个操作，如下所示：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let num1 &#x3D; 1, num2 &#x3D; 2, num3 &#x3D; 3;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let num &#x3D; (5, 1, 4, 8, 0); &#x2F;&#x2F; num 的值为 0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-14 日报 Day35</title>
    <url>/undefined/2024-12-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>成年人的生活,万般皆苦,唯有自渡,<br>活着就要遇山开山,见水架桥,<br>其实一直陪着你的永远都是那个了不起<br>的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P167-169
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、图的遍历<br>和树数据结构类似，图的遍历也有两种算法：广度优先搜索（BFS）和深度优先搜索（DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径、检查图是否连通、检查图是否含有环等。<br>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探<br>索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。<br>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点<br>列表的数据结构。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>深度优先搜索</td>
<td>栈</td>
<td>通过将顶点存入栈中（在第3章中学习过），顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td>
</tr>
<tr>
<td>广度优先搜索</td>
<td>队列</td>
<td>通过将顶点存入队列中（在第4章中学习过），最先入队列的顶点先被探索</td>
</tr>
</tbody></table>
<p>当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。</p>
<p> 白色：表示该顶点还没有被访问。</p>
<p> 灰色：表示该顶点被访问过，但并未被探索过。</p>
<p> 黑色：表示该顶点被访问过且被完全探索过。<br>2、广度优先搜索<br>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。<br>3、深度优先搜索<br>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶<br>点被访问了，接着原路回退并探索下一条路径。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-13 日报 Day34</title>
    <url>/undefined/2024-12-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>少欲则心静，心静则事简，只有这样方能够挣脱繁华虚妄的羁绊，拥抱明确而简单的生活。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P161-166
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、非线形数据结构-图。图是由一组由边连接的节点(或顶点)。<br>图由G&#x3D;(V,E)组成，其中V是顶点的集合，E是边的集合。<br>由一条边连接在一起的顶点称为相邻顶点。<br>一个顶点的度是其相邻顶点的数量。<br>路径是顶点v1,v2,…,vk的一个连续序列，其中vi和vi+1是相邻的。<br>简单路径要求不包含重复的顶点。<br>图分为有向图和无向图。图还可以是加权的或非加权的。<br>2、图的表示: 从数据结构上来说可以用多种方式来表示图，不存在绝对的正确表示方法，取决于待解决的问题和图的类型。</p>
<ul>
<li>邻接矩阵: 二维数组，其中的元素表示两个顶点之间是否有一条边。如果索引为i的节点和索引为j的节点相邻，则matrix[i][j]为1，否则为0。</li>
<li>邻接表: 用列表(数组)、链表，甚至是散列表或是字典来表示相邻顶点列表。</li>
<li>关联矩阵: 二维数组，其中的元素表示顶点和边的关系。行表示顶点，列表示边，元素表示顶点和边的关系。可以使用二维数组来表示两者之间的连通性，<br>如果顶点v是边e的入射点，则array[v][e]为1，否则为0。关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。<br>3、创建Graph类<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Graph</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> vertices = [];</span><br><span class="line">  <span class="keyword">var</span> adjList = <span class="keyword">new</span> <span class="title class_">Dictionary</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
其中vertices数组用来存储图中所有顶点的名字，adjList用来存储邻接表。图类需要实现三个方法:</li>
<li>addVertex: 向图中添加一个新的顶点。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">addVertex</span> = <span class="keyword">function</span>(<span class="params">v</span>)&#123;</span><br><span class="line">  vertices.<span class="title function_">push</span>(v);</span><br><span class="line">  adjList.<span class="title function_">set</span>(v, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>addEdge: 添加一条边。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">addEdge</span> = <span class="keyword">function</span>(<span class="params">v, w</span>)&#123;</span><br><span class="line">  adjList.<span class="title function_">get</span>(v).<span class="title function_">push</span>(w);</span><br><span class="line">  adjList.<span class="title function_">get</span>(w).<span class="title function_">push</span>(v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>toString: 输出图的顶点和邻接表。</li>
</ul>
<pre><code class="javascript">this.toString = function()&#123;
  var s = &#39;&#39;;
  for(var i=0; i&lt;vertices.length; i++)&#123;
    s += vertices[i] + &#39; -&gt; &#39;;
    var neighbors = adjList.get(vertices[i]);
    for(var j=0; j&lt;neighbors.length; j++)&#123;
      s += neighbors[j] + &#39; &#39;;
    &#125;
    s += &#39;\n&#39;;
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-10 日报 Day31</title>
    <url>/undefined/2024-12-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>山不让尘，<br>川不辞盈。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>最近已经要求开始写大论文了，所以学习的时间会减少，但是我会尽量保持每天的学习时间，不会放弃的。<br>    1、《JavaScript数据结构与算法》 P93-105</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、链表简单实现</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">append</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head === <span class="literal">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">                current = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current.<span class="property">next</span> = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">position, element</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(positio &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">            current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">          node.<span class="property">next</span> = current;</span><br><span class="line">          head = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = current.<span class="property">next</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          node.<span class="property">next</span> = current;</span><br><span class="line">          previous.<span class="property">next</span> = node;</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length)&#123;</span><br><span class="line">            <span class="keyword">let</span> current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">                head = current.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.<span class="property">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previous.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">element</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(element);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> current = head,</span><br><span class="line">          index = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        <span class="keyword">if</span>(element === current.<span class="property">element</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        current = current.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.isEmpty = function()&#123;</span></span><br><span class="line"><span class="string">      return length === 0;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.size = function()&#123;</span></span><br><span class="line"><span class="string">      return length;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.getHead = function()&#123;</span></span><br><span class="line"><span class="string">      return head;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.toString = function()&#123;</span></span><br><span class="line"><span class="string">      let current = head;</span></span><br><span class="line"><span class="string">      string = &#x27;</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string">      while(current)&#123;</span></span><br><span class="line"><span class="string">        string += current.element + (current.next ? &#x27;</span>n<span class="string">&#x27;: &#x27;</span><span class="string">&#x27;);</span></span><br><span class="line"><span class="string">        current = current.next;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      return string;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    this.print = function()&#123;&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>2、双向链表: 双向链表和普通链表的区别在于，双向链表的节点有两个指针，一个指向前一个节点，一个指向后一个节点。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DoublyLinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> tail = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里是方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3、循环链表: 循环链表和链表的区别在于，链表的最后一个节点指向null，而循环链表的最后一个节点指向第一个节点。<br>4、双向循环链表有指向head元素的tail.next,和指向tail元素的head.prev。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-17 日报 Day38</title>
    <url>/undefined/2024-12-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你今天的一言一行，都是在为以后的成功谋篇布局。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P99-102 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、内存泄露：在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。<br>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。<br>定时器也会导致内存泄露。下面的代码中，定时器的回调通过闭包引用了外部变量：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name); </span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></div>
<p>只要定时器一直运行，回调函数中引用的 name 就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。<br>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏。请看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line"> &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>2、静态分配与对象池：为了提升 JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。<br>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运<br>行。下面是一个对象池的伪实现：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vectorPool 是已有的对象池 </span></span><br><span class="line"><span class="keyword">let</span> v1 = vectorPool.<span class="title function_">allocate</span>(); </span><br><span class="line"><span class="keyword">let</span> v2 = vectorPool.<span class="title function_">allocate</span>(); </span><br><span class="line"><span class="keyword">let</span> v3 = vectorPool.<span class="title function_">allocate</span>(); </span><br><span class="line">v1.<span class="property">x</span> = <span class="number">10</span>; </span><br><span class="line">v1.<span class="property">y</span> = <span class="number">5</span>; </span><br><span class="line">v2.<span class="property">x</span> = -<span class="number">3</span>; </span><br><span class="line">v2.<span class="property">y</span> = -<span class="number">6</span>; </span><br><span class="line"><span class="title function_">addVector</span>(v1, v2, v3); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([v3.<span class="property">x</span>, v3.<span class="property">y</span>]); <span class="comment">// [7, -1] </span></span><br><span class="line">vectorPool.<span class="title function_">free</span>(v1); </span><br><span class="line">vectorPool.<span class="title function_">free</span>(v2); </span><br><span class="line">vectorPool.<span class="title function_">free</span>(v3); </span><br><span class="line"><span class="comment">// 如果对象有属性引用了其他对象</span></span><br><span class="line"><span class="comment">// 则这里也需要把这些属性设置为 null </span></span><br><span class="line">v1 = <span class="literal">null</span>; </span><br><span class="line">v2 = <span class="literal">null</span>; </span><br><span class="line">v3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>
<p>3、小结:  JavaScript 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始数据类型之一：Undefined、Null、Boolean、Number、String 和 Symbol。原始值和引用值有以下特点。<br> 原始值大小固定，因此保存在栈内存上。<br> 从一个变量到另一个变量复制原始值会创建该值的第二个副本。<br> 引用值是对象，存储在堆内存上。<br> 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。<br> 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。<br> typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。<br>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。<br> 执行上下文分全局上下文、函数上下文和块级上下文。<br> 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。<br> 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。<br> 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。<br> 变量的执行上下文用于确定什么时候释放内存。<br>JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收程序可以总结如下。<br> 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。<br> 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。<br> 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）。<br> 引用计数在代码中存在循环引用时会出现问题。<br> 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-15 日报 Day36</title>
    <url>/undefined/2024-12-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>且以青春赴山海,<br>青舟无惧万重山。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P170-174
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、排序和搜索算法</p>
<ul>
<li><p>排序算法</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>计数排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
</li>
<li><p>搜索算法</p>
<ul>
<li>顺序搜索</li>
<li>二分搜索</li>
<li>插值搜索</li>
<li>斐波那契搜索</li>
<li>二叉树搜索</li>
<li>散列算法<br>2、排序算法: 排序算法是一种算法，用于将一组元素按照一定的顺序排列。在开始排序算法之前，先创建一个数组来表示待排序和搜索的数据结构。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ArrayList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">        array.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array.<span class="title function_">join</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
2、冒泡排序<br>冒泡排序是排序算法中最简单的但是从运行时间的角度来看，冒泡排序是最差的一个。<br>冒泡排序算法的原理如下:</li>
</ul>
</li>
</ul>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">bubbleSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="title function_">swap</span>(j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> swap = <span class="keyword">function</span>(<span class="params">index1, index2</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> aux = array[index1];</span><br><span class="line">    array[index1] = array[index2];</span><br><span class="line">    array[index2] = aux;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
冒泡排序的时间复杂度是O(n2)。<br>3、选择排序<br>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放在第一位，接着找到第二小的值并将其放在第二位，以此类推。<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">selectionSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.<span class="property">length</span>,</span><br><span class="line">        indexMin;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        indexMin = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i; j&lt;length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[indexMin] &gt; array[j])&#123;</span><br><span class="line">                indexMin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i !== indexMin)&#123;</span><br><span class="line">            <span class="title function_">swap</span>(i, indexMin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
选择排序同样也是一个复杂度为O(n2)的算法。</li>
</ol>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-18 日报 Day39</title>
    <url>/undefined/2024-12-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在哪里付出，就在哪里得到；在哪里打磨，就在哪里闪耀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P103-108 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数，比如下面这行代码：let now &#x3D; new Date();函数也是一种引用类型。<br>2、Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。要创建日期对象，就使用 new 操作符来调用 Date 构造函数：<br>let now &#x3D; new Date();<br>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262 第 5 版定义了 Date.parse()应该支持的日期格式，填充了第 3 版遗留的空白。所有实现都必须支持下列日期格式：<br>“月&#x2F;日&#x2F;年”，如”5&#x2F;23&#x2F;2019”；<br>“月名 日, 年”，如”May 23, 2019”；<br>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”；<br> ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现）。<br>比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：<br>let someDate &#x3D; new Date(Date.parse(“May 23, 2019”));<br>如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：<br>let someDate &#x3D; new Date(“May 23, 2019”);<br>这两行代码得到的日期对象相同。<br>Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：<br>&#x2F;&#x2F; GMT 时间 2000 年 1 月 1 日零点<br>let y2k &#x3D; new Date(Date.UTC(2000, 0));<br>&#x2F;&#x2F; GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒<br>let allFives &#x3D; new Date(Date.UTC(2005, 4, 5, 17, 55, 55));<br>ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：<br>&#x2F;&#x2F; 起始时间<br>let start &#x3D; Date.now();<br>&#x2F;&#x2F; 调用函数<br>doSomething();<br>&#x2F;&#x2F; 结束时间<br>let stop &#x3D; Date.now(),<br>result &#x3D; stop - start;<br>3、继承的方式：Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的2019 年 2 月 1 日零点的示例（地区为”en-US”的 PST，即 Pacific Standard Time，太平洋标准时间）：<br>toLocaleString() - 2&#x2F;1&#x2F;2019 12:00:00 AM<br>toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)<br>现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着 toLocaleString()和 toString()可能只对调试有用，不能用于显示。<br>Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：<br>let date1 &#x3D; new Date(2019, 0, 1); &#x2F;&#x2F; 2019 年 1 月 1 日<br>let date2 &#x3D; new Date(2019, 1, 1); &#x2F;&#x2F; 2019 年 2 月 1 日<br>console.log(date1 &lt; date2); &#x2F;&#x2F; true<br>console.log(date1 &gt; date2); &#x2F;&#x2F; false<br>4、日期格式化方法：<br>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：<br> toDateString()显示日期中的周几、月、日、年（格式特定于实现）；<br> toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；<br> toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；<br> toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；<br> toUTCString()显示完整的 UTC 日期（格式特定于实现）。<br>5、日期&#x2F;时间组件方法：Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getTime()</td>
<td align="center">返回日期的毫秒表示；与 valueOf()相同</td>
</tr>
<tr>
<td align="center">setTime(<em>milliseconds</em>)</td>
<td align="center">设置日期的毫秒表示，从而修改整个日期</td>
</tr>
<tr>
<td align="center">getFullYear()</td>
<td align="center">返回 4 位数年（即 2019 而不是 19）</td>
</tr>
<tr>
<td align="center">getUTCFullYear()</td>
<td align="center">返回 UTC 日期的 4 位数年</td>
</tr>
<tr>
<td align="center">setFullYear(<em>year</em>)</td>
<td align="center">设置日期的年（<em>year</em> 必须是 4 位数）</td>
</tr>
<tr>
<td align="center">setUTCFullYear(<em>year</em>)</td>
<td align="center">设置 UTC 日期的年（<em>year</em> 必须是 4 位数）</td>
</tr>
<tr>
<td align="center">getMonth()</td>
<td align="center">返回日期的月（0 表示 1 月，11 表示 12 月）</td>
</tr>
<tr>
<td align="center">getUTCMonth()</td>
<td align="center">返回 UTC 日期的月（0 表示 1 月）</td>
</tr>
<tr>
<td align="center">setMonth(<em>month</em>)</td>
<td align="center">设置日期的月（0 表示 1 月，11 表示 12 月）</td>
</tr>
<tr>
<td align="center">setUTCMonth(<em>month</em>)</td>
<td align="center">设置 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td>
</tr>
<tr>
<td align="center">getDate()</td>
<td align="center">返回日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">getUTCDate()</td>
<td align="center">返回 UTC 日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">setDate(<em>date</em>)</td>
<td align="center">设置日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">setUTCDate(<em>date</em>)</td>
<td align="center">设置 UTC 日期的日（月中的某一天）</td>
</tr>
<tr>
<td align="center">getDay()</td>
<td align="center">返回日期中的星期几（0 表示星期日，6 表示星期六）</td>
</tr>
<tr>
<td align="center">getUTCDay()</td>
<td align="center">返回 UTC 日期中的星期几（0 表示星期日，6 表示星期六）</td>
</tr>
<tr>
<td align="center">getHours()</td>
<td align="center">返回日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">getUTCHours()</td>
<td align="center">返回 UTC 日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">setHours(<em>hours</em>)</td>
<td align="center">设置日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">setUTCHours(<em>hours</em>)</td>
<td align="center">设置 UTC 日期的小时（0~23）</td>
</tr>
<tr>
<td align="center">getMinutes()</td>
<td align="center">返回日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">getUTCMinutes()</td>
<td align="center">返回 UTC 日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">setMinutes(<em>minutes</em>)</td>
<td align="center">设置日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">setUTCMinutes(<em>minutes</em>)</td>
<td align="center">设置 UTC 日期的分钟（0~59）</td>
</tr>
<tr>
<td align="center">getSeconds()</td>
<td align="center">返回日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">getUTCSeconds()</td>
<td align="center">返回 UTC 日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">setSeconds(<em>seconds</em>)</td>
<td align="center">设置日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">setUTCSeconds(<em>seconds</em>)</td>
<td align="center">设置 UTC 日期的秒（0~59）</td>
</tr>
<tr>
<td align="center">getMilliseconds()</td>
<td align="center">返回日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">getUTCMilliseconds()</td>
<td align="center">返回 UTC 日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">setMilliseconds(<em>milliseconds</em>)</td>
<td align="center">设置日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">setUTCMilliseconds(<em>milliseconds</em>)</td>
<td align="center">设置 UTC 日期的毫秒（0~999）</td>
</tr>
<tr>
<td align="center">getTimezoneOffset()</td>
<td align="center">返回本地时间与 UTC 时间相差的分钟数</td>
</tr>
<tr>
<td align="center">6、RegExp：ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let expression &#x3D; &#x2F;pattern&#x2F;flags;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这个正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> m：多行模式，表示查找到一行文本末尾时会继续查找。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> u：Unicode 模式，启用 Unicode 匹配。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"> s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">使用不同模式和标记可以创建出各种正则表达式，比如：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配字符串中的所有”at”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern1 &#x3D; &#x2F;at&#x2F;g;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”bat”或”cat”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern2 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配所有以”at”结尾的三字符组合，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern3 &#x3D; &#x2F;.at&#x2F;gi;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">( [ { \ ^ $</td>
<td align="center">) ] } ? * + .</td>
</tr>
<tr>
<td align="center">元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”bat”或”cat”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern1 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”[bc]at”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern2 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配所有以”at”结尾的三字符组合，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern3 &#x3D; &#x2F;.at&#x2F;gi;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配所有”.at”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern4 &#x3D; &#x2F;.at&#x2F;gi;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这里的 pattern1 匹配”bat”或”cat”，不区分大小写。要直接匹配”[bc]at”，左右中括号都必须像 pattern2 中那样使用反斜杠转义。在 pattern3 中，点号表示”at”前面的任意字符都可以匹配。如果想匹配”.at”，那么要像 pattern4 中那样对点号进行转义。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 匹配第一个”bat”或”cat”，忽略大小写</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern1 &#x3D; &#x2F;[bc]at&#x2F;i;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F; 跟 pattern1 一样，只不过是用构造函数创建的</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">let pattern2 &#x3D; new RegExp(“[bc]at”, “i”);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">这里的 pattern1 和 pattern2 是等效的正则表达式。注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\，在正则表达式字符串中则要写成\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ 字面量模式 ｜ 对应的字符串 ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;[bc]at&#x2F; ｜  “\[bc\]at” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;.at&#x2F; ｜ “\.at” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;name/age&#x2F; ｜ “name\&#x2F;age” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;\d.\d{1,2}&#x2F; ｜ “\d.\d{1,2}” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">｜ &#x2F;\w\hello\123&#x2F; ｜ “\w\\hello\\123” ｜</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">const re1 &#x3D; &#x2F;cat&#x2F;g;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">console.log(re1); &#x2F;&#x2F; “&#x2F;cat&#x2F;g”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">const re2 &#x3D; new RegExp(re1);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">console.log(re2); &#x2F;&#x2F; “&#x2F;cat&#x2F;g”</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">const re3 &#x3D; new RegExp(re1, “i”);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">console.log(re3); &#x2F;&#x2F; “&#x2F;cat&#x2F;i”</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-19 日报 Day40</title>
    <url>/undefined/2024-12-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>在哪里付出，就在哪里得到；在哪里打磨，就在哪里闪耀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P109-111 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、RegExp实例属性：<br>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。<br> global：布尔值，表示是否设置了 g 标记。<br> ignoreCase：布尔值，表示是否设置了 i 标记。<br> unicode：布尔值，表示是否设置了 u 标记。<br> sticky：布尔值，表示是否设置了 y 标记。<br> lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。<br> multiline：布尔值，表示是否设置了 m 标记。<br> dotAll：布尔值，表示是否设置了 s 标记。<br> source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的<br>斜杠。<br> flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没<br>有前后斜杠）。<br>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含<br>这些信息。下面是一个例子：<br>let pattern1 &#x3D; &#x2F;[bc]at&#x2F;i;<br>console.log(pattern1.global); &#x2F;&#x2F; false<br>console.log(pattern1.ignoreCase); &#x2F;&#x2F; true<br>console.log(pattern1.multiline); &#x2F;&#x2F; false<br>console.log(pattern1.lastIndex); &#x2F;&#x2F; 0<br>console.log(pattern1.source); &#x2F;&#x2F; “[bc]at”<br>console.log(pattern1.flags); &#x2F;&#x2F; “i”<br>let pattern2 &#x3D; new RegExp(“\[bc\]at”, “i”);<br>console.log(pattern2.global); &#x2F;&#x2F; false<br>console.log(pattern2.ignoreCase); &#x2F;&#x2F; true<br>console.log(pattern2.multiline); &#x2F;&#x2F; false<br>console.log(pattern2.lastIndex); &#x2F;&#x2F; 0<br>console.log(pattern2.source); &#x2F;&#x2F; “[bc]at”<br>console.log(pattern2.flags); &#x2F;&#x2F; “i”<br>2、RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>; </span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">input</span>); <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// &quot;mom and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">1</span>]); <span class="comment">// &quot; and dad and baby&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">2</span>]); <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，模式包含两个捕获组：最内部的匹配项” and baby”，以及外部的匹配项” and dad”或” and dad and baby”。调用 exec()后找到了一个匹配项。因为整个字符串匹配模式，所以 matchs数组的 index 属性就是 0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。<br>如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标<br>记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>; </span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// cat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0 </span></span><br><span class="line">matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// cat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
<p>上面例子中的模式没有设置全局标记，因此调用 exec()只返回第一个匹配项（”cat”）。lastIndex在非全局模式下始终不变。<br>如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/g</span>; </span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// cat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 3 </span></span><br><span class="line">matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 5 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// bat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 8 </span></span><br><span class="line">matches = pattern.<span class="title function_">exec</span>(text); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 10 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// sat </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 13</span></span><br></pre></td></tr></table></figure></div>
<p>这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到<br>字符串末尾。注意模式的 lastIndex 属性每次都会变化。在全局匹配模式下，每次调用 exec()都会更新 lastIndex 值，以反映上次匹配的最后一个字符的索引。<br>粘附模式要求正则匹配必须从 lastIndex 指定的位置开始，不能跳过字符，否则匹配失败。<br>正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数<br>返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在 if 语句中：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;000-00-0000&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The pattern was matched.&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。无论正则表达式是怎么创建的，继承的方法 toLocaleString()和 toString()都返回正则表达式的字面量表示。比如：<br>let pattern &#x3D; new RegExp(“\[bc\]at”, “gi”);<br>console.log(pattern.toString()); &#x2F;&#x2F; &#x2F;[bc]at&#x2F;gi<br>console.log(pattern.toLocaleString()); &#x2F;&#x2F; &#x2F;[bc]at&#x2F;gi<br>这里的模式是通过 RegExp 构造函数创建的，但 toLocaleString()和 toString()返回的都是其字面量的形式。<br>注意 正则表达式的 valueOf()方法返回正则表达式本身。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-2 日报 Day23</title>
    <url>/undefined/2024-12-2/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生，从外打破是压力，从内打破是成长。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P73-76 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、if语句：if (condition) statement1 else statement2<br>这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为 true，则执行语句statement1；如果条件求值为 false，则执行语句 statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greater than 25.&quot;</span>); <span class="comment">// 只有一行代码的语句</span></span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Less than or equal to 25.&quot;</span>); <span class="comment">// 一个语句块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以像这样连续使用多个 if 语句：</span></span><br><span class="line"><span class="comment">// if (condition1) statement1 else if (condition2) statement2 else statement3 </span></span><br><span class="line"><span class="comment">// 下面是一个例子：</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greater than 25.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Less than 0.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2、do-while 语句：do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试条件。因此，循环体内的代码至少会执行一次。do-while 语句的语法如下：<br>do {<br> statement<br>} while (condition);</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"> i += <span class="number">2</span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure></div>
<p>3、while 语句：while 语句是一种先测试循环语句，即在循环体内的代码被执行之前，就会先测试条件。如果条件为 true，则继续执行循环；如果条件为 false，则不执行循环。while 语句的语法如下：<br>while (condition) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123; </span><br><span class="line"> i += <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>4、for 语句：for 语句是一种前测试循环语句，即在循环体内的代码被执行之前，就会先测试条件。如果条件为 true，则继续执行循环；如果条件为 false，则不执行循环。for 语句的语法如下：<br>for (initialization; condition; post-loop-expression) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>5、for-in 语句：for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。for-in 语句的语法如下：<br>for (property in expression) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> propName <span class="keyword">in</span> <span class="variable language_">window</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(propName); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>6、for-of 语句：for-of 语句是一种精准的迭代语句，可以用来遍历可迭代对象的元素。for-of 语句的语法如下：<br>for (variable of expression) {<br> statement<br>}</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> data) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>7、for-of和for-in的区别：</p>
<ul>
<li>for-in 循环用来枚举对象的属性，包括原型链上的属性。</li>
<li>for-of 循环用来遍历可迭代对象的元素，包括数组、字符串、Map 和 Set 等。<br>8、标签语句<br>标签语句是一种标识语句的方法，可以在代码中添加标签，以便将来引用。标签语句的语法如下：<br>label: statement<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">start</span>: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
在 JavaScript 中，标签语句（Labeled Statement） 是一种给语句打上标签的语法结构，常用于配合 break 或 continue，跳出多层循环或控制流程。</li>
</ul>
<p>⸻</p>
<p>✅ 语法：</p>
<p>labelName:<br>  statement</p>
<p>⸻<br>🚩 使用场景：<br>多层嵌套循环中提前跳出某一层外部循环，这时候普通的 break 只能跳出一层，用标签可以指定跳出哪一层。<br>⸻<br>🧪 举个例子：<br>🚫 普通 break 只能跳出一层：<br>for (let i &#x3D; 0; i &lt; 3; i++) {<br>  for (let j &#x3D; 0; j &lt; 3; j++) {<br>    if (i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1) break;<br>    console.log(<code>i=$&#123;i&#125;, j=$&#123;j&#125;</code>);<br>  }<br>}<br>&#x2F;&#x2F; 输出：i&#x3D;0,j&#x3D;0 → i&#x3D;0,j&#x3D;1 → i&#x3D;0,j&#x3D;2 → i&#x3D;1,j&#x3D;0 → i&#x3D;1,j&#x3D;2 还继续了<br>⸻<br>✅ 用标签配合 break：<br>outerLoop: &#x2F;&#x2F; 给外层循环打标签<br>for (let i &#x3D; 0; i &lt; 3; i++) {<br>  for (let j &#x3D; 0; j &lt; 3; j++) {<br>    if (i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1) break outerLoop;<br>    console.log(<code>i=$&#123;i&#125;, j=$&#123;j&#125;</code>);<br>  }<br>}<br>&#x2F;&#x2F; 输出：i&#x3D;0,j&#x3D;0 → i&#x3D;0,j&#x3D;1 → i&#x3D;0,j&#x3D;2 → i&#x3D;1,j&#x3D;0（然后 break 了整个外层）<br>⸻<br>✅ continue 也可以配合标签使用：<br>outer:<br>for (let i &#x3D; 0; i &lt; 3; i++) {<br>  for (let j &#x3D; 0; j &lt; 3; j++) {<br>    if (j &#x3D;&#x3D;&#x3D; 1) continue outer;<br>    console.log(<code>i=$&#123;i&#125;, j=$&#123;j&#125;</code>);<br>  }<br>}<br>&#x2F;&#x2F; j&#x3D;1 时直接跳到下一轮外层 i++<br>⸻</p>
<p>⚠️ 注意事项：<br>    •	标签不能重复定义。<br>    •	标签 只能配合 break 或 continue 使用，不能像 goto 那样任意跳转。<br>    •	使用频率不高，但在复杂嵌套逻辑中可以提升可读性或性能。</p>
<p>⸻</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-20 日报 Day41</title>
    <url>/undefined/2024-12-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>不是因为看见了成功才坚持，是只有坚持才会看见成功。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P112-114 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、RegExp构造函数属性：RegExp 构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了RegExp 构造函数的属性。<br>｜全名｜简写｜说明｜<br>｜input｜$_｜最后搜索的字符串（非标准特性）｜<br>｜lastMatch｜$&amp;｜最后匹配的文本｜<br>｜lastParen｜$+｜最后匹配的捕获组（非标准特性）｜<br>｜leftContext｜$&#96;｜input 字符串中 lastMatch 之前的文本。｜<br>｜rightContext｜$’｜input 字符串中 lastMatch 之后的文本。｜<br>这些属性在正则表达式操作期间可能会变化，因此在使用它们时要小心。下面是一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">通过这些属性可以提取出与 <span class="title function_">exec</span>()和 <span class="title function_">test</span>()执行的操作相关的信息。来看下面的例子：</span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">input</span>); <span class="comment">// this has been a short summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">leftContext</span>); <span class="comment">// this has been a </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">rightContext</span>); <span class="comment">// summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">lastMatch</span>); <span class="comment">// short </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">lastParen</span>); <span class="comment">// s </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大<br>多数简写形式都不是合法的 ECMAScript 标识符：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>; </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 注意：Opera 不支持简写属性名</span></span><br><span class="line"><span class="comment"> * IE 不支持多行匹配</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$_</span>); <span class="comment">// this has been a short summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$`&quot;</span>]); <span class="comment">// this has been a </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$&#x27;&quot;</span>]); <span class="comment">// summer </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$&amp;&quot;</span>]); <span class="comment">// short </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$+&quot;</span>]); <span class="comment">// s </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>RegExp 还有其他几个构造函数属性，可以存储最多 9 个捕获组的匹配项。这些属性通过 RegExp. $1<del>RegExp.$9 来访问，分别包含第 1</del>9 个捕获组的匹配项。在调用 exec()或 test()时，这些属性就会被填充，然后就可以像下面这样使用它们：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(..)or(.)/g</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// sh </span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span>); <span class="comment">// t </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，模式包含两个捕获组。调用 test()搜索字符串之后，因为找到了匹配项所以返回true，而且可以打印出通过 RegExp 构造函数的$1 和$2 属性取得的两个捕获组匹配的内容。<br>2、为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：<br>let s1 &#x3D; “some text”;<br>let s2 &#x3D; s1.substring(2);<br>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring()方法，并把结果保存在 s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：<br>(1) 创建一个 String 类型的实例；<br>(2) 调用实例上的特定方法；<br>(3) 销毁实例。<br>可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：<br>let s1 &#x3D; new String(“some text”);<br>let s2 &#x3D; s1.substring(2);<br>s1 &#x3D; null;<br>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过<br>使用的是 Boolean 和 Number 包装类型而已。<br>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：<br>let s1 &#x3D; “some text”;<br>s1.color &#x3D; “red”;<br>console.log(s1.color); &#x2F;&#x2F; undefined<br>这里的第二行代码尝试给字符串 s1 添加了一个 color 属性。可是，第三行代码访问 color 属性时，它却不见了。原因就是第二行代码运行时会临时创建一个 String 对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的 String 对象，但这个对象没有 color 属性。<br>可以显式地使用 Boolean、Number 和 String 构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 typeof 会返回”object”，所有原始值包装对象都会转换为布尔值 true。<br>另外，Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实<br>例。比如：<br>let obj &#x3D; new Object(“some text”);<br>console.log(obj instanceof String); &#x2F;&#x2F; true<br>如果传给 Object 的是字符串，则会创建一个 String 的实例。如果是数值，则会创建 Number 的实例。布尔值则会得到 Boolean 的实例。<br>注意，使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：<br>let value &#x3D; “25”;<br>let number &#x3D; Number(value); &#x2F;&#x2F; 转型函数<br>console.log(typeof number); &#x2F;&#x2F; “number”<br>let obj &#x3D; new Number(value); &#x2F;&#x2F; 构造函数<br>console.log(typeof obj); &#x2F;&#x2F; “object”</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-22 日报 Day43</title>
    <url>/undefined/2024-12-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>成功其实很简单，就是比失败击倒你们的次数多一次。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P120-124 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、某些 Unicode 字符可以有多种编码方式。有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示。比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// U+00C5：上面带圆圈的大写拉丁字母 A </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x00C5</span>)); <span class="comment">// Å </span></span><br><span class="line"><span class="comment">// U+212B：长度单位“埃”</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x212B</span>)); <span class="comment">// Å </span></span><br><span class="line"><span class="comment">// U+004：大写拉丁字母 A </span></span><br><span class="line"><span class="comment">// U+030A：上面加个圆圈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x0041</span>, <span class="number">0x030A</span>)); <span class="comment">// Å</span></span><br></pre></td></tr></table></figure></div>
<p>为解决这个问题，Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：”NFD”、”NFC”、”NFKD”或”NFKC”。<br>2、字符串操作方法：</p>
<ul>
<li>concat()：将一个或多个字符串拼接起来，返回拼接后的新字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>slice()：提取字符串的一部分，返回一个新字符串，不会改变原始字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>substr()：从字符串中提取指定数目的字符，返回新字符串。</li>
<li>substring()：提取字符串中两个指定的索引位置之间的字符，返回新字符串。<br>slice()、substr()和 substring()是以相同方式被调用的，而且多数情况下返<br>回的值也相同。如果只传一个参数 3，则所有方法都将返回”lo world”，因为”hello”中”l”位置为 3。如果传入两个参数 3 和 7，则 slice()和 substring()返回”lo w”（因为”world”中”o”在位置 7，不包含），而 substr()返回”lo worl”，因为第二个参数对它而言表示返回的字符数。<br>当某个参数是负值时，这 3 个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字符串长度加上负参数值。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(-<span class="number">3</span>)); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(-<span class="number">3</span>)); <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;lo w&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;hel&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure></div>
在给 slice()和 substr()传入负参数时，它们的返回结果相同。这是因为-3 会被转换为 8（长度加上负参数），实际上调用的是 slice(8)和 substr(8)。而substring()方法返回整个字符串，因为-3 会转换为 0。在第二个参数是负值时，这 3 个方法各不相同。slice()方法将第二个参数转换为 7，实际上相当于调用 slice(3, 7)，因此返回”lo w”。而 substring()方法会将第二个参数转换为 0，相当于调用substring(3, 0)，等价于 substring(0, 3)，这是因为这个方法会将较小的参数作为起点，将较大的参数作为终点。对 substr()来说，第二个参数会被转换为 0，意味着返回的字符串包含零个字符，因而会返回一个空字符串。</li>
<li>字符串位置方法：indexOf()、lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></div>
这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。下面看一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 7 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>
在传入第二个参数 6 以后，结果跟前面的例子恰好相反。这一次，indexOf()返回 7，因为它从位置 6（字符”w”）开始向后搜索字符串，在位置 7 找到了”o”。而 lastIndexOf()返回 4，因为它从位置 6 开始反向搜索至字符串开头，因此找到了”hello”中的”o”。</li>
<li>字符串包含方法：startsWith()、endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而 includes()检查整个字符串：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;baz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;qux&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是一个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></li>
<li>trim()：创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot; hello world &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot; hello world &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStringValue); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></div>
由于 trim()返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。另外，trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</li>
<li>repeat()：ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">repeat</span>(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>); </span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure></div></li>
<li>padStart()和 padEnd()：padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">6</span>)); <span class="comment">// &quot;   foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">6</span>)); <span class="comment">// &quot;foo   &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>)); <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure></div>
可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;foobarba&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">2</span>)); <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>字符串迭代与解构：字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></div>
在 for-of 循环中可以通过这个迭代器按序访问每个字符：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(c); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// a </span></span><br><span class="line"><span class="comment">// b </span></span><br><span class="line"><span class="comment">// c </span></span><br><span class="line"><span class="comment">// d </span></span><br><span class="line"><span class="comment">// e </span></span><br></pre></td></tr></table></figure></div>
有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...message]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure></div></li>
<li>字符串大小写转换：下一组方法涉及大小写转换，包括 4 个方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。toLowerCase()和toUpperCase()方法是原来就有的方法，与 java.lang.String 中的方法同名。toLocaleLowerCase()和 toLocaleUpperCase()方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode 大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。下面是几个例子：<br>let stringValue &#x3D; “hello world”;<br>console.log(stringValue.toLocaleUpperCase()); &#x2F;&#x2F; “HELLO WORLD”<br>console.log(stringValue.toUpperCase()); &#x2F;&#x2F; “HELLO WORLD”<br>console.log(stringValue.toLocaleLowerCase()); &#x2F;&#x2F; “hello world”<br>console.log(stringValue.toLowerCase()); &#x2F;&#x2F; “hello world”<br>这里，toLowerCase()和 toLocaleLowerCase()都返回 hello world，而 toUpperCase()和toLocaleUpperCase()都返回 HELLO WORLD。通常，如果不知道代码涉及什么语言，则最好使用地区特定的转换方法。<br>好嘞！我们来看看 土耳其语（Turkish） 是为什么要使用 toLocaleLowerCase() 和 toLocaleUpperCase() 的经典示例语言，以及它和普通 toLowerCase()&#x2F;toUpperCase() 的区别。<br>⸻<br>🇹🇷 土耳其语大小写转换的特别之处<br>在英文中：<br>  •	‘i’ → ‘I’<br>  •	‘I’ → ‘i’<br>这是我们熟悉的大小写规则。<br>但在 土耳其语 中：<br>  •	小写 ‘i’ → 大写 ‘İ’（带点的大写 i）<br>  •	大写 ‘I’ → 小写 ‘ı’（不带点的小写 i）<br>也就是说，土耳其语有两个不同的字母：<br>  •	‘i’（点的 i）<br>  •	‘ı’（无点的 i）<br>⸻</li>
</ul>
<p>✅ 举个代码例子：<br>let str &#x3D; “i”;<br>console.log(str.toUpperCase()); &#x2F;&#x2F; “I” —— 英文规则<br>console.log(str.toLocaleUpperCase(“tr-TR”)); &#x2F;&#x2F; “İ” —— 土耳其语规则<br>let str2 &#x3D; “I”;<br>console.log(str2.toLowerCase()); &#x2F;&#x2F; “i” —— 英文规则<br>console.log(str2.toLocaleLowerCase(“tr-TR”)); &#x2F;&#x2F; “ı” —— 土耳其语规则<br>⸻<br>📌 总结建议：<br>    •	如果你处理的是英文或默认语言环境，toUpperCase() 和 toLowerCase() 足够。<br>    •	如果你处理的是用户可能使用土耳其语、立陶宛语等语言的多语言应用，请使用 toLocaleUpperCase(locale) 和 toLocaleLowerCase(locale) 并显式指定区域，这样才能保证转换符合语言规则。<br>⸻</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-23 日报 Day44</title>
    <url>/undefined/2024-12-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每当事情推进一步，你的迷茫就会减少一分。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P125-127 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、字符串模式匹配方法：</p>
<ul>
<li>match()：这个方法本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>; </span><br><span class="line"><span class="comment">// 等价于 pattern.exec(text) </span></span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// &quot;cat&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
match()方法返回的数组与 RegExp 对象的 exec()方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。<br>另一个查找模式的字符串方法是 search()。这个方法唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回1。search()始终从字符串开头向后匹配模式。看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> pos = text.<span class="title function_">search</span>(<span class="regexp">/at/</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pos); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>
为简化子字符串替换操作，ECMAScript 提供了 replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;cond, bat, sat, fat&quot; </span></span><br><span class="line">result = text.<span class="title function_">replace</span>(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure></div>
第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。</li>
<li>$&amp;：与正则表达式相匹配的子字符串。</li>
<li>$&#96;：位于匹配子字符串左侧的文本。</li>
<li>$’：位于匹配子字符串右侧的文本。</li>
<li>$n：匹配第 n 个捕获组的文本（如果有的话）。</li>
<li>$nn：匹配第 nn 个捕获组的文本（如果有的话）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>; </span><br><span class="line">result = text.<span class="title function_">replace</span>(<span class="regexp">/(.at)/g</span>, <span class="string">&quot;word ($1)&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure></div>
replace()的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程，如下所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">text</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> text.<span class="title function_">replace</span>(<span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) &#123; </span><br><span class="line"> <span class="keyword">switch</span>(match) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">htmlEscape</span>(<span class="string">&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;</span>)); </span><br><span class="line"><span class="comment">// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>split(): 这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">&quot;red,blue,green,yellow&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;] </span></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;] </span></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.<span class="title function_">split</span>(<span class="regexp">/[^,]+/</span>); <span class="comment">// [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure></div>
在这里，字符串 colorText 是一个逗号分隔的颜色名称符串。调用 split(“,”)会得到包含这些颜色名的数组，基于逗号进行拆分。要把数组元素限制为 2 个，传入第二个参数 2 即可。最后，使用正则表达式可以得到一个包含逗号的数组。注意在最后一次调用 split()时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（”red”）和末尾（”yellow”）。</li>
<li>localeCompare(): 这个方法比较两个字符串，并返回下列值中的一个：<br> 如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。）<br> 如果字符串与字符串参数相等，则返回 0。<br> 如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>
在这里，字符串”yellow”与 3 个不同的值进行了比较：”brick”、”yellow”和”zoo”。”brick”按字母表顺序应该排在”yellow”前头，因此 localeCompare()返回 1。”yellow”等于”yellow”，因此”localeCompare()”返回 0。最后，”zoo”在”yellow”后面，因此 localeCompare()返回-1。强调一下，因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用 localeCompare()：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">determineOrder</span>(<span class="params">value</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> result = stringValue.<span class="title function_">localeCompare</span>(value); </span><br><span class="line"> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The string &#x27;yellow&#x27; comes before the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>); </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The string &#x27;yellow&#x27; comes after the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The string &#x27;yellow&#x27; is equal to the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">determineOrder</span>(<span class="string">&quot;brick&quot;</span>); </span><br><span class="line"><span class="title function_">determineOrder</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="title function_">determineOrder</span>(<span class="string">&quot;zoo&quot;</span>);</span><br></pre></td></tr></table></figure></div>
localeCompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是 ECMAScript 实现的标准语言，localeCompare()区分大小写，大写字母排在小写字母前面。但其他地区未必是这种情况。</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-16 日报 Day37</title>
    <url>/undefined/2024-12-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>且以青春赴山海,<br>青舟无惧万重山。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P174-
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、插入排序: 插入排序是一种最简单的排序算法，其原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">insertionSort</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.<span class="property">length</span>,</span><br><span class="line">        j, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;length; i++)&#123;</span><br><span class="line">        j = i;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; array[j-<span class="number">1</span>] &gt; temp)&#123;</span><br><span class="line">            array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>时间复杂度: O(n^2)<br>空间复杂度: O(1)</p>
<h3 id="低代码平台学习"><a href="#低代码平台学习" class="headerlink" title="低代码平台学习"></a>低代码平台学习</h3><p>1、以<a href="https://github.com/alibaba/lowcode-demo%E6%8F%90%E4%BE%9B%E7%9A%84https://lowcode-engine.cn/index">https://github.com/alibaba/lowcode-demo提供的https://lowcode-engine.cn/index</a> 模版学习<br>主要了解低代码平台所包含的主要模块和分包各自功能实现。对整体框架有一个简单的认识。<br>2、首先以demo-basic-antd为例进行学习，了解其基本功能和实现方式。<br>demo-basic-antd引入的包:</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;@alilc/lowcode-datasource-fetch-handler&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-code-editor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-code-generator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-components-pane&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-datasource-pane&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.9&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-inject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-manual&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-simulator-select&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-undo-redo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-zh-en&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-plugin-set-ref-prop&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-react-renderer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.1.2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-setter-behavior&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;@alilc/lowcode-setter-title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.2&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></div>
<p>接下来对各个包的功能进行简单的分析:</p>
<ul>
<li>lowcode-datasource-fetch-handler: 数据源获取处理 </li>
<li>lowcode-plugin-code-editor: 代码编辑器 <a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></li>
<li>lowcode-plugin-code-generator: 出码器 <a href="https://github.com/alibaba/lowcode-code-generator-demo">https://github.com/alibaba/lowcode-code-generator-demo</a> 有demo但应该不是完整的</li>
<li>lowcode-plugin-components-pane: 低代码组件面板 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-datasource-pane: 数据源面板 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-inject: 低代码引擎生态元素项目内调试用插件 <a href="https://github.com/alibaba/lowcode-tools.git">https://github.com/alibaba/lowcode-tools.git</a></li>
<li>lowcode-plugin-manual: 低代码产品使用手册 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-schema: 查看低代码引擎 schema <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-simulator-select: 画布切换 <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-undo-redo: alibaba lowcode editor undo redo plugin <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-zh-en: alibaba lowcode editor zhong english plugin <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-plugin-set-ref-prop: alibaba lowcode editor plugin for setting ref-id <a href="https://github.com/alibaba/lowcode-plugins.git">https://github.com/alibaba/lowcode-plugins.git</a></li>
<li>lowcode-react-renderer: react renderer for ali lowcode engine <a href="https://github.com/alibaba/lowcode-engine/tree/main/packages/react-renderer">https://github.com/alibaba/lowcode-engine/tree/main/packages/react-renderer</a></li>
<li>lowcode-setter-behavior: 交互 setter</li>
<li>lowcode-setter-title: 标题 setter</li>
</ul>
<p>找到了npm包对应源码的地址</p>
<table>
<thead>
<tr>
<th><strong>包名</strong></th>
<th><strong>仓库</strong></th>
<th><strong>路径</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@alilc&#x2F;lowcode-code-generator</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>modules&#x2F;code-generator</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-material-parser</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>modules&#x2F;material-parser</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-designer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;designer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-editor-core</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;editor-core</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-editor-skeleton</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;editor-skeleton</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-engine</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;engine</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-designer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;plugin-designer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-outline-pane</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;plugin-outline-pane</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-react-renderer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;react-renderer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-react-simulator-renderer</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;react-simulator-renderer</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-renderer-core</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;renderer-core</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-shell</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;shell</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-types</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;types</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-utils</td>
<td><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></td>
<td>packages&#x2F;utils</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-engine</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-engine</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-fetch-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-fetch-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-jsonp-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-jsonp-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-mopen-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-mopen-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-mtop-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-mtop-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-types</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-types</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-universal-mtop-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-universal-mtop-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-datasource-url-params-handler</td>
<td><a href="https://github.com/alibaba/lowcode-datasource">https://github.com/alibaba/lowcode-datasource</a></td>
<td>packages&#x2F;datasource-url-params-handler</td>
</tr>
<tr>
<td>@alilc&#x2F;build-plugin-alt</td>
<td><a href="https://github.com/alibaba/lowcode-tools">https://github.com/alibaba/lowcode-tools</a></td>
<td>packages&#x2F;build-plugin-alt</td>
</tr>
<tr>
<td>@alilc&#x2F;create-element</td>
<td><a href="https://github.com/alibaba/lowcode-tools">https://github.com/alibaba/lowcode-tools</a></td>
<td>packages&#x2F;create-element</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-inject</td>
<td><a href="https://github.com/alibaba/lowcode-tools">https://github.com/alibaba/lowcode-tools</a></td>
<td>packages&#x2F;lowcode-plugin-inject</td>
</tr>
<tr>
<td>@alilc&#x2F;action-block</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;action-block</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-base-monaco-editor</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-base-monaco-editor</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-block</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-block</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-code-editor</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-code-editor</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-components-pane</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-components-pane</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-datasource-pane</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-datasource-pane</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-manual</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-manual</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-schema</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-schema</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-undo-redo</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-undo-redo</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-plugin-zh-en</td>
<td><a href="https://github.com/alibaba/lowcode-plugins">https://github.com/alibaba/lowcode-plugins</a></td>
<td>packages&#x2F;plugin-zh-en</td>
</tr>
<tr>
<td>@alifd&#x2F;fusion-ui</td>
<td><a href="https://github.com/alibaba/lowcode-materials">https://github.com/alibaba/lowcode-materials</a></td>
<td>packages&#x2F;fusion-ui</td>
</tr>
<tr>
<td>@alilc&#x2F;lowcode-materials</td>
<td><a href="https://github.com/alibaba/lowcode-materials">https://github.com/alibaba/lowcode-materials</a></td>
<td>packages&#x2F;fusion-lowcode-materials</td>
</tr>
<tr>
<td>@alilc&#x2F;antd-lowcode-materials</td>
<td><a href="https://github.com/alibaba/lowcode-materials">https://github.com/alibaba/lowcode-materials</a></td>
<td>packages&#x2F;antd-lowcode-materials</td>
</tr>
<tr>
<td>@alifd&#x2F;layout（原 @alifd&#x2F;pro-layout 升级后的版本）</td>
<td><a href="https://github.com/alibaba-fusion/layout">https://github.com/alibaba-fusion/layout</a></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-21 日报 Day42</title>
    <url>/undefined/2024-12-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生如同浪潮，每一次触底，都是为下一次反弹蓄力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P115-119 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false，如下例所示：<br>let booleanObject &#x3D; new Boolean(true);<br>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时，比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>; </span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>在这段代码中，我们创建一个值为 false 的 Boolean 对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值 true 组合起来。在布尔算术中，false &amp;&amp; true 等于 false。可是，这个表达式是对 falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值。那么true &amp;&amp; true 当然是 true。<br>除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean 对象是 Boolean 类型的实例，在使用instaceof 操作符时返回 true，但对原始值则返回 false，如下所示：<br>console.log(typeof falseObject); &#x2F;&#x2F; object<br>console.log(typeof falseValue); &#x2F;&#x2F; boolean<br>console.log(falseObject instanceof Boolean); &#x2F;&#x2F; true<br>console.log(falseValue instanceof Boolean); &#x2F;&#x2F; false<br>2、Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，如下例所示：<br>let numberObject &#x3D; new Number(10);<br>与 Boolean 类型一样，Number 类型重写了 valueOf()、toLocaleString()和 toString()方、法。valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：<br>let num &#x3D; 10;<br>console.log(num.toString()); &#x2F;&#x2F; “10”<br>console.log(num.toString(2)); &#x2F;&#x2F; “1010”<br>console.log(num.toString(8)); &#x2F;&#x2F; “12”<br>console.log(num.toString(10)); &#x2F;&#x2F; “10”<br>console.log(num.toString(16)); &#x2F;&#x2F; “a”<br>除了继承的方法，Number 类型还提供了几个用于将数值格式化为字符串的方法。<br>toFixed()方法返回包含指定小数点位数的数值字符串，如：<br>let num &#x3D; 10;<br>console.log(num.toFixed(2)); &#x2F;&#x2F; “10.00”<br>这里的 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为”10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：<br>let num &#x3D; 10.005;<br>console.log(num.toFixed(2)); &#x2F;&#x2F; “10.01”<br>toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 &#x3D; 0.30000000000000004<br>另一个用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。与 toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。来看下面的例子：<br>let num &#x3D; 10;<br>console.log(num.toExponential(1)); &#x2F;&#x2F; “1.0e+1”<br>这段代码的输出为”1.0e+1”。一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用 toPrecision()。toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：<br>let num &#x3D; 99;<br>console.log(num.toPrecision(1)); &#x2F;&#x2F; “1e+2”<br>console.log(num.toPrecision(2)); &#x2F;&#x2F; “99”<br>console.log(num.toPrecision(3)); &#x2F;&#x2F; “99.0”<br>在处理原始数值和引用数值时，typeof 和 instacnceof操作符会返回不同的结果，如下所示：<br>let numberObject &#x3D; new Number(10);<br>let numberValue &#x3D; 10;<br>console.log(typeof numberObject); &#x2F;&#x2F; “object”<br>console.log(typeof numberValue); &#x2F;&#x2F; “number”<br>console.log(numberObject instanceof Number); &#x2F;&#x2F; true<br>console.log(numberValue instanceof Number); &#x2F;&#x2F; false<br>isInteger()方法与安全整数：ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0可能会让人误以为数值是一个浮点值：<br>console.log(Number.isInteger(1)); &#x2F;&#x2F; true<br>console.log(Number.isInteger(1.00)); &#x2F;&#x2F; true<br>console.log(Number.isInteger(1.01)); &#x2F;&#x2F; false<br>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从 Number.MIN_SAFE_INTEGER（-2^53 + 1）到 Number.MAX_SAFE_INTEGER（2^53 - 1）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的<br>数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法：<br>console.log(Number.isSafeInteger(-1 * (2 ** 53))); &#x2F;&#x2F; false<br>console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); &#x2F;&#x2F; true<br>console.log(Number.isSafeInteger(2 ** 53)); &#x2F;&#x2F; false<br>console.log(Number.isSafeInteger((2 ** 53) - 1)); &#x2F;&#x2F; true<br>3、String 是对应字符串的引用类型。要创建一个 String 对象，就使用 String 构造函数并传入一个字符串，如下例所示：<br>let stringObject &#x3D; new String(“hello world”);<br>String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf()、toLocaleString()和 toString()都返回对象的原始字符串值。<br>每个 String 对象都有一个 length 属性，表示字符串中字符的数量。来看下面的例子：<br>let stringValue &#x3D; “hello world”;<br>console.log(stringValue.length); &#x2F;&#x2F; “11”<br>JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元：<br>let message &#x3D; “abcde”;<br>console.log(message.length); &#x2F;&#x2F; 5<br>此外，charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。<br>let message &#x3D; “abcde”;<br>console.log(message.charAt(2)); &#x2F;&#x2F; “c”<br>使用 charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。比如：<br>let message &#x3D; “abcde”;<br>console.log(message.charCodeAt(2)); &#x2F;&#x2F; 99<br>console.log(99 &#x3D;&#x3D;&#x3D; 0x63); &#x2F;&#x2F; true<br>fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode &quot;Latin small letter A&quot;的编码是 U+0061 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter B&quot;的编码是 U+0062 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是 U+0063 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter D&quot;的编码是 U+0064 </span></span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter E&quot;的编码是 U+0065 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"><span class="comment">// 0x0061 === 97 </span></span><br><span class="line"><span class="comment">// 0x0062 === 98 </span></span><br><span class="line"><span class="comment">// 0x0063 === 99 </span></span><br><span class="line"><span class="comment">// 0x0064 === 100 </span></span><br><span class="line"><span class="comment">// 0x0065 === 101 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了<br>表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。在涉及增补平面的字符时，前面讨论的字符串方法就会出问题。比如，下面的例子中使用了一个笑脸表情符号，也就是一个使用代理对编码的字符：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;smiling face with smiling eyes&quot; 表情符号的编码是 U+1F60A </span></span><br><span class="line"><span class="comment">// 0x1F60A === 128522 </span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">length</span>); <span class="comment">// 6 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">1</span>)); <span class="comment">// b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// &lt;?&gt; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">3</span>)); <span class="comment">// &lt;?&gt; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">4</span>)); <span class="comment">// d </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)); <span class="comment">// 98 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">2</span>)); <span class="comment">// 55357 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">3</span>)); <span class="comment">// 56842 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">4</span>)); <span class="comment">// 100 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">0x1F60A</span>)); <span class="comment">// 😊</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55357</span>, <span class="number">56842</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure></div>
<p>这些方法仍然将 16 位码元当作一个字符，事实上索引 2 和索引 3 对应的码元应该被看成一个代理对，只对应一个字符。fromCharCode()方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成），并正确地将其识别为一个Unicode 笑脸字符。<br>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用 codePointAt()来代替charCodeAt()。跟使用 charCodeAt()时类似，codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识。比如，”c”的码点是 0x0063，而”😊”的码点是 0x1F60A。码点可能是 16 位，也可能是 32 位，而 codePointAt()方法可以从指定码元位置识别完整的码点。<br>let message &#x3D; “ab😊de”;<br>console.log(message.codePointAt(1)); &#x2F;&#x2F; 98<br>console.log(message.codePointAt(2)); &#x2F;&#x2F; 128522<br>console.log(message.codePointAt(3)); &#x2F;&#x2F; 56842<br>console.log(message.codePointAt(4)); &#x2F;&#x2F; 100<br>注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：<br>console.log([…”ab😊de”]); &#x2F;&#x2F; [“a”, “b”, “😊”, “d”, “e”]<br>与charCodeAt()有对应的 codePointAt()一样，fromCharCode()也有一个对应的 fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：<br>console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); &#x2F;&#x2F; ab☺de<br>console.log(String.fromCodePoint(97, 98, 128522, 100, 101)); &#x2F;&#x2F; ab☺de</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-25 日报 Day46</title>
    <url>/undefined/2024-12-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>不要只顾着欣赏他人的绚烂，而忘记了自己的芬芳。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P132-135 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象提供了一些辅助计算的属性和方法。<br>注意 Math 对象上提供的计算要比直接在 JavaScript 实现的快得多，因为 Math 对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用 Math 计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。<br>2、Math对象属性：</p>
<ul>
<li>Math.E：自然对数的底数，即常量e的值。</li>
<li>Math.LN2：2的自然对数。</li>
<li>Math.LN10：10的自然对数。</li>
<li>Math.LOG2E：以2为底e的对数。</li>
<li>Math.LOG10E：以10为底e的对数。</li>
<li>Math.PI：圆周率。</li>
<li>Math.SQRT1_2：1&#x2F;2的平方根。</li>
<li>Math.SQRT2：2的平方根。<br>3、Math对象方法：</li>
<li>min()和max方法：min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max); <span class="comment">// 54 </span></span><br><span class="line"><span class="keyword">let</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(min); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：<br>let values &#x3D; [1, 2, 3, 4, 5, 6, 7, 8];<br>let max &#x3D; Math.max(…val);</li>
<li>舍入方法：接下来是用于把小数值舍入为整数的 4 个方法：Math.ceil()、Math.floor()、Math.round()和 Math.fround()。这几个方法处理舍入的方式如下所述。<br> Math.ceil()方法始终向上舍入为最接近的整数<br> Math.floor()方法始终向下舍入为最接近的整数<br> Math.round()方法把舍入为最接近的整数<br> Math.fround()方法返回最接近参数的单精度浮点数表示<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">25.9</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">25.5</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">25.1</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">25.9</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">25.5</span>)); <span class="comment">// 26 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">25.1</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">fround</span>(<span class="number">0.4</span>)); <span class="comment">// 0.4000000059604645 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">fround</span>(<span class="number">0.5</span>)); <span class="comment">// 0.5 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">fround</span>(<span class="number">25.9</span>)); <span class="comment">// 25.899999618530273 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">25.9</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">25.5</span>)); <span class="comment">// 25 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">25.1</span>)); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></div></li>
<li>random()方法：Math.random()方法返回大于等于 0 小于 1 的一个随机数。这个随机数是由一个均匀分布产生的，其平均值是 0.5。<br>注意 Math.random()方法在这里出于演示目的是没有问题的。如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用 window.crypto.getRandomValues()。</li>
<li>其他方法:<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abs()</td>
<td>返回数值的绝对值</td>
</tr>
<tr>
<td>cbrt()</td>
<td>返回数值的立方根</td>
</tr>
<tr>
<td>exp()</td>
<td>返回Math.E的x次幂</td>
</tr>
<tr>
<td>log()</td>
<td>返回数值的自然对数（以e为底）</td>
</tr>
<tr>
<td>pow()</td>
<td>返回数值的x次幂</td>
</tr>
<tr>
<td>sqrt()</td>
<td>返回数值的平方根</td>
</tr>
<tr>
<td>sign()</td>
<td>返回数值的符号，指示数值是正数、负数还是零</td>
</tr>
<tr>
<td>trunc()</td>
<td>返回数值的整数部分，去除小数部分</td>
</tr>
<tr>
<td>4、小结：</td>
<td></td>
</tr>
<tr>
<td>JavaScript 中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。</td>
<td></td>
</tr>
<tr>
<td> 引用值与传统面向对象编程语言中的类相似，但实现不同。</td>
<td></td>
</tr>
<tr>
<td> Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。</td>
<td></td>
</tr>
<tr>
<td> RegExp 类型是 ECMAScript 支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。</td>
<td></td>
</tr>
<tr>
<td>JavaScript 比较独特的一点是，函数实际上是 Function 类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类型：Boolean、Number 和 String。它们都具备如下特点。</td>
<td></td>
</tr>
<tr>
<td> 每种包装类型都映射到同名的原始类型。</td>
<td></td>
</tr>
<tr>
<td> 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相</td>
<td></td>
</tr>
<tr>
<td>应的数据。</td>
<td></td>
</tr>
<tr>
<td> 涉及原始值的语句执行完毕后，包装对象就会被销毁。</td>
<td></td>
</tr>
<tr>
<td>当代码开始执行时，全局上下文中会存在两个内置对象：Global 和 Math。其中，Global 对象在大多数 ECMAScript 实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是 Global 对象的属性。Math 对象包含辅助完成复杂计算的属性和方法。</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-26 日报 Day47</title>
    <url>/undefined/2024-12-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>当你成长为一株向日葵，才能吸引来更多的阳光与正能量。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P136-138 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。显式地创建 Object 的实例有两种方式。<br>第一种是使用 new 操作符和 Object 构造函数，如下所示：<br>let person &#x3D; new Object();<br>person.name &#x3D; “Nicholas”;<br>person.age &#x3D; 29;<br>第二种方式是使用对象字面量表示法，如下所示：<br>let person &#x3D; {<br>  name: “Nicholas”,<br>  age: 29<br>};<br>在对象字面量表示法中，属性名可以是字符串或数值。注意，数值属性会自动转换为字符串。虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性，通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。<br>注意 在使用对象字面量表示法定义对象时，并不会实际调用 Object 构造函数。	当你用 对象字面量 {} 来定义对象时，JavaScript 引擎会在底层自动创建一个继承自 Object.prototype 的对象，但不会显式调用 new Object() 构造函数。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-27 日报 Day48</title>
    <url>/undefined/2024-12-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生的淡定和从容，都是从学到的本领修炼来的气定神闲。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P139-142 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、除了 Object，Array 应该就是 ECMAScript 中最常用的类型了。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。<br>2、创建数组的方式有两种。第一种是使用 Array 构造函数，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>第二种方式是使用数组字面量表示法，如下所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br></pre></td></tr></table></figure></div>
<p>数组字面量表示法是数组创建方式中最常用的一种，因为它更简洁。数组字面量表示法中的数组项不必是常量，可以是任意表达式。数组项可以是任意类型的数据，也可以是对象或其他数组。注意 与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。<br>Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：from()和 of()。from()用于将类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。<br>Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。这种方式可用于很多场合：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;] </span></span><br><span class="line"><span class="comment">// 可以使用 from()将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="number">3</span>, <span class="number">4</span>); </span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="number">1</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">2</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">3</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(m)); <span class="comment">// [[1, 2], [3, 4]] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(s)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// Array.from()对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="title function_">alert</span>(a1 === a2); <span class="comment">// false </span></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123; </span><br><span class="line"> *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">4</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arguments 对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArgsArray</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getArgsArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="comment">// from()也能转换带有必要属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; </span><br><span class="line"> <span class="number">0</span>: <span class="number">1</span>, </span><br><span class="line"> <span class="number">1</span>: <span class="number">2</span>, </span><br><span class="line"> <span class="number">2</span>: <span class="number">3</span>, </span><br><span class="line"> <span class="number">3</span>: <span class="number">4</span>, </span><br><span class="line"> <span class="attr">length</span>: <span class="number">4</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLikeObject)); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></div>
<p>Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像<br>调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函<br>数中 this 的值。但这个重写的 this 值在箭头函数中不适用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; </span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="keyword">function</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x**<span class="variable language_">this</span>.<span class="property">exponent</span>&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2); <span class="comment">// [1, 4, 9, 16] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3); <span class="comment">// [1, 4, 9, 16] </span></span><br></pre></td></tr></table></figure></div>
<p>Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype. slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：</p>
<p>console.log(Array.of(1, 2, 3, 4)); &#x2F;&#x2F; [1, 2, 3, 4]<br>console.log(Array.of(undefined)); &#x2F;&#x2F; [undefined]<br>3、要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如果把一个值设置给超过数组最大索引的索引，就像示例中的 colors[3]，则数组长度会自动扩展到该索引值加 1<br>数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">2</span>; </span><br><span class="line"><span class="title function_">alert</span>(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>注意 数组最多可以包含 4 294 967 295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。<br>4、检测数组：一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123; </span><br><span class="line"> <span class="comment">// 对数组执行某些操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。<br>为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value))&#123; </span><br><span class="line"> <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>5、迭代器方法：在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回索引&#x2F;值对的迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]; </span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容</span></span><br><span class="line"><span class="comment">// 通过 Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">keys</span>()); </span><br><span class="line"><span class="keyword">const</span> aValues = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">values</span>()); </span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">entries</span>()); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys); <span class="comment">// [0, 1, 2, 3] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues); <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aEntries); <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]] </span></span><br><span class="line">使用 <span class="title class_">ES6</span> 的解构可以非常容易地在循环中拆分键/值对：</span><br><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(idx); </span><br><span class="line"> <span class="title function_">alert</span>(element); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// foo </span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// bar </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// baz </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-28 日报 Day49</title>
    <url>/undefined/2024-12-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>懂得适时转变位置，成为一束照亮别人的光，也才能被他人照耀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P143-147 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、复制和填充方法:批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。<br>使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; </span><br><span class="line"><span class="comment">// 用 5 填充整个数组</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [5, 5, 5, 5, 5] </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 6 填充索引大于等于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">6</span>, <span class="number">3</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 6, 6] </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 7, 7, 0, 0]; </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 8 填充索引大于等于 1 且小于 4 的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1) </span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4) </span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure></div>
<p>fill()静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0] </span></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure></div>
<p>与 fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 支持负索引值，与 fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></div>
<p>copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ints, </span><br><span class="line"> reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; </span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, -<span class="number">15</span>, -<span class="number">12</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>() </span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>); </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; </span></span><br><span class="line"><span class="title function_">reset</span>(); </span><br><span class="line"><span class="comment">// 索引部分可用，复制、填充可用部分</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>) </span><br><span class="line"><span class="title function_">alert</span>(ints); <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure></div>
<p>2、转换方法：所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf()返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。来看下面的<br>例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toString</span>()); <span class="comment">// red,blue,green </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">valueOf</span>()); <span class="comment">// red,blue,green </span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// red,blue,green</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123; </span><br><span class="line"> <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nikolaos&quot;</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">toString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> person2 = &#123; </span><br><span class="line"> <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Grigorios&quot;</span>; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="title function_">toString</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> people = [person1, person2]; </span><br><span class="line"><span class="title function_">alert</span>(people); <span class="comment">// Nicholas,Greg </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toString</span>()); <span class="comment">// Nicholas,Greg </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toLocaleString</span>()); <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure></div>
<p>继承的方法 toLocaleString()以及 toString()都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用 join()方法。join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。来看下面的例子：<br>let colors &#x3D; [“red”, “green”, “blue”];<br>alert(colors.join(“,”)); &#x2F;&#x2F; red,green,blue<br>alert(colors.join(“||”)); &#x2F;&#x2F; red||green||blue<br>如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符。<br>注意 如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、toString()和 valueOf()返回的结果中会以空字符串表示。<br>3、栈方法：ECMAScript 给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了 push()和 pop()方法，以实现类似栈的行为。<br>push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。来看下面的例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// black </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
<p>3、队列方法：就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push()方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 shift()，它会删除数组的第一项并返回它，然后数组长度减 1。使用 shift()和 push()，可以把数组当成队列来使用：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// red </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>
<p>ECMAScript 也为数组提供了 unshift()方法。顾名思义，unshift()就是执行跟 shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 unshift()和 pop()，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 2 </span></span><br><span class="line">count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">// 3 </span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item); <span class="comment">// green </span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-24 日报 Day45</title>
    <url>/undefined/2024-12-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>很多时候，能力决定你能走多快，人品决定你能走多远。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P128-131 第五章：基本引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、HTML：早期的浏览器开发商认为使用 JavaScript 动态生成 HTML 标签是一个需求。因此，早期浏览器扩展了规范，增加了辅助生成 HTML 标签的方法。下表总结了这些 HTML 方法。不过，这些方法基本上已经没有人使用了，因为结果通常不是语义化的标记。</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>输 出</th>
</tr>
</thead>
<tbody><tr>
<td>anchor(name)</td>
<td><a name="name">string</a></td>
</tr>
<tr>
<td>big()</td>
<td><big>string</big></td>
</tr>
<tr>
<td>bold()</td>
<td><b>string</b></td>
</tr>
<tr>
<td>fixed()</td>
<td><tt>string</tt></td>
</tr>
<tr>
<td>fontcolor(color)</td>
<td><font color="color">string</font></td>
</tr>
<tr>
<td>fontsize(size)</td>
<td><font size="size">string</font></td>
</tr>
<tr>
<td>italics()</td>
<td><i>string</i></td>
</tr>
<tr>
<td>link(url)</td>
<td><a href="url">string</a></td>
</tr>
<tr>
<td>small()</td>
<td><small>string</small></td>
</tr>
<tr>
<td>strike()</td>
<td><strike>string</strike></td>
</tr>
<tr>
<td>sub()</td>
<td><sub>string</sub></td>
</tr>
<tr>
<td>sup()</td>
<td><sup>string</sup ></td>
</tr>
<tr>
<td>2、单例内置对象：ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括 Object、Array 和 String。本节介绍 ECMA-262定义的另外两个单例内置对象：Global 和 Math。</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Global：Global 对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定 Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本书前面介绍的函数，包括 isNaN()、isFinite()、parseInt()和 parseFloat()，实际上都是 Global 对象的方法。除了这些，Global 对象上还有另外一些方法。<br>URL编码方法：encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解它们，同时又以特殊的 UTF-8 编码替换掉所有无效字符。<br>ecnodeURI()方法用于对整个 URI 进行编码，比如”<a class="link"   href="http://www.wrox.com/illegal" >www.wrox.com/illegal <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> value.js”。而encodeURIComponent()方法用于编码 URI 中单独的组件，比如前面 URL 中的”illegal value.js”。这两个方法的主要区别是，encodeURI()不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而 encodeURIComponent()会编码它发现的所有非标准字符。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>; </span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURI</span>(uri)); </span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></div>
这里使用 encodeURI()编码后，除空格被替换为%20 之外，没有任何变化。而 encodeURIComponent()方法将所有非字母字符都替换成了相应的编码形式。这就是使用 encodeURI()编码整个URI，但只使用 encodeURIComponent()编码那些会追加到已有 URI 后面的字符串的原因。<br>与 encodeURI()和 encodeURIComponent()相对的是 decodeURI()和 decodeURIComponent()。decodeURI()只对使用 encodeURI()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由 encodeURI()替换的。类似地，decodeURIComponent()解码所有被 encodeURIComponent()编码的字符，基本上就是解码所有特殊值。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span>; </span><br><span class="line"><span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURI</span>(uri)); </span><br><span class="line"><span class="comment">// http:// www.wrox.com/illegal value.js#start </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure></div>
这里，uri 变量中包含一个使用 encodeURIComponent()编码过的字符串。首先输出的是使用decodeURI()解码的结果，可以看到只用空格替换了%20。然后是使用 decodeURIComponent()解码的结果，其中替换了所有特殊字符，并输出了没有包含任何转义的字符串。（这个字符串不是有效的 URL。）<br>3、eval()方法：eval()方法是 ECMAScript 中最强大的函数之一，也是最容易被滥用的函数之一。它的用途是将对应的字符串解析成 JS 代码并运行。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>);</span><br></pre></td></tr></table></figure></div>
当解释器发现 eval()调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置。通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在 eval()调用内部被引用，比如下面这个例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></div>
注意 解释代码字符串的能力是非常强大的，但也非常危险。在使用 eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。<br>4、Global对象属性：Global 对象有很多属性，其中一些前面已经提到过了。像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function，也都是Global 对象的属性。下表列出了所有这些属性。</li>
</ul>
<table>
<thead>
<tr>
<th>属 性</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>特殊值 undefined</td>
</tr>
<tr>
<td>NaN</td>
<td>特殊值 NaN</td>
</tr>
<tr>
<td>Infinity</td>
<td>特殊值 Infinity</td>
</tr>
<tr>
<td>Object</td>
<td>构造函数 Object</td>
</tr>
<tr>
<td>Array</td>
<td>构造函数 Array</td>
</tr>
<tr>
<td>Function</td>
<td>构造函数 Function</td>
</tr>
<tr>
<td>Boolean</td>
<td>构造函数 Boolean</td>
</tr>
<tr>
<td>String</td>
<td>构造函数 String</td>
</tr>
<tr>
<td>Number</td>
<td>构造函数 Number</td>
</tr>
<tr>
<td>Date</td>
<td>构造函数 Date</td>
</tr>
<tr>
<td>RegExp</td>
<td>构造函数 RegExp</td>
</tr>
<tr>
<td>Symbol</td>
<td>构造函数 Symbol</td>
</tr>
<tr>
<td>Error</td>
<td>构造函数 Error（所有错误类型的基类型）</td>
</tr>
<tr>
<td>EvalError</td>
<td>构造函数 EvalError</td>
</tr>
<tr>
<td>RangeError</td>
<td>构造函数 RangeError</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>构造函数 ReferenceError</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>构造函数 SyntaxError</td>
</tr>
<tr>
<td>TypeError</td>
<td>构造函数 TypeError</td>
</tr>
<tr>
<td>URIError</td>
<td>构造函数 URIError</td>
</tr>
<tr>
<td>5、window对象：虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。来看下面的例子：</td>
<td></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">color</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayColor</span>(); <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>另一种获取 Global 对象的方式是使用如下的代码：<br>let global &#x3D; function() {<br> return this;<br>}();<br>这段代码创建一个立即调用的函数表达式，返回了 this 的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过 call()&#x2F;apply()）指定 this 值的情况下执行时，this 值等于Global 对象。因此，调用一个简单返回 this 的函数是在任何执行上下文中获取 Global 对象的通用方式。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-29 日报 Day50</title>
    <url>/undefined/2024-12-29/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>愿你历经风霜，依然初心不改，坚定走在自己的路上。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P148-151 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、排序方法：数组有2个方法对元素进行重新排序reverse()和sort()。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line">values.<span class="title function_">reverse</span>(); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure></div>
<p>默认情况下，sort()会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。比如:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>();</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure></div>
<p>一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。因此，即使 5 小于 10，但字符串”10”在字符串”5”的前头，所以 10 还是会排到 5 前面。很明显，这在多数情况下都不是最合适的。为此，sort()方法可以接收一个比较函数，用于判断哪个值应该排在前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。比如:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(compare); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure></div>
<p>在给 sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也<br>可以产生降序效果，只要把返回值交换一下即可：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (value1 &lt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123; </span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.<span class="title function_">sort</span>(compare); </span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure></div>
<p>此外，这个比较函数还可简写为一个箭头函数：<br>let values &#x3D; [0, 1, 5, 10, 15];<br>values.sort((a, b) &#x3D;&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0);<br>alert(values); &#x2F;&#x2F; 15,10,5,1,0<br>如果数组的元素是数值，或者是其 valueOf()方法返回数值的对象（如 Date 对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：<br>function compare(value1, value2){<br> return value2 - value1;<br>}<br>2、数组操作方法：</p>
<ul>
<li>concat()方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure></div>
打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。这个符号能够阻止 concat()打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">length</span>: <span class="number">2</span>, </span><br><span class="line"> <span class="number">0</span>: <span class="string">&quot;pink&quot;</span>, </span><br><span class="line"> <span class="number">1</span>: <span class="string">&quot;cyan&quot;</span> </span><br><span class="line">&#125;; </span><br><span class="line">newColors[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, newColors); </span><br><span class="line"><span class="comment">// 强制打平类数组对象</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">concat</span>(moreNewColors); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]] </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]</span></span><br></pre></td></tr></table></figure></div></li>
<li>slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line"><span class="title function_">alert</span>(colors2); <span class="comment">// green,blue,yellow,purple </span></span><br><span class="line"><span class="title function_">alert</span>(colors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure></div>
注意 如果 slice()的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如，在包含 5 个元素的数组上调用 slice(-2,-1)，就相当于调用 slice(3,4)。如果结束位置小于开始位置，则返回空数组。</li>
<li>最强大的数组方法就属 splice()了，使用它的方式可以有很多种。splice()的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。<br> 删除。需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。<br> 插入。需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2, 0, “red”, “green”)会从数组位置 2 开始插入字符串”red”和”green”。<br> 替换。splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始向数组中插入”red”和”green”。<br>splice()方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]; </span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 在位置 1 插入两个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,yellow,orange,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// green,red,purple,orange,blue </span></span><br><span class="line"><span class="title function_">alert</span>(removed); <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-30 日报 Day51</title>
    <url>/undefined/2024-12-30/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>我们的人生不是只有成功和失败两个词，坚持和奋斗同样有意义。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P152-158 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、搜索和位置方法：ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p>
<ul>
<li>严格相等：ECMAScript 提供了 3 个严格相等的搜索方法：indexOf()、lastIndexOf()和 includes()。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项）开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索。<br>indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（&#x3D;&#x3D;&#x3D;）比较，也就是说两项必须严格相等。下面来看一些例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; </span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 5 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>, <span class="number">7</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;]; </span><br><span class="line"><span class="keyword">let</span> morePeople = [person]; </span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">indexOf</span>(person)); <span class="comment">// -1 </span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">indexOf</span>(person)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">includes</span>(person)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">includes</span>(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></li>
<li>断言函数：ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。<br>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [ </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">27</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span> </span><br><span class="line"> &#125; </span><br><span class="line">]; </span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125; </span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)); </span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
2、迭代方法：ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。数组的 5 个迭代方法如下。<br> every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。<br> filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。<br> forEach()：对数组每一项都运行传入的函数，没有返回值。<br> map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。<br> some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。<br>这些方法都不改变调用它们的数组。<br>3、归并方法：ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。而 reduceRight()从最后一项开始遍历至第一项。<br>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。<br>可以使用 reduce()函数执行累加数组中所有数值的操作，比如：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></div>
第一次执行归并函数时，prev 是 1，cur 是 2。第二次执行时，prev 是 3（1 + 2），cur 是 3（数组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。<br>reduceRight()方法与之类似，只是方向相反。来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduceRight</span>(<span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)&#123; </span><br><span class="line"> <span class="keyword">return</span> prev + cur; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></div>
在这里，第一次调用归并函数时 prev 是 5，而 cur 是 4。究竟是使用 reduce()还是 reduceRight()，只取决于遍历数组元素的方向。<br>4、定型数组: 定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。用途：随着浏览器的流行，不难想象人们会满怀期待地通过它来运行复杂的 3D 应用程序。早在 2006 年，Mozilla、Opera 等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插件。其目标是开发一套 JavaScript API，从而充分利用 3D 图形 API 和 GPU 加速，以便在<canvas>元素上渲染复杂的图形。</li>
<li>WebGL: 在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript数组在内存中的格式。因此，每次 WebGL 与 JavaScript 运行时之间传递数组时，WebGL 绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费很多时间。</li>
<li>定型数组: 这当然是难以接受的，Mozilla 为解决这个问题而实现了 CanvasFloatArray。这是一个提供JavaScript 接口的、C 语言风格的浮点值数组。JavaScript 运行时使用这个类型可以分配、读取和写入数组。这个数组可以直接传给底层图形驱动程序 API，也可以直接从底层获取到。最终，CanvasFloatArray变成了 Float32Array，也就是今天定型数组中可用的第一个“类型”。<br>5、ArrayBuffer: Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。<br>ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 在内存中分配 16 字节</span></span><br><span class="line"><span class="title function_">alert</span>(buf.<span class="property">byteLength</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></div>
ArrayBuffer 一经创建就不能再调整大小。不过，可以使用 slice()复制其全部或部分到一个新实例中：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); </span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.<span class="title function_">slice</span>(<span class="number">4</span>, <span class="number">12</span>); </span><br><span class="line"><span class="title function_">alert</span>(buf2.<span class="property">byteLength</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></div>
不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须通过视图。视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据。<br>6、DataView: 第一种允许你读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I&#x2F;O 和网络 I&#x2F;O 设计，其API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。<br>必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// DataView 默认使用整个 ArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteOffset</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteLength</span>); <span class="comment">// 16 </span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">buffer</span> === buf); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">// byteOffset=0 表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">// byteLength=8 限制视图为前 8 个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>); </span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteOffset</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">buffer</span> === buf); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不指定，则 DataView 会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">// byteOffset=8 表示视图从缓冲的第 9 个字节开始</span></span><br><span class="line"><span class="comment">// byteLength 未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">8</span>); </span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">byteOffset</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></div>
alert(secondHalfDataView.byteLength); &#x2F;&#x2F; 8<br>alert(secondHalfDataView.buffer &#x3D;&#x3D;&#x3D; buf); &#x2F;&#x2F; true<br>要通过 DataView 读取缓冲，还需要几个组件。<br> 首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地址”。<br> DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。<br> 最后是内存中值的字节序。默认为大端字节序。<br>DataView 对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读、写时指定一个ElementType，然后 DataView 就会忠实地为读、写而完成相应的转换。ECMAScript 6 支持 8 种不同的 ElementType:<table>
<thead>
<tr>
<th>ElementType</th>
<th>字节长度</th>
<th>描述</th>
<th>等价的C类型</th>
<th>值范围</th>
</tr>
</thead>
<tbody><tr>
<td>Int8</td>
<td>1</td>
<td>8 位有符号整数</td>
<td>signed char</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>Uint8</td>
<td>1</td>
<td>8 位无符号整数</td>
<td>unsigned char</td>
<td>0 到 255</td>
</tr>
<tr>
<td>Int16</td>
<td>2</td>
<td>16 位有符号整数</td>
<td>short</td>
<td>-32 768 到 32 767</td>
</tr>
<tr>
<td>Uint16</td>
<td>2</td>
<td>16 位无符号整数</td>
<td>unsigned short</td>
<td>0 到 65 535</td>
</tr>
<tr>
<td>Int32</td>
<td>4</td>
<td>32 位有符号整数</td>
<td>int</td>
<td>-2 147 483 648 到 2 147 483 647</td>
</tr>
<tr>
<td>Uint32</td>
<td>4</td>
<td>32 位无符号整数</td>
<td>unsigned int</td>
<td>0 到 4 294 967 295</td>
</tr>
<tr>
<td>Float32</td>
<td>4</td>
<td>32 位浮点数</td>
<td>float</td>
<td>-3.4e+38 到 +3.4e+38</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
<td>64 位浮点数</td>
<td>double</td>
<td>-1.7e+308 到 +1.7e+308</td>
</tr>
<tr>
<td>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView </span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 说明整个缓冲确实所有二进制位都是 0 </span></span><br><span class="line"><span class="comment">// 检查第一个和第二个字符</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">1</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 检查整个缓冲</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为 1 </span></span><br><span class="line"><span class="comment">// 255 的二进制表示是 11111111（2^8 - 1）</span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">255</span>); </span><br><span class="line"><span class="comment">// DataView 会自动将数据转换为特定的 ElementType </span></span><br><span class="line"><span class="comment">// 255 的十六进制表示是 0xFF </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0xFF</span>); </span><br><span class="line"><span class="comment">// 现在，缓冲里都是 1 了</span></span><br><span class="line"><span class="comment">// 如果把它当成二补数的有符号整数，则应该是-1 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>
7、字节序: 前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。<br>JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这个约定。对一段内存而言，DataView 是一个中立接口，它会遵循你指定的字节序。DataView 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序。<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView </span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 填充缓冲，让第一位和最后一位都是 1 </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左边的位等于 1 </span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右边的位等于 1 </span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x8 0x0 0x0 0x1 </span></span><br><span class="line"><span class="comment">// 1000 0000 0000 0001 </span></span><br><span class="line"><span class="comment">// 按大端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x80 是高字节，0x01 是低字节</span></span><br><span class="line"><span class="comment">// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>)); <span class="comment">// 32769 </span></span><br><span class="line"><span class="comment">// 按小端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x01 是高字节，0x80 是低字节</span></span><br><span class="line"><span class="comment">// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 384 </span></span><br><span class="line"><span class="comment">// 按大端字节序写入 Uint16 </span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0004</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x0 0x0 0x4 </span></span><br><span class="line"><span class="comment">// 0000 0000 0000 0100 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 按小端字节序写入 Uint16 </span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x2 0x0 0x0 </span></span><br><span class="line"><span class="comment">// 0000 0010 0000 0000 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 2 </span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-4 日报 Day25</title>
    <url>/undefined/2024-12-4/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>真正困住你的不是困难本身，而是你对自己的负面暗示。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P81-82 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、函数：ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。函数的基本语法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, ..., argN</span>) &#123; </span><br><span class="line"> statements </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>return 语句也可以不带返回值。这时候，函数会立即停止执行并返回 undefined。这种用法最常用于提前终止函数执行，并不是为了返回值。比如在下面的例子中，console.log 不会执行：<br>function sayHi(name, message) {<br> return;<br> console.log(“Hello “ + name + “, “ + message); &#x2F;&#x2F; 不会执行<br>}<br>2、总结：ECMAScript包含所有基本语法、操作符、数据类型和对象<br> ECMAScript 中的基本数据类型包括 Undefined、Null、Boolean、Number、String 和 Symbol。<br> 与其他语言不同，ECMAScript 不区分整数和浮点值，只有 Number 一种数值数据类型。<br> Object 是一种复杂数据类型，它是这门语言中所有对象的基类。<br> 严格模式为这门语言中某些容易出错的部分施加了限制。<br> ECMAScript 提供了 C 语言和类 C 语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。<br> 这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如 if 语句、for 语句和 switch语句等。<br>ECMAScript 中的函数与其他语言中的函数不一样。<br> 不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。<br> 不指定返回值的函数实际上会返回特殊值 undefined。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-3 日报 Day24</title>
    <url>/undefined/2024-12-3/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>人生，从外打破是压力，从内打破是成长。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P77-80 第三章：语言基础</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、break和continue语句：break 和 continue 语句用于在循环中精确地控制代码的执行。break 语句会立即退出循环，强制终止循环的执行，而 continue 语句只会退出当前循环的一次迭代。来看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>; </span><br><span class="line"><span class="attr">outermost</span>: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span> outermost; </span><br><span class="line"> &#125; </span><br><span class="line"> num++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outermost</span>:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line"> <span class="keyword">continue</span> outermost;</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure></div>
<p>这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当 i 和 j 都等于 5 时，会执行 continue，跳到外部循环继续执行，从而导致内部循环少执行 5 次，结果 num 等于 95。<br>2、with 语句：with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statement</span><br></pre></td></tr></table></figure></div>
<p>3、switch语句：switch 语句是一种多分支语句，用于基于不同条件执行不同动作。switch 语句的语法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="attr">value1</span>: </span><br><span class="line">  statement </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="attr">value2</span>: </span><br><span class="line">  statement </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="attr">value3</span>: </span><br><span class="line">  statement </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line"> <span class="attr">default</span>: </span><br><span class="line">  statement </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为避免不必要的条件判断，最好给每个条件后面都加上 break 语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了 break，如下所示：</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="number">25</span>: </span><br><span class="line"> <span class="comment">/*跳过*/</span> </span><br><span class="line"> <span class="keyword">case</span> <span class="number">35</span>: </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;25 or 35&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="number">45</span>: </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;45&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-31 日报 Day52</title>
    <url>/undefined/2024-12-31/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>从来没有一蹴而就的成功，所有熠熠闪光的背后都是默默的努力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P159-162 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、边界情况：DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">6</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">8</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(-<span class="number">1</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">setInt32</span>(<span class="number">4</span>, <span class="number">123</span>); </span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure></div>
<p>DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf); </span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="number">1.5</span>); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 1 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, [<span class="number">4</span>]); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 4 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="title class_">Symbol</span>()); </span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></div>
<p>2、定型数组: 定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别在于，它特定于一种 ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API 和更高的性能。设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。<br>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过<ElementType>.from()和<ElementType>.of()也可以创建定型数组：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 12 字节的缓冲</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">12</span>); </span><br><span class="line"><span class="comment">// 创建一个引用该缓冲的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buf); </span><br><span class="line"><span class="comment">// 这个定型数组知道自己的每个元素需要 4 字节</span></span><br><span class="line"><span class="comment">// 因此长度为 3 </span></span><br><span class="line"><span class="title function_">alert</span>(ints.<span class="property">length</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 创建一个长度为 6 的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(<span class="number">6</span>); </span><br><span class="line"><span class="comment">// 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节</span></span><br><span class="line"><span class="title function_">alert</span>(ints2.<span class="property">length</span>); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 类似 DataView，定型数组也有一个指向关联缓冲的引用</span></span><br><span class="line"><span class="title function_">alert</span>(ints2.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 24 </span></span><br><span class="line"><span class="comment">// 创建一个包含[2, 4, 6, 8]的 Int32Array </span></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]); </span><br><span class="line"><span class="title function_">alert</span>(ints3.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints3.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 16 </span></span><br><span class="line"><span class="title function_">alert</span>(ints3[<span class="number">2</span>]); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 通过复制 ints3 的值创建一个 Int16Array </span></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(ints3); </span><br><span class="line"><span class="comment">// 这个新类型数组会分配自己的缓冲</span></span><br><span class="line"><span class="comment">// 对应索引的每个值会相应地转换为新格式</span></span><br><span class="line"><span class="title function_">alert</span>(ints4.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints4.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(ints4[<span class="number">2</span>]); <span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 基于普通数组来创建一个 Int16Array </span></span><br><span class="line"><span class="keyword">const</span> ints5 = <span class="title class_">Int16Array</span>.<span class="title function_">from</span>([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]); </span><br><span class="line"><span class="title function_">alert</span>(ints5.<span class="property">length</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="title function_">alert</span>(ints5.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 8 </span></span><br><span class="line"><span class="title function_">alert</span>(ints5[<span class="number">2</span>]); <span class="comment">// 7 </span></span><br><span class="line"><span class="comment">// 基于传入的参数创建一个 Float32Array </span></span><br><span class="line"><span class="keyword">const</span> floats = <span class="title class_">Float32Array</span>.<span class="title function_">of</span>(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>); </span><br><span class="line"><span class="title function_">alert</span>(floats.<span class="property">length</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="title function_">alert</span>(floats.<span class="property">buffer</span>.<span class="property">byteLength</span>); <span class="comment">// 12 </span></span><br><span class="line"><span class="title function_">alert</span>(floats[<span class="number">2</span>]); <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure></div>
<p>3、下溢和上溢：定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长度为 2 的有符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个二补数形式的有符号整数</span></span><br><span class="line"><span class="comment">// 范围是-128（-1 * 2^7）~127（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 长度为 2 的无符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个无符号整数</span></span><br><span class="line"><span class="comment">// 范围是 0~255（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// 上溢的位不会影响相邻索引</span></span><br><span class="line"><span class="comment">// 索引只取最低有效位上的 8 位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>; <span class="comment">// 0x100 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 0] </span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>; <span class="comment">// 0x1FF </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 255] </span></span><br><span class="line"><span class="comment">// 下溢的位会被转换为其无符号的等价值</span></span><br><span class="line"><span class="comment">// 0xFF 是以二补数形式表示的-1（截取到 8 位）, </span></span><br><span class="line"><span class="comment">// 但 255 是一个无符号整数</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = -<span class="number">1</span> <span class="comment">// 0xFF (truncated to 8 bits) </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(unsignedInts); <span class="comment">// [0, 255] </span></span><br><span class="line"><span class="comment">// 上溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0x80 是无符号整数的 128，是二补数形式的-128 </span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>; <span class="comment">// 0x80 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, -128] </span></span><br><span class="line"><span class="comment">// 下溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0xFF 是无符号整数的 255，是二补数形式的-1 </span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>; <span class="comment">// 0xFF </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints); <span class="comment">// [0, -1]</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-5 日报 Day26</title>
    <url>/undefined/2024-12-5/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>只有努力多一点，人生的遗憾才会少一点。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P83-86 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、原始值和引用值：ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值就是简单的数据，而引用值则是由多个值构成的对象。6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（by  value）访问的，因为我们操作的就是存储在变量中的实际值。<br>引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。<br>2、注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：<br>let name1 &#x3D; “Nicholas”;<br>let name2 &#x3D; new String(“Matt”);<br>name1.age &#x3D; 27;<br>name2.age &#x3D; 26;<br>console.log(name1.age); &#x2F;&#x2F; undefined<br>console.log(name2.age); &#x2F;&#x2F; 26<br>console.log(typeof name1); &#x2F;&#x2F; string<br>console.log(typeof name2); &#x2F;&#x2F; object<br>3、原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。<br>let num1 &#x3D; 5;<br>let num2 &#x3D; num1;<br>这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。<br>4、在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际<br>上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：<br>let obj1 &#x3D; new Object();<br>let obj2 &#x3D; obj1;<br>obj1.name &#x3D; “Nicholas”;<br>console.log(obj2.name); &#x2F;&#x2F; “Nicholas”<br>5、ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。变量有按值和按引用访问，而传参则只有按值传递。<br>注意 ECMAScript 中函数的参数就是局部变量。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-6 日报 Day27</title>
    <url>/undefined/2024-12-6/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>失望和希望，常常在同一条路上朝你走来。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P87-94 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof 返回”object”，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>; </span><br><span class="line"><span class="keyword">let</span> u; </span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s); <span class="comment">// string </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> i); <span class="comment">// number </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b); <span class="comment">// boolean </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> u); <span class="comment">// undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> n); <span class="comment">// object </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br></pre></td></tr></table></figure></div>
<p>typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下：<br>result &#x3D; variable instanceof constructor<br>如果变量是给定引用类型（由其原型链决定，将在第 8 章详细介绍）的实例，则 instanceof 操作符返回 true。来看下面的例子：<br>console.log(person instanceof Object); &#x2F;&#x2F; 变量 person 是 Object 吗？<br>console.log(colors instanceof Array); &#x2F;&#x2F; 变量 colors 是 Array 吗？<br>console.log(pattern instanceof RegExp); &#x2F;&#x2F; 变量 pattern 是 RegExp 吗？<br>按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象<br>注意 typeof 操作符在用于检测函数时也会返回”function”。当在 Safari（直到 Safari 5）和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回”function”。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在typeof 检测时返回”function”。因为上述浏览器中的正则表达式实现了这个方法，所以 typeof 对正则表达式也返回”function”。在 IE 和 Firefox 中，typeof 对正则表达式返回”object”。<br>2、变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。<br>全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象（第 12 章会详细介绍），因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。<br>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。<br>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。<br>3、执行上下文主要有全局上下文和函数上下文两种（eval（）调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：<br> try&#x2F;catch 语句的 catch 块<br> with 语句<br>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildUrl</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>; </span><br><span class="line"> <span class="title function_">with</span>(<span class="params">location</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> url = href + qs; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> url; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为函数上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块级作用域（稍后介绍），所以在 with 块之外没有定义。</p>
<p>注意 IE 的实现在 IE8 之前是有偏差的，即它们会将 catch 语句中捕获的错误添加到执行上下文的变量对象上，而不是 catch 语句的变量对象上，导致在 catch 块外部都可以访问到错误。IE9 纠正了这个问题。<br>4、在使用var作为函数作用域声明时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> <span class="keyword">var</span> sum = num1 + num2; </span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 报错：sum在这里不是有效变量</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，sum 是 add()函数的局部变量，只能在函数内部访问。如果在函数外部访问 sum，就会导致错误。这是因为 sum 是在函数上下文中定义的，而不是在全局上下文中定义的。如果在函数内部没有使用 var 声明 sum，那么 sum 就会被自动添加到全局上下文中，如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line"> sum = num1 + num2; </span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，sum 是全局变量，因为它是在函数内部而没有使用 var 声明的。这种情况下，sum 会被添加到全局上下文中，因此在函数外部也可以访问到它。这种行为在严格模式下会导致错误，因为在严格模式下不能给未声明的变量赋值。<br>var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫做变量提升（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是Reference Error：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// undefined </span></span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>5、let的作用域是块级的，其由最近的一对包含花括号{}界定。换句话说，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferenceError: c is not defined</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// ReferenceError: d is not defined</span></span><br></pre></td></tr></table></figure></div>
<p>let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; <span class="comment">// SyntaxError: Identifier &#x27;b&#x27; has already been declared</span></span><br></pre></td></tr></table></figure></div>
<p>let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。来看下面两个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 10 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// ReferenceError: j 没有定义</span></span><br></pre></td></tr></table></figure></div>
<p>严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提升跟 var是不一样的。</p>
<p>这是一个很容易产生误解但非常关键的 JavaScript 知识点，我们来详细讲讲：</p>
<p>⸻</p>
<p>🌟 为什么说 let 会被“提升”，但不能用？</p>
<p>✅ 提升的定义</p>
<p>“变量提升（Hoisting）” 是指：</p>
<pre><code>在 JavaScript 的编译阶段，变量的声明会被“提前”到当前作用域的顶部。
</code></pre>
<p>所以：let 声明的变量，其实也被提升了！<br>    •	但不同于 var 被提升后初始化为 undefined，<br>    •	let（和 const）在提升后不会立刻初始化，<br>    •	而是在真正的声明语句执行前处于“暂时性死区”（TDZ）中，<br>    •	只要在 TDZ 里访问这个变量，就会报错！</p>
<p>⸻</p>
<p>🧠 什么是“暂时性死区（TDZ）”？</p>
<p>TDZ 是从变量绑定开始，到代码执行到声明语句的那一刻之间的这段时间。</p>
<p>在这段时间内，访问变量会抛出 ReferenceError，因为它还没有被初始化。</p>
<p>示例一：</p>
<p>console.log(a); &#x2F;&#x2F; ❌ ReferenceError: Cannot access ‘a’ before initialization<br>let a &#x3D; 10;</p>
<p>尽管 a 被“提升”了，但在 let a &#x3D; 10 执行之前，你就是不能访问它！</p>
<p>⸻</p>
<p>🔁 和 var 的区别</p>
<p>console.log(b); &#x2F;&#x2F; ✅ undefined（不会报错）<br>var b &#x3D; 20;</p>
<p>var 的声明也被提升了，并且提前赋值为 undefined，所以访问不会报错。</p>
<p>⸻</p>
<p>✅ 小总结：</p>
<p>特性	var	let &#x2F; const<br>是否提升	是	是<br>提升后是否初始化	初始化为 undefined	不初始化，进入 TDZ<br>提升后能否访问	能（值为 undefined）	不能，访问会报 ReferenceError<br>是否有暂时性死区（TDZ）	❌ 没有	✅ 有，直到真正的声明位置才可用<br>6、除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 3 </span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> 除了要遵循以上规则，其他方面与 <span class="keyword">let</span> 声明是一样的：</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> a = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a 没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> b = <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: b 没有定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> c = <span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferenceError: c 没有定义</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">const</span> d = <span class="number">3</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// ReferenceError: d 没有定义</span></span><br></pre></td></tr></table></figure></div>
<p>const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;; </span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;; </span><br><span class="line">o2.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="property">name</span>); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p>如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;); </span><br><span class="line">o3.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。<br>7、标识符查找：当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-7 日报 Day28</title>
    <url>/undefined/2024-12-7/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>如果你不提前倒下，没有任何人可以打败你。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P95-98 第四章：变量、作用域与内存</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、垃圾回收机制：JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 C 和 C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。<br>我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。<br>2、标记清理：<br>JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。<br>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。<br>垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。<br>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。<br>3、引用计数：<br>另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则这个值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收程序下次运行时，它就会释放那些引用次数为 0 的值所占用的内存。<br>引用计数策略的一个问题是循环引用。循环引用指的是对象 A 持有一个指向对象 B 的引用，而对象 B 又持有一个指向对象 A 的引用。在这种情况下，这两个对象的引用次数永远不会是 0，因为它们互相引用着。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">problem</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  objectA.<span class="property">someOtherObject</span> = objectB;</span><br><span class="line">  objectB.<span class="property">anotherObject</span> = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种情况下，引用计数策略就会导致内存泄漏。在 IE8 及更早版本的 IE 中，并非所有对象都是原生 JavaScript 对象。BOM 和 DOM 中的对象是 C++实现的组件对象模型（COM，Component Object Model）对象，而 COM 对象使用引用计数实现垃圾回收。因此，即使这些版本 IE 的 JavaScript 引擎使用标记清理，JavaScript 存取的 COM 对象依旧使用引用计数。换句话说，只要涉及 COM 对象，就无法避开循环引用问题。下面这个简单的例子展示了涉及 COM对象的循环引用问题：<br>let element &#x3D; document.getElementById(“some_element”);<br>let myObject &#x3D; new Object();<br>myObject.element &#x3D; element;<br>element.someObject &#x3D; myObject;<br>这个例子在一个 DOM 对象（element）和一个原生 JavaScript 对象（myObject）之间制造了循环引用。myObject 变量有一个名为 element 的属性指向 DOM 对象 element，而 element 对象有一个someObject 属性指回 myObject 对象。由于存在循环引用，因此 DOM 元素的内存永远不会被回收，即使它已经被从页面上删除了也是如此。为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：<br>myObject.element &#x3D; null;<br>element.someObject &#x3D; null;<br>把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。为了补救这一点，IE9 把 BOM 和 DOM 对象都改成了 JavaScript 对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。<br>4、性能问题：<br>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。<br>现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，根据 V8 团队 2016 年的一篇博文的说法：“在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”</p>
<p>警告 在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 IE 中，window.CollectGarbage()方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 window.opera.collect()也会启动垃圾回收程序。<br>5、内存管理：将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，<br>如下面的例子所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name</span>)&#123; </span><br><span class="line"> <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"> localPerson.<span class="property">name</span> = name; </span><br><span class="line"> <span class="keyword">return</span> localPerson; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> globalPerson = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>); </span><br><span class="line"><span class="comment">// 解除 globalPerson 对值的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>
<p>1、通过 const 和 let 声明提升性能<br>ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 const和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。<br>2、根据 JavaScript 所在的运行环境，有时候需要根据浏览器使用的 JavaScript 引擎来采取不同的性能优化策略。<br>V8 在将解释后的 JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的代码非常注重性能，那么这一点可能对你很<br>重要。<br>运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。比如下面的代码：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br></pre></td></tr></table></figure></div>
<p>V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：<br>a2.author &#x3D; ‘Jake’;<br>此时两个 Article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。当然，解决方案就是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性，如下所示：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">opt_author</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">author</span> = opt_author; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>这样，两个实例基本上就一样了（不考虑 hasOwnProperty 的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过要记住，使用 delete 关键字会导致生成相同的隐藏类片段。看一下这个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">author</span> = <span class="string">&#x27;Jake&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>(); </span><br><span class="line"><span class="keyword">delete</span> a1.<span class="property">author</span>;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-01 日报 Day53</title>
    <url>/undefined/2025-01-01/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>接纳自己的不完美、肯定和认可自己，是我们这一生重要的课题。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P162-167 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、Map: 在 JavaScript 中实现“键&#x2F;值”式存储可以使用 Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。Map 是一种新的集合类型，为这门语言带来了真正的键&#x2F;值存储机制。Map 的大多数特性都可以通过 Object 类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。<br>基本API：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 Map 构造函数可以创建一个空映射：</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">// 如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：</span></span><br><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(m1.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>(&#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>]; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>]; </span><br><span class="line"> <span class="keyword">yield</span> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(m2.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>([[]]); </span><br><span class="line"><span class="title function_">alert</span>(m3.<span class="title function_">has</span>(<span class="literal">undefined</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m3.<span class="title function_">get</span>(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>初始化之后，可以使用 set()方法再添加键&#x2F;值对。另外，可以使用 get()和 has()进行查询，可以通过 size 属性获取映射中的键&#x2F;值对的数量，还可以使用 delete()和 clear()删除值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// undefined </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 0 </span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 2 </span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="string">&quot;firstName&quot;</span>); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">m.<span class="title function_">clear</span>(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">has</span>(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">size</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为键。Map 内部使用 SameValueZero 比较操作（ECMAScript 规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。与 Object 类似，映射的值是没有限制的。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="title class_">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">m.<span class="title function_">set</span>(functionKey, <span class="string">&quot;functionValue&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(symbolKey, <span class="string">&quot;symbolValue&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(objectKey, <span class="string">&quot;objectValue&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(functionKey)); <span class="comment">// functionValue </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(symbolKey)); <span class="comment">// symbolValue </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(objectKey)); <span class="comment">// objectValue </span></span><br><span class="line"><span class="comment">// SameValueZero 比较意味着独立实例不冲突</span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>
<p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;, </span><br><span class="line"> objVal = &#123;&#125;, </span><br><span class="line"> arrKey = [], </span><br><span class="line"> arrVal = []; </span><br><span class="line">m.<span class="title function_">set</span>(objKey, objVal); </span><br><span class="line">m.<span class="title function_">set</span>(arrKey, arrVal); </span><br><span class="line">objKey.<span class="property">foo</span> = <span class="string">&quot;foo&quot;</span>; </span><br><span class="line">objVal.<span class="property">bar</span> = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrKey.<span class="title function_">push</span>(<span class="string">&quot;foo&quot;</span>); </span><br><span class="line">arrVal.<span class="title function_">push</span>(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(objKey)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(arrKey)); <span class="comment">// [&quot;bar&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>SameValueZero 比较也可能导致意想不到的冲突：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN </span></span><br><span class="line"> b = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN </span></span><br><span class="line"> pz = +<span class="number">0</span>, </span><br><span class="line"> nz = -<span class="number">0</span>;</span><br><span class="line"> <span class="title function_">alert</span>(a === b); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(pz === nz); <span class="comment">// true </span></span><br><span class="line">m.<span class="title function_">set</span>(a, <span class="string">&quot;foo&quot;</span>); </span><br><span class="line">m.<span class="title function_">set</span>(pz, <span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(b)); <span class="comment">// foo </span></span><br><span class="line"><span class="title function_">alert</span>(m.<span class="title function_">get</span>(nz)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure></div>
<p>2、与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。<br>映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过 entries()方法（或者 Symbol.iterator 属性，它引用 entries()）取得这个迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(m.<span class="property">entries</span> === m[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [key1,val1] </span></span><br><span class="line"><span class="comment">// [key2,val2] </span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br></pre></td></tr></table></figure></div>
<p>因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure></div>
<p>如果不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line">m.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, key</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// key1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// key2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// key3 -&gt; val3</span></span><br></pre></td></tr></table></figure></div>
<p>keys()和 values()分别返回以插入顺序生成键和值的迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// key1 </span></span><br><span class="line"><span class="comment">// key2 </span></span><br><span class="line"><span class="comment">// key3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// value1 </span></span><br><span class="line"><span class="comment">// value2 </span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure></div>
<p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> key = <span class="string">&quot;newKey&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(key); <span class="comment">// newKey </span></span><br><span class="line"> <span class="title function_">alert</span>(m1.<span class="title function_">get</span>(<span class="string">&quot;key1&quot;</span>)); <span class="comment">// val1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>([ </span><br><span class="line"> [keyObj, <span class="string">&quot;val1&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.<span class="title function_">keys</span>()) &#123; </span><br><span class="line"> key.<span class="property">id</span> = <span class="string">&quot;newKey&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(key); <span class="comment">// &#123;id: &quot;newKey&quot;&#125; </span></span><br><span class="line"> <span class="title function_">alert</span>(m.<span class="title function_">get</span>(keyObj)); <span class="comment">// val1 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">alert</span>(keyObj); <span class="comment">// &#123;id: &quot;newKey&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-9 日报 Day30</title>
    <url>/undefined/2024-12-9/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每次归程，都是为了更好出发;<br>每次停歇，都是为了积攒力量。</p>

    </div>
  </div>

<h3 id="近况描述"><a href="#近况描述" class="headerlink" title="近况描述"></a>近况描述</h3><p>挺更了将近三个礼拜，最近发生了很多事情，也是人生的一个低谷和迷茫期，但是我相信，这一切都会过去，我也要从中吸取教训、走出来变得更加强大。Just keep going on.</p>
<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><pre><code>1、《JavaScript数据结构与算法》 P89-92
</code></pre>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>链表存储有序的元素集合，其存放的是当前元素和下一个元素的引用。链表的好处是在添加和移除元素的时候不需要移动其他元素。其缺点是访问元素时需要从头开始迭代链表直到找到所需的元素。</p>
<ul>
<li>简单链表实现<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> head = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">append</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element),</span><br><span class="line">        current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head === <span class="literal">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(current.<span class="property">next</span>)&#123;</span><br><span class="line">                current = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current.<span class="property">next</span> = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">position, element</span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length)&#123;</span><br><span class="line">            <span class="keyword">let</span> current = head,</span><br><span class="line">            previous,</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(position === <span class="number">0</span>)&#123;</span><br><span class="line">                head = current.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(index++ &lt; position)&#123;</span><br><span class="line">                    previous = current;</span><br><span class="line">                    current = current.<span class="property">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previous.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> current.<span class="property">element</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">element</span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getHead</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="VPN-Virtual-Private-Network"><a href="#VPN-Virtual-Private-Network" class="headerlink" title="VPN(Virtual Private Network)"></a>VPN(Virtual Private Network)</h3><p>VPN是一种通过公共网络建立私人网络的技术，通过加密通道将用户的数据传输到VPN服务器，再由VPN服务器转发到目标网站，从而实现用户的上网隐私和安全。</p>
<ul>
<li>为什么需要VPN?<ul>
<li>GFW(防火长城)：国内的网络审查系统，会屏蔽一些国外的网站，使用VPN可以突破GFW，访问国外网站。</li>
</ul>
</li>
</ul>
<p>正常没有GFW的情况下，网络包的传输过程是这样的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用户设备 (发起DNS请求) -&gt; 2. 路由器 (转发请求) -&gt; 3. ISP DNS服务器 (缓存或递归解析)</span><br><span class="line">     ↓</span><br><span class="line">4. 用户设备 (接收IP地址) -&gt; 5. 路由器 (发送数据包) -&gt; 6. ISP网络 -&gt; 7. 国际/区域骨干网</span><br><span class="line">     ↓</span><br><span class="line">8. 目标服务器网络 -&gt; 9. 目标服务器 (处理请求并返回数据)</span><br></pre></td></tr></table></figure></div>
<p>有了GFW之后，网络包的传输过程变成了这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用户设备 (发起DNS请求) -&gt; 2. 路由器 (转发请求) -&gt; 3. ISP DNS服务器 (缓存或递归解析，可能受到GFW干预)</span><br><span class="line">     ↓</span><br><span class="line">   - GFW可能拦截DNS请求，返回伪造的IP地址（DNS污染）。</span><br><span class="line">     ↓</span><br><span class="line">4. 用户设备 (接收IP地址，可能是错误的伪造地址) -&gt; 5. 路由器 (发送数据包) -&gt; 6. ISP网络</span><br><span class="line">     ↓</span><br><span class="line">   - GFW监控传输的数据包，发现敏感关键词时进行干预。（过滤关键字）。</span><br><span class="line">   - GFW对端口进行封锁，导致用户无法访问一些网站。（端口阻断）。</span><br><span class="line">   - GFW对IP地址进行封锁，导致用户无法访问一些网站。（IP地址封锁）。</span><br><span class="line">     ↓</span><br><span class="line">7. 国际/区域骨干网 (若未被阻断，数据包继续传输)</span><br><span class="line">     ↓</span><br><span class="line">   - GFW可能通过深度包检测（DPI）分析数据包内容，发现敏感流量特征时进行干预（丢包、限速、阻断IP等）。</span><br><span class="line">     ↓</span><br><span class="line">8. 目标服务器网络 (若数据包未被拦截，正常到达目标网络) -&gt; 9. 目标服务器 (处理请求并返回数据，回程时可能再次被GFW干预)</span><br></pre></td></tr></table></figure></div>

<p>VPN SSH HTTP代理的原理<br>1、用户设备会先和VPN服务器建立加密通道，使用SSH（Secure Shell）协议创建加密隧道。<br>2、在VPN服务器上使用HTTP代理，将用户的数据包转发到目标服务器。</p>
<p>Shadowsocks SSR v2ray等方式运作原理<br>1、在本地网络上进行加密，发送加密数据经过DNS解析后，到达VPN服务器。<br>2、VPN服务器解密数据，将数据包转发到目标服务器。<br>3、目标服务器返回数据，VPN服务器再次加密数据，发送到用户设备。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-8 日报 Day29</title>
    <url>/undefined/2024-12-8/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>勇敢的人不是不落泪，而是含着泪继续前行。</p>

    </div>
  </div>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划是一种基于分治法与递归思想结合的优化方法。其主要核心思想就是将原问题分解为若干个子问题，然后在子问题上求解，将子问题的解组合起来，从而得到原问题的解。动态规划的核心思想是<strong>最优子结构</strong>，即问题的最优解可以通过子问题的最优解来求解。</p>
<p>以旅行商问题(TSP)为例:<br>首先 问题描述如下：给定 n 个城市，旅行商需要从某个起点城市出发，访问每个城市一次，最后返回起点，且总路径长度最短。</p>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-02 日报 Day54</title>
    <url>/undefined/2025-01-02/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>好书也许不能立马带给你想要的成功，但它们一定能让你成为更好的自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P168-172 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、选择Object还是Map: 对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p>
<ul>
<li>内存占用: Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键&#x2F;值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键&#x2F;值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键&#x2F;值对</li>
<li>插入性能: 向 Object 和 Map 中插入新键&#x2F;值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键&#x2F;值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</li>
<li>查找速度: 与插入不同，从大型 Object 和 Map 中查找键&#x2F;值对的性能差异极小，但如果只包含少量键&#x2F;值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来说是不可能的。对这两个类型而言，查找速度不会随着键&#x2F;值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。</li>
<li>删除性能: 使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。<br>2、WeakMap: ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键&#x2F;值对存储机制。WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。<br>基本API:<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 WeakMap 构造函数可以创建一个空弱映射：</span></span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="comment">// 弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。</span></span><br><span class="line"><span class="comment">// 如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中：</span></span><br><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line"> key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 使用嵌套数组初始化弱映射</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [key2, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key1)); <span class="comment">// val1 </span></span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key2)); <span class="comment">// val2 </span></span><br><span class="line"><span class="title function_">alert</span>(wm1.<span class="title function_">get</span>(key3)); <span class="comment">// val3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> [key1, <span class="string">&quot;val1&quot;</span>], </span><br><span class="line"> [<span class="string">&quot;BADKEY&quot;</span>, <span class="string">&quot;val2&quot;</span>], </span><br><span class="line"> [key3, <span class="string">&quot;val3&quot;</span>] </span><br><span class="line">]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key </span></span><br><span class="line"><span class="keyword">typeof</span> wm2; </span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined </span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作键</span></span><br><span class="line"><span class="keyword">const</span> stringKey = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;key1&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> wm3 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([ </span><br><span class="line"> stringKey, <span class="string">&quot;val1&quot;</span> </span><br><span class="line">]); </span><br><span class="line"><span class="title function_">alert</span>(wm3.<span class="title function_">get</span>(stringKey)); <span class="comment">// &quot;val1&quot;</span></span><br></pre></td></tr></table></figure></div>
初始化之后可以使用 set()再添加键&#x2F;值对，可以使用 get()和 has()查询，还可以使用 delete()删除：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;; </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// undefined </span></span><br><span class="line">wm.<span class="title function_">set</span>(key1, <span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(key2, <span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// Matt </span></span><br><span class="line">wm.<span class="title function_">delete</span>(key1); <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key1)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">has</span>(key2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
set()方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line"> key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line"> key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>().<span class="title function_">set</span>(key1, <span class="string">&quot;val1&quot;</span>);</span><br><span class="line">wm.<span class="title function_">set</span>(key2, <span class="string">&quot;val2&quot;</span>) </span><br><span class="line"> .<span class="title function_">set</span>(key3, <span class="string">&quot;val3&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key1)); <span class="comment">// val1 </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key2)); <span class="comment">// val2 </span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(key3)); <span class="comment">// val3</span></span><br></pre></td></tr></table></figure></div>
3、弱键: WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键&#x2F;值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。<br>来看下面的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line">wm.<span class="title function_">set</span>(&#123;&#125;, <span class="string">&quot;val&quot;</span>);</span><br></pre></td></tr></table></figure></div>
set()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键&#x2F;值对就从弱映射中消失了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键&#x2F;值被破坏以后，值本身也会成为垃圾回收的目标。<br>再看一个稍微不同的例子：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> container = &#123; </span><br><span class="line"> <span class="attr">key</span>: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">wm.<span class="title function_">set</span>(container.<span class="property">key</span>, <span class="string">&quot;val&quot;</span>); </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeReference</span>(<span class="params"></span>) &#123; </span><br><span class="line"> container.<span class="property">key</span> = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键&#x2F;值对清理掉。<br>不可迭代键: 因为 WeakMap 中的键&#x2F;值对任何时候都可能被销毁，所以没必要提供迭代其键&#x2F;值对的能力。当然，也用不着像 clear()这样一次性销毁所有键&#x2F;值的方法。WeakMap 确实没有这个方法。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问 WeakMap 实例，也没办法看到其中的内容。<br>WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了<br>4、弱映射的应用:</li>
<li>私有变量: 弱映射造就了在 JavaScript 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。下面是一个示例实现：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">idProperty</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setId</span>(id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">setPrivate</span>(<span class="params">property, value</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> privateMembers = wm.<span class="title function_">get</span>(<span class="variable language_">this</span>) || &#123;&#125;; </span><br><span class="line"> privateMembers[property] = value; </span><br><span class="line"> wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, privateMembers); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">getPrivate</span>(<span class="params">property</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>)[property]; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">setId</span>(<span class="params">id</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>, id); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="title function_">getId</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 123 </span></span><br><span class="line">user.<span class="title function_">setId</span>(<span class="number">456</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 456 </span></span><br><span class="line"><span class="comment">// 并不是真正私有的</span></span><br><span class="line"><span class="title function_">alert</span>(wm.<span class="title function_">get</span>(user)[user.<span class="property">idProperty</span>]); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure></div>
慧眼独具的读者会发现，对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以取得“私有”变量了。为了避免这种访问，可以用一个闭包把 WeakMap 包装起来，这样就可以把弱映射与外界完全隔离开了：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = (<span class="function">() =&gt;</span> &#123; </span><br><span class="line"> <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">User</span> &#123; </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">idProperty</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>); </span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setId</span>(id); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="title function_">setPrivate</span>(<span class="params">property, value</span>) &#123; </span><br><span class="line">        <span class="keyword">const</span> privateMembers = wm.<span class="title function_">get</span>(<span class="variable language_">this</span>) || &#123;&#125;; </span><br><span class="line">        privateMembers[property] = value; </span><br><span class="line">        wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, privateMembers); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getPrivate</span>(<span class="params">property</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>)[property]; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="title function_">setId</span>(<span class="params">id</span>) &#123; </span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>, id); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="title function_">getId</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">User</span>; </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 123 </span></span><br><span class="line">user.<span class="title function_">setId</span>(<span class="number">456</span>); </span><br><span class="line"><span class="title function_">alert</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure></div>
这样，拿不到弱映射中的健，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但整个代码也完全陷入了 ES6 之前的闭包私有变量模式。</li>
<li>DOM节点元数据: 因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中使用了常规的 Map：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></div>
假设在上面的代码执行后，页面被 JavaScript 改变了，原来的登录按钮从 DOM 树中被删掉了。但由于映射中还保存着按钮的引用，所以对应的 DOM 节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。<br>如果这里使用的是弱映射，如以下代码所示，那么当节点从 DOM 树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）：<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); </span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#login&#x27;</span>); </span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.<span class="title function_">set</span>(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-04 日报 Day56</title>
    <url>/undefined/2025-01-04/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>每个人都想有所成就，却不知信手拈来的从容都是厚积薄发的沉淀。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS 红皮书 P176- 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、从各方面来看，Set 跟 Map 都很相似，只是 API 稍有调整。唯一需要强调的就是集合的 API 对自身的简单操作。很多开发者都喜欢使用 Set 操作，但需要手动实现：或者是子类化 Set，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。<br> 某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。<br> Set 保留插入顺序，所有方法返回的集合必须保证顺序。<br> 尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。<br> 不要修改已有的集合实例。union(a, b)或 a.union(b)应该返回包含结果的新集合实例。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Set</span> &#123;</span><br><span class="line">  <span class="title function_">union</span>(<span class="params">...sets</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">union</span>(<span class="variable language_">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">intersection</span>(<span class="params">...sets</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">intersection</span>(<span class="variable language_">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">difference</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">difference</span>(<span class="variable language_">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">symmetricDifference</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">symmetricDifference</span>(<span class="variable language_">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">cartesianProduct</span>(<span class="params">set</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">cartesianProduct</span>(<span class="variable language_">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">powerSet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">XSet</span>.<span class="title function_">powerSet</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的并集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">union</span>(<span class="params">a, ...bSets</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        unionSet.<span class="title function_">add</span>(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的交集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">intersection</span>(<span class="params">a, ...bSets</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b.<span class="title function_">has</span>(aValue)) &#123;</span><br><span class="line">          intersectionSet.<span class="title function_">delete</span>(aValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">difference</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="title class_">XSet</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.<span class="title function_">has</span>(bValue)) &#123;</span><br><span class="line">        differenceSet.<span class="title function_">delete</span>(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">symmetricDifference</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">union</span>(b).<span class="title function_">difference</span>(a.<span class="title function_">intersection</span>(b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line">  <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">cartesianProduct</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> <span class="title class_">XSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        cartesianProductSet.<span class="title function_">add</span>([aValue, bValue]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartesianProductSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">powerSet</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> powerSet = <span class="keyword">new</span> <span class="title class_">XSet</span>().<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">XSet</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> set <span class="keyword">of</span> <span class="keyword">new</span> <span class="title class_">XSet</span>(powerSet)) &#123;</span><br><span class="line">        powerSet.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">XSet</span>(set).<span class="title function_">add</span>(aValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> powerSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-06 日报 Day21</title>
    <url>/undefined/2025-03-06/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>真正的力量，往往并非来源于成绩的辉煌，而是来自于内心的平静与坚持，是在面对风雨时依然能够保持的一份从容与勇气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>LeetCode 双指针之移动零、盛最多水的容器、三数之和、接雨水</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-05 日报 Day20</title>
    <url>/undefined/2025-03-05/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>且以青春赴山海,<br>青舟无惧万重山。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>LeetCode 双指针之移动零、盛最多水的容器、三数之和</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-07 日报 Day22</title>
    <url>/undefined/2025-03-07/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>我将玫瑰藏于身后，风起花落，从此鲜花赠自己，纵马踏花向自由。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 滑动窗口之无重复字符的最长子串、找到字符串中所有字母异位词</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-08 日报 Day23</title>
    <url>/undefined/2025-03-08/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>所有难过，难是难，但总会过。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 子串之和为K的子数组、滑动窗口最大值</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-04 日报 Day19</title>
    <url>/undefined/2025-03-04/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>前期回顾</p>

    </div>
    <div class="notel-content">
      <p>人生的魅力就在于未知。最近发生了许多的事情，但anyway，打不死我的只会让我更强大，重整旗鼓，继续前行。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>LeetCode 哈希表HOT100之两数之和、字母异位词分组、最长连续序列</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-09 日报 Day24</title>
    <url>/undefined/2025-03-09/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>蹉跎只能感动自己，行动才能打动别人。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 子串之最小覆盖子串</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-11 日报 Day26</title>
    <url>/undefined/2025-03-11/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>如果你热爱生活，生活一定比谁都清楚。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之轮转数组、除自身以外数组的乘积</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-10 日报 Day25</title>
    <url>/undefined/2025-03-10/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有输得起的勇气，才会有赢得到的底气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之最大子数组和合并区间</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-01-03 日报 Day55</title>
    <url>/undefined/2025-01-03/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日的鸡汤</p>

    </div>
    <div class="notel-content">
      <p>往后时光，愿你能扛事、懂翻篇，有静下来的力量，也有向内看的能力。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、JS红皮书P173-175 第六章：集合引用类型</p>
<h3 id="今日笔记"><a href="#今日笔记" class="headerlink" title="今日笔记"></a>今日笔记</h3><p>1、ECMAScript 6 新增的 Set 是一种新集合类型，为这门语言带来集合数据结构。Set 在很多方面都像是加强的 Map，这是因为它们的大多数 API 和行为都是共有的。<br>基本API:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 Set 构造函数可以创建一个空集合：</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="comment">// 如果想在创建的同时初始化实例，可以给 Set 构造函数传入一个可迭代对象，需要包含值数组。可迭代对象中的每个值都会按照迭代顺序插入到新集合实例中：</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="title function_">alert</span>(s1.<span class="property">size</span>); <span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>(&#123; </span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">alert</span>(s2.<span class="property">size</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>
<p>初始化之后，可以使用 add()方法添加值。另外，可以使用 has()进行查询，可以通过 size 属性获取集合中的值的数量，还可以使用 delete()和 clear()删除值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 0 </span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&quot;Matt&quot;</span>) </span><br><span class="line"> .<span class="title function_">add</span>(<span class="string">&quot;Frisbie&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 2 </span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="string">&quot;Matt&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">s.<span class="title function_">clear</span>(); <span class="comment">// 销毁集合实例中的所有值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></div>
<p>与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作（ECMAScript 内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="title class_">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">s.<span class="title function_">add</span>(functionVal); </span><br><span class="line">s.<span class="title function_">add</span>(symbolVal); </span><br><span class="line">s.<span class="title function_">add</span>(objectVal); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(functionVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(symbolVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(objectVal)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// SameValueZero 检查意味着独立的实例不会冲突</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;, </span><br><span class="line"> arrVal = []; </span><br><span class="line">s.<span class="title function_">add</span>(objVal); </span><br><span class="line">s.<span class="title function_">add</span>(arrVal); </span><br><span class="line">objVal.<span class="property">bar</span> = <span class="string">&quot;bar&quot;</span>; </span><br><span class="line">arrVal.<span class="title function_">push</span>(<span class="string">&quot;bar&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(objVal)); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">has</span>(arrVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p>add()和 delete()操作是幂等的。delete()返回一个布尔值，表示集合中是否存在要删除的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); </span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">size</span>); <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 集合里有这个值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 集合里没有这个值</span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>Set 会维护值插入时的顺序，因此支持按顺序迭代。集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">values</span> === s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="title function_">alert</span>(s.<span class="property">keys</span> === s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) &#123; </span><br><span class="line"> <span class="title function_">alert</span>(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// val1 </span></span><br><span class="line"><span class="comment">// val2 </span></span><br><span class="line"><span class="comment">// val3</span></span><br></pre></td></tr></table></figure></div>
<p>因为 values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"><span class="keyword">const</span> arr = [...s];</span><br><span class="line"><span class="title function_">alert</span>(arr); <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>集合的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.<span class="title function_">entries</span>()) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(pair); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// [&quot;val1&quot;, &quot;val1&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val2&quot;, &quot;val2&quot;] </span></span><br><span class="line"><span class="comment">// [&quot;val3&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure></div>
<p>如果不使用迭代器，而是使用回调方式，则可以调用集合的 forEach()方法并传入回调，依次迭代每个键&#x2F;值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]); </span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>)); </span><br><span class="line"><span class="comment">// val1 -&gt; val1 </span></span><br><span class="line"><span class="comment">// val2 -&gt; val2 </span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure></div>
<p>修改集合中值的属性不会影响其作为集合值的身份：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val1&quot;</span>]); </span><br><span class="line"><span class="comment">// 字符串原始值作为值不会被修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.<span class="title function_">values</span>()) &#123;</span><br><span class="line">     value = <span class="string">&quot;newVal&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(value); <span class="comment">// newVal </span></span><br><span class="line"> <span class="title function_">alert</span>(s1.<span class="title function_">has</span>(<span class="string">&quot;val1&quot;</span>)); <span class="comment">// true </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> valObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([valObj]); </span><br><span class="line"><span class="comment">// 修改值对象的属性，但对象仍然存在于集合中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s2.<span class="title function_">values</span>()) &#123; </span><br><span class="line"> value.<span class="property">id</span> = <span class="string">&quot;newVal&quot;</span>; </span><br><span class="line"> <span class="title function_">alert</span>(value); <span class="comment">// &#123;id: &quot;newVal&quot;&#125; </span></span><br><span class="line"> <span class="title function_">alert</span>(s2.<span class="title function_">has</span>(valObj)); <span class="comment">// true </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">alert</span>(valObj); <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>journal</category>
      </categories>
      <tags>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-13 日报 Day28</title>
    <url>/undefined/2025-03-13/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你做三四月的事，在八九月自有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之缺失的第一个正数</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-12 日报 Day27</title>
    <url>/undefined/2025-03-12/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你做三四月的事，在八九月自有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之轮转数组、除自身以外数组的乘积</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-17 日报 Day32</title>
    <url>/undefined/2025-03-17/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>想要成为什么人，就努力靠近什么样的人。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之旋转图像</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-14 日报 Day29</title>
    <url>/undefined/2025-03-14/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你做三四月的事，在八九月自有答案。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 普通数组之缺失的第一个正数</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-18 日报 Day33</title>
    <url>/undefined/2025-03-18/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>勇敢地迈出第一步，是治愈焦虑的良药。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之搜索二维矩阵 II</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-15 日报 Day30</title>
    <url>/undefined/2025-03-15/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>多一分坚持，就会少一分遗憾。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之矩阵置零</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-16 日报 Day31</title>
    <url>/undefined/2025-03-16/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>那些难走的路，往往都是向上的路。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 矩阵之螺旋矩阵</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-22 日报 Day37</title>
    <url>/undefined/2025-03-22/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>假如生活抛来一颗柠檬，你大可以选择把它榨成鲜美的柠檬汁。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之合并两个有序链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-20 日报 Day35</title>
    <url>/undefined/2025-03-20/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>读书就是用最低廉的成本走最高级的成长路。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之反转链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-19 日报 Day34</title>
    <url>/undefined/2025-03-19/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有风有雨是人生的常态，迎难而上才能逆风翻盘。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之相交链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-25 日报 Day39</title>
    <url>/undefined/2025-03-25/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>自律和不自律，都会吃苦。不同的是，自律的苦会让人生越来越甜</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之两两交换链表中的节点</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-21 日报 Day36</title>
    <url>/undefined/2025-03-21/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>你的迷茫，大多都是因为想得太多、做得太少。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之回文链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-23 日报 Day38</title>
    <url>/undefined/2025-03-23/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>如果真的有谁能改变命运，推翻自己身上的偏见，那一定是你自己。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之两数相加</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-24 日报 Day39</title>
    <url>/undefined/2025-03-24/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>把心放宽，该看开的看开，该放下的放下，才能看到不同的风景。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之删除链表的倒数第N个结点</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-29 日报 Day43</title>
    <url>/undefined/2025-03-29/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>没有完美的人生，但成熟的人，会懂得如何让自己变得更好。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之合并k个升序链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-30 日报 Day44</title>
    <url>/undefined/2025-03-30/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>有梦想的人，总是知道自己要什么，一步一个脚印地让梦想离自己更近。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之LRU缓存</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-31 日报 Day45</title>
    <url>/undefined/2025-03-31/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>一次又一次的努力，会不断激发你的潜力，促使你成长为自己期待的样子。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 二叉树之二叉树的中序遍历</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-27 日报 Day41</title>
    <url>/undefined/2025-03-27/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>那些失意和受挫不过是人生的插曲，十年后回头再看，或许已成为财富。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之随机链表的复制</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-26 日报 Day40</title>
    <url>/undefined/2025-03-26/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>远离不必要的计较和纠缠，把每一个平凡的日子都活出热气腾腾的样子。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之k个一组翻转链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-03-28 日报 Day42</title>
    <url>/undefined/2025-03-28/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>今日鸡汤</p>

    </div>
    <div class="notel-content">
      <p>不要害怕一次的选择会改变自己的一生，要有一切推倒重来的勇气。</p>

    </div>
  </div>

<h3 id="今日学习内容"><a href="#今日学习内容" class="headerlink" title="今日学习内容"></a>今日学习内容</h3><p>1、LeetCode 链表之排序链表</p>
]]></content>
      <categories>
        <category>journal</category>
        <category>lowcode</category>
      </categories>
      <tags>
        <tag>journal</tag>
        <tag>lowcode</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC</title>
    <url>/Yuyang/BFC/</url>
    <content><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC(Block Formatting Context) 是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level box 如何布局，并且与这个区域外部毫不相干。</p>
<h2 id="BFC-的布局规则"><a href="#BFC-的布局规则" class="headerlink" title="BFC 的布局规则"></a>BFC 的布局规则</h2><ul>
<li>内部的 Box 会在垂直方向，一个接一个地放置。</li>
<li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li>
<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触（对于从左往右的格式化，否则相反），即使存在浮动也是如此。</li>
<li>BFC 的区域不会与 float box 重叠。</li>
<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。</li>
<li>计算 BFC 的高度时，浮动元素也参与计算。</li>
</ul>
<h2 id="BFC的触发条件"><a href="#BFC的触发条件" class="headerlink" title="BFC的触发条件"></a>BFC的触发条件</h2><ul>
<li>根元素，即 HTML 元素</li>
<li>float 的值不为 none</li>
<li>overflow 的值不为 visible</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>position 的值为 absolute 或 fixed</li>
<li>flex 元素的子元素，且父元素的 display 值为 flex 或 inline-flex</li>
</ul>
<h2 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h2><ul>
<li>阻止 margin 重叠<br>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠,以最大的为准。<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>避免重叠可以在box外面包裹一层容器，并触发这个容器生成一个BFC，此时不会出现margin重叠</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>这时候box1和box2的margin不会重叠</p>
<ul>
<li>清除浮动<br>有浮动样式</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410201531989.png"
                      alt="image-20241020153054705"
                ></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix-example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落，如果不清除浮动，它会和上面的浮动框重叠。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#eaf2f8</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.float-box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#3498db</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.clearfix-example</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#f9e79f</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>清除浮动后</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410201534497.png"
                      alt="image-20241020153407574"
                ></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span>浮动框 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix-example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落，如果不清除浮动，它会和上面的浮动框重叠。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#eaf2f8</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.float-box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#3498db</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.clearfix-example</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#f9e79f</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>自适应两栏布局<br>这里以两栏布局为例</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410201541730.png"
                      alt="image-20241020154148226"
                ></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.aside</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此。而BFC的区域不会与浮动盒子重叠，所以可以通过触发main生成一个BFC来实现两栏布局</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BFC 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.aside</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202036606.png"
                      alt="image-20241020203632868"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>CSS 盒模型</title>
    <url>/Yuyang/CSS_BOX_MODEL/</url>
    <content><![CDATA[<h2 id="CSS-盒模型介绍"><a href="#CSS-盒模型介绍" class="headerlink" title="CSS 盒模型介绍"></a>CSS 盒模型介绍</h2><p>CSS中的盒模型用来描述一个元素在页面汇总的布局方式，每个HTML元素都被视为是一个矩形的盒子，这个盒子由实际内容（content）、外边距（margin）、边框（border）和内边距（padding）组成。<br>CSS盒模型主要包含两种：W3C标准盒子模型和IE怪异盒子模型。</p>
<p>CSS的box-sizing属性定义了引擎如何计算一个元素的总宽度和总高度</p>
<p>box-sizing: content-box ｜ border-box ｜inherit</p>
<ul>
<li>content-box 默认值，元素的 width&#x2F;height 不包含 padding，border 与标准盒子模型表现一致</li>
<li>border-box 元素的 width&#x2F;height 包含 padding，border，与怪异盒子模型表现一致</li>
<li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li>
</ul>
<h3 id="标准盒子模型："><a href="#标准盒子模型：" class="headerlink" title="标准盒子模型："></a>标准盒子模型：</h3><ul>
<li>盒子总宽度 &#x3D; width + padding + border + margin</li>
<li>盒子总高度 &#x3D; height + padding + border + margin</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410200006845.png"
                      alt="image-20241020000606496"
                ></p>
<h3 id="IE怪异盒子模型："><a href="#IE怪异盒子模型：" class="headerlink" title="IE怪异盒子模型："></a>IE怪异盒子模型：</h3><ul>
<li>盒子总宽度 &#x3D; width + margin</li>
<li>盒子总高度 &#x3D; height + margin</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410200018782.png"
                      alt="image-20241020001810933"
                ></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS 盒模型示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>W3C 标准盒子模型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>IE 怪异盒子模型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#3498db</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#3498db</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>自动化构建</title>
    <url>/Yuyang/autoBuild/</url>
    <content><![CDATA[<h2 id="自动化构建方案"><a href="#自动化构建方案" class="headerlink" title="自动化构建方案"></a>自动化构建方案</h2><p>通过自动化手段 提高效率 可靠性</p>
<p>构建工具： grunt webpack gulp vite rollup esbuild swc turbopack</p>
<p>编译 测试 部署 区分环境</p>
<h2 id="构建的整体设计思路"><a href="#构建的整体设计思路" class="headerlink" title="构建的整体设计思路"></a>构建的整体设计思路</h2><ul>
<li><p>构建工具的选择</p>
<p>实际业务触发</p>
<ul>
<li>UI rollup</li>
<li>小型项目 vite</li>
<li>大型项目 vite webpack</li>
<li>swc swc-loader 对标 babel-loader &#x3D;&gt; ast</li>
</ul>
</li>
<li><p>确定构建流程</p>
<ul>
<li>loader（解析 编译 文件处理）webpack 需要了解 基础</li>
<li>plugin  增强 最后阶段进行输出 webpack</li>
</ul>
</li>
<li><p>确定构建产物的输出</p>
<ul>
<li>分chunk输出 可以对内容进行按需加载</li>
</ul>
</li>
<li><p>优化打包构建流程</p>
<ul>
<li>review构建过程 优化部分阶段</li>
<li>怎么让打出来的包体积更小？</li>
<li>tree shaking webpack 静态编译的时候<ul>
<li>尽量减少commonjs库的使用，尽量使用esm的库？</li>
</ul>
</li>
<li>按需加载（异步组件）把非首屏的组件异步出来</li>
<li>配合缓存 splitChunks<ul>
<li>不怎么变动的包打包到一起 vue pinia vue-router vrender.js<ul>
<li>优势 减小入口js体积</li>
<li>vender 利用缓存 无需跟新</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>….</p>
<ul>
<li><p>externals 通过这种方式导入第三方资源</p>
<ul>
<li>微前端 引用公共资源</li>
</ul>
</li>
<li><p>提升构建速度</p>
<ul>
<li>空间 时间<ul>
<li>缓存 cache</li>
<li>利用好计算机算力</li>
<li>多线程打包 happy-pack thread-loader</li>
</ul>
</li>
</ul>
</li>
<li><p>构建的技术选型和方案</p>
</li>
<li><p>初始化工程</p>
</li>
<li><p>依赖盘点与安装</p>
</li>
<li><p>确定一些工程化脚本</p>
</li>
<li><p>start build</p>
</li>
<li><p>test lint type-check</p>
</li>
<li><p>基于git钩子 commit pre-commit</p>
</li>
<li><p>前端代码规范 确定代码规范 ts eslint spellcheck git flow 规范</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>tapbale 组织这条复杂的生产线</p>
</li>
<li><p>事件发布订阅机制</p>
</li>
<li><p>广播事件</p>
<h3 id="tapbale"><a href="#tapbale" class="headerlink" title="tapbale"></a>tapbale</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化钩子</span></span><br><span class="line"><span class="keyword">const</span> hook = <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&#x27;compilation&#x27;</span>])</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>事件注册</p>
</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">hook.<span class="title function_">tap</span>(<span class="string">&quot;flag1&quot;</span>,<span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(compilation)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>事件执行</li>
</ul>
<p>call()</p>
<h3 id="compilation"><a href="#compilation" class="headerlink" title="compilation"></a>compilation</h3><p>compilation 对象包含当前的模块资源 编译生成的资源 变化的文件</p>
<p>compiler 包含 webpack所有配置信息 options loaders plugins全局唯一的</p>
<p>compiler &#x3D;&gt; compilation</p>
]]></content>
  </entry>
  <entry>
    <title>Blockchain and Money Session1</title>
    <url>/Yuyang/MIT15-S12-session1/</url>
    <content><![CDATA[<p>最近在学习这个区块链课程，单纯记录一下学习笔记。</p>
<p>The Internet: Layers of open protocols</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408060025360.png"
                      alt="image-20240806002506930"
                ></p>
<h2 id="what-is-a-blockchain？"><a href="#what-is-a-blockchain？" class="headerlink" title="what is a blockchain？"></a>what is a blockchain？</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408060032056.png"
                      alt="image-20240806003227672"
                ></p>
<p>区块链技术</p>
<ul>
<li>Verifiably moves ‘data’ on a decentralized network </li>
<li>The ‘data’ can represent value or computer code </li>
<li>Thus it goes directly to the plumbing of the financial sector and money </li>
<li>Broad adoption rests on addressing technical, commercial and public policy hurdles </li>
<li>It can be a catalyst for change in the world of finance and money</li>
</ul>
<h2 id="What-is-the-Role-of-Money"><a href="#What-is-the-Role-of-Money" class="headerlink" title="What is the Role of Money?"></a>What is the Role of Money?</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408060118524.png"
                      alt="image-20240806011757446"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/Yuyang/autoTest/</url>
    <content><![CDATA[<h2 id="自动化测试与技术选型"><a href="#自动化测试与技术选型" class="headerlink" title="自动化测试与技术选型"></a>自动化测试与技术选型</h2><h3 id="认识并使用jest"><a href="#认识并使用jest" class="headerlink" title="认识并使用jest"></a>认识并使用jest</h3><h3 id="e2e测试"><a href="#e2e测试" class="headerlink" title="e2e测试"></a>e2e测试</h3><h3 id="devops"><a href="#devops" class="headerlink" title="devops"></a>devops</h3><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h4 id="为什么需要测试"><a href="#为什么需要测试" class="headerlink" title="为什么需要测试"></a>为什么需要测试</h4><p>让程序稳定健壮，提高代码质量，减少bug，提高开发效率。</p>
<ul>
<li>频繁变动的需求</li>
<li>人力成本</li>
<li>不太重视</li>
</ul>
<h4 id="什么时候-或者什么场景需要考虑自动化测试"><a href="#什么时候-或者什么场景需要考虑自动化测试" class="headerlink" title="什么时候 或者什么场景需要考虑自动化测试"></a>什么时候 或者什么场景需要考虑自动化测试</h4><ul>
<li>公共库项目开发维护 vue react babel</li>
<li>中长期项目</li>
<li>需求趋于稳定后的系统</li>
</ul>
<h4 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h4><ul>
<li>单元测试 Unit Test 小的功能的测试 Jest @vue&#x2F;test-utils Mocha</li>
<li>集成测试 Integration Test 小的模块测试</li>
<li>端到端测试 End-to-End Test 从页面出发去测试一些功能</li>
<li>E2E测试 End-to-End Test (UI+接口) puppeteer</li>
</ul>
<p>断言库 Assert</p>
<h2 id="单元测试原理"><a href="#单元测试原理" class="headerlink" title="单元测试原理"></a>单元测试原理</h2><p>通过一些测试用例 来编写测试代码 保证测试用例通过</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="comment">// import chalk from &#x27;chalk&#x27;</span></span><br><span class="line"><span class="comment">// 描述测试场景</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">describe</span>(<span class="params">desc, fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(desc))</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试的测试描述</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">it</span>(<span class="params">desc, fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">yellow</span>(desc))</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expect</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">toBe</span>(<span class="params">actual</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result != actual) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;FAIL&#x27;</span>, result, actual))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`预期值和实际值不相等，预期<span class="subst">$&#123;actual&#125;</span>,实际是<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, result, actual)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">toEqual</span>(<span class="params">actual</span>) &#123;</span><br><span class="line">      <span class="comment">//   if (result != actual) &#123;</span></span><br><span class="line">      <span class="comment">//     console.log(chalk.red(&#x27;FAIL&#x27;, result, actual))</span></span><br><span class="line">      <span class="comment">//     throw new Error(`预期值和实际值不相等，预期$&#123;actual&#125;,实际是$&#123;result&#125;`)</span></span><br><span class="line">      <span class="comment">//   &#125;</span></span><br><span class="line">      <span class="comment">//   console.log(&#x27;success&#x27;, result, actual)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  describe,</span><br><span class="line">  it,</span><br><span class="line">  expect,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect, describe, it &#125; = <span class="built_in">require</span>(<span class="string">&quot;./test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;用来测试sum函数&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;1 + 1 = 2&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">expect</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">1</span>)).<span class="title function_">toBe</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;1 + 2 = 3&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">expect</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>)).<span class="title function_">toBe</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&quot;2 + 3 = 5&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">expect</span>(<span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">3</span>)).<span class="title function_">toBe</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="JEST"><a href="#JEST" class="headerlink" title="JEST"></a>JEST</h3><ul>
<li>快照测试</li>
<li>测试覆盖率</li>
<li>基本使用<ul>
<li>基本方法测试</li>
</ul>
</li>
</ul>
<h4 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h4><ul>
<li>describe 将多个相关的测试进行组合 组合到一块</li>
<li>it </li>
<li>expect 断言</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul>
<li>beforeAll 所有用例执行前调用</li>
<li>beforeEach 每个测试用例执行前调用</li>
<li>after All 执行结束后调用</li>
<li>afterEach 每个执行后调用</li>
</ul>
<h4 id="断言钩子"><a href="#断言钩子" class="headerlink" title="断言钩子"></a>断言钩子</h4><ul>
<li>toBe 严格比对 &#x3D;&#x3D;&#x3D; 内存空间都是一致的</li>
<li>toEqual 值比对 对象 递归遍历 比对值</li>
</ul>
<h4 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h4><p>确保UI不会有意外的改变</p>
<h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><ul>
<li>stmts 语句覆盖率</li>
<li>branch 是否执行了每个分支</li>
<li>funcs 函数覆盖率</li>
<li>lines 是否执行每一行代码</li>
</ul>
<h2 id="E2E测试"><a href="#E2E测试" class="headerlink" title="E2E测试"></a>E2E测试</h2><p>puppeteer 无头浏览器</p>
<p>cypress</p>
<h3 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h3><p>node库 chrome</p>
<p>在node环境下面对浏览器行为进行控制</p>
<ul>
<li>生成页面快照 图片 pdf</li>
<li>抓取spa</li>
<li>从网站上抓取需要的内容</li>
<li>自动表单提交 UI 测试 键盘输入</li>
<li>测试chrome扩展</li>
<li>抓取应用的性能数据</li>
</ul>
<h4 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h4><ul>
<li>browser 浏览器实例</li>
<li>page页面</li>
<li>executionContext js执行环境</li>
<li>elementhandle 对应dom的元素借点</li>
<li>jshandler js对象</li>
</ul>
<h4 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h4><ul>
<li>表单输入 用户名 密码 提交 页面跳转</li>
<li>体验优化 生成骨架屏 直接使用对应的页面截图</li>
</ul>
<p>puppteer 制定一些规则 img 灰色代码块替换</p>
<h4 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h4><p>工程化 &#x3D;&gt; 研发工作台 &#x3D;&gt; 管理维护 发布 运维</p>
<p>ci </p>
<p>构建 &#x3D;&gt; 生成最终构建产物</p>
<p>Test &#x3D;&gt; 保证产物健壮性</p>
<p>cd</p>
<p>最后阶段 &#x3D;&gt; 发布到对应的环境上 &#x3D;&gt; 线上服务器 nginx</p>
<h4 id="git-action-自动化部署"><a href="#git-action-自动化部署" class="headerlink" title="git action 自动化部署"></a>git action 自动化部署</h4><p>workflow 工作流程</p>
<ul>
<li><p>配置文件</p>
</li>
<li><p>   .github&#x2F;workflows</p>
</li>
<li><p>   xxx.yml</p>
<ul>
<li>   name workflow名称</li>
<li>   on:[push pull_request]</li>
</ul>
</li>
<li><p>job 任务 可以配置一项或者多项任务</p>
<ul>
<li>name 名称 任务说明</li>
<li>needs 运行顺序<ul>
<li>jobs:<ul>
<li>job1:</li>
<li>job2:<ul>
<li>needs: job1</li>
</ul>
</li>
<li><h2 id="job3-needs-job1-job2-runs-on-ubuntuxx"><a href="#job3-needs-job1-job2-runs-on-ubuntuxx" class="headerlink" title="job3:- needs: [job1, job2]  - runs-on: ubuntuxx"></a>job3:<br>- needs: [job1, job2]<br>  - runs-on: ubuntuxx</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>step 步骤</p>
<ul>
<li>name 步骤名称</li>
<li>run 执行的命令 action</li>
<li>env 环境变量</li>
</ul>
</li>
<li><p>action 动作</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>响应式设计</title>
    <url>/Yuyang/RWD/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的需求包含平台的H5和PC端，为了适应不同的屏幕尺寸，我们需要做响应式设计。<br>响应式网站设计（Responsive Web Design）是一种网络页面设计布局，页面的设计与开发应该根据用户行为以及设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相应的响应和调整。响应式设计是一种优化设计，不同于传统的网站设计，它可以使网站在不同的设备上显示效果更加友好，提高用户体验。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>响应式设计的基本原理可以根据不同的设备设置不同的样式，为了处理移动端，页面头部必须有meta标签，设置viewport。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>属性对应如下:</p>
<ul>
<li>width&#x3D;device-width: 宽度等于设备宽度</li>
<li>maximum-scale: 是缩放比例的最大值</li>
<li>initial-scale: 是初始缩放比例</li>
<li>user-scalable: 是否允许用户缩放页面</li>
</ul>
<p>实现响应式的方式有如下：</p>
<ul>
<li>媒体查询</li>
<li>百分比</li>
<li>vw&#x2F;vh</li>
<li>rem</li>
</ul>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是CSS3的一个模块，它允许你查询设备的特性，比如视口的宽度、高度、设备的宽度、高度等等。通过媒体查询，可以为不同的设备设置不同的样式。</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen (<span class="attribute">min-width</span>: <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面的代码表示，当屏幕宽度大于375px和小于600px时，body的背景颜色为lightblue。</p>
<ul>
<li><p>demo:</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>响应式设计示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">header</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#3498db</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.navbar</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex-wrap</span>: wrap;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">gap</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">article</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">3</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#eaf2f8</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">aside</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#f9e79f</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">footer</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: <span class="number">#2c3e50</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">article</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">header</span> <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.navbar</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的响应式网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>服务<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>文章标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些内容。这段内容会根据屏幕的大小自动调整布局。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是侧边栏的内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>版权所有 © 2024 Yuyang<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>手机版</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202350100.png"
                      alt="image-20241020234953469"
                ></p>
<ul>
<li><p>平板</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202350281.png"
                      alt="image-20241020235037286"
                ></p>
</li>
<li><p>PC网页</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410202351402.png"
                      alt="image-20241020235116130"
                ></p>
<h3 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h3><p>百分比是相对于父元素的百分比，可以根据父元素的大小来设置子元素的大小。</p>
<h3 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw&#x2F;vh"></a>vw&#x2F;vh</h3><p>vw和vh是相对于视口的宽度和高度的百分比，1vw等于视口宽度的1%，1vh等于视口高度的1%。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem是相对于根元素的字体大小的单位，1rem等于根元素的字体大小。rem的好处是可以根据根元素的字体大小来设置子元素的大小，方便调整。默认情况下浏览器字体大小为16px, 此时1rem &#x3D; 16px。</p>
<p>为了更准确监听监听设备可视窗口变化，我们可以在css之前插入script标签，代码实现如下：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">init</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> width = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = width / <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">init</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听手机旋转事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;orientationchange&#x27;</span>, init);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听手机窗口大小变化事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, init);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="rem和em的区别"><a href="#rem和em的区别" class="headerlink" title="rem和em的区别"></a>rem和em的区别</h4><ul>
<li>rem是相对于根元素的字体大小的单位，1rem等于根元素的字体大小。</li>
<li>em是相对于父元素的字体大小的单位，1em等于父元素的字体大小。</li>
</ul>
<table>
<thead>
<tr>
<th>特点</th>
<th>em</th>
<th>rem</th>
</tr>
</thead>
<tbody><tr>
<td><strong>相对基准</strong></td>
<td>相对于<strong>父元素的字体大小</strong></td>
<td><strong>相对于</strong>根元素<html> <strong>的字体大小</strong></td>
</tr>
<tr>
<td><strong>嵌套影响</strong></td>
<td>受父级元素的字体大小影响，可能层层放大</td>
<td>不受嵌套结构影响，保持一致的参考大小</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>适用于局部样式调整，比如按钮、标题等</td>
<td>适用于全局布局，确保页面一致性和可控性</td>
</tr>
<tr>
<td><strong>优缺点</strong></td>
<td>灵活但复杂，容易因嵌套变动导致不可预期的结果</td>
<td>简单且稳定，方便全局控制字体和布局</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>前端编码规范工程化</title>
    <url>/Yuyang/baseconfigcli/</url>
    <content><![CDATA[<h2 id="前端规范"><a href="#前端规范" class="headerlink" title="前端规范"></a>前端规范</h2><p>1、React Vue Js Ts 代码规范 eslint<br>2、Css Less Scss css预处理器 代码规范 stylelint<br>3、git commitlint 规范提交信息 husky<br>4、markdownlint 规范 markdown 代码</p>
<p>lint 收敛 CLI</p>
<p>1、一键接入、一键扫描、一键修复、一键升级</p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>多包：monorepo lerna</li>
<li>包管理工具：pnpm</li>
<li>lint:<ul>
<li>eslint</li>
<li>stylelint</li>
<li>commitlint</li>
<li>markdownlint</li>
<li>prettier</li>
</ul>
</li>
<li>CLI</li>
<li>Jest mocha</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>浏览器引擎（Browser engine/ layout engine + rendering engine）</title>
    <url>/Yuyang/browserEngine/</url>
    <content><![CDATA[<p><a class="link"   href="https://en.wikipedia.org/wiki/Browser_engine" >https://en.wikipedia.org/wiki/Browser_engine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>浏览器引擎：<a class="link"   href="https://taligarsiel.com/Projects/howbrowserswork1.htm" >https://taligarsiel.com/Projects/howbrowserswork1.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="The-browser-List"><a href="#The-browser-List" class="headerlink" title="The browser List:"></a>The browser List:</h2><p>Internet Explorer, Firefox, Safari, Chrome.</p>
<h2 id="Browser-Functionality"><a href="#Browser-Functionality" class="headerlink" title="Browser Functionality:"></a>Browser Functionality:</h2><p>The browser main functionality is to present the web resource you choose, by requesting it from the server and displaying it on the browser window. The resource format is usually HTML but also PDF, image and more. The location of the resource is specified by the user using a URI (Uniform resource Identifier).<br>Browsers’ user interface have a lot in common with each other. Among the common user interface elements are:</p>
<ul>
<li>Address bar for inserting a URI</li>
<li>Back and forward buttons</li>
<li>Bookmarking options</li>
<li>Refresh and stop buttons for refreshing or stopping the loading of current documents</li>
<li>Home button that gets you to your home page</li>
</ul>
<h2 id="The-main-components-of-a-browser"><a href="#The-main-components-of-a-browser" class="headerlink" title="The main components of a browser:"></a>The main components of a browser:</h2><ul>
<li>The user interface: this includes the address bar, back&#x2F;forward button, bookmarking menu etc.</li>
<li>The browser engine: the interface for querying and manipulating the rendering engine.</li>
<li>The rendering engine: responsible for displaying the requested content. For example if the requested content is HTML, it is responsible for parsing the HTML and CSS and displaying the parsed content on the screen.</li>
<li>Networking: for network calls such as HTTP requests, using different implementations for different platform behind a platform-independent interface.</li>
<li>UI backend: used for drawing basic widgets like combo boxes and windows. It exposes a generic interface that is not platform specific. Underneath it uses the operating system user interface methods.</li>
<li>JavaScript interpreter: Used to parse and execute the JavaScript code.</li>
<li>Data storage: This is a persistence layer. The browser needs to save all sorts of data on the hard disk, such as cookies. Browsers also support storage mechanisms such as localStorage, IndexedDB, WebSQL and FileSystem.</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/layers.png"
                      alt="img"
                ></p>
<h2 id="The-Rendering-Engine"><a href="#The-Rendering-Engine" class="headerlink" title="The Rendering Engine:"></a>The Rendering Engine:</h2><p>Both chrome and safari use the WebKit rendering engine. Firefox uses Gecko. Internet Explorer uses Trident.<br>Webkit is an open source rendering engine which started as an engine for the Linux platform and was modified by Apple to support Mac and Windows. See <a class="link"   href="http://webkit.org/" >http://webkit.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more details.</p>
<h2 id="The-main-flow"><a href="#The-main-flow" class="headerlink" title="The main flow"></a>The main flow</h2><p>The rendering engine will start getting the contents of the requested document from the networking layer. This will usually be done in 8kB chunks.<br>The basic flow of the rendering engine is as follows:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/flow.png"
                      alt="img"
                ></p>
<p>The render tree contains rectangles with visual attributes like color and dimensions. The rectangles are in the right order to be displayed on the screen.</p>
<p>After the construction of the render tree it goes through a “layout” process. This means giving each node the exact coordinates where it should appear on the screen. The next stage is painting – the render tree will be traversed and each node will be painted using the UI backend layer.</p>
<p>It’s important to understand that this is a gradual process. For better user experience, the rendering engine will try to display contents on the screen as soon as possible. It will not wait until all HTML is parsed before starting to build and layout the render tree. Parts of the content will be parsed and displayed, while the process continues with the rest of the contents that keeps coming from the network.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/webkitflow.png"
                      alt="img"
                ></p>
<h2 id="Parsing-general"><a href="#Parsing-general" class="headerlink" title="Parsing - general"></a>Parsing - general</h2><p>Parsing a document means translating it to some structure that makes sense - something the code can understand and use. The output of the parsing is usually a tree which will be used to render the page on the screen.</p>
<h2 id="Grammars"><a href="#Grammars" class="headerlink" title="Grammars"></a>Grammars</h2><p>Parsing is based on the syntax rules the document obeys.</p>
<h2 id="Parser-Lexer-combination"><a href="#Parser-Lexer-combination" class="headerlink" title="Parser - Lexer combination"></a>Parser - Lexer combination</h2><p>Parser can be separated into two sub processes - Lexical analysis and Syntactic analysis.<br>Lexical analysis is the process of breaking the input into tokens. Tokens are the language vocabulary - the collection of valid building blocks. In human language it will consist of all the words that appear in the dictionary for that language.<br>Syntactic analysis is the application of the language syntax rules. It is the process of analyzing the token sequence to determine the grammatical structure of the language.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/image011.png"
                      alt="img"
                ></p>
<h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>Parsing is often used in translation - transforming the input document to another format.The compiler that compiles a source code into machine code first parses it into a parse tree and then translates the parse tree into machine code.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/image013.png"
                      alt="img"
                ></p>
<h2 id="Parsing-example"><a href="#Parsing-example" class="headerlink" title="Parsing example"></a>Parsing example</h2><p>Example - parsing the expression “2 + 3 - 1”<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://taligarsiel.com/Projects/image009.png"
                      alt="img"
                ><br>Vocabulary: Our language can include integers, plus signs and minus signs.<br>Syntax:</p>
<ul>
<li>The language syntax building blocks are expressions, terms and operations.</li>
<li>Our language can include any number of expressions.</li>
<li>A expression is defined as a “term” followed by an “operation” followed by another “term”.</li>
<li>An operation is a plus token or a minus token.</li>
<li>A term is an integer token or an expression.</li>
</ul>
<p><a href="https://github.com/mengjian-github/copilot-analysis">https://github.com/mengjian-github/copilot-analysis</a></p>
<h2 id="Referenc"><a href="#Referenc" class="headerlink" title="Referenc"></a>Referenc</h2><h2 id="抓不到copilot的链接"><a href="#抓不到copilot的链接" class="headerlink" title="抓不到copilot的链接"></a>抓不到copilot的链接</h2><ul>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Browser_engine" >https://en.wikipedia.org/wiki/Browser_engine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://taligarsiel.com/Projects/howbrowserswork1.htm" >https://taligarsiel.com/Projects/howbrowserswork1.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>从输入URL到页面加载完成的过程</title>
    <url>/Yuyang/borwer/</url>
    <content><![CDATA[<h2 id="输入URL用户发起请求"><a href="#输入URL用户发起请求" class="headerlink" title="输入URL用户发起请求"></a>输入URL用户发起请求</h2><p>当用户在客户端输入一个网址如（如 <a class="link"   href="https://www.example.com),浏览器会根据这个操作发起网络请求./" >https://www.example.com），浏览器会根据这个操作发起网络请求。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="浏览器解析URL"><a href="#浏览器解析URL" class="headerlink" title="浏览器解析URL"></a>浏览器解析URL</h2><p>浏览器会解析用户输入的URL</p>
<ul>
<li>协议：例如HTTP或HTTPS</li>
<li>主机名：例如<a class="link"   href="http://www.example.com/" >www.example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>端口号：例如80或443</li>
<li>路径：例如&#x2F;index.html</li>
<li>查询参数：例如?name&#x3D;example</li>
<li>锚点：例如#section</li>
</ul>
<h2 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h2><p>在发起真正的网络请求之前，浏览器会检查以下几处缓存，以节省时间和资源：</p>
<ul>
<li>浏览器缓存：如果之前已经访问过该网站，浏览器可能已经缓存了该资源，直接从缓存中加载。（强缓存、协商缓存）<ul>
<li>强缓存依赖于请求头的Expires或Cache-Control</li>
</ul>
</li>
<li>DNS 缓存：浏览器会首先检查是否缓存了该域名对应的 IP 地址，避免重复的 DNS 解析。</li>
<li>操作系统的 DNS 缓存：如果浏览器没有缓存 DNS 记录，它会查询操作系统的 DNS 缓存（如 Windows 的 DNS 缓存或 Linux 的 nscd）。</li>
</ul>
<h2 id="发起DNS请求"><a href="#发起DNS请求" class="headerlink" title="发起DNS请求"></a>发起DNS请求</h2><p>如果缓存中没有找到对应的IP地址，浏览器会发起一个DNS请求，将域名解析为IP地址。</p>
<h2 id="构建HTTP-HTTPS请求-应用层"><a href="#构建HTTP-HTTPS请求-应用层" class="headerlink" title="构建HTTP&#x2F;HTTPS请求(应用层)"></a>构建HTTP&#x2F;HTTPS请求(应用层)</h2><p>一旦获取了IP地址，浏览器就可以构建HTTP&#x2F;HTTPS请求。HTTP请求报文包含以下几个部分：</p>
<ul>
<li>请求行：包含请求方法、请求URL和HTTP协议版本</li>
<li>请求头：包含请求的各种信息，如User-Agent、Accept、Cookie等</li>
<li>请求体：包含请求的数据，如POST请求的表单数据</li>
</ul>
<h2 id="建立TCP连接-传输层"><a href="#建立TCP连接-传输层" class="headerlink" title="建立TCP连接(传输层)"></a>建立TCP连接(传输层)</h2><p>HTTP是基于TCP协议的，因此浏览器需要建立TCP连接。TCP是一种面向连接的协议，它提供可靠的数据传输服务。HTTPS还需要建立TLS连接，TLS是SSL的升级版，提供了更强的安全性。</p>
<ul>
<li>三次握手：客户端和服务器之间需要通过三次握手建立连接。</li>
<li>第一次握手：客户端发送一个 SYN 包给服务器，请求建立连接。</li>
<li>第二次握手：服务器收到 SYN 包后，回应一个 SYN+ACK 包。</li>
<li>第三次握手：客户端收到 SYN+ACK 包后，回应一个 ACK 包。</li>
</ul>
<h2 id="构建数据包-网络层"><a href="#构建数据包-网络层" class="headerlink" title="构建数据包(网络层)"></a>构建数据包(网络层)</h2><p>一旦建立了TCP连接，浏览器就可以基于DNS解析得到的IP地址将HTTP请求报文封装成数据包，通过网络层发送给服务器。</p>
<h2 id="数据包在网络中传输-数据链路层"><a href="#数据包在网络中传输-数据链路层" class="headerlink" title="数据包在网络中传输(数据链路层)"></a>数据包在网络中传输(数据链路层)</h2><p>数据包通过数据链路层的设备（如交换机、网卡）在网络中传输，最终到达服务器。</p>
<h2 id="服务器处理请求，浏览器接受HTTP响应"><a href="#服务器处理请求，浏览器接受HTTP响应" class="headerlink" title="服务器处理请求，浏览器接受HTTP响应"></a>服务器处理请求，浏览器接受HTTP响应</h2><p>服务器收到请求后，会根据请求的 URL、<br>请求头等信息，调用相应的处理程序，如处理静态资源的 Nginx、处理动态资源的 Tomcat。</p>
<h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><p>浏览器接收到服务器返回的 HTTP 响应后，会解析响应报文，根据响应头中的 Content-Type 等信息判断响应的类型，然后进行相应的处理。</p>
<ul>
<li>HTML：浏览器会解析 HTML，构建 DOM 树。</li>
<li>CSS：浏览器会解析 CSS，构建 CSSOM 树。</li>
<li>render tree：浏览器会将 DOM 树和 CSSOM 树合并成一个 render tree。</li>
<li>布局：浏览器会根据 render tree 计算每个节点的位置。</li>
<li>绘制：浏览器会将 render tree 绘制到屏幕上。</li>
</ul>
<h2 id="关闭TCP连接-四次挥手"><a href="#关闭TCP连接-四次挥手" class="headerlink" title="关闭TCP连接(四次挥手)"></a>关闭TCP连接(四次挥手)</h2><p>一旦服务器返回了 HTTP 响应，浏览器会关闭 TCP 连接。</p>
<ul>
<li>四次挥手：客户端和服务器之间需要通过四次挥手关闭连接。</li>
<li>第一次挥手：客户端发送一个 FIN 包给服务器，请求关闭连接。</li>
<li>第二次挥手：服务器收到 FIN 包后，回应一个 ACK 包。</li>
<li>第三次挥手：服务器发送一个 FIN 包给客户端，请求关闭连接。</li>
<li>第四次挥手：客户端收到 FIN 包后，回应一个 ACK 包。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是从输入 URL 到页面加载完成的整个过程。在这个过程中，浏览器和服务器之间进行了多次的交互，包括 DNS 解析、建立 TCP 连接、发送 HTTP 请求、处理请求、返回 HTTP 响应等。最终，浏览器会将服务器返回的 HTML、CSS、JavaScript 等资源解析渲染，最终呈现给用户。</p>
]]></content>
  </entry>
  <entry>
    <title>强缓存和协商缓存</title>
    <url>/Yuyang/cache/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>为了减少资源请求次数，加快资源访问速度，浏览器会对资源文件如图片、css文件、js文件等进行缓存，而浏览器缓存策略又分为强缓存和协商缓存。</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是指浏览器在缓存有效期内直接从本地缓存中读取资源，而不与服务器进行任何通信。强缓存的实现依赖于 HTTP 响应头中的 Expires 或 Cache-Control。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires" >https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>一个绝对的过期时间（GMT 时间），在此时间之前，浏览器会认为缓存是有效的。</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Wed, 21 Oct 2024 07:28:00 GMT</span><br></pre></td></tr></table></figure></div>

<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>max-age代表缓存时间，单位为秒</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=3600</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" >https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121558393.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121558374.webp"
                      alt="img"
                ></p>
<p>使用缓存的话，状态码200后面会标明情况。浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache）。</p>
<p>当缓存时间到期后再次访问时，状态码200后面便没有括号内的内容了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121558501.webp"
                      alt="img"
                ></p>
<p>一般来说，浏览器会将较大的资源缓存到disk cache，而较小的资源则被缓存到memory cache里。内存缓存与磁盘缓存相比，访问速度要更快一些！</p>
<p>Cache-Control除了max-age外，还可以设置其它属性值：</p>
<ul>
<li>no-cache: 不使用强缓存（但仍会使用协商缓存）。</li>
<li>no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。</li>
<li>private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。</li>
<li>public: 客户端和代理服务器都可缓存。</li>
<li>s-maxage: 与max-age类似，区别是s-maxage是设定代理服务器的缓存时间。</li>
</ul>
<p>另外，Cache-control的优先级要高于Expires，如果两者同时设置，会优先使用Cache-control而忽略掉Expires。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><strong>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存</strong>，协商缓存的具体流程如下：</p>
<p>浏览器初次请求资源，服务器返回资源，同时生成一个Etag值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带If-None-Match，值是之前服务器返回的Etag的值，服务器收到之后拿该值与资源文件最新的Etag值做对比。</p>
<ul>
<li>如果没有变化则返回304，告诉浏览器继续使用缓存（不返回资源文件）。</li>
<li>如果发生变化，则返回200和最新的资源文件给浏览器使用。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121603356.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121603175.webp"
                      alt="img"
                ></p>
<p>除了Etag外，还有一个Last-Modified的属性，它是Http1.0规范的，服务器返回Last-Modified，浏览器请求头对应携带的是If-Modified-since，与Etag不同的是，Last-Modified的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121603459.webp"
                      alt="img"
                ></p>
<p>相比Last-Modified，Etag优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，Last-Modified不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。</p>
<p>强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强缓存就是浏览器本地根据服务器设置的过期时间来判断是否使用缓存，未过期则从本地缓存里拿资源，已过期则重新请求服务器获取最新资源。</p>
<p>协商缓存则是浏览器本地每次都向服务器发起请求，由服务器来告诉浏览器是从缓存里拿资源还是返回最新资源给浏览器使用。</p>
<p>Reference: <a class="link"   href="https://juejin.cn/post/7259298281578889273?searchId=20240712153934B2B3A1160462EB235132" >https://juejin.cn/post/7259298281578889273?searchId=20240712153934B2B3A1160462EB235132 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>AST-抽象语法树</title>
    <url>/Yuyang/ast/</url>
    <content><![CDATA[<h2 id="编译器的底层原理-AST"><a href="#编译器的底层原理-AST" class="headerlink" title="编译器的底层原理 AST"></a>编译器的底层原理 AST</h2><p>编译器介绍：它会将用某种编程语言写成的源代码，转换成另一种编程语言。编译器（compiler）是一种用于将源代码（通常是高级编程语言编写的代码）翻译成目标代码（如机器语言或中间代码）的软件工具。目标代码通常可以直接在计算机上执行，或者在特定的运行环境中执行。编译器的主要目的是使程序员编写的源代码能够在计算机硬件上运行。</p>
<h2 id="编译器实现的思路"><a href="#编译器实现的思路" class="headerlink" title="编译器实现的思路"></a>编译器实现的思路</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407142153107.png"
                      alt="image-20240714215346889"
                ></p>
<h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><p>这一部分主要实现的功能是将源码转换为抽象语法树</p>
<p>解析通常分为两个阶段：词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）。</p>
<ol>
<li><p><strong>词法分析</strong> 将原始代码拆分成称为标记（tokens）的部分，这个过程由一个称为分词器（tokenizer）或词法分析器（lexer）的东西完成。</p>
<p>标记是描述语法中独立部分的小对象的数组。它们可以是数字、标签、标点符号、操作符等。</p>
</li>
<li><p><strong>语法分析</strong> 将标记重新格式化为描述语法各部分及其相互关系的表示形式。这被称为中间表示或抽象语法树（AST）。</p>
<p>抽象语法树（AST）是一个深度嵌套的对象，它以一种易于处理并包含大量信息的方式表示代码。</p>
</li>
</ol>
<p>对于以下语法：</p>
<p>  <code>(add 2 (subtract 4 2))</code></p>
<p>Tokens应该是这样的这样：</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;name&#x27;,   value: &#x27;add&#x27;      &#125;,</span><br><span class="line">  &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;(&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;name&#x27;,   value: &#x27;subtract&#x27; &#125;,</span><br><span class="line">  &#123; type: &#x27;number&#x27;, value: &#x27;4&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,</span><br><span class="line">  &#123; type: &#x27;paren&#x27;,  value: &#x27;)&#x27;        &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<p>而抽象语法树（AST）可能看起来像这样：</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;Program&#x27;,</span><br><span class="line">  body: [&#123;</span><br><span class="line">    type: &#x27;CallExpression&#x27;,</span><br><span class="line">    name: &#x27;add&#x27;,</span><br><span class="line">    params: [&#123;</span><br><span class="line">      type: &#x27;NumberLiteral&#x27;,</span><br><span class="line">      value: &#x27;2&#x27;,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      type: &#x27;CallExpression&#x27;,</span><br><span class="line">      name: &#x27;subtract&#x27;,</span><br><span class="line">      params: [&#123;</span><br><span class="line">        type: &#x27;NumberLiteral&#x27;,</span><br><span class="line">        value: &#x27;4&#x27;,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        type: &#x27;NumberLiteral&#x27;,</span><br><span class="line">        value: &#x27;2&#x27;,</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>这一部分主要实现的功能是对初始的抽象语法树进行操作使其变成我们所期望的抽象语法树。</p>
<p>同样，这个阶段只是接收上一步生成的AST并对其进行更改。它可以在相同的语言中操作AST，也可以将其转换为完全新的语言。</p>
<p>让我们看看如何转换一个AST。</p>
<p>你可能会注意到，我们的AST中有一些看起来非常相似的元素。这些对象都有一个type属性。每个这样的对象都被称为AST节点。这些节点上有定义的属性，用来描述树的一个独立部分。</p>
<p>我们可以有一个表示“NumberLiteral”（数字字面量）的节点：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;NumberLiteral&#x27;</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者一个表示“CallExpression”（调用表达式）的节点：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;CallExpression&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;subtract&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: [...嵌套节点在这里...],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在转换AST时，我们可以通过添加&#x2F;移除&#x2F;替换属性来操作节点，我们可以添加新节点，移除节点，或者保留现有的AST不变，基于它创建一个全新的AST。</p>
<p>由于我们目标是一种新语言，因此我们将专注于创建一个特定于目标语言的全新AST。</p>
<h3 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h3><p>将新的语法树转换成新的代码</p>
]]></content>
  </entry>
  <entry>
    <title>MAC 内网穿透 cpolar</title>
    <url>/Yuyang/cpolar/</url>
    <content><![CDATA[<blockquote>
<p>介绍如何通过使用cpolar来完成将内网下的本地服务器通过安全隧道暴露至公网，完成公网正常访问内网服务。目前我的本地web服务只能在局域网内访问，使用cpolar内网穿透可以将本地服务映射到公网，实现公网用户也可以访问到本地服务，无需公网IP，也无需设置路由器。<br>cpolar官网：<a class="link"   href="https://www.cpolar.com/" >https://www.cpolar.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="1、安装配置cpolar"><a href="#1、安装配置cpolar" class="headerlink" title="1、安装配置cpolar"></a>1、安装配置cpolar</h2><ul>
<li>通过Homebrew包管理器安装cpolar</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap probezy/core &amp;&amp; brew install cpolar</span><br></pre></td></tr></table></figure></div>

<ul>
<li>token认证：在cpolar官网后台的验证初复制自己的token</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232255851.png"
                      alt="img"
                ></p>
<p>cpolar authtoken xxx</p>
<p>         xxx处用复制的token代替</p>
<ul>
<li><p>安装cpolar服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service install</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="2、使用cpolar"><a href="#2、使用cpolar" class="headerlink" title="2、使用cpolar"></a>2、使用cpolar</h2><ul>
<li><p>启动服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service start</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>cpolar web UI管理界面</p>
<p> 访问本地9200端口【<a class="link"   href="http://127.0.0.1:9200/%E3%80%91%EF%BC%8C%E4%BD%BF%E7%94%A8cpolar%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E3%80%82" >http://127.0.0.1:9200/】，使用cpolar账号登录。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232257170.png"
                      alt="img"
                ></p>
<p>         可在UI界面中查看自己的隧道信息 以及编辑、启动、停止和删除。其中状态列表下的的在线隧道列表显示了目前的公网地址和本地地址映射关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232257753.png"
                      alt="img"
                ></p>
<ul>
<li><p> 公网请求测试。</p>
<p>     可借助APIFOX在线测试。官网地址：<a class="link"   href="https://apifox.com/" >https://apifox.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232258155.png"
                      alt="img"
                ></p>
<p> 根据自己情况填写。示例中的接口地址为&#x2F;model</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232258116.png"
                      alt="img"
                ></p>
<p>        请求成功🎉 </p>
<ul>
<li> 停止服务</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cpolar service stop</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意⚠️：停止后再启动，免费版的域名会发生变化需要重新设置，及时更新。 </p>
</blockquote>
<p>Reference：<a class="link"   href="https://www.cpolar.com/blog/cpolar-quick-start-tutorial-macos-series" >https://www.cpolar.com/blog/cpolar-quick-start-tutorial-macos-series <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>前端工程化</title>
    <url>/Yuyang/engineering/</url>
    <content><![CDATA[<h1 id="前端工程化讲解-包管理工具"><a href="#前端工程化讲解-包管理工具" class="headerlink" title="前端工程化讲解&amp;包管理工具"></a>前端工程化讲解&amp;包管理工具</h1><h2 id="工程化体系"><a href="#工程化体系" class="headerlink" title="工程化体系"></a>工程化体系</h2><p>前端工程化： 前端+软件工程</p>
<p>整个前端的研发周期当中 我们可以干预的行为</p>
<h3 id="前端工程化开展"><a href="#前端工程化开展" class="headerlink" title="前端工程化开展"></a>前端工程化开展</h3><ul>
<li>模块化：模块复用</li>
<li>自动化：CI&#x2F;CD 研发平台</li>
<li>智能化：AI code</li>
</ul>
<h3 id="脚手架能力"><a href="#脚手架能力" class="headerlink" title="脚手架能力"></a>脚手架能力</h3><p>通过更多的规范 约束开发人员的研发流程</p>
<p>狭义：命令行<br>广义：约束</p>
<p>准备阶段：</p>
<ul>
<li>需求</li>
<li>技术选型</li>
<li>代码规范<ul>
<li>lint 规范</li>
</ul>
</li>
<li>生态规范<ul>
<li>UI库</li>
<li>静态站点 npm github readme types</li>
</ul>
</li>
<li>三方规范<ul>
<li>npm 发布</li>
<li>github ci cd</li>
</ul>
</li>
</ul>
<h4 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h4><p>确定规范内容<br>规范 eslint md stylelint</p>
<p>测试</p>
<ul>
<li>单元测试</li>
<li>e2e测试</li>
</ul>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><ul>
<li>webpack</li>
<li>rollup</li>
<li>vite</li>
</ul>
<h3 id="体验度量"><a href="#体验度量" class="headerlink" title="体验度量"></a>体验度量</h3><p>定义一些指标 衡量当前系统好不好用</p>
<p>埋点：用户行为统计<br>perfomance：性能指标</p>
<h3 id="研发效能流程"><a href="#研发效能流程" class="headerlink" title="研发效能流程"></a>研发效能流程</h3><h3 id="稳定性建设"><a href="#稳定性建设" class="headerlink" title="稳定性建设"></a>稳定性建设</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407220023631.png"
                      alt="image-20240722002317481"
                ></p>
<p>pdd:<br>高端机 2s &#x3D;&gt; 0.8s<br>0.5s<br>低端机 1.2s</p>
<h2 id="npm包"><a href="#npm包" class="headerlink" title="npm包"></a>npm包</h2><p>查看包版本 npm view xxx</p>
<p>peerDependencies<br>基础包约束依赖包版本</p>
<h3 id="打包工具对比"><a href="#打包工具对比" class="headerlink" title="打包工具对比"></a>打包工具对比</h3><p>yarn npm</p>
<ul>
<li>问题？</li>
<li>慢</li>
<li>体积大</li>
</ul>
<p>pnpm 推荐</p>
<ul>
<li>快</li>
<li>体积小</li>
</ul>
<h3 id="前端仓库管理对比"><a href="#前端仓库管理对比" class="headerlink" title="前端仓库管理对比"></a>前端仓库管理对比</h3><ul>
<li>Multirepo</li>
<li>Monorepo</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端埋点与全链路</title>
    <url>/Yuyang/eventTracking/</url>
    <content><![CDATA[<h2 id="什么是埋点："><a href="#什么是埋点：" class="headerlink" title="什么是埋点："></a>什么是埋点：</h2><p>​	前端埋点是一种用于收集用户在网站或应用程序上的行为数据的方法。这些数据可以帮助企业了解用户的行为模式、使用习惯，并对产品进行优化。</p>
<h2 id="为什么要埋点："><a href="#为什么要埋点：" class="headerlink" title="为什么要埋点："></a>为什么要埋点：</h2><ul>
<li>流量监测（按时间空间维度分析，留存分析，转化分析）。</li>
<li>构建行为路径，获取用户的全链路信息获取，实现用户分群、人群洞察、行为细查等，构建用户画像。</li>
<li>通过对埋点数据的处理、分析、建模，判断产品的效果和未来走向。</li>
<li>为营销策略提供数据支持，分析营销效果，提高渠道转化。</li>
<li>热力分析，帮助判断访客热衷的区域，评估网页设计是否合理等。</li>
<li>实施AB Test，持续优化产品，使产品在市场上更具有竞争力。</li>
<li>用户行为异常监测以及问题快速定位与响应。</li>
</ul>
<h2 id="埋点的使用场景有哪些："><a href="#埋点的使用场景有哪些：" class="headerlink" title="埋点的使用场景有哪些："></a>埋点的使用场景有哪些：</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250013175.png"
                      alt="image-20240625001317104"
                ></p>
<h2 id="埋点方式："><a href="#埋点方式：" class="headerlink" title="埋点方式："></a>埋点方式：</h2><table>
<thead>
<tr>
<th></th>
<th>代码埋点</th>
<th>全埋点</th>
<th>可视化埋点</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td><strong>代码埋点</strong>是指在前端代码中手动添加埋点代码，用于捕获特定用户行为事件。这种方法灵活且精确，适用于需要细粒度数据收集的场景。</td>
<td><strong>全埋点</strong>是一种自动化的埋点方式，旨在捕获页面上的所有用户行为事件。通过全埋点，可以自动记录用户在页面上的所有操作，如点击、滑动、输入等，减少了手动添加埋点的工作量。</td>
<td><strong>可视化埋点</strong>是通过可视化界面配置埋点，而不需要修改代码。通过可视化工具，非技术人员也可以方便地配置和管理埋点。</td>
</tr>
<tr>
<td>优点</td>
<td>•	精确控制埋点的位置和事件。	<br />•	可以收集详细的事件信息。</td>
<td>•	覆盖全面，无需手动添加埋点代码。<br />•	能够捕获所有用户行为，数据更完整</td>
<td>•	无需修改代码，配置方便。<br />•	非技术人员也可以配置和管理埋点。</td>
</tr>
<tr>
<td>缺点</td>
<td>•	手动维护埋点代码，工作量大，容易出错。<br />•	需要开发人员介入，维护成本高。</td>
<td>•	数据量大，可能带来存储和处理的压力。<br />•	需要在数据清洗和分析阶段进行大量处理。</td>
<td>•	可能无法满足所有细粒度的埋点需求。<br />•	配置不当可能导致数据不准确。</td>
</tr>
</tbody></table>
<h2 id="埋点例子："><a href="#埋点例子：" class="headerlink" title="埋点例子："></a>埋点例子：</h2><p>代码埋点例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#button&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构建埋点数据</span></span><br><span class="line">    <span class="keyword">var</span> eventData = &#123;</span><br><span class="line">        <span class="attr">eventType</span>: <span class="string">&#x27;button_click&#x27;</span>,</span><br><span class="line">        <span class="attr">buttonId</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">        <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送数据到服务器</span></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;https://example.com/track&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(eventData),</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;埋点数据发送成功&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;埋点数据发送失败&#x27;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>全埋点例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全埋点脚本</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 事件监听器</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">eventListener</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> eventData = &#123;</span><br><span class="line">            <span class="attr">eventType</span>: event.<span class="property">type</span>,</span><br><span class="line">            <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(),</span><br><span class="line">            <span class="attr">element</span>: event.<span class="property">target</span>.<span class="property">tagName</span>,</span><br><span class="line">            <span class="attr">id</span>: event.<span class="property">target</span>.<span class="property">id</span>,</span><br><span class="line">            <span class="attr">className</span>: event.<span class="property">target</span>.<span class="property">className</span>,</span><br><span class="line">            <span class="attr">pageX</span>: event.<span class="property">pageX</span>,</span><br><span class="line">            <span class="attr">pageY</span>: event.<span class="property">pageY</span>,</span><br><span class="line">            <span class="attr">url</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送数据到服务器</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;https://example.com/track&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(eventData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听点击事件</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, eventListener, <span class="literal">true</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>

<h2 id="埋点模型："><a href="#埋点模型：" class="headerlink" title="埋点模型："></a>埋点模型：</h2><blockquote>
<p>埋点模型包含两个主要概念：<strong>事件(event)</strong> 、<strong>属性(params)</strong></p>
<p><strong>事件</strong>：通过埋点定义的用户行为或业务操作，比如页面打开，页面离开，模块曝光，模块点击</p>
<p><strong>属性</strong>：事件附带的各种维度信息，比如用户信息，网络信息，设备信息，事件具体维度信息等</p>
</blockquote>
<p>一个设计的相对完善的模型,一般包含用户行为五元素</p>
<p>通过这个可以详细的分析是谁在什么地方什么时间，怎么样进行了什么操作</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250041129.png"
                      alt="image-20240625004123315"
                ></p>
<p>模型事件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250047727.png"
                      alt="image-20240625004727426"
                ></p>
<p>模型信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250053185.png"
                      alt="image-20240625005335046"
                ></p>
<h2 id="埋点上报："><a href="#埋点上报：" class="headerlink" title="埋点上报："></a>埋点上报：</h2><p>数据队列处理：当需要上报的数据量逐渐变多时，就需要考虑进行批量上报和延迟上报，本质上都是为了不阻塞业务程序的执行，上报本来就是用户无感知的事情，用户不能为此耗时买单。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406250115952.png"
                      alt="image-20240625011532834"
                ></p>
<p>对于数据请求处理，主要考虑的有三个因素</p>
<ul>
<li>跨域的问题</li>
<li>页面销毁时，如何保障还未成功上传的数据完成数据上传请求</li>
<li>大数据量的上传</li>
</ul>
<p>较为标准的针对模块曝光的定义：窗口可视区域内 &amp;&amp; 组件矩形与视窗区域发生交集 &amp;&amp; 交集垂线距离 &gt;&#x3D; 1px &amp;&amp; 停留时间 &gt;&#x3D; XXms</p>
<p>Reference：<a class="link"   href="https://juejin.cn/post/7324334380373426227?searchId=202406242342178A14CCB0DE15106BCCCB" >https://juejin.cn/post/7324334380373426227?searchId=202406242342178A14CCB0DE15106BCCCB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>备注：近几个月来看到👀过质量最高的文章！学到了！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/helloalgo/</url>
    <content><![CDATA[<h2 id="速刷hello-algo"><a href="#速刷hello-algo" class="headerlink" title="速刷hello-algo"></a>速刷hello-algo</h2><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>复杂度分析: 时间复杂度、空间复杂度<br>数据结构: 数组、链表、栈、队列、哈希表、树、堆、图<br>算法: 搜索、排序、分治、回溯、动态规划、贪心<br><a class="link"   href="https://www.hello-algo.com/" >https://www.hello-algo.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410251743992.png"
                      alt="image-20241025174311243"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202410251749524.png"
                      alt="image-20241025174936400"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>How Browsers Work</title>
    <url>/Yuyang/howbrowserswork/</url>
    <content><![CDATA[<p>Users want web experiences with content that is fast to load and smooth to interact with.They are two goals we want to achieve.</p>
<p>To better achieve these goals, we need to understand how browsers work.</p>
<h2 id="How-Browsers-Work"><a href="#How-Browsers-Work" class="headerlink" title="How Browsers Work"></a>How Browsers Work</h2><p>Two major issues in web performance are issues having to do with network latency and issues having to do with the fact that for the most part, browsers are single-threaded.</p>
<h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><p>Navigation is the process of loading a web page. It involves the following steps:</p>
<ol>
<li>DNS lookup<br>The first step in the navigation process is to look up the IP address of the server that hosts the website. This is done using the Domain Name System (DNS).If you navigate to <a class="link"   href="https://example.com/" >https://example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, the HTML page is located on the server with IP address of 93.184.216.34. If you’ve never visited this site, a DNS lookup must happen.<br>After this initial request, the IP will likely be cached for a time, which speeds up subsequent requests by retrieving the IP address from the cache instead of contacting a name server again.</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180700896.jpeg"
                      alt="img"
                ><br>This can be problematic for performance, particularly on mobile networks. When a user is on a mobile network, each DNS lookup has to go from the phone to the cell tower to reach an authoritative DNS server. The distance between a phone, a cell tower, and the name server can add significant latency.</p>
<ol start="2">
<li>TCP handshake<br>Once the browser has the IP address, it can establish a connection to the server. This is done using the Transmission Control Protocol (TCP). The browser sends a SYN packet to the server, which responds with a SYN-ACK packet, and the browser sends an ACK packet back. This is known as the TCP handshake.</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180705057.png"
                      alt="img"
                ></p>
<ol start="3">
<li>TLS negotiation<br>If the website uses HTTPS, the browser and server must negotiate a secure connection. This is done using the Transport Layer Security (TLS) protocol. The browser sends a ClientHello message to the server, which responds with a ServerHello message, and the browser sends a Finished message. This is known as the TLS handshake.</li>
</ol>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Once we have established a connection to the server, we can request the HTML page. The server responds with the HTML page, which the browser parses and renders.</p>
<h4 id="Congestion-control-TCP-slow-start"><a href="#Congestion-control-TCP-slow-start" class="headerlink" title="Congestion control &#x2F; TCP slow start"></a>Congestion control &#x2F; TCP slow start</h4><p>During the TCP handshake, the browser and server negotiate the maximum segment size (MSS) for the connection. The browser starts by sending a small number of segments and increases the number of segments it sends until it reaches the maximum segment size. This is known as TCP slow start.</p>
<h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><p>Once the browser receives the first chunk of data, it can begin parsing the information.Parsing is the step the browser takes to turn the data it receives over the network into a Document Object Model (DOM) tree and a CSS Object Model (CSSOM), which are used to render the page.  </p>
<p>The browser will begin parsing and attempting to render the page as soon as it receives the first chunk of data. This is known as incremental rendering.</p>
<ul>
<li>Building the DOM tree<br><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path" >https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Above describes the process of building the DOM tree.</li>
</ul>
<p>CRP: Critical Rendering Path</p>
<p>Web Performance includes the following:</p>
<ul>
<li>server requests and responses</li>
<li>loading</li>
<li>scripting</li>
<li>rendering</li>
<li>layout</li>
<li>painting</li>
</ul>
<p>The CRP is the sequence of steps the browser goes through to convert the HTML, CSS, and JavaScript into pixels on the screen.<br>A request for a web page or app starts with an HTTP request. The server sends a response containing the HTML. The browser then begins parsing the HTML, converting the received bytes to the DOM tree. The browser initiates requests every time it finds links to external resources, be it stylesheets, scripts, or embedded image references. Some requests are blocking, which means the parsing of the rest of the HTML is halted until the imported asset is handled. The browser continues to parse the HTML making requests and building the DOM, until it gets to the end, at which point it constructs the CSS object model. With the DOM and CSSOM complete, the browser builds the render tree, computing the styles for all the visible content. After the render tree is complete, layout occurs, defining the location and size of all the render tree elements. Once complete, the page is rendered, or ‘painted’ on the screen.</p>
<h4 id="Document-Object-Model-DOM"><a href="#Document-Object-Model-DOM" class="headerlink" title="Document Object Model (DOM)"></a>Document Object Model (DOM)</h4><p>DOM construction is incremental.</p>
<h4 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h4><p>CSSOM construction is incremental.CSS is render blocking.</p>
<h4 id="Render-tree"><a href="#Render-tree" class="headerlink" title="Render tree"></a>Render tree</h4><p>The render tree is the combination of the DOM and CSSOM. It is used to render the page.<br>To contrcut the render tree, the browser will:</p>
<ul>
<li>Traverse the DOM tree</li>
<li>Match the CSSOM rules to the DOM nodes</li>
<li>Apply the CSSOM rules to the DOM nodes</li>
<li>Construct the render tree</li>
</ul>
<h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>Layout is the process of determining the size and position of each element on the page. The browser will:</p>
<ul>
<li>Traverse the render tree</li>
<li>Calculate the size and position of each element</li>
<li>Determine the flow of the page</li>
</ul>
<h4 id="Painting"><a href="#Painting" class="headerlink" title="Painting"></a>Painting</h4><p>Painting is the process of filling in pixels on the screen. The browser will:</p>
<ul>
<li>Traverse the render tree</li>
<li>Paint the pixels on the screen</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端路由hash和history</title>
    <url>/Yuyang/hash_history/</url>
    <content><![CDATA[<p>前端路由hash和history</p>
<h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><p>使用window.location.hash属性以及onhashchange事件，实现监听浏览器地址的hash值变化，执行相应的js切换网页</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">location.href</td>
<td align="center">完整的URL字符串</td>
<td align="center"><a class="link"   href="https://www.example.com:8080/pathname/?search=test#hash" >https://www.example.com:8080/pathname/?search=test#hash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="center">location.protocol</td>
<td align="center">协议部分</td>
<td align="center">https:</td>
</tr>
<tr>
<td align="center">location.hostname</td>
<td align="center">主机名</td>
<td align="center"><a class="link"   href="http://www.example.com/" >www.example.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="center">location.port</td>
<td align="center">端口号</td>
<td align="center">8080</td>
</tr>
<tr>
<td align="center">location.host</td>
<td align="center">主机名和端口号</td>
<td align="center"><a class="link"   href="http://www.example.com:8080/" >www.example.com:8080 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="center">location.pathname</td>
<td align="center">路径部分</td>
<td align="center">&#x2F;post&#x2F;6993840419041706014</td>
</tr>
<tr>
<td align="center">location.search</td>
<td align="center">查询字符串部分</td>
<td align="center">?search&#x3D;test</td>
</tr>
<tr>
<td align="center">location.hash</td>
<td align="center">哈希值</td>
<td align="center">#hash</td>
</tr>
</tbody></table>
<p>window.location还提供了一些方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">location.assign(url)</td>
<td align="center">加载指定的URL</td>
</tr>
<tr>
<td align="center">location.replace(url)</td>
<td align="center">替换当前的 URL，但不会在历史记录中创建新的条目。即用户无法通过浏览器的“后退”按钮返回到之前的页面。</td>
</tr>
<tr>
<td align="center">location.reload(forceReload)</td>
<td align="center">重新加载当前页面。forceReload 参数为 true 时会强制从服务器重新加载页面（而不是从缓存中加载）。</td>
</tr>
<tr>
<td align="center">location.toString()</td>
<td align="center">返回当前 URL 的字符串表示。</td>
</tr>
</tbody></table>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前 URL 的各种部分</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>);      <span class="comment">// 输出完整的 URL</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>);  <span class="comment">// 输出协议部分</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span>);      <span class="comment">// 输出主机和端口号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span>);  <span class="comment">// 输出主机名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">port</span>);      <span class="comment">// 输出端口号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>);  <span class="comment">// 输出路径</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>);    <span class="comment">// 输出查询字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>);      <span class="comment">// 输出哈希</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">origin</span>);    <span class="comment">// 输出源 URL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 URL 并重新加载页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;https://www.example.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换当前 URL，不会在历史记录中创建新的条目</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&#x27;https://www.example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新加载页面</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();     <span class="comment">// 从缓存中重新加载</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>(<span class="literal">true</span>); <span class="comment">// 强制从服务器重新加载</span></span><br></pre></td></tr></table></figure></div>



<h2 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h2><p>History API是H5提供的新特性，允许开发者直接更改前端路由，即更新浏览器URL地址而不重新发起请求。它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。 History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">history.length</td>
<td align="center">历史记录中的条目数</td>
</tr>
<tr>
<td align="center">history.state</td>
<td align="center">历史记录条目的状态对象</td>
</tr>
</tbody></table>
<p>window.history 还提供了一些方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">history.pushState(state, title, url)</td>
<td align="center">将一个状态对象添加到历史记录栈中</td>
<td>window.history.pushState({ page: 1 }, “title 1”, “&#x2F;page1”);</td>
</tr>
<tr>
<td align="center">history.replaceState(state, title, url)</td>
<td align="center">修改当前历史记录条目的状态对象、标题和 URL</td>
<td>window.history.replaceState({ page: 2 }, “title 2”, “&#x2F;page2”);</td>
</tr>
<tr>
<td align="center">history.back()</td>
<td align="center">加载历史记录列表中的前一个 URL，与用户点击浏览器的后退按钮相同。</td>
<td>window.history.back();</td>
</tr>
<tr>
<td align="center">history.forward()</td>
<td align="center">加载历史记录列表中的下一个 URL，与用户点击浏览器的前进按钮相同。</td>
<td>window.history.forward();</td>
</tr>
<tr>
<td align="center">history.go(delta)</td>
<td align="center">根据 delta 值加载历史记录中的特定页面。delta: 为正值时前进，为负值时后退。</td>
<td>window.history.go(-1); &#x2F;&#x2F; 后退一页<br/>window.history.go(1);  &#x2F;&#x2F; 前进一页</td>
</tr>
</tbody></table>
<h2 id="history代码实现"><a href="#history代码实现" class="headerlink" title="history代码实现"></a>history代码实现</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomHistory</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentIndex</span> = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pushState</span>(<span class="params">state, title, url</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currentIndex</span> &lt; <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">stack</span> = <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">currentIndex</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(&#123; state, title, url &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentIndex</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updateUrl</span>(url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">replaceState</span>(<span class="params">state, title, url</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">currentIndex</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">currentIndex</span>] = &#123; state, title, url &#125;;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">updateUrl</span>(url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">pushState</span>(state, title, url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">go</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newIndex = <span class="variable language_">this</span>.<span class="property">currentIndex</span> + index;</span><br><span class="line">    <span class="keyword">if</span> (newIndex &gt;= <span class="number">0</span> &amp;&amp; newIndex &lt; <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentIndex</span> = newIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">back</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">currentIndex</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentIndex</span>--;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">applyState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">forward</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">currentIndex</span> &lt; <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentIndex</span>++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">applyState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">applyState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentState = <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">currentIndex</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updateUrl</span>(currentState.<span class="property">url</span>);</span><br><span class="line">    <span class="comment">// this.dispatchPopStaet(currentState);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">updateUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ CustomHistory ~ updateUrl ~ url:&quot;</span>, url)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dispatchPopStaet</span>(<span class="params">state</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;popstate&#x27;</span>, &#123; <span class="attr">detail</span>: state &#125;);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage example:</span></span><br><span class="line"><span class="keyword">const</span> customHistory = <span class="keyword">new</span> <span class="title class_">CustomHistory</span>();</span><br><span class="line"></span><br><span class="line">customHistory.<span class="title function_">pushState</span>(&#123; <span class="attr">page</span>: <span class="number">1</span> &#125;, <span class="string">&quot;Title 1&quot;</span>, <span class="string">&quot;/page1&quot;</span>);</span><br><span class="line">customHistory.<span class="title function_">pushState</span>(&#123; <span class="attr">page</span>: <span class="number">2</span> &#125;, <span class="string">&quot;Title 2&quot;</span>, <span class="string">&quot;/page2&quot;</span>);</span><br><span class="line">customHistory.<span class="title function_">replaceState</span>(&#123; <span class="attr">page</span>: <span class="number">3</span> &#125;, <span class="string">&quot;Title 3&quot;</span>, <span class="string">&quot;/page3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;popstate&#x27;, (event) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;Popstate event:&#x27;, event.detail);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">customHistory.<span class="title function_">back</span>(); <span class="comment">// Navigating to: /page1</span></span><br><span class="line">customHistory.<span class="title function_">forward</span>(); <span class="comment">// Navigating to: /page3</span></span><br><span class="line">customHistory.<span class="title function_">go</span>(-<span class="number">1</span>); <span class="comment">// Navigating to: /page1</span></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>MVVM和MVC</title>
    <url>/Yuyang/mvvmAndMvc/</url>
    <content><![CDATA[<p>众所周知，Vue.js是一个MVVM框架</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411042301055.png"
                      alt="image-20241104230111263"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/Yuyang/jsModule/</url>
    <content><![CDATA[<p>JS模块化</p>
<h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><p>模块化主要解决两个问题：命名冲突和文件依赖。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> 生态             诞生时间</span><br><span class="line"> <span class="title class_">CommonJS</span>         <span class="number">2009</span>年</span><br><span class="line"> <span class="title class_">Node</span>.<span class="property">js</span>          <span class="number">2009</span>年   </span><br><span class="line"> <span class="variable constant_">NPM</span>              <span class="number">2010</span>年   </span><br><span class="line"> requireJS(<span class="variable constant_">AMD</span>)   <span class="number">2010</span>年	异步模块定义 <span class="keyword">async</span> <span class="variable language_">module</span> definition</span><br><span class="line"> <span class="title function_">seaJS</span>(<span class="variable constant_">CMD</span>)       <span class="number">2011</span>年	common <span class="variable language_">module</span> define</span><br><span class="line"> broswerify       <span class="number">2011</span>年</span><br><span class="line"> webpack          <span class="number">2012</span>年</span><br><span class="line"> grunt            <span class="number">2012</span>年 </span><br><span class="line"> gulp             <span class="number">2013</span>年</span><br><span class="line"> react            <span class="number">2013</span>年 </span><br><span class="line"> vue              <span class="number">2014</span>年</span><br><span class="line"> <span class="title class_">ES6</span>(<span class="title class_">Module</span>)      <span class="number">2015</span>年</span><br><span class="line"> angular          <span class="number">2016</span>年</span><br><span class="line"> redux            <span class="number">2015</span>年 </span><br><span class="line"> vite             <span class="number">2020</span>年</span><br><span class="line"> snowpack         <span class="number">2020</span>年  </span><br><span class="line">跨端 rollup truopack</span><br></pre></td></tr></table></figure></div>

<h2 id="模块化的进程"><a href="#模块化的进程" class="headerlink" title="模块化的进程"></a>模块化的进程</h2><h3 id="全局function模式"><a href="#全局function模式" class="headerlink" title="全局function模式"></a>全局function模式</h3><p>将不同的功能封装成不同的全局函数<br>问题：污染全局命名空间，容易引起命名冲突</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="namespace模式"><a href="#namespace模式" class="headerlink" title="namespace模式"></a>namespace模式</h3><p>简单对象封装<br>作用：减少了全局变量，解决命名冲突<br>问题：数据不安全(外部可以直接修改模块内部的数据)</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myModule.<span class="property">data</span> = <span class="string">&#x27;other data&#x27;</span> <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.<span class="title function_">foo</span>() <span class="comment">// foo() other data</span></span><br></pre></td></tr></table></figure></div>


<h3 id="IIFE模式"><a href="#IIFE模式" class="headerlink" title="IIFE模式"></a>IIFE模式</h3><p>immediately-invoked function expression 匿名函数自调用(闭包)<br>作用：数据是私有的, 外部只能通过暴露的方法操作。将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口<br>问题：如果当前这个模块依赖另一个模块怎么办?</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="title function_">foo</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="title function_">bar</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">data</span>) <span class="comment">//undefined 不能访问模块内部数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="property">data</span> = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    myModule.<span class="title function_">foo</span>() <span class="comment">//没有改变</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    <span class="title function_">otherFun</span>() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">otherFun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">myModule</span> = &#123; foo, bar &#125; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo() www.baidu.com</span></span><br><span class="line"><span class="comment">// bar() www.baidu.com</span></span><br><span class="line"><span class="comment">// otehrFun()</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// foo() www.baidu.com</span></span><br></pre></td></tr></table></figure></div>

<h3 id="IIFE模式增强"><a href="#IIFE模式增强" class="headerlink" title="IIFE模式增强"></a>IIFE模式增强</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span>, $</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    <span class="title function_">otherFun</span>() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">otherFun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">myModule</span> = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, jQuery)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// index.html文件</span></span><br><span class="line">&lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  myModule.foo()</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><ul>
<li>避免命名冲突（减少命名空间污染）</li>
<li>更好的分离，按需加载</li>
<li>更高的复用性</li>
<li>更高的可维护性</li>
</ul>
<h3 id="引入多个的问题"><a href="#引入多个的问题" class="headerlink" title="引入多个的问题"></a>引入多个<script>的问题</h3><ul>
<li>依赖引用顺序、依赖模糊、难以维护<br>因此才有了后续的commonjs, AMD, ESM, CMD规范。</li>
</ul>
<h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>Node.js的模块规范，同步加载模块。每个文件都是一个模块有自己的作用域，模块可以通过module.exports导出变量，通过require()来导入其他模块的输出到当前模块作用域中。其里面定义的变量、函数、类都是私有的，不会污染全局作用域。在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">x</span> = x;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">addX</span> = addX;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);<span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="property">x</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="title function_">addX</span>(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></div>

<h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">incCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>如果需要获取到模块内部变化后的值，可以通过getter函数来获取。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCounter</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">  <span class="attr">getCounter</span>: getCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./example&#x27;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./example&#x27;</span>).<span class="property">incCounter</span>;</span><br><span class="line"><span class="keyword">var</span> getCounter = <span class="built_in">require</span>(<span class="string">&#x27;./example&#x27;</span>).<span class="property">getCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ require(&#x27;./example&#x27;).counter:&quot;</span>, <span class="title function_">getCounter</span>() ) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>

<h3 id="AMD-Asynchronous-Module-Definition"><a href="#AMD-Asynchronous-Module-Definition" class="headerlink" title="AMD(Asynchronous Module Definition)"></a>AMD(Asynchronous Module Definition)</h3><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。此外AMD规范比CommonJS规范在浏览器端实现要来着早。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="keyword">function</span>(<span class="params">m1, m2</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="keyword">function</span>(<span class="params">m1, m2</span>)&#123;</span><br><span class="line">   使用m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="CMD-Common-Module-Definition"><a href="#CMD-Common-Module-Definition" class="headerlink" title="CMD(Common Module Definition)"></a>CMD(Common Module Definition)</h3><p>CMD规范是Sea.js推广过程中产生的，Sea.js是阿里的玉伯大神推出的，Sea.js的推广过程中对模块定义的规范化产生了影响，CMD是Sea.js推广过程中产生的。CMD规范是依赖就近，用的时候再require。CMD规范是依赖就近，用的时候再require。CMD规范是依赖就近，用的时候再require。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>)&#123;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">xxx</span> = value</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>)&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.<span class="title function_">async</span>(<span class="string">&#x27;./module3&#x27;</span>, <span class="keyword">function</span> (<span class="params">m3</span>) &#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">xxx</span> = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入使用的模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.<span class="title function_">show</span>()</span><br><span class="line">  m4.<span class="title function_">show</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6模块是ECMAScript 6标准新增的功能，它是JavaScript模块的标准写法，是未来JS模块的主流标准。ES6模块不是对象，而是通过export命令显示指定输出的代码，再通过import命令输入。ES6模块自动采用严格模式，不管你有没有在模块头部加上"use strict"。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js /</span></span><br><span class="line"><span class="comment">var basicNum = 0;</span></span><br><span class="line"><span class="comment">var add = function (a, b) &#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">export &#123; basicNum, add &#125;;</span></span><br><span class="line"><span class="comment">/ 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">    ele.<span class="property">textContent</span> = <span class="title function_">add</span>(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span>;</span><br><span class="line"><span class="title function_">customName</span>(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>ES6模块与CommonJS模块的差异：</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。<br>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>

<p>TreeShaking是指在打包时去除无用的代码，只打包需要的代码。ES6模块静态引入的特性，使得TreeShaking成为可能。</p>
<h3 id="UMD-Universal-Module-Definition"><a href="#UMD-Universal-Module-Definition" class="headerlink" title="UMD(Universal Module Definition)"></a>UMD(Universal Module Definition)</h3><p>UMD是AMD和CommonJS的糅合，既可以支持浏览器端，又可以支持服务器端。UMD规范通常在模块定义中先判断是否支持Node.js模块（exports）是否存在，存在则使用Node.js模块模式，不存在则判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span>.<span class="property">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是commonjs模块规范，nodejs环境&#x27;</span>)</span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是AMD模块规范，如require.js&#x27;</span>)</span><br><span class="line">        <span class="title function_">define</span>(factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">cmd</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是CMD模块规范，如sea.js&#x27;</span>)</span><br><span class="line">        <span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">            <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有模块环境，直接挂载在全局对象上&#x27;</span>)</span><br><span class="line">        root.<span class="property">umdModule</span> = <span class="title function_">factory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;我是一个umd模块&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>]]></content>
  </entry>
  <entry>
    <title>node_modules困境以及pnpm</title>
    <url>/Yuyang/pnpm/</url>
    <content><![CDATA[<p>node_modules的设计虽然能满足大部分的场景，但是其仍然存在着种种缺陷由于每个项目可能依赖成百上千个小模块，node_modules 目录的体积往往非常庞大，动辄几百MB甚至超过1GB。这不仅增加了存储负担，也影响了项目的克隆、备份和部署速度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232217640.png"
                      alt="image.png"
                ></p>
<p>pnpm 的机制对于 yarn 和 npm 来说是降维打击。</p>
<p>包管理工具发展史，npm2 开始</p>
<h2 id="npm2"><a href="#npm2" class="headerlink" title="npm2"></a>npm2</h2><p>用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。</p>
<p>然后找个目录，执行下 npm init -y，快速创建个 package.json。然后执行 npm install express，那么 express 包和它的依赖都会被下载下来：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247533.webp"
                      alt="img"
                ></p>
<p>展开 express，它也有 node_modules：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247605.webp"
                      alt="img"
                ></p>
<p>再展开几层，每个依赖都有自己的 node_modules：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247887.webp"
                      alt="img"
                ></p>
<p>也就是说 npm2 的 node_modules 是嵌套的。</p>
<p><strong>存在的缺陷：</strong></p>
<ul>
<li>嵌套深度问题：深层嵌套结构容易导致路径过长，特别是在 Windows 系统中，这可能导致系统路径长度限制问题。 windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247173.png"
                      alt="img"
                ></p>
<ul>
<li>重复的包：多层嵌套意味着大量重复的包实例，这无疑增加了磁盘空间的使用且影响安装速度。多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。</li>
</ul>
<h2 id="YARN-NPM-3"><a href="#YARN-NPM-3" class="headerlink" title="YARN &amp; NPM@3"></a>YARN &amp; NPM@3</h2><p>yarn 是怎么解决依赖重复很多次，嵌套路径过长的问题的呢？</p>
<p><strong>处理方式：</strong></p>
<ul>
<li>扁平化结构：大部分依赖被安装在顶层 node_modules 目录，减少了重复安装相同包的情况。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247543.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247991.png"
                      alt="img"
                ></p>
<ul>
<li>版本冲突处理：当两个包需要不同版本的同一个依赖时，无法被提升至顶层的依赖会被安装在需要它们的包的 node_modules 目录下。</li>
</ul>
<p><strong>存在的缺陷：</strong></p>
<ul>
<li>依赖结构的不确定性导致扁平化结果的不确定解决方法.lock 文件</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232247361.png"
                      alt="img"
                ></p>
<ul>
<li>幽灵依赖：最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。这就是幽灵依赖的问题。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248078.png"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248136.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248329.png"
                      alt="img"
                ></p>
<ul>
<li>包重复安装问题。提升机制仍然可能导致大量的依赖被重复安装。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248172.png"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232248183.png"
                      alt="img"
                ></p>
<p>扁平化处理：</p>
<p>我们把 node_modules 删了，用 yarn 再重新安装下，执行 yarn add express：</p>
<p>这时候 node_modules 就是这样了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249070.webp"
                      alt="img"
                ></p>
<p>全部铺平在了一层，展开下面的包大部分是没有二层 node_modules 的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249644.webp"
                      alt="img"
                ></p>
<p>当然也有的包还是有 node_modules 的，比如这样：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249531.webp"
                      alt="img"
                ></p>
<p>为什么还有嵌套呢？</p>
<p>因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。</p>
<p>npm 后来升级到 3 之后，也是采用这种铺平的方案了，和 yarn 很类似：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249282.webp"
                      alt="img"
                ></p>
<p>当然，yarn 还实现了 yarn.lock 来锁定依赖版本的功能，不过这个 npm 也实现了。</p>
<p>扁平化的方案也有相应的问题。而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题。</p>
<p>那 pnpm 是怎么解决这俩问题的呢？</p>
<h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p><strong>pnpm：</strong>是一个更新的包管理工具，旨在提供比 npm 和 Yarn 更好的磁盘空间效率和更快的安装速度。</p>
<p>pnpm 通过使用软硬链接解决这个问题。</p>
<p>软链接：软链接是一个指向文件路径的引用。</p>
<p>硬链接：硬链接是一个指向文件数据的直接引用。</p>
<p>这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。</p>
<p>没错，pnpm 就是通过这种思路来实现的。</p>
<p>再把 node_modules 删掉，然后用 pnpm 重新装一遍，执行 pnpm install。</p>
<p>你会发现它打印了这样一句话：</p>
<p>包是从全局 store 硬连接到虚拟 store 的，这里的虚拟 store 就是 node_modules&#x2F;.pnpm。</p>
<p>我们打开 node_modules 看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249706.webp"
                      alt="img"
                ></p>
<p>确实不是扁平化的了，依赖了 express，那 node_modules 下就只有 express，没有幽灵依赖。</p>
<p>展开 .pnpm 看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249750.webp"
                      alt="img"
                ></p>
<p>所有的依赖都在这里铺平了，都是从全局 store 硬连接过来的，然后包和包之间的依赖关系是通过软链接组织的。</p>
<p>比如 .pnpm 下的 expresss，这些都是软链接，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249099.webp"
                      alt="img"
                ></p>
<p>也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules&#x2F;.pnpm 下，然后之间通过软链接来相互依赖。</p>
<p>官方给了一张原理图，配合着看一下就明白了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232249755.webp"
                      alt="img"
                ></p>
<p>这就是 pnpm 的实现原理。</p>
<p>那么回过头来看一下，pnpm 为什么优秀呢？</p>
<p>首先，最大的优点是节省磁盘空间呀，一个包全局只保存一份，剩下的都是软硬连接，这得节省多少磁盘空间呀。</p>
<p>其次就是快，因为通过链接的方式而不是复制，自然会快。</p>
<p>这也是它所标榜的优点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202406232250962.webp"
                      alt="img"
                ></p>
<p>相比 npm2 的优点就是不会进行同样依赖的多次复制。</p>
<p>相比 yarn 和 npm3+ 呢，那就是没有幽灵依赖，也不会有没有被提升的依赖依然复制多份的问题。</p>
<p>这就已经足够优秀了，对 yarn 和 npm 可以说是降维打击。</p>
<p>Reference：<a class="link"   href="https://juejin.cn/post/7127295203177676837?searchId=20240623222554B51B38FF0362E0D545BE" >https://juejin.cn/post/7127295203177676837?searchId=20240623222554B51B38FF0362E0D545BE <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Process and Thread</title>
    <url>/Yuyang/processandthread/</url>
    <content><![CDATA[<h2 id="Process-and-Thread"><a href="#Process-and-Thread" class="headerlink" title="Process and Thread"></a>Process and Thread</h2><p>What is process and thread?And what is the difference between them?In this article, we will discuss the concept of process and thread.To better understand the concept of process and thread, we need to understand the concept of program.</p>
<h3 id="What-program-is"><a href="#What-program-is" class="headerlink" title="What program is"></a>What program is</h3><p>A program is a excutable file that is stored on disk and is loaded into memory when it is run.<br>When a program is loaded into memory, it becomes a process. </p>
<h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>Process is a program in execution. A process is an instance of a program running on a computer. When a program is executed, it is loaded into memory and becomes a process. A process is an independent entity to which system resources (such as CPU time and memory) are allocated. Each process is executed in a separate address space, and one process cannot access the variables and data structures of another process. If a process wishes to access another process’ resources, inter-process communications have to be used. These include pipes, files, sockets, and other forms.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180633691.png"
                      alt="image-20240818063319857"
                ></p>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread is a basic unit of CPU utilization, consisting of a program counter, a stack, and a set of registers, (and a thread ID.) Each thread shares with other threads belonging to the same process its code section, data section, and other operating-system resources, such as open files and signals.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180632067.png"
                      alt="image-20240818063237021"
                ></p>
<h3 id="How-does-the-operating-system-manage-processes-and-threads"><a href="#How-does-the-operating-system-manage-processes-and-threads" class="headerlink" title="How does the operating system manage processes and threads"></a>How does the operating system manage processes and threads</h3><p>This is handled by the context switching mechanism, which enables the CPU to switch rapidly from one thread to another. This is done by saving the context of the thread that is currently running and loading the saved context of the thread that is to be executed. The operating system is responsible for managing the execution of processes and threads, and it does this by scheduling them to run on the CPU.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180634154.png"
                      alt="image-20240818063447864"
                ></p>
<p>![image-20240818064017828](..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240818064017828.png)</p>
<p>The thread switching is also need context switching, but the thread switching is faster than the process switching.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180642421.png"
                      alt="image-20240818064201566"
                ></p>
<p>Because the expansive cost of context switching, there also have some other ways, such as fiber, coroutine, etc.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408180645121.png"
                      alt="image-20240818064530759"
                ></p>
<p>Thanks <a class="link"   href="https://www.youtube.com/watch?v=4rLW7zg21gI" >https://www.youtube.com/watch?v=4rLW7zg21gI <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/undefined/redbook/</url>
    <content><![CDATA[<h2 id="问题准备"><a href="#问题准备" class="headerlink" title="问题准备"></a>问题准备</h2><h2 id="Vite构建"><a href="#Vite构建" class="headerlink" title="Vite构建"></a>Vite构建</h2><p>几大特点</p>
<p>1、冷启动<br>2、快速热更新<br>3、bundleless<br>4、优化构建</p>
<p>特性说明：<br>1、开发环境冷启动，构建基于ESBuild，线上产物构建 rollup<br>2、本地HMR，做了很多优化，webpack是不是需要分析依赖图（耗时的），因为开发环境ESM方式请求资源文件<br>3、配置简单，比parcel还是复杂点</p>
<p>区分环境构建</p>
<p>开发环境 esbuild，bundleless方案进行构建<br>开发环境 rollup<br>如果你想在低版本浏览器调试，不好意思，vite不支持，因为vite是基于ESM的，低版本浏览器不支持ESM</p>
<p>热更新原理</p>
<p>建立长链接，websocket</p>
<p>vite&#x2F;client 插入到客户端<br>vite websocket 服务</p>
<p>浏览器的热更新需要结合，定义一些事件来处理：connect、disconnect、message<br>vite&#x2F;client 会监听文件变化，然后通知vite服务，vite服务会推送到客户端</p>
<p>turbopack</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="前端工程化方向"><a href="#前端工程化方向" class="headerlink" title="前端工程化方向"></a>前端工程化方向</h3><p>1、构建工具<br>2、自动化测试<br>3、代码规范<br>4、性能优化<br>5、持续集成<br>6、部署</p>
<h2 id="React性能优化，性能优化指标采集"><a href="#React性能优化，性能优化指标采集" class="headerlink" title="React性能优化，性能优化指标采集"></a>React性能优化，性能优化指标采集</h2><p>React性能优化Hooks<br>1、React.memo<br>React.memo是一个高阶组件，类似于React.PureComponent，用于函数组件的性能优化，它只会在props发生变化时重新渲染组件，如果props没有发生变化，它会返回上一次的渲染结果，从而避免不必要的渲染。<br>2、useMemo<br>useMemo是一个自定义Hook，用于缓存计算结果，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useMemo才会重新计算结果，否则直接返回上一次的计算结果。<br>3、useCallback<br>useCallback是一个自定义Hook，用于缓存函数，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useCallback才会返回新的函数，否则直接返回上一次的函数。<br>4、useEffect<br>useEffect是一个自定义Hook，用于处理副作用，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useEffect才会执行函数，否则直接返回上一次的执行结果。<br>5、useLayoutEffect<br>useLayoutEffect是一个自定义Hook，用于处理副作用，它接收一个函数和一个依赖数组，只有依赖数组中的值发生变化时，useLayoutEffect才会执行函数，否则直接返回上一次的执行结果。</p>
<h2 id="React-Hooks实现原理-useEffect的实现原理以及执行时机"><a href="#React-Hooks实现原理-useEffect的实现原理以及执行时机" class="headerlink" title="React Hooks实现原理 useEffect的实现原理以及执行时机"></a>React Hooks实现原理 useEffect的实现原理以及执行时机</h2><p>React Hooks实现原理:</p>
<h2 id="function组件如何保存状态"><a href="#function组件如何保存状态" class="headerlink" title="function组件如何保存状态"></a>function组件如何保存状态</h2><p>1、useState<br>2、useReducer<br>3、useRef<br>4、useMemo<br>5、useCallback</p>
<h2 id="React事件处理机制是什么？以及为什么？"><a href="#React事件处理机制是什么？以及为什么？" class="headerlink" title="React事件处理机制是什么？以及为什么？"></a>React事件处理机制是什么？以及为什么？</h2><p>React事件处理机制是基于合成事件的，React会将原生事件封装成合成事件，然后通过事件委托的方式统一管理事件，从而提高性能。</p>
<h2 id="输入url到页面呈现的过程，以及render树是怎么渲染的"><a href="#输入url到页面呈现的过程，以及render树是怎么渲染的" class="headerlink" title="输入url到页面呈现的过程，以及render树是怎么渲染的"></a>输入url到页面呈现的过程，以及render树是怎么渲染的</h2><h2 id="script-async和defer的区别"><a href="#script-async和defer的区别" class="headerlink" title="script async和defer的区别"></a>script async和defer的区别</h2><p>script async和script defer都是用于异步加载脚本的，但是它们之间有一些区别：<br>1、执行时机<br>script async是在下载完成后立即执行脚本，不会阻塞页面的渲染，但是执行顺序不确定；<br>script defer是在DOM解析完成后按照顺序执行脚本，不会阻塞页面的渲染，但是执行顺序是按照顺序执行的。</p>
<h2 id="微任务和红任务"><a href="#微任务和红任务" class="headerlink" title="微任务和红任务"></a>微任务和红任务</h2><h2 id="css绘制同心圆"><a href="#css绘制同心圆" class="headerlink" title="css绘制同心圆"></a>css绘制同心圆</h2><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h2 id="Promise-all-和-Promise-allSettled"><a href="#Promise-all-和-Promise-allSettled" class="headerlink" title="Promise.all 和 Promise.allSettled"></a>Promise.all 和 Promise.allSettled</h2><p>function myPromiseAll(promises) {<br>  return new Promise((resolve, reject) &#x3D;&gt; {<br>    if (!Array.isArray(promises)) {<br>      return reject(new TypeError(“Argument must be an array”));<br>    }</p>
<pre><code>const resultArray = [];
let resolvedCount = 0;

promises.forEach((promise, index) =&gt; &#123;
  // 处理非 Promise 对象
  Promise.resolve(promise)
    .then((value) =&gt; &#123;
      resultArray[index] = value; // 保存结果在对应位置
      resolvedCount++; // 记录已成功的 Promise 数量

      // 如果所有 Promise 都成功，resolve 返回结果
      if (resolvedCount === promises.length) &#123;
        resolve(resultArray);
      &#125;
    &#125;)
    .catch((error) =&gt; &#123;
      reject(error); // 一旦有 Promise 失败，立即 reject
    &#125;);
&#125;);

// 如果传入空数组，直接 resolve
if (promises.length === 0) &#123;
  resolve(resultArray);
&#125;
</code></pre>
<p>  });<br>}</p>
<p>&#x2F;&#x2F; 测试用例<br>const p1 &#x3D; Promise.resolve(1);<br>const p2 &#x3D; Promise.resolve(2);<br>const p3 &#x3D; Promise.resolve(3);</p>
<p>myPromiseAll([p1, p2, p3])<br>  .then((result) &#x3D;&gt; console.log(“成功:”, result)) &#x2F;&#x2F; 成功: [1, 2, 3]<br>  .catch((error) &#x3D;&gt; console.log(“失败:”, error));</p>
<h2 id="实现一个URL解析"><a href="#实现一个URL解析" class="headerlink" title="实现一个URL解析"></a>实现一个URL解析</h2><p>url解析是一个比较复杂的过程，需要考虑很多情况，比如协议、主机、端口、路径、查询参数、锚点等，下面是一个简单的实现：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> urlObject = <span class="keyword">new</span> <span class="title function_">URL</span>(url); <span class="comment">// 使用 URL 构造函数解析</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">protocol</span>: urlObject.<span class="property">protocol</span>,  <span class="comment">// 协议，如 &#x27;https:&#x27;</span></span><br><span class="line">    <span class="attr">host</span>: urlObject.<span class="property">host</span>,          <span class="comment">// 主机名和端口号，如 &#x27;example.com:8080&#x27;</span></span><br><span class="line">    <span class="attr">hostname</span>: urlObject.<span class="property">hostname</span>,  <span class="comment">// 主机名，如 &#x27;example.com&#x27;</span></span><br><span class="line">    <span class="attr">port</span>: urlObject.<span class="property">port</span>,          <span class="comment">// 端口号，如 &#x27;8080&#x27;</span></span><br><span class="line">    <span class="attr">pathname</span>: urlObject.<span class="property">pathname</span>,  <span class="comment">// 路径，如 &#x27;/path/to/resource&#x27;</span></span><br><span class="line">    <span class="attr">search</span>: urlObject.<span class="property">search</span>,      <span class="comment">// 查询字符串，如 &#x27;?name=John&amp;age=30&#x27;</span></span><br><span class="line">    <span class="attr">params</span>: <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(urlObject.<span class="property">search</span>)), <span class="comment">// 查询参数对象</span></span><br><span class="line">    <span class="attr">hash</span>: urlObject.<span class="property">hash</span>           <span class="comment">// 锚点，如 &#x27;#section1&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://example.com:8080/path/to/resource?name=John&amp;age=30#section1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">parseUrl</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></div>

<h2 id="React-memo-useCallback-useEffect"><a href="#React-memo-useCallback-useEffect" class="headerlink" title="React.memo&#x2F;useCallback&#x2F;useEffect"></a>React.memo&#x2F;useCallback&#x2F;useEffect</h2><h2 id="介绍created和beforeRouteEnter区别-优劣"><a href="#介绍created和beforeRouteEnter区别-优劣" class="headerlink" title="介绍created和beforeRouteEnter区别 优劣"></a>介绍created和beforeRouteEnter区别 优劣</h2><h2 id="父子组建生命周期的顺序，为什么是这样的-为什么是在beforeMount的时候渲染子组件"><a href="#父子组建生命周期的顺序，为什么是这样的-为什么是在beforeMount的时候渲染子组件" class="headerlink" title="父子组建生命周期的顺序，为什么是这样的?为什么是在beforeMount的时候渲染子组件?"></a>父子组建生命周期的顺序，为什么是这样的?为什么是在beforeMount的时候渲染子组件?</h2><h2 id="http和tcp的关系"><a href="#http和tcp的关系" class="headerlink" title="http和tcp的关系"></a>http和tcp的关系</h2><h2 id="http状态码以及常见状态码"><a href="#http状态码以及常见状态码" class="headerlink" title="http状态码以及常见状态码"></a>http状态码以及常见状态码</h2><h2 id="介绍下三次握手"><a href="#介绍下三次握手" class="headerlink" title="介绍下三次握手"></a>介绍下三次握手</h2><h2 id="为什么需要三次"><a href="#为什么需要三次" class="headerlink" title="为什么需要三次"></a>为什么需要三次</h2><h2 id="二叉树-求根节点到叶子节点的路径之间数字构成的数总和，如路径4-1-5-表示415，故答案为414-415-436"><a href="#二叉树-求根节点到叶子节点的路径之间数字构成的数总和，如路径4-1-5-表示415，故答案为414-415-436" class="headerlink" title="二叉树 求根节点到叶子节点的路径之间数字构成的数总和，如路径4-&gt;1-&gt;5 表示415，故答案为414+415+436"></a>二叉树 求根节点到叶子节点的路径之间数字构成的数总和，如路径4-&gt;1-&gt;5 表示415，故答案为414+415+436</h2>]]></content>
  </entry>
  <entry>
    <title>RSA前端js加密 后端java解密</title>
    <url>/Yuyang/rsa/</url>
    <content><![CDATA[<h1 id="什么是RSA加密"><a href="#什么是RSA加密" class="headerlink" title="什么是RSA加密"></a>什么是RSA加密</h1><p>RSA加密是一种非对称加密算法，其具体实现如下：<br>1、选择两个不相等的质数p和q，计算n&#x3D;p<em>q<br>2、计算n的欧拉函数φ(n)&#x3D;(p-1)</em>(q-1)<br>3、选择一个整数e，1&lt;e&lt;φ(n)，且e与φ(n)互质<br>4、计算d, 使得(d*e)modφ(n)&#x3D;1<br>5、公钥是(n, e)，私钥是(n, d)<br>6、加密时，将明文m^e mod n，解密时，将密文c^d mod n</p>
<p>例如公钥(n, e) &#x3D; (33, 3)，私钥(n, d) &#x3D; (33, 7)，明文m &#x3D; 24，加密后的密文c &#x3D; 24^3 mod 33 &#x3D; 24，解密后的明文m &#x3D; 24^7 mod 33 &#x3D; 24</p>
<p>p &#x3D; 11, q &#x3D; 3, n &#x3D; 33, φ(n) &#x3D; 20, e &#x3D; 3, d &#x3D; 7</p>
<h2 id="前端js加密"><a href="#前端js加密" class="headerlink" title="前端js加密"></a>前端js加密</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install jsencrypt</span><br><span class="line">npm install node-forge</span><br></pre></td></tr></table></figure></div>
<h3 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> forge <span class="keyword">from</span> <span class="string">&#x27;node-forge&#x27;</span></span><br><span class="line"><span class="comment">// 生成RSA密钥对</span></span><br><span class="line"><span class="keyword">const</span> &#123; privateKey, publicKey &#125; = forge.<span class="property">pki</span>.<span class="property">rsa</span>.<span class="title function_">generateKeyPair</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换公钥和私钥为PEM格式字符串</span></span><br><span class="line"><span class="keyword">const</span> publicKeyPem = forge.<span class="property">pki</span>.<span class="title function_">publicKeyToPem</span>(publicKey);</span><br><span class="line"><span class="keyword">const</span> privateKeyPem = forge.<span class="property">pki</span>.<span class="title function_">privateKeyToPem</span>(privateKey);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Public Key:&#x27;</span>, publicKeyPem);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Private Key:&#x27;</span>, privateKeyPem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的公钥和私钥</span></span><br><span class="line"><span class="comment">// 公钥</span></span><br><span class="line"><span class="comment">// -----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="comment">// MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCjXq96Iz4+TShUSGkPO2LpCWue</span></span><br><span class="line"><span class="comment">// C56FQoEFGZqx/7F6JIqLdF8qA773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDp</span></span><br><span class="line"><span class="comment">// cGM4QbMwDhYN2WgUHbnaAPJOLpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5f</span></span><br><span class="line"><span class="comment">// lf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="comment">// -----END PUBLIC KEY-----</span></span><br><span class="line"><span class="comment">// 私钥</span></span><br><span class="line"><span class="comment">// -----BEGIN RSA PRIVATE KEY-----</span></span><br><span class="line"><span class="comment">// MIICXAIBAAKBgQCjXq96Iz4+TShUSGkPO2LpCWueC56FQoEFGZqx/7F6JIqLdF8q</span></span><br><span class="line"><span class="comment">// A773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDpcGM4QbMwDhYN2WgUHbnaAPJO</span></span><br><span class="line"><span class="comment">// LpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5flf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="comment">// AoGAUfw9gcTYAroD6DAikSNTYvF4UWsxVVznlKCh0nwoG8zkvlFbRKF2n5Dcx8Jy</span></span><br><span class="line"><span class="comment">// v/PhdzN4jX0mot38oCrCFbGq9UoohUYo0tKKroWjV6Tz2Cbfv/9/GGi6I3nrn409</span></span><br><span class="line"><span class="comment">// hh9LzyRoIddLRaBBL91bZZ7OKF9G98Ya27y3teUM1MfX5uECQQDcD6dtZsNTjqFm</span></span><br><span class="line"><span class="comment">// haWKlcvEB3z/+brgwMFU53g0PLhfCTD7dXfh83Sc9zcrMDMYAnM6bDBTKrMet6LV</span></span><br><span class="line"><span class="comment">// M33OmyURAkEAvgzf6luLFHlQZ8T8CpPRMOcfYrn6qnVBeZ5FsQx+Le84rqk3Tcv+</span></span><br><span class="line"><span class="comment">// mXqhjJia49J2n6qlSRyiY5loos6A64Qm/wJASY5p9mWNEJbyWCSACuy7KZEfNSiy</span></span><br><span class="line"><span class="comment">// UIHdnZWpVjydnBakasj/A2WvKvBvXl5EFdhrz7FuDb6OFMxo/z6w5KhzIQJAZVHB</span></span><br><span class="line"><span class="comment">// 0lRpikm+twPKhu0VOmgNUHnsDBIlDOx3JROO9XgylNM726rkmfhJxgXZlZmviiHU</span></span><br><span class="line"><span class="comment">// qmysmkLACQPksSqsCwJBAJVEcG3gonm0BGmZiMDmwwP0M7grYTOUHDAVDJV1u1cB</span></span><br><span class="line"><span class="comment">// hYoV6mr5ZDBOMMIMroIHorcuYdqEKfiV8ulHc8hxBmo=</span></span><br><span class="line"><span class="comment">// -----END RSA PRIVATE KEY-----</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="前端加密"><a href="#前端加密" class="headerlink" title="前端加密"></a>前端加密</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Encrypt</span> <span class="keyword">from</span> <span class="string">&#x27;jsencrypt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publulicKey = <span class="string">`-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCjXq96Iz4+TShUSGkPO2LpCWue</span></span><br><span class="line"><span class="string">C56FQoEFGZqx/7F6JIqLdF8qA773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDp</span></span><br><span class="line"><span class="string">cGM4QbMwDhYN2WgUHbnaAPJOLpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5f</span></span><br><span class="line"><span class="string">lf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----`</span>;</span><br><span class="line"><span class="keyword">const</span> encryptor = <span class="keyword">new</span> <span class="title class_">Encrypt</span>();</span><br><span class="line">encryptor.<span class="title function_">setPublicKey</span>(publulicKey);</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> encrypted = encryptor.<span class="title function_">encrypt</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ encrypted:&quot;</span>, encrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🚀 ~ encrypted: HFzmziwImUXYOfVDy2RnlFm73rjWRQ/sacZ/hV7/XEATCaIjQdTbIPeH3iy+Kc6rIRJRp42LKMWLGq0x2pBdHauCEbJeKDGF3t3RXKk+AM/CFsODv3rXwXt4ArDMkhrtDg7ha6Zgr4jIqvkhauV9hVrB34RUK4jRBw8gBO9rmoM=</span></span><br></pre></td></tr></table></figure></div>

<h3 id="后端解密"><a href="#后端解密" class="headerlink" title="后端解密"></a>后端解密</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.util.io.pem.PemObject;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.util.io.pem.PemReader;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RSA_KEY_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHUNK_SIZE</span> <span class="operator">=</span> RSA_KEY_SIZE / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRsa</span><span class="params">(String encryptedData)</span>&#123;</span><br><span class="line">        System.out.println(encryptedData);</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">privateKeyStr</span> <span class="operator">=</span> <span class="string">&quot; -----BEGIN RSA PRIVATE KEY-----\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; MIICXAIBAAKBgQCjXq96Iz4+TShUSGkPO2LpCWueC56FQoEFGZqx/7F6JIqLdF8q\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; A773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDpcGM4QbMwDhYN2WgUHbnaAPJO\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; LpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5flf6KAddjsiCBi85x7wIDAQAB\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; AoGAUfw9gcTYAroD6DAikSNTYvF4UWsxVVznlKCh0nwoG8zkvlFbRKF2n5Dcx8Jy\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; v/PhdzN4jX0mot38oCrCFbGq9UoohUYo0tKKroWjV6Tz2Cbfv/9/GGi6I3nrn409\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; hh9LzyRoIddLRaBBL91bZZ7OKF9G98Ya27y3teUM1MfX5uECQQDcD6dtZsNTjqFm\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; haWKlcvEB3z/+brgwMFU53g0PLhfCTD7dXfh83Sc9zcrMDMYAnM6bDBTKrMet6LV\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; M33OmyURAkEAvgzf6luLFHlQZ8T8CpPRMOcfYrn6qnVBeZ5FsQx+Le84rqk3Tcv+\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; mXqhjJia49J2n6qlSRyiY5loos6A64Qm/wJASY5p9mWNEJbyWCSACuy7KZEfNSiy\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; UIHdnZWpVjydnBakasj/A2WvKvBvXl5EFdhrz7FuDb6OFMxo/z6w5KhzIQJAZVHB\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; 0lRpikm+twPKhu0VOmgNUHnsDBIlDOx3JROO9XgylNM726rkmfhJxgXZlZmviiHU\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; qmysmkLACQPksSqsCwJBAJVEcG3gonm0BGmZiMDmwwP0M7grYTOUHDAVDJV1u1cB\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; hYoV6mr5ZDBOMMIMroIHorcuYdqEKfiV8ulHc8hxBmo=\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; -----END RSA PRIVATE KEY-----&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> getPrivateKeyFromPem(privateKeyStr);</span><br><span class="line">            <span class="type">String</span> <span class="variable">decryptedData</span> <span class="operator">=</span> decryptData(encryptedData, privateKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将解密后的 Base64 编码字符串转换回原始的 JSON 字符串</span></span><br><span class="line"><span class="comment">//            byte[] decodedBytes = Base64.getDecoder().decode(decryptedData);</span></span><br><span class="line"><span class="comment">//            String jsonString = new String(decodedBytes, StandardCharsets.UTF_8);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(&quot;Decrypted Data: &quot; + jsonString);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Decrypted Data: &quot;</span> + decryptedData);</span><br><span class="line"><span class="comment">//            System.out.println(java.net.URLDecoder.decode(decryptedData ,&quot;UTF-8&quot;));</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title function_">getPrivateKeyFromPem</span><span class="params">(String pemString)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        PemReader pemReader = new PemReader(new StringReader(pemString));</span></span><br><span class="line"><span class="comment">//        PemObject pemObject = pemReader.readPemObject();</span></span><br><span class="line"><span class="comment">//        byte[] keyBytes = pemObject.getContent();</span></span><br><span class="line"><span class="comment">//        pemReader.close();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);</span></span><br><span class="line"><span class="comment">//        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span></span><br><span class="line"><span class="comment">//        return keyFactory.generatePrivate(keySpec);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyPEM</span> <span class="operator">=</span> pemString</span><br><span class="line">                .replace(<span class="string">&quot;-----BEGIN RSA PRIVATE KEY-----&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .replace(<span class="string">&quot;-----END RSA PRIVATE KEY-----&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .replaceAll(<span class="string">&quot;\\s&quot;</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 删除所有空格和换行</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] encoded = Base64.getDecoder().decode(privateKeyPEM);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(encoded);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">decryptData</span><span class="params">(String encryptedData, PrivateKey privateKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] encryptedBytes = Base64.getDecoder().decode(encryptedData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the buffer is large enough to hold all decrypted chunks</span></span><br><span class="line">        <span class="type">byte</span>[] decryptedBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[encryptedBytes.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">decryptedLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; encryptedBytes.length; i += CHUNK_SIZE) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">chunkLength</span> <span class="operator">=</span> Math.min(CHUNK_SIZE, encryptedBytes.length - i);</span><br><span class="line">            <span class="type">byte</span>[] chunk = <span class="keyword">new</span> <span class="title class_">byte</span>[chunkLength];</span><br><span class="line">            System.arraycopy(encryptedBytes, i, chunk, <span class="number">0</span>, chunkLength);</span><br><span class="line">            <span class="type">byte</span>[] decryptedChunk = cipher.doFinal(chunk);</span><br><span class="line">            System.arraycopy(decryptedChunk, <span class="number">0</span>, decryptedBytes, decryptedLength, decryptedChunk.length);</span><br><span class="line">            decryptedLength += decryptedChunk.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(decryptedBytes, <span class="number">0</span>, decryptedLength, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="存在的问题-当前端解密信息超长时jsencrypt库无法分段加密"><a href="#存在的问题-当前端解密信息超长时jsencrypt库无法分段加密" class="headerlink" title="存在的问题 当前端解密信息超长时jsencrypt库无法分段加密"></a>存在的问题 当前端解密信息超长时jsencrypt库无法分段加密</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数据替换为以下数据即会显示Message too long for RSA 原因：RSA 加密算法对单个消息块的长度有限制。这是因为 RSA 加密使用公钥对消息进行加密，而消息的长度不能超过密钥的长度减去填充字节数。因此对于 1024 位（128 字节）的 RSA 密钥，最大消息长度为：128 - 11 - 3 = 128 - 14 = 117</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">result</span>: &#123;</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="number">1572321851823</span>,</span><br><span class="line">    <span class="attr">inter1</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter2</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter3</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter4</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter5</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123s123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter6</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">stream</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">caton</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">card</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>解决方法使用encryptlong库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install encryptlong</span><br></pre></td></tr></table></figure></div>

<p>验证</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">JSEncrypt</span> <span class="keyword">from</span> <span class="string">&#x27;encryptlong&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> publulicKey = <span class="string">`-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCjXq96Iz4+TShUSGkPO2LpCWue</span></span><br><span class="line"><span class="string">C56FQoEFGZqx/7F6JIqLdF8qA773iPk1qbqSbtYPzu3lCOXWxDl99bI+aIKEJPDp</span></span><br><span class="line"><span class="string">cGM4QbMwDhYN2WgUHbnaAPJOLpCvf2S+COG3HRQMarMvTX2PVujIhi44EfOPPJ5f</span></span><br><span class="line"><span class="string">lf6KAddjsiCBi85x7wIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----`</span>;</span><br><span class="line"><span class="keyword">const</span> encryptor = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>();</span><br><span class="line">encryptor.<span class="title function_">setPublicKey</span>(publulicKey);</span><br><span class="line"><span class="comment">// const data = &#123;</span></span><br><span class="line"><span class="comment">//   password: &#x27;123456&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">result</span>: &#123;</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="number">1572321851823</span>,</span><br><span class="line">    <span class="attr">inter1</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter2</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter3</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter4</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter5</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123s123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter6</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">stream</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">caton</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">card</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> encrypted = encryptor.<span class="title function_">encryptLong</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ encrypted:&quot;</span>, encrypted)</span><br></pre></td></tr></table></figure></div>

<p>后端可以解析 but 当内容过长且出现中文时后端就会解析失败😭 例如加密输入改为：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">result</span>: &#123;</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="number">1572321851823</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;宇阳&quot;</span>,</span><br><span class="line">    <span class="attr">inter1</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter2</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter3</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter4</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter5</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123s123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">inter6</span>: [</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">      <span class="string">&quot;123123123&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">stream</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">caton</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">card</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>后端解析报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408042344886.png"
                      alt="image-20240804234409275"
                ></p>
<p>原因排查 源码解析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050036985.png"
                      alt="image-20240805001758724"
                ></p>
<p><strong>PKCS#1 v1.5 填充方案</strong></p>
<p>PKCS#1 v1.5 是一种填充方案，用于确保 RSA 加密的安全性和一致性。它在加密前对数据进行填充，以确保填充后的数据长度与 RSA 密钥长度相匹配。具体填充格式如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x00</span> || <span class="number">0x02</span> || <span class="variable constant_">PS</span> || <span class="number">0x00</span> || D</span><br></pre></td></tr></table></figure></div>

<p>代码中体现</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050036260.png"
                      alt="image-20240805001918947"
                ></p>
<p>中文问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050036574.png"
                      alt="image-20240805003508983"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202408050037323.png"
                      alt="image-20240805003620646"
                ></p>
<p>当出现中文时由于其占3个字符 所以会导致传入的ba数组出现负索引的情况 导致后续解密失败</p>
<p><a class="link"   href="https://www.npmjs.com/package/jsencrypt-ext" >https://www.npmjs.com/package/jsencrypt-ext <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>使用这位大哥改进的代码就可以，但是我在使用其打包构建后的文件script导入仍有问题。</p>
]]></content>
  </entry>
  <entry>
    <title>monorepo</title>
    <url>/undefined/monorepo/</url>
    <content><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>之前写过的一个项目是基于vue.js的前端和express的后端,一直是以分开的git repositories管理的。但其实后端内容很少，因此考虑后期的维护和开发，将前后端合并到一个git repository中，这样可以更好的管理项目。</p>
<h2 id="What-is-Monorepo"><a href="#What-is-Monorepo" class="headerlink" title="What is Monorepo"></a>What is Monorepo</h2><p>A monorepo is a code management approach where all code for multiple projects, including components, libraries, and internal dependencies, is stored in a single centralized repository, often involving multiple programming languages and application types.</p>
<h2 id="Why-Monorepo"><a href="#Why-Monorepo" class="headerlink" title="Why Monorepo"></a>Why Monorepo</h2><ul>
<li><strong>Simplified Code Management</strong></li>
<li><strong>Enhanced Collaboration</strong></li>
<li><strong>Streamlined Tooling</strong></li>
<li><strong>Code Sharing and Reusability</strong></li>
<li><strong>Dependency Management</strong></li>
<li><strong>Consistent Development Environment</strong></li>
<li><strong>Flexibility and Scalability</strong></li>
</ul>
<h2 id="How-to-create-a-Monorepo"><a href="#How-to-create-a-Monorepo" class="headerlink" title="How to create a Monorepo"></a>How to create a Monorepo</h2><p>目前主流的monorepo管理工具主要是Lerna(<a class="link"   href="https://lerna.js.org/).%E4%BD%86%E7%94%B1%E4%BA%8E%E6%88%91%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%BB%E8%A6%81%E6%98%AF%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%8D%E6%98%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%9A%82%E4%B8%8D%E4%BD%BF%E7%94%A8Lerna%E3%80%82%E4%B8%BB%E8%A6%81%E8%BF%98%E6%98%AF%E5%AE%8C%E6%88%90%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E5%90%88%E5%B9%B6%E3%80%82" >https://lerna.js.org/).但由于我这个项目主要是前后端代码，不是组件化的项目，因此暂不使用Lerna。主要还是完成前后端代码的合并。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202411110410947.png"
                      alt="image-20241111041031268"
                ></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a class="link"   href="https://www.sonarsource.com/learn/monorepo/" >https://www.sonarsource.com/learn/monorepo/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://juejin.cn/post/7215886869199896637" >https://juejin.cn/post/7215886869199896637 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>monorepo</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 与 打包工具开发</title>
    <url>/Yuyang/webpack/</url>
    <content><![CDATA[<h1 id="webpack-与-打包工具开发"><a href="#webpack-与-打包工具开发" class="headerlink" title="webpack 与 打包工具开发"></a>webpack 与 打包工具开发</h1><h2 id="webpack核心配置"><a href="#webpack核心配置" class="headerlink" title="webpack核心配置"></a>webpack核心配置</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><h3 id="MiniCssExtractPlugin"><a href="#MiniCssExtractPlugin" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h3><p>用于提取css样式内容</p>
<h3 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h3><p>用于解析</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><h2 id="grunt、gulp-15、16年"><a href="#grunt、gulp-15、16年" class="headerlink" title="grunt、gulp 15、16年"></a>grunt、gulp 15、16年</h2><h2 id="新晋打包工具"><a href="#新晋打包工具" class="headerlink" title="新晋打包工具"></a>新晋打包工具</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><p>1、2009，commonjs，Modules&#x2F;1.0；<br>2、2011，为commonjs引入异步加载特性，Module&#x2F;Transfer&#x2F;C 提案，独立成AMD规范；<br>3、2013，grunt、gulp，基于任务的自动化构建工具；<br>4、2014，定义跨平台的模块规范，定义了一个新的规范，叫做UMD；<br>5、2014，将ES6 -&gt; ES5的工具，命名为babel；<br>6、2014，systemjs问世，简化了模块加载和处理的过程；<br>7、2014，Webpack问世，基于模块化的打包工具；<br>8、2015，正式ES6（ECMAScript 2015）规范正式发布<br>9、2015，Rollup，因为ES6的发布，借用ESModul，提出了tree-shaking的概念；<br>10、2017，webpack逐渐让人厌倦，Parcel问世，零配置的打包工具；<br>11、2019，snowpack出现 node_modules转ESM构建工具出现；<br>12、2020，浏览器对于ESM和HTTP2的更全面化支持，bundleless思路出现，ESBuild，出现在大众视野<br>13、2021，Vite发布</p>
<p>阶段分为：<br>1、初版构建工具：grunt（task）、gulp（flow）<br>2、webpack<br>3、基于webpack思维，扩展一些新兴构建工具<br>4、bundleless构建工具<br>5、正在进行时，基于Rust的前端工具链重构（swc、rspack）</p>
<h3 id="grunt-11年"><a href="#grunt-11年" class="headerlink" title="grunt 11年"></a>grunt 11年</h3><p>基于Task的构建工具，对应任务的配置，我们通过Plugins来完成</p>
<h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><p>通过定义Task与Flow，自定义打包构建流程</p>
<h2 id="构建基石-Webpack"><a href="#构建基石-Webpack" class="headerlink" title="构建基石 Webpack"></a>构建基石 Webpack</h2><h2 id="衍生出rollup、parcel"><a href="#衍生出rollup、parcel" class="headerlink" title="衍生出rollup、parcel"></a>衍生出rollup、parcel</h2><p>突破性的构建工具<br>go、rust来去编写构建工具<br>webpack+babel 比较受人诟病</p>
<h3 id="ESBuild"><a href="#ESBuild" class="headerlink" title="ESBuild"></a>ESBuild</h3><p>js编译引擎v8，v8引擎是基于C++编写的<br>js属于解释性语言，go语言是编译型语言不存在编译时的开销，只有运行时，所以速度快<br>基于Go语言，速度快，但是功能不够完善 多线程</p>
<p>在webpack、rollup使用中，相关的依赖我们需要第三方库来支持</p>
<ul>
<li>babel来去转译和检查</li>
<li>eslint来去检查</li>
<li>tsc 实现ts的转译和检查</li>
<li>less、sass这些都需要预处理器工具来完成</li>
</ul>
<h3 id="swc"><a href="#swc" class="headerlink" title="swc"></a>swc</h3><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><p>几大特点</p>
<p>1、冷启动<br>2、快速热更新<br>3、bundleless<br>4、优化构建</p>
<p>特性说明：<br>1、开发环境冷启动，构建基于ESBuild，线上产物构建 rollup<br>2、本地HMR，做了很多优化，webpack是不是需要分析依赖图（耗时的），因为开发环境ESM方式请求资源文件<br>3、配置简单，比parcel还是复杂点</p>
<p>区分环境构建</p>
<ul>
<li>开发环境 esbuild，bundleless方案进行构建</li>
<li>开发环境 rollup</li>
</ul>
<p>如果你想在低版本浏览器调试，不好意思，vite不支持，因为vite是基于ESM的，低版本浏览器不支持ESM</p>
<p>热更新原理</p>
<p>建立长链接，websocket</p>
<p>vite&#x2F;client 插入到客户端<br>vite websocket 服务</p>
<p>浏览器的热更新需要结合，定义一些事件来处理：connect、disconnect、message<br>vite&#x2F;client 会监听文件变化，然后通知vite服务，vite服务会推送到客户端</p>
<p>turbopack</p>
]]></content>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/Yuyang/prototype/</url>
    <content><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>什么是原型？什么是构造函数、实例原型、实例？它们的关系是什么？</p>
<h3 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h3><p>每个 JavaScript 对象都有一个内部链接到另一个对象的引用，这个对象被称为原型。当试图访问一个对象的属性时，JavaScript 会首先在这个对象自身上寻找该属性，如果找不到，则会查找该对象的原型，如此递归下去，直到找到该属性或达到原型链的末端。</p>
<h3 id="构造函数（Constructor）"><a href="#构造函数（Constructor）" class="headerlink" title="构造函数（Constructor）"></a>构造函数（Constructor）</h3><p>构造函数是用于创建对象的函数。通过 new 操作符调用构造函数时，它会创建一个新对象，并将这个新对象的内部 [[Prototype]] 连接到构造函数的 prototype 属性。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Yuyang&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>Person是构造函数，person是创建的对象</p>
<h3 id="实例原型（Instance-Prototype）"><a href="#实例原型（Instance-Prototype）" class="headerlink" title="实例原型（Instance Prototype）"></a>实例原型（Instance Prototype）</h3><p>实例原型是由构造函数的 <code>prototype</code> 属性引用的对象。所有由该构造函数创建的实例对象都将共享这个实例原型对象的属性和方法。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;zyz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Yuyang&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;YuyangA&quot;</span>);</span><br><span class="line">person1.<span class="property">callName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">person1.<span class="title function_">callName</span>();</span><br><span class="line">person2.<span class="title function_">callName</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="实例（Instance）"><a href="#实例（Instance）" class="headerlink" title="实例（Instance）"></a>实例（Instance）</h3><p>实例是通过构造函数创建的具体对象。每个实例都有一个内部链接到它的构造函数的 <code>prototype</code> 属性的引用，这个链接可以通过 <code>__proto__</code>（非标准）或 <code>Object.getPrototypeOf</code> 方法来访问。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person3 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Charlie&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person3.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121647943.png"
                      alt="image.png"
                ></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/YuZeZhang/myImgslib/main/202407121648478.png"
                      alt="image.png"
                ></p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><strong>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</strong></p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>JavaScript中的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。</p>
<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li>Function.prototype.call 或 Function.prototype.apply 调用</li>
</ul>
<h4 id="作为对象的方法调用："><a href="#作为对象的方法调用：" class="headerlink" title="作为对象的方法调用："></a>作为对象的方法调用：</h4><p>函数作为对象的方法被调用时，this指向该对象：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getA</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span> === obj);</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getA</span>();</span><br></pre></td></tr></table></figure></div>

<h4 id="作为普通函数调用："><a href="#作为普通函数调用：" class="headerlink" title="作为普通函数调用："></a>作为普通函数调用：</h4><p>当函数不作为对象的属性被调用时，此时的this总是指向全局对象。在浏览器的javascript里，这个全局对象是window对象。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;globalName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>()); <span class="comment">//输出: globalName</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;globalName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;sven&quot;</span>,</span><br><span class="line">	<span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = myObject.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>()); <span class="comment">// globalName</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">id</span> = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>) </span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>)</span><br><span class="line">  &#125;        </span><br><span class="line">  <span class="title function_">callback</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback中的this指向window</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;;        </span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数没有this 捕获其上下文的this值</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>);        </span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 bind 显式地将 this 绑定到 div1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, <span class="variable language_">this</span>.<span class="property">id</span>, <span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🚀 ~ window.id:&quot;</span>, self.<span class="property">id</span>, self);</span><br><span class="line">  &#125;;        </span><br><span class="line">  <span class="title function_">callback</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂存this</span></span><br></pre></td></tr></table></figure></div>

<h4 id="构造器调用："><a href="#构造器调用：" class="headerlink" title="构造器调用："></a>构造器调用：</h4><p>用new调用函数时，该函数会返回一个对象，通常情况下，构造器的this就会指向返回的这个对象，</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;seven&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="property">name</span>);</span><br></pre></td></tr></table></figure></div>

<p>当构造器显式的返回一个对象时，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyClass</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;sven&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&quot;anne&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="property">name</span>); <span class="comment">//anne</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Function-prototype-call-或-Function-prototype-apply-调用"><a href="#Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="Function.prototype.call 或 Function.prototype.apply 调用:"></a>Function.prototype.call 或 Function.prototype.apply 调用:</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;anne&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>()) <span class="comment">// seven</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">getName</span>.<span class="title function_">call</span>(obj2)) <span class="comment">// anne</span></span><br></pre></td></tr></table></figure></div>

<p><code>call</code> 方法调用一个函数，并显式地指定 <code>this</code> 值和传递的参数。</p>
<p>call源码实现：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果没有提供 context，默认设置为全局对象（在浏览器中是 window）</span></span><br><span class="line">  context = context || globalThis;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 为 context 创建一个唯一的临时属性来存储函数</span></span><br><span class="line">  <span class="keyword">const</span> fnSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line">  context[fnSymbol] = <span class="variable language_">this</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 context 调用函数，并传递参数</span></span><br><span class="line">  <span class="keyword">const</span> result = context[fnSymbol](...args);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">delete</span> context[fnSymbol];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例使用 myCall</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting, punctuation</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + punctuation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">myCall</span>(person, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;!&#x27;</span>);  <span class="comment">// 输出: &quot;Hello, Alice!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p> <strong>call() 方法接受的是参数列表，而 apply() 方法接受的是一个参数数组</strong>。</p>
<p>call：</p>
<blockquote>
<p><em>function</em>.call(<em>thisArg</em>, <em>arg1</em>, <em>arg2</em>, …)</p>
</blockquote>
<p>apply：</p>
<blockquote>
<p><em>func</em>.apply(<em>thisArg, [argsArray</em>])</p>
</blockquote>
<p><code>bind</code> 方法创建一个新的函数，该函数在调用时，其 <code>this</code> 值和传递的参数被预先设置。与 <code>call</code> 方法不同，<code>bind</code> 不会立即调用函数，而是返回一个新的函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind2</span> = <span class="keyword">function</span>(<span class="params">context</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    _this.<span class="title function_">apply</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo2 = bar.<span class="title function_">bind2</span>(foo);</span><br></pre></td></tr></table></figure></div>

<h3 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h3>]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/Yuyang/reg/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。具有强大的模式匹配和文本检索与替换功能。</p>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>在 JavaScript 中，可以通过两种方式定义正则表达式：</p>
<ol>
<li><p><strong>正则表达式字面量</strong>： 使用一对斜杠（<code>/</code>）包围正则表达式模式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/i</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>RegExp 构造函数</strong>： 使用 <code>RegExp</code> 构造函数来创建正则表达式。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;pattern&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="正则表达式的标志（Flags）"><a href="#正则表达式的标志（Flags）" class="headerlink" title="正则表达式的标志（Flags）"></a>正则表达式的标志（Flags）</h2><p>正则表达式标志用于修改正则表达式的行为。常见的标志包括：</p>
<ul>
<li><code>g</code>：全局搜索（global search）。</li>
<li><code>i</code>：不区分大小写搜索（case-insensitive search）。</li>
<li><code>m</code>：多行搜索（multi-line search）。</li>
<li><code>s</code>：允许点号（<code>.</code>）匹配换行符（newline characters）。</li>
<li><code>u</code>：启用 Unicode 匹配。</li>
<li><code>y</code>：粘性匹配（sticky search），从目标字符串的当前位置开始匹配。</li>
</ul>
<h2 id="常用的正则表达式方法"><a href="#常用的正则表达式方法" class="headerlink" title="常用的正则表达式方法"></a>常用的正则表达式方法</h2><p>1、**<code>test()</code>**： 测试字符串中是否存在与正则表达式模式匹配的文本，返回布尔值。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.<span class="title function_">test</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>2、**<code>exec()</code>**： 搜索字符串中与正则表达式模式匹配的文本，返回一个结果数组或 <code>null</code>。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.<span class="title function_">exec</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&quot;hello&quot;]</span></span><br></pre></td></tr></table></figure></div>

<h2 id="正则表达式的基本模式"><a href="#正则表达式的基本模式" class="headerlink" title="正则表达式的基本模式"></a>正则表达式的基本模式</h2><p><strong>字符类</strong>：</p>
<ul>
<li><code>.</code>：匹配除换行符外的任何单个字符。</li>
<li><code>\d</code>：匹配一个数字（0-9）。</li>
<li><code>\D</code>：匹配一个非数字字符。</li>
<li><code>\w</code>：匹配一个字母、数字或下划线字符。</li>
<li><code>\W</code>：匹配一个非字母、数字或下划线字符。</li>
<li><code>\s</code>：匹配一个空白字符（包括空格、制表符等）。</li>
<li><code>\S</code>：匹配一个非空白字符。</li>
</ul>
<p><strong>边界匹配</strong>：</p>
<ul>
<li><code>^</code>：匹配字符串的开始。</li>
<li><code>$</code>：匹配字符串的结束。</li>
<li><code>\b</code>：匹配单词边界。</li>
<li><code>\B</code>：匹配非单词边界。</li>
</ul>
<p><strong>量词</strong>：</p>
<ul>
<li><code>*</code>：匹配前一个字符 0 次或多次。</li>
<li><code>+</code>：匹配前一个字符 1 次或多次。</li>
<li><code>?</code>：匹配前一个字符 0 次或 1 次。</li>
<li><code>&#123;n&#125;</code>：匹配前一个字符恰好 n 次。</li>
<li><code>&#123;n,&#125;</code>：匹配前一个字符至少 n 次。</li>
<li><code>&#123;n,m&#125;</code>：匹配前一个字符至少 n 次，但不超过 m 次。</li>
</ul>
<p><strong>什么是贪婪匹配和非贪婪匹配</strong>：</p>
<h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p><strong>贪婪匹配（Greedy Matching）</strong> 会尽可能多地匹配字符。这是正则表达式的默认行为。</p>
<p>例如，考虑以下正则表达式和字符串：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a.*b/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aabab&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> match = str.<span class="title function_">match</span>(regex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>]); <span class="comment">// &quot;aabab&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>.*</code> 是贪婪的，它会尝试匹配尽可能多的字符，以使整个表达式匹配成功。因此，它从第一个 <code>a</code> 开始，直到最后一个 <code>b</code> 才停止匹配。</p>
<p>在正则表达式中，“贪婪匹配”和“非贪婪匹配”是用于描述重复量词（如 <code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;&#125;</code>）的两种不同行为。</p>
<h3 id="贪婪匹配-1"><a href="#贪婪匹配-1" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p><strong>贪婪匹配（Greedy Matching）</strong> 会尽可能多地匹配字符。这是正则表达式的默认行为。</p>
<p>例如，考虑以下正则表达式和字符串：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript</span><br><span class="line">复制代码</span><br><span class="line">let regex = /a.*b/;</span><br><span class="line">let str = &quot;aabab&quot;;</span><br><span class="line">let match = str.match(regex);</span><br><span class="line">console.log(match[0]); // &quot;aabab&quot;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>.*</code> 是贪婪的，它会尝试匹配尽可能多的字符，以使整个表达式匹配成功。因此，它从第一个 <code>a</code> 开始，直到最后一个 <code>b</code> 才停止匹配。</p>
<h3 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h3><p><strong>非贪婪匹配（Non-Greedy Matching）</strong>，也称为“懒惰匹配（Lazy Matching）”，会尽可能少地匹配字符。使用 <code>?</code> 来表示非贪婪匹配。</p>
<p>例如，考虑以下正则表达式和字符串：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a.*?b/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aabab&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> match = str.<span class="title function_">match</span>(regex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>]); <span class="comment">// &quot;aab&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>.*?</code> 是非贪婪的，它会尽可能少地匹配字符。因此，它从第一个 <code>a</code> 开始，匹配到第一个 <code>b</code> 就停止匹配。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
  </entry>
</search>
